(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

// This file will likely become a generated file in the future. Please
// avoid adding extra APIs or exports here.

var i18n = require('../../../libs/spotify-i18n')({
  'cs': require('./json/cs.json'),
  'de': require('./json/de.json'),
  'el': require('./json/el.json'),
  'en': require('./json/en.json'),
  'es': require('./json/es.json'),
  'es-419': require('./json/es-419.json'),
  'fi': require('./json/fi.json'),
  'fr': require('./json/fr.json'),
  'fr-CA': require('./json/fr-CA.json'),
  'hu': require('./json/hu.json'),
  'id': require('./json/id.json'),
  'it': require('./json/it.json'),
  'ja': require('./json/ja.json'),
  'nl': require('./json/nl.json'),
  'pl': require('./json/pl.json'),
  'pt-BR': require('./json/pt-BR.json'),
  'sv': require('./json/sv.json'),
  'tr': require('./json/tr.json'),
  'zh-Hant': require('./json/zh-Hant.json'),
  'zsm': require('./json/zsm.json')
});

module.exports = i18n;

},{"../../../libs/spotify-i18n":456,"./json/cs.json":2,"./json/de.json":3,"./json/el.json":4,"./json/en.json":5,"./json/es-419.json":6,"./json/es.json":7,"./json/fi.json":8,"./json/fr-CA.json":9,"./json/fr.json":10,"./json/hu.json":11,"./json/id.json":12,"./json/it.json":13,"./json/ja.json":14,"./json/nl.json":15,"./json/pl.json":16,"./json/pt-BR.json":17,"./json/sv.json":18,"./json/tr.json":19,"./json/zh-Hant.json":20,"./json/zsm.json":21}],2:[function(require,module,exports){
module.exports={
  "app.name": "Feed přátel",
  "app.description": "Feed přátel",
  "nux.description": "Podívej se, co poslouchají tví přátelé",
  "nux.recently_played_description": "Zde získáš rychlý přístup k veškerému nedávno přehrávanému obsahu.",
  "button.follow": "Najít přátele",
  "button.try_again": "Zkus to znovu",
  "error.general_error_title": "Bohužel Feed přátel se nepodařilo načíst.",
  "error.offline_title": "Feed přátel není k dispozici offline",
  "error.offline_subtitle": "Připoj se k internetu a načti Feed přátel.",
  "header.inactive_friends": "Více přátel",
  "header.inactive_friends_tooltip": "Přátelé bez nedávné veřejné aktivity poslechu",
  "timeago.minutes": "{0} m",
  "timeago.hours": "{0} h",
  "timeago.days": "{0} d",
  "timeago.weeks": "{0} t",
  "timeago.now": "nyní",
  "surround.buddy_list.title": "Aktivita přátel",
  "qbe.greeting_title": "Vítej",
  "qbe.greeting1": "Vítáme tě, uživateli {0}!",
  "qbe.greeting1_tagline": "Získej zdarma verzi Premium.",
  "qbe.greeting2": "Už jsi téměř v cíli!",
  "qbe.greeting2_tagline": "Kliknutím na úkol zobrazíš nápovědu.",
  "qbe.greeting3": "Dobrá práce!",
  "qbe.greeting3_tagline": "Teď si můžeš užívat hudbu ve špičkové kvalitě a bez reklam.",
  "qbe.tasks.sign_in_to_spotify.title": "Přihlášení do Spotify",
  "qbe.tasks.search.title": "Vyhledání skladby",
  "qbe.tasks.search.header": "Najdi si, co tě zajímá.",
  "qbe.tasks.search.description": "Většina lidí hledá umělce nebo skladby. Víš ale, že můžeš vyhledávat také alba, playlisty a profily?",
  "qbe.tasks.play_song.title": "Přehrávání skladby",
  "qbe.tasks.play_song.header": "Zažeň ticho.",
  "qbe.tasks.play_song.description": "Poklikáním na skladbu nebo stisknutím tlačítka Přehrát nalevo od řádku skladby spustíš nekonečné streamování hudby.",
  "qbe.tasks.create_playlist.title": "Vytvoření playlistu",
  "qbe.tasks.create_playlist.header": "Ulož si své skladby.",
  "qbe.tasks.create_playlist.description": "Playlisty jsou sbírky skladeb, do kterých si uživatelé mohou ukládat hudbu pro nejrůznější nálady a příležitosti. Vytvořit si jich můžeš tolik, kolik chceš. Fantazii se meze nekladou.",
  "qbe.tasks.add_songs_to_playlist.title": "Přidání {0} skladeb do playlistu",
  "qbe.tasks.add_songs_to_playlist.header": "Naplň svůj playlist!",
  "qbe.tasks.add_songs_to_playlist.description": "Playlisty by neměly zůstat prázdné. Po kliknutí na ikonu tří teček napravo od řádku skladeb se zobrazuje možnost přidání do playlistu. Vyzkoušej, jak funguje!",
  "qbe.reward.description": "Splň zadané úkoly a získej bezplatnou zkušební verzi Spotify Premium na 7 dní.",
  "qbe.reward.what_is_premium": "Co je Premium?",
  "qbe.reward.cta": "Aktivovat Premium",
  "qbe.reward.activated": "Zkušební verze Premium je aktivována!",
  "qbe.reward.activated_description": "Zkušební verze je aktivována a ty můžeš 7 dní zdarma využívat výhody služby Spotify Premium. Věříme, že si je užiješ!",
  "qbe.modal.heading": "Toto je služba Spotify Premium",
  "qbe.modal.download.title": "Stahování hudby.",
  "qbe.modal.download.subtitle": "Možnost poslouchat kdekoli.",
  "qbe.modal.ads.title": "Bez reklam. ",
  "qbe.modal.ads.subtitle": "Nonstop příval hudby.",
  "qbe.modal.play.title": "Přehrávání na přání.",
  "qbe.modal.play.subtitle": "I na mobilu.",
  "qbe.modal.skips.title": "Přeskakování bez omezení.",
  "qbe.modal.skips.subtitle": "Stačí kliknout na šipku Další."
}
},{}],3:[function(require,module,exports){
module.exports={
  "app.name": "Freundes-Feed",
  "app.description": "Freundes-Feed",
  "nux.description": "Finde heraus, was Deine Freunde hören.",
  "nux.recently_played_description": "Hier direkt auf zuletzt abgespielte Inhalte zugreifen",
  "button.follow": "Freunde finden",
  "button.try_again": "Erneut versuchen",
  "error.general_error_title": "Hmmm, der Freundes-Feed konnte nicht geladen werden.",
  "error.offline_title": "Der Freundes-Feed ist offline nicht verfügbar.",
  "error.offline_subtitle": "Gehe online, um den Freundes-Feed zu laden.",
  "header.inactive_friends": "Weitere Freunde",
  "header.inactive_friends_tooltip": "Freunde ohne neueste Aktivität beim öffentlichen Hören",
  "timeago.minutes": "{0} Min",
  "timeago.hours": "{0} Std",
  "timeago.days": "{0} T",
  "timeago.weeks": "{0} W",
  "timeago.now": "jetzt",
  "surround.buddy_list.title": "Aktivität deiner Freunde",
  "qbe.greeting_title": "Willkommen!",
  "qbe.greeting1": "Willkommen, {0}!",
  "qbe.greeting1_tagline": "Spotify Premium kostenlos holen",
  "qbe.greeting2": "Nur noch wenige Schritte.",
  "qbe.greeting2_tagline": "Klicke auf eine Aufgabe, um Hinweise zu erhalten.",
  "qbe.greeting3": "Gut gemacht!",
  "qbe.greeting3_tagline": "Nun genießt du Musik ohne Werbung und mit hoher Soundqualität.",
  "qbe.tasks.sign_in_to_spotify.title": "Bei Spotify anmelden",
  "qbe.tasks.search.title": "Nach einem Song suchen",
  "qbe.tasks.search.header": "Alle finden.",
  "qbe.tasks.search.description": "Die meisten nutzen die Suche, um nach Künstlern oder Songs zu suchen. Wusstest du schon, dass du auch nach Alben, Playlists und Profilen suchen kannst?",
  "qbe.tasks.play_song.title": "Song abspielen",
  "qbe.tasks.play_song.header": "Mit einem Song geht alles besser.",
  "qbe.tasks.play_song.description": "Doppelklicke auf einen Titel oder drücke links neben einer Titelzeile „Play“. Und schon kannst du unendlich viele Songs streamen.",
  "qbe.tasks.create_playlist.title": "Playlist erstellen",
  "qbe.tasks.create_playlist.header": "Sammle deine Titel.",
  "qbe.tasks.create_playlist.description": "Playlists sind Titelsammlungen, die du und andere User für jede Stimmung, jedes Event usw. zusammenstellen könnt. Du kannst so viele Playlists erstellen, wie du möchtest. Lass deiner Kreativität freien Lauf!",
  "qbe.tasks.add_songs_to_playlist.title": "{0} Songs zu einer Playlist hinzufügen",
  "qbe.tasks.add_songs_to_playlist.header": "Mehr Songs, bitte!",
  "qbe.tasks.add_songs_to_playlist.description": "Playlists sollten nicht leer sein. Wenn du auf die drei Buttons rechts neben einer Titelzeile klickst, kannst du eine Playlist hinzufügen. Probier's mal aus.",
  "qbe.reward.description": "Erledige deine Aufgaben und teste Spotify Premium 7 Tage kostenlos.",
  "qbe.reward.what_is_premium": "Was ist Spotify Premium?",
  "qbe.reward.cta": "Spotify Premium aktivieren",
  "qbe.reward.activated": "Dein Test-Abo für Spotify Premium wurde aktiviert.",
  "qbe.reward.activated_description": "Dein Test-Abo wurde aktiviert. Du genießt Spotfy Premium nun 7 Tage lang kostenlos. Viel Spaß damit!",
  "qbe.modal.heading": "Das ist Spotify Premium.",
  "qbe.modal.download.title": "Lade Musik herunter.",
  "qbe.modal.download.subtitle": "Hör Musik überall.",
  "qbe.modal.ads.title": "Keine Werbung.",
  "qbe.modal.ads.subtitle": "Genieße Musik nonstop.",
  "qbe.modal.play.title": "Hör dir jeden beliebigen Song an.",
  "qbe.modal.play.subtitle": "Sogar auf Mobilgeräten.",
  "qbe.modal.skips.title": "Überspringe beliebig viele Titel.",
  "qbe.modal.skips.subtitle": "Tippe einfach auf „Weiter“."
}
},{}],4:[function(require,module,exports){
module.exports={
  "app.name": "Ροή φίλων",
  "app.description": "Ροή φίλων",
  "nux.description": "Δες τι ακούνε οι φίλοι σου",
  "nux.recently_played_description": "Απόκτησε γρήγορη πρόσβαση σε όλο το περιεχόμενο που άκουσες πρόσφατα εδώ.",
  "button.follow": "Βρες φίλους",
  "button.try_again": "Δοκίμασε ξανά",
  "error.general_error_title": "Κρίμα. Η φόρτωση της ροής φίλων απέτυχε.",
  "error.offline_title": "Η ροή φίλων δεν είναι διαθέσιμη εκτός σύνδεσης",
  "error.offline_subtitle": "Συνδέσου στο διαδίκτυο για να φορτώσεις τη ροή Φίλων",
  "header.inactive_friends": "Περισσότεροι Φίλοι",
  "header.inactive_friends_tooltip": "Φίλοι χωρίς πρόσφατη δραστηριότητα δημόσιας ακρόασης",
  "timeago.minutes": "{0} λ.",
  "timeago.hours": "{0} ώρ.",
  "timeago.days": "{0} ημ.",
  "timeago.weeks": "{0} εβδ.",
  "timeago.now": "τώρα",
  "surround.buddy_list.title": "Δραστηριότητα φίλων",
  "qbe.greeting_title": "Καλωσόρισες",
  "qbe.greeting1": "Καλώς όρισες, {0}!",
  "qbe.greeting1_tagline": "Απόκτησε το Premium δωρεάν",
  "qbe.greeting2": "Απομένουν μονάχα λίγα βήματα!",
  "qbe.greeting2_tagline": "Κάνε κλικ σε μια εργασία για να δεις μια υπόδειξη",
  "qbe.greeting3": "Μπράβο!",
  "qbe.greeting3_tagline": "Τώρα ας απολαύσουμε μουσική χωρίς διαφημίσεις, με υψηλή ποιότητα ήχου",
  "qbe.tasks.sign_in_to_spotify.title": "Συνδέσου στο Spotify",
  "qbe.tasks.search.title": "Ψάξε ένα τραγούδι",
  "qbe.tasks.search.header": "Βρες τα πάντα.",
  "qbe.tasks.search.description": "Οι περισσότεροι άνθρωποι χρησιμοποιούν την αναζήτηση για να βρουν έναν καλλιτέχνη ή ένα τραγούδι. Ήξερες όμως ότι μπορείς επίσης να ψάξεις για άλμπουμ, playlist και προφίλ;",
  "qbe.tasks.play_song.title": "Άκου ένα τραγούδι",
  "qbe.tasks.play_song.header": "Απογείωσέ το.",
  "qbe.tasks.play_song.description": "Κάνε διπλό κλικ σε ένα κομμάτι ή πάτα το play στα αριστερά μιας σειράς κομματιών για να ξεκινήσεις το ατέλειωτο streaming τραγουδιών.",
  "qbe.tasks.create_playlist.title": "Δημιούργησε μια playlist",
  "qbe.tasks.create_playlist.header": "Συγκέντρωσε τα κομμάτια σου.",
  "qbe.tasks.create_playlist.description": "Οι playlist είναι συλλογές κομματιών που δημιουργούνται από εσένα και άλλα άτομα, για κάθε διάθεση, περίσταση κ.λπ. Μπορείς να φτιάξεις όσες playlist θέλεις. Το μόνο που σε περιορίζει είναι η φαντασία σου.",
  "qbe.tasks.add_songs_to_playlist.title": "Πρόσθεσε {0} τραγούδια σε μια playlist",
  "qbe.tasks.add_songs_to_playlist.header": "Γέμισέ τη!",
  "qbe.tasks.add_songs_to_playlist.description": "Μια playlist δεν πρέπει να είναι άδεια. Κάνοντας κλικ στις τρεις τελείες στα δεξιά οποιασδήποτε σειράς κομματιών, εμφανίζεται η επιλογή να προσθέσεις ένα κομμάτι σε μια playlist. Δοκίμασέ το!",
  "qbe.reward.description": "Ολοκλήρωσε τις εργασίες σου για να ξεκλειδώσεις μια δωρεάν δοκιμή του Spotify Premium 7 ημερών.",
  "qbe.reward.what_is_premium": "Τι είναι το premium",
  "qbe.reward.cta": "Ενεργοποίησε το Premium",
  "qbe.reward.activated": "Η δοκιμή Premium ενεργοποιήθηκε!",
  "qbe.reward.activated_description": "Η δοκιμή σου ενεργοποιήθηκε και τώρα θα έχεις το Spotify Premium δωρεάν για 7 ημέρες. Ελπίζουμε να το απολαύσεις!",
  "qbe.modal.heading": "Αυτό είναι το Spotify Premium",
  "qbe.modal.download.title": "Κάνε download μουσική.",
  "qbe.modal.download.subtitle": "Άκου οπουδήποτε.",
  "qbe.modal.ads.title": "Χωρίς διαφημίσεις.",
  "qbe.modal.ads.subtitle": "Απόλαυσε μουσική χωρίς διακοπές.",
  "qbe.modal.play.title": "Άκου όποιο τραγούδι θες.",
  "qbe.modal.play.subtitle": "Ακόμα και στο κινητό.",
  "qbe.modal.skips.title": "Απεριόριστες παραλείψεις.",
  "qbe.modal.skips.subtitle": "Απλώς πάτα «επόμενο»."
}
},{}],5:[function(require,module,exports){
module.exports={
  "app.name": "Friend Feed",
  "app.description": "Friend Feed",
  "nux.description": "See what your friends are playing",
  "nux.recently_played_description": "Get quick access to all your recently played content here.",
  "button.follow": "Find Friends",
  "button.try_again": "Try again",
  "error.general_error_title": "Hmm, the Friend Feed failed to load.",
  "error.offline_title": "Friend feed is not available offline",
  "error.offline_subtitle": "Please go online to load Friend feed",
  "header.inactive_friends": "More Friends",
  "header.inactive_friends_tooltip": "Friends without recent public listening activity",
  "timeago.minutes": "{0} m",
  "timeago.hours": "{0} h",
  "timeago.days": "{0} d",
  "timeago.weeks": "{0} w",
  "timeago.now": "now",
  "surround.buddy_list.title": "Friend activity",
  "qbe.greeting_title": "Welcome",
  "qbe.greeting1": "Welcome {0}!",
  "qbe.greeting1_tagline": "Get Premium for free",
  "qbe.greeting2": "Just a few steps left!",
  "qbe.greeting2_tagline": "Click a task for a hint",
  "qbe.greeting3": "Well done!",
  "qbe.greeting3_tagline": "Now let's enjoy ad-free music with high sound quality",
  "qbe.tasks.sign_in_to_spotify.title": "Sign in to Spotify",
  "qbe.tasks.search.title": "Search for a song",
  "qbe.tasks.search.header": "Find everything.",
  "qbe.tasks.search.description": "Most people use search to find an artist or a song. But did you know you can also search for albums, playlists and profiles?",
  "qbe.tasks.play_song.title": "Play a song",
  "qbe.tasks.play_song.header": "Make it sing.",
  "qbe.tasks.play_song.description": "Double-click a track or press play on the left of a trackrow to start streaming endless songs.",
  "qbe.tasks.create_playlist.title": "Create a playlist",
  "qbe.tasks.create_playlist.header": "Collect your tracks.",
  "qbe.tasks.create_playlist.description": "Playlists are collections of tracks you and others can build for every mood, event, etc. You can make as many platlists as you like, the only limit is your imagination.",
  "qbe.tasks.add_songs_to_playlist.title": "Add {0} songs to a playlist",
  "qbe.tasks.add_songs_to_playlist.header": "Fill it up!",
  "qbe.tasks.add_songs_to_playlist.description": "A playlist shouldn't be empty. Clicking the three buttons to the right of any trackrow gives you the option to add a playlist. Try it!",
  "qbe.reward.description": "Complete your tasks to unlock a free 7 day Spotify Premium trial.",
  "qbe.reward.what_is_premium": "What is premium",
  "qbe.reward.cta": "Activate Premium",
  "qbe.reward.activated": "Your Premium trial is activated!",
  "qbe.reward.activated_description": "Your trial is activated and you now have Spotify Premium for free for 7 days. Hope you enjoy it!",
  "qbe.modal.heading": "This is Spotify Premium",
  "qbe.modal.download.title": "Download music.",
  "qbe.modal.download.subtitle": "Listen everywhere.",
  "qbe.modal.ads.title": "No ads.",
  "qbe.modal.ads.subtitle": "Enjoy nonstop music.",
  "qbe.modal.play.title": "Play any song.",
  "qbe.modal.play.subtitle": "Even on mobile.",
  "qbe.modal.skips.title": "Unlimited skips.",
  "qbe.modal.skips.subtitle": "Just hit next."
}
},{}],6:[function(require,module,exports){
module.exports={
  "app.name": "Actividad de amigos",
  "app.description": "Actividad de amigos",
  "nux.description": "Ve lo que están reproduciendo tus amigos",
  "nux.recently_played_description": "Acceso rápido a todo lo que escuchaste recientemente.",
  "button.follow": "Encontrar amigos",
  "button.try_again": "Intentar de nuevo",
  "error.general_error_title": "Mmmm, no se cargó el Feed de amigos.",
  "error.offline_title": "El Feed de amigos no está disponible sin conexión",
  "error.offline_subtitle": "Conéctate a Internet para cargar el Feed de amigos",
  "header.inactive_friends": "Más amigos",
  "header.inactive_friends_tooltip": "Amigos sin actividad de escucha pública reciente",
  "timeago.minutes": "{0} min",
  "timeago.hours": "{0} h",
  "timeago.days": "{0} d",
  "timeago.weeks": "{0} sem",
  "timeago.now": "ahora",
  "surround.buddy_list.title": "Actividad de amigos",
  "qbe.greeting_title": "Welcome",
  "qbe.greeting1": "¡Hola, {0}!",
  "qbe.greeting1_tagline": "Obtén Premium gratis",
  "qbe.greeting2": "¡Solo te faltan unos pasos más!",
  "qbe.greeting2_tagline": "Haz clic en una tarea y recibe un consejo",
  "qbe.greeting3": "¡Bien hecho!",
  "qbe.greeting3_tagline": "Ahora, disfruta de tu música en alta calidad y sin anuncios",
  "qbe.tasks.sign_in_to_spotify.title": "Inicia sesión en Spotify",
  "qbe.tasks.search.title": "Busca una canción",
  "qbe.tasks.search.header": "Encuentra todo lo que quieras.",
  "qbe.tasks.search.description": "La mayoría de las personas usan esta función para buscar una canción o a un artista.  Pero ¿sabías que también puedes buscar álbumes, playlists y perfiles?",
  "qbe.tasks.play_song.title": "Reproduce una canción.",
  "qbe.tasks.play_song.header": "Escúchala a todo volumen.",
  "qbe.tasks.play_song.description": "Haz doble clic en una canción o pulsa reproducir a la izquierda del nombre para empezar a escuchar tu música sin parar.",
  "qbe.tasks.create_playlist.title": "Crea una playlist",
  "qbe.tasks.create_playlist.header": "Reúne tus canciones favoritas.",
  "qbe.tasks.create_playlist.description": "Las playlists son colecciones de canciones creadas por los usuarios para un determinado estado de ánimo, evento, etc. Puedes crear tantas playlists como quieras. ¡No hay límite!",
  "qbe.tasks.add_songs_to_playlist.title": "Agrega {0} canciones a una playlist",
  "qbe.tasks.add_songs_to_playlist.header": "¡Arma tu propia colección!",
  "qbe.tasks.add_songs_to_playlist.description": "Una playlist no debería estar vacía. Haz clic en el ícono con tres puntos a la derecha de una canción y tendrás la opción de agregarla a una playlist. ¡Inténtalo!",
  "qbe.reward.description": "Completa estas tareas para obtener una prueba gratis de 7 días de Spotify Premium.",
  "qbe.reward.what_is_premium": "¿Qué es Premium?",
  "qbe.reward.cta": "Activar Premium",
  "qbe.reward.activated": "¡Se ha activado tu prueba de Premium!",
  "qbe.reward.activated_description": "Se ha activado tu período de prueba. Eso significa que ahora tienes 7 días de Spotify Premium gratis. ¡Disfrútalo!",
  "qbe.modal.heading": "Esto es Spotify Premium",
  "qbe.modal.download.title": "Descarga canciones.",
  "qbe.modal.download.subtitle": "Escucha en cualquier parte.",
  "qbe.modal.ads.title": "Sin anuncios.",
  "qbe.modal.ads.subtitle": "Disfruta de tu música sin interrupciones.",
  "qbe.modal.play.title": "Escucha la canción que quieras.",
  "qbe.modal.play.subtitle": "Incluso desde dispositivos móviles.",
  "qbe.modal.skips.title": "Sáltate todas las canciones que quieras.",
  "qbe.modal.skips.subtitle": "Tan solo pasa a la siguiente."
}
},{}],7:[function(require,module,exports){
module.exports={
  "app.name": "Actividad del amigo",
  "app.description": "Actividad del amigo",
  "nux.description": "Mira lo que escuchan tus amigos",
  "nux.recently_played_description": "Obtén acceso rápido a todo el contenido que hayas escuchado recientemente aquí.",
  "button.follow": "Encontrar amigos",
  "button.try_again": "Probar de nuevo",
  "error.general_error_title": "Vaya, no se ha logrado cargar la actividad de los amigos.",
  "error.offline_title": "La actividad de los amigos no está disponible sin conexión",
  "error.offline_subtitle": "Por favor, conéctate a Internet para cargar la actividad de los amigos",
  "header.inactive_friends": "Más amigos",
  "header.inactive_friends_tooltip": "Amigos sin actividad pública reciente",
  "timeago.minutes": "{0} m",
  "timeago.hours": "{0} h",
  "timeago.days": "{0} d",
  "timeago.weeks": "{0} seman.",
  "timeago.now": "ahora",
  "surround.buddy_list.title": "Actividad de los amigos",
  "qbe.greeting_title": "¡Hola!",
  "qbe.greeting1": "¡Hola, {0}!",
  "qbe.greeting1_tagline": "Consigue Premium gratis",
  "qbe.greeting2": "¡Solo faltan un par de pasos!",
  "qbe.greeting2_tagline": "Pulsa en las tareas si quieres ver ayuda",
  "qbe.greeting3": "¡Genial!",
  "qbe.greeting3_tagline": "Ahora vamos a disfrutar de música sin anuncios con sonido de alta calidad",
  "qbe.tasks.sign_in_to_spotify.title": "Inicia sesión en Spotify",
  "qbe.tasks.search.title": "Buscar una canción",
  "qbe.tasks.search.header": "Encuentra lo que quieras.",
  "qbe.tasks.search.description": "La mayoría de la gente usa la búsqueda para encontrar un artista o una canción. Pero ¿sabes que también puedes buscar álbumes, playlists y perfiles?",
  "qbe.tasks.play_song.title": "Escucha una canción",
  "qbe.tasks.play_song.header": "¡Que suene!",
  "qbe.tasks.play_song.description": "Haz doble clic en la canción o dale al play a la izquierda de la canción para iniciar una cadena de música sin fin.",
  "qbe.tasks.create_playlist.title": "Crea una playlist",
  "qbe.tasks.create_playlist.header": "Recopila tus canciones.",
  "qbe.tasks.create_playlist.description": "Las playlists son colecciones de canciones que tú y tus amigos podéis reunir para cualquier estado de ánimo, evento, etc. Puedes hacer tantas como quieras. ¡El único límite es tu imaginación!",
  "qbe.tasks.add_songs_to_playlist.title": "Añade {0} canciones a una playlist",
  "qbe.tasks.add_songs_to_playlist.header": "¡Llénala bien!",
  "qbe.tasks.add_songs_to_playlist.description": "Una playlist no debería estar vacía. Pulsando en los tres puntos que aparecen a la derecha de cada canción te saldrá la opción de añadirla a una playlist. ¡Pruébalo!",
  "qbe.reward.description": "Completa las tareas y recibe una prueba gratuita de 7 días de Spotify Premium.",
  "qbe.reward.what_is_premium": "¿Qué es Premium?",
  "qbe.reward.cta": "Activa Premium",
  "qbe.reward.activated": "¡Prueba Premium activada!",
  "qbe.reward.activated_description": "Tu prueba está activada y ahora puedes disfrutar de Spotify Premium gratis durante 7 días. ¡Esperamos que te guste!",
  "qbe.modal.heading": "Spotify Premium es esto",
  "qbe.modal.download.title": "Descarga música.",
  "qbe.modal.download.subtitle": "Escúchala donde quieras.",
  "qbe.modal.ads.title": "Sin anuncios.",
  "qbe.modal.ads.subtitle": "Disfruta de música sin parar.",
  "qbe.modal.play.title": "Escucha a la carta.",
  "qbe.modal.play.subtitle": "Incluso en móvil.",
  "qbe.modal.skips.title": "Salta canciones sin límites.",
  "qbe.modal.skips.subtitle": "Simplemente dale a \"siguiente\"."
}
},{}],8:[function(require,module,exports){
module.exports={
  "app.name": "Kaverinsyöte",
  "app.description": "Kaverinsyöte",
  "nux.description": "Selvitä, mitä kaverisi kuuntelevat",
  "nux.recently_played_description": "Tästä pääset nopeasti käsiksi äskettäin kuunneltuun sisältöön.",
  "button.follow": "Löydä kavereita",
  "button.try_again": "Yritä uudelleen",
  "error.general_error_title": "Hmm, kaverisyötteen lataus ei onnistunut.",
  "error.offline_title": "Kaverisyötettä ei voi käyttää offline-tilassa",
  "error.offline_subtitle": "Siirry online-tilaan, jotta voit ladata kaverisyötteen",
  "header.inactive_friends": "Lisää kavereita",
  "header.inactive_friends_tooltip": "Kaverit, joilla ei ole viimeaikaisia kuuntelutapahtumia",
  "timeago.minutes": "{0} min",
  "timeago.hours": "{0} h",
  "timeago.days": "{0} pv",
  "timeago.weeks": "{0} vk",
  "timeago.now": "nyt",
  "surround.buddy_list.title": "Kaverin toimet",
  "qbe.greeting_title": "Tervetuloa",
  "qbe.greeting1": "Tervetuloa, {0}!",
  "qbe.greeting1_tagline": "Hanki Premium ilmaiseksi",
  "qbe.greeting2": "Enää muutama vaihe!",
  "qbe.greeting2_tagline": "Saat vinkin napsauttamalla kohdetta",
  "qbe.greeting3": "Hyvä!",
  "qbe.greeting3_tagline": "Nyt voit nauttia musiikista ilman mainoksia sekä erinomaisesta äänenlaadusta",
  "qbe.tasks.sign_in_to_spotify.title": "Kirjaudu sisään Spotifyhin",
  "qbe.tasks.search.title": "Hae kappaletta",
  "qbe.tasks.search.header": "Hae kaikkea kaipaamaasi.",
  "qbe.tasks.search.description": "Useimmat käyttävät hakua artistin tai kappaleen etsimiseen. Tiesitkö, että voit hakea myös albumeja, soittolistoja ja profiileja?",
  "qbe.tasks.play_song.title": "Kuuntele kappale",
  "qbe.tasks.play_song.header": "Anna musiikin soida.",
  "qbe.tasks.play_song.description": "Aloita jatkuva striimaus kaksoisnapsauttamalla kappaletta tai painamalla toistopainiketta kappaleen nimen vasemmalla puolella.",
  "qbe.tasks.create_playlist.title": "Luo soittolista",
  "qbe.tasks.create_playlist.header": "Kokoa kappaleesi yhteen.",
  "qbe.tasks.create_playlist.description": "Soittolistat ovat kappalekokoelmia, joita sinä ja muut voitte luoda jokaista mielentilaa, tapahtumaa ja ties mitä muuta varten. Voit luoda niin monta soittolistaa kuin haluat – ainoastaan mielikuvituksesi on rajana.",
  "qbe.tasks.add_songs_to_playlist.title": "Lisää {0} kappaletta soittolistaan",
  "qbe.tasks.add_songs_to_playlist.header": "Käytä kaikki tila hyväksi!",
  "qbe.tasks.add_songs_to_playlist.description": "Soittolistaa ei kannata jättää tyhjäksi. Napsauttamalla minkä tahansa kappaleen oikealla puolella olevaa kolmea pistettä voit lisätä kappaleita soittolistaan. Kokeile itse!",
  "qbe.reward.description": "Viimeistele tehtävät, niin saat Spotify Premiumin kokeiltavaksi ilmaiseksi seitsemän päivän ajaksi.",
  "qbe.reward.what_is_premium": "Mikä Premium on?",
  "qbe.reward.cta": "Aktivoi Premium",
  "qbe.reward.activated": "Premium-kokeilujaksosi on alkanut!",
  "qbe.reward.activated_description": "Kokeilujaksosi on alkanut, ja voit nyt käyttää Spotify Premiumia ilmaiseksi seitsemän päivän ajan. Toivottavasti pidät siitä!",
  "qbe.modal.heading": "Tällainen on Spotify Premium",
  "qbe.modal.download.title": "Lataa musiikkia.",
  "qbe.modal.download.subtitle": "Kuuntele missä vain.",
  "qbe.modal.ads.title": "Ei mainoksia.",
  "qbe.modal.ads.subtitle": "Nauti musiikista tauotta.",
  "qbe.modal.play.title": "Kuuntele mikä tahansa kappale.",
  "qbe.modal.play.subtitle": "Myös mobiililaitteilla.",
  "qbe.modal.skips.title": "Rajoittamaton määrä skippauksia.",
  "qbe.modal.skips.subtitle": "Siirry vain seuraavaan."
}
},{}],9:[function(require,module,exports){
module.exports={
  "app.name": "Fil d'actualité d'un ami",
  "app.description": "Fil d'actualité d'un ami",
  "nux.description": "Voyez ce que vos amis écoutent",
  "nux.recently_played_description": "Obtenez un accès rapide à tous vos contenus écoutés récemment ici.",
  "button.follow": "Trouver des amis",
  "button.try_again": "Réessayer",
  "error.general_error_title": "Mince ! Impossible de charger le flux des activités de votre ami.",
  "error.offline_title": "Le fil d'actualité de votre ami n'est pas accessible hors ligne.",
  "error.offline_subtitle": "Veuillez accéder à Internet pour charger le fil d'actualité de votre ami.",
  "header.inactive_friends": "Plus d'amis",
  "header.inactive_friends_tooltip": "Amis qui n'ont pas d'écoutes publiques récentes",
  "timeago.minutes": "{0} m",
  "timeago.hours": "{0} h",
  "timeago.days": "{0} j",
  "timeago.weeks": "{0} s",
  "timeago.now": "maintenant",
  "surround.buddy_list.title": "Activité d'un ami",
  "qbe.greeting_title": "Bienvenue",
  "qbe.greeting1": "Bienvenue {0}!",
  "qbe.greeting1_tagline": "Abonnez-vous gratuitement à Spotify Premium",
  "qbe.greeting2": "Il ne reste que quelques étapes!",
  "qbe.greeting2_tagline": "Cliquez sur une tâche pour afficher un indice",
  "qbe.greeting3": "Bien joué!",
  "qbe.greeting3_tagline": "Appréciez maintenant de la musique sans publicité avec une qualité sonore supérieure",
  "qbe.tasks.sign_in_to_spotify.title": "Connectez-vous à Spotify",
  "qbe.tasks.search.title": "Rechercher une chanson",
  "qbe.tasks.search.header": "Trouvez tout ce que vous souhaitez.",
  "qbe.tasks.search.description": "La majorité des abonnés utilisent la fonction « Rechercher » pour trouver un artiste ou une chanson. Mais saviez-vous que vous pouvez également rechercher des albums, des listes de lecture et des profils?",
  "qbe.tasks.play_song.title": "Écoutez une chanson",
  "qbe.tasks.play_song.header": "Faites-la chanter.",
  "qbe.tasks.play_song.description": "Double-cliquez sur une chanson ou touchez « Lecture » à gauche de la ligne d'une chanson pour commencer à diffuser des chansons à l'infini.",
  "qbe.tasks.create_playlist.title": "Créez une liste de lecture",
  "qbe.tasks.create_playlist.header": "Collectionnez vos chansons.",
  "qbe.tasks.create_playlist.description": "Les listes de lecture sont des collections de chansons que vous (et d'autres personnes) pouvez créer pour chaque humeur, événement, etc. Vous pouvez créer autant de listes de lecture que vous le souhaitez, la seule limite est votre imagination.",
  "qbe.tasks.add_songs_to_playlist.title": "Ajoutez {0} chansons à une liste de lecture",
  "qbe.tasks.add_songs_to_playlist.header": "Remplissez-la!",
  "qbe.tasks.add_songs_to_playlist.description": "Une liste de lecture ne doit pas être vide. Si vous cliquez sur les trois boutons à droite de la ligne d'une chanson, vous aurez l'option de l'ajouter à une liste de lecture. Essayez!",
  "qbe.reward.description": "Achevez vos tâches pour déverrouiller un essai gratuit de sept jours de Spotify Premium.",
  "qbe.reward.what_is_premium": "Qu'est-ce que Spotify Premium?",
  "qbe.reward.cta": "Activez Spotify Premium",
  "qbe.reward.activated": "Votre essai de Spotify Premium est activé!",
  "qbe.reward.activated_description": "Votre essai est activé et vous pouvez maintenant profiter gratuitement de Spotify Premium pendant sept jours. Nous espérons que vous l'aimerez!",
  "qbe.modal.heading": "Voici Spotify Premium",
  "qbe.modal.download.title": "Téléchargez de la musique.",
  "qbe.modal.download.subtitle": "Écoutez partout.",
  "qbe.modal.ads.title": "Aucune publicité.",
  "qbe.modal.ads.subtitle": "Appréciez la musique sans interruption.",
  "qbe.modal.play.title": "Écoutez n'importe quelle chanson.",
  "qbe.modal.play.subtitle": "Même sur un appareil mobile.",
  "qbe.modal.skips.title": "Sauts illimités.",
  "qbe.modal.skips.subtitle": "Touchez simplement « Suivant »."
}
},{}],10:[function(require,module,exports){
module.exports={
  "app.name": "Flux d'amis",
  "app.description": "Flux d'amis",
  "nux.description": "Voir ce que vos amis écoutent",
  "nux.recently_played_description": "Accédez rapidement à tous vos titres récents ici.",
  "button.follow": "Trouver des amis",
  "button.try_again": "Réessayez",
  "error.general_error_title": "Mince ! Impossible de charger le flux d'amis.",
  "error.offline_title": "Le flux d'amis n'est pas disponible hors connexion.",
  "error.offline_subtitle": "Connectez-vous pour charger le flux d'amis.",
  "header.inactive_friends": "Davantage d'amis",
  "header.inactive_friends_tooltip": "Amis sans activité publique récente",
  "timeago.minutes": "{0} min",
  "timeago.hours": "{0} h",
  "timeago.days": "{0} j",
  "timeago.weeks": "{0} sem",
  "timeago.now": "maintenant",
  "surround.buddy_list.title": "Activité de vos amis",
  "qbe.greeting_title": "Bienvenue",
  "qbe.greeting1": "Bienvenue {0} !",
  "qbe.greeting1_tagline": "Abonnez-vous à Spotify Premium gratuitement.",
  "qbe.greeting2": "Vous y êtes presque !",
  "qbe.greeting2_tagline": "Cliquez sur une tâche pour recevoir un indice.",
  "qbe.greeting3": "Bien joué !",
  "qbe.greeting3_tagline": "À présent, écoutons la musique sans interruption en profitant d'une qualité de son exceptionnelle.",
  "qbe.tasks.sign_in_to_spotify.title": "S'inscrire sur Spotify",
  "qbe.tasks.search.title": "Chercher un titre",
  "qbe.tasks.search.header": "Trouvez tout ce que vous voulez.",
  "qbe.tasks.search.description": "La plupart des utilisateurs utilisent la fonction de recherche pour trouver un artiste ou un titre. Mais saviez-vous que vous pouvez également chercher des albums, des playlists et des profils ?",
  "qbe.tasks.play_song.title": "Écouter un titre",
  "qbe.tasks.play_song.header": "Faites la différence.",
  "qbe.tasks.play_song.description": "Double-cliquez sur un titre ou appuyez sur Lire à gauche d'une liste de morceaux pour écouter à l'infini.",
  "qbe.tasks.create_playlist.title": "Créer une playlist",
  "qbe.tasks.create_playlist.header": "Collectionnez la musique.",
  "qbe.tasks.create_playlist.description": "Les playlists sont des collections de titres que les utilisateurs peuvent créer pour chaque ambiance, événement, etc. Vous pouvez créer autant de playlists que vous le souhaitez. La seule limite est votre imagination.",
  "qbe.tasks.add_songs_to_playlist.title": "Ajouter {0} titres à une playlist",
  "qbe.tasks.add_songs_to_playlist.header": "Faites le plein !",
  "qbe.tasks.add_songs_to_playlist.description": "Une playlist ne peut en aucun cas rester vide. Cliquez sur les trois boutons à droite d'une liste de morceaux pour pouvoir ajouter une playlist. À tester !",
  "qbe.reward.description": "Accomplissez vos tâches pour pouvoir tester Spotify Premium gratuitement pendant 7 jours.",
  "qbe.reward.what_is_premium": "Qu'est-ce que Spotify Premium ?",
  "qbe.reward.cta": "Activer Spotify Premium",
  "qbe.reward.activated": "Votre essai Premium est activé !",
  "qbe.reward.activated_description": "Votre essai est activé. Vous pouvez profiter de Spotify Premium gratuitement pendant 7 jours. Bonne écoute !",
  "qbe.modal.heading": "Spotify Premium en bref",
  "qbe.modal.download.title": "Téléchargez votre musique.",
  "qbe.modal.download.subtitle": "Écoutez partout.",
  "qbe.modal.ads.title": "Zéro pub.",
  "qbe.modal.ads.subtitle": "Écoutez votre musique non-stop.",
  "qbe.modal.play.title": "Écoutez les titres de votre choix.",
  "qbe.modal.play.subtitle": "Même sur votre mobile.",
  "qbe.modal.skips.title": "Passez autant de titres que vous voulez.",
  "qbe.modal.skips.subtitle": "Appuyez simplement sur Suivant."
}
},{}],11:[function(require,module,exports){
module.exports={
  "app.name": "Ismerőseidtől érkezett",
  "app.description": "Ismerőseidtől érkezett",
  "nux.description": "Megnézheted, mit hallgatnak az ismerőseid",
  "nux.recently_played_description": "Itt gyorsan hozzáférhetsz az összes nemrég lejátszott tartalomhoz.",
  "button.follow": "Ismerősök keresése",
  "button.try_again": "Próbáld meg újra",
  "error.general_error_title": "Nem sikerült betölteni az ismerősöktől származó információkat.",
  "error.offline_title": "Offline módban nem érhető el az ismerősök üzenőfala.",
  "error.offline_subtitle": "Az ismerősök üzenőfalának betöltéséhez internetkapcsolat szükséges",
  "header.inactive_friends": "További ismerősök",
  "header.inactive_friends_tooltip": "Ismerősök nyilvános közelmúltbeli zenehallgatási megosztások nélkül",
  "timeago.minutes": "{0} p",
  "timeago.hours": "{0} ó",
  "timeago.days": "{0} n",
  "timeago.weeks": "{0} h",
  "timeago.now": "most",
  "surround.buddy_list.title": "Ismerős tevékenysége",
  "qbe.greeting_title": "Üdv!",
  "qbe.greeting1": "Üdv, {0}!",
  "qbe.greeting1_tagline": "Legyél Premium-felhasználó ingyen",
  "qbe.greeting2": "Már csak néhány lépés!",
  "qbe.greeting2_tagline": "A segítség megtekintéséhez kattints a feladatokra ",
  "qbe.greeting3": "Szép volt!",
  "qbe.greeting3_tagline": "Most pedig élvezd a reklámmentes zenéket, kiváló hangminőségben.",
  "qbe.tasks.sign_in_to_spotify.title": "Bejelentkezés a Spotifyra",
  "qbe.tasks.search.title": "Dal keresése",
  "qbe.tasks.search.header": "Találj meg bármit.",
  "qbe.tasks.search.description": "A legtöbben csak előadókra és dalokra keresnek rá. Tudtad amúgy, hogy albumokat, műsorlistákat és profilokat is kereshetsz?",
  "qbe.tasks.play_song.title": "Dal lejátszása",
  "qbe.tasks.play_song.header": "Hadd szóljon.",
  "qbe.tasks.play_song.description": "A véget nem érő számok streameléséhez kattints duplán egy számra, vagy kattints a szám sorának bal oldalán a lejátszásra.",
  "qbe.tasks.create_playlist.title": "Műsorlista létrehozása",
  "qbe.tasks.create_playlist.header": "Gyűjtsd a számokat.",
  "qbe.tasks.create_playlist.description": "A műsorlisták számgyűjtemények, amelyeket te és a többi felhasználó hozhattok létre bármilyen hangulathoz, eseményhez stb. Annyi műsorlistát hozhatsz létre, amennyit csak akarsz.",
  "qbe.tasks.add_songs_to_playlist.title": "{0} dal hozzáadása műsorlistához",
  "qbe.tasks.add_songs_to_playlist.header": "Töltsd meg!",
  "qbe.tasks.add_songs_to_playlist.description": "Egyetlen műsorlista se maradjon üresen. Bármely szám sorának jobb oldalán a három gombra kattintva kiválaszthatod a műsorlistához való hozzáadás lehetőségét. Próbáld ki!",
  "qbe.reward.description": "Teljesítsd a feladatokat, és 7 napos ingyenes Spotify-próbaidőszak lesz a jutalmad.",
  "qbe.reward.what_is_premium": "Mi az a Premium?",
  "qbe.reward.cta": "Premium aktiválása",
  "qbe.reward.activated": "Aktiváltad a Premium próbaidőszakát!",
  "qbe.reward.activated_description": "A próbaidőszak aktiválva van, megkezdődött tehát 7 napos ingyenes Spotify Premium-időszakod. Reméljük, szeretni fogod!",
  "qbe.modal.heading": "Ez a Spotify Premium",
  "qbe.modal.download.title": "Zeneletöltés.",
  "qbe.modal.download.subtitle": "Zenehallgatás bárhol.",
  "qbe.modal.ads.title": "És nincs több reklám.",
  "qbe.modal.ads.subtitle": "Megszakítások nélküli zene.",
  "qbe.modal.play.title": "Bármely dal meghallgatása.",
  "qbe.modal.play.subtitle": "Mobilon is.",
  "qbe.modal.skips.title": "Korlátlanul válthatsz számot.",
  "qbe.modal.skips.subtitle": "Csak lépj a következőre."
}
},{}],12:[function(require,module,exports){
module.exports={
  "app.name": "Feed Teman",
  "app.description": "Feed Teman",
  "nux.description": "Lihat yang dimainkan temanmu",
  "nux.recently_played_description": "Dapatkan akses cepat ke semua konten yang baru kamu putar di sini.",
  "button.follow": "Cari Teman",
  "button.try_again": "Coba lagi",
  "error.general_error_title": "Hmm, gagal memuat Feed Teman.",
  "error.offline_title": "Feed teman tidak tersedia offline.",
  "error.offline_subtitle": "Alihkan ke online untuk memuat Feed teman",
  "header.inactive_friends": "Teman Lainnya",
  "header.inactive_friends_tooltip": "Teman tanpa aktivitas mendengarkan publik terkini",
  "timeago.minutes": "{0} mnt",
  "timeago.hours": "{0} jam",
  "timeago.days": "{0} hr",
  "timeago.weeks": "{0} mg",
  "timeago.now": "sekarang",
  "surround.buddy_list.title": "Aktivitas teman",
  "qbe.greeting_title": "Selamat Datang",
  "qbe.greeting1": "Selamat datang {0}!",
  "qbe.greeting1_tagline": "Dapatkan akun Premium gratis",
  "qbe.greeting2": "Hanya beberapa langkah lagi!",
  "qbe.greeting2_tagline": "Klik tugas untuk mendapatkan petunjuk",
  "qbe.greeting3": "Hebat!",
  "qbe.greeting3_tagline": "Sekarang mari kita nikmati musik bebas iklan dengan suara berkualitas tinggi",
  "qbe.tasks.sign_in_to_spotify.title": "Masuk ke Spotify",
  "qbe.tasks.search.title": "Cari lagu",
  "qbe.tasks.search.header": "Temukan segala hal. ",
  "qbe.tasks.search.description": "Banyak orang menggunakan pencarian untuk menemukan artis atau lagu. Tapi apakah kamu tahu, kamu juga bisa mencari album, playlist, dan profil?",
  "qbe.tasks.play_song.title": "Putar lagu",
  "qbe.tasks.play_song.header": "Nyanyikanlah.",
  "qbe.tasks.play_song.description": "Klik dua kali lagu atau tekan putar di sebelah kiri baris lagu untuk mulai streaming lagu tanpa batas.",
  "qbe.tasks.create_playlist.title": "Buat playlist",
  "qbe.tasks.create_playlist.header": "Kumpulkan lagumu.",
  "qbe.tasks.create_playlist.description": "Playlist adalah koleksi lagu yang bisa kamu dan orang lain buat untuk setiap suasana hati, acara, dll. Kamu bisa membuat playlist sebanyak yang kamu suka, satu-satunya batasan hanyalah imajinasimu.",
  "qbe.tasks.add_songs_to_playlist.title": "Tambah {0} lagu ke playlist",
  "qbe.tasks.add_songs_to_playlist.header": "Penuhi koleksimu!",
  "qbe.tasks.add_songs_to_playlist.description": "Playlist tidak boleh kosong. Mengeklik tiga tombol di sebelah kanan pada baris lagu mana pun akan memberimu opsi untuk menambahkan playlist. Cobalah!",
  "qbe.reward.description": "Selesaikan tugasmu untuk membuka uji coba Spotify Premium gratis selama 7 hari.",
  "qbe.reward.what_is_premium": "Apakah premium itu",
  "qbe.reward.cta": "Aktfikan Premium",
  "qbe.reward.activated": "Uji coba Premium kamu diaktifkan!",
  "qbe.reward.activated_description": "Uji cobamu diakifkan dan sekarang kamu memiliki Spotify Premium gratis selama 7 hari. Semoga kamu suka!",
  "qbe.modal.heading": "Ini adalah Spotify Premium",
  "qbe.modal.download.title": "Unduh musik.",
  "qbe.modal.download.subtitle": "Dengarkan di mana saja.",
  "qbe.modal.ads.title": "Tanpa iklan.",
  "qbe.modal.ads.subtitle": "Nikmati musik tanpa henti.",
  "qbe.modal.play.title": "Putar lagu apa saja.",
  "qbe.modal.play.subtitle": "Bahkan di ponsel.",
  "qbe.modal.skips.title": "Lewati tak terbatas.",
  "qbe.modal.skips.subtitle": "Cukup tekan berikutnya."
}
},{}],13:[function(require,module,exports){
module.exports={
  "app.name": "Feed amici",
  "app.description": "Feed amici",
  "nux.description": "Scopri cosa stanno ascoltando i tuoi amici",
  "nux.recently_played_description": "Qui potrai accedere rapidamente a tutti i contenuti riprodotti di recente.",
  "button.follow": "Trova amici",
  "button.try_again": "Riprova",
  "error.general_error_title": "Uhm, caricamento Feed Amici non riuscito.",
  "error.offline_title": "Feed Amici non disponibile offline.",
  "error.offline_subtitle": "Vai online per caricare il feed Amici.",
  "header.inactive_friends": "Altri amici",
  "header.inactive_friends_tooltip": "Amici senza attività pubbliche di ascolto recenti",
  "timeago.minutes": "{0} m",
  "timeago.hours": "{0} h",
  "timeago.days": "{0} g",
  "timeago.weeks": "{0} sett",
  "timeago.now": "ora",
  "surround.buddy_list.title": "Attività amici",
  "qbe.greeting_title": "Benvenuti",
  "qbe.greeting1": "Benvenuto {0}",
  "qbe.greeting1_tagline": "Passa gratis a Premium",
  "qbe.greeting2": "Mancano pochi passaggi.",
  "qbe.greeting2_tagline": "Seleziona un'attività per ricevere un suggerimento",
  "qbe.greeting3": "Ottimo.",
  "qbe.greeting3_tagline": "Ora immergiti nella musica senza pubblicità con una qualità audio elevata ",
  "qbe.tasks.sign_in_to_spotify.title": "Accedi a Spotify",
  "qbe.tasks.search.title": "Cerca un brano",
  "qbe.tasks.search.header": "Trova tutto quello che cerchi.",
  "qbe.tasks.search.description": "Molti usano la ricerca per trovare un artista o un brano. Sapevi che puoi cercare anche album, playlist e profili?",
  "qbe.tasks.play_song.title": "Riproduci un brano",
  "qbe.tasks.play_song.header": "Inizia ad ascoltare.",
  "qbe.tasks.play_song.description": "Clicca due volte su un brano o premi Play a sinistra di un elenco di brani per avviare lo streaming di brani illimitati.",
  "qbe.tasks.create_playlist.title": "Crea una playlist",
  "qbe.tasks.create_playlist.header": "Crea una selezione dei tuoi brani.",
  "qbe.tasks.create_playlist.description": "Le playlist sono raccolte di brani che tutti gli utenti possono creare per qualsiasi mood, occasione, ecc. L'unico limite al numero di playlist che puoi creare è la tua immaginazione.",
  "qbe.tasks.add_songs_to_playlist.title": "Aggiungi {0} brani a una playlist",
  "qbe.tasks.add_songs_to_playlist.header": "Riempi di musica la tua playlist!",
  "qbe.tasks.add_songs_to_playlist.description": "Una playlist non dovrebbe essere vuota. Cliccando sull'icona con i tre punti a destra di qualsiasi elenco di brani puoi aggiungere una playlist. Prova!",
  "qbe.reward.description": "Completa le tue attività per provare Spotify Premium gratis per 7 giorni.",
  "qbe.reward.what_is_premium": "Che cos'è Premium?",
  "qbe.reward.cta": "Attiva Premium",
  "qbe.reward.activated": "Il tuo periodo di prova di Premium è attivo.",
  "qbe.reward.activated_description": "Il tuo periodo di prova è attivo e ora puoi usare Spotify Premium gratis per 7 giorni. Buon ascolto!",
  "qbe.modal.heading": "Ecco Spotify Premium",
  "qbe.modal.download.title": "Scarica la musica.",
  "qbe.modal.download.subtitle": "Ascolta ovunque ti trovi.",
  "qbe.modal.ads.title": "Niente pubblicità.",
  "qbe.modal.ads.subtitle": "Immergiti in musica non-stop.",
  "qbe.modal.play.title": "Ascolta qualsiasi brano.",
  "qbe.modal.play.subtitle": "Accedi anche da dispositivo mobile.",
  "qbe.modal.skips.title": "Approfitta di salti illimitati.",
  "qbe.modal.skips.subtitle": "Ti basta passare al brano successivo."
}
},{}],14:[function(require,module,exports){
module.exports={
  "app.name": "友達フィード",
  "app.description": "友達フィード",
  "nux.description": "友達が聴いている曲をチェックしよう",
  "nux.recently_played_description": "ここには最近再生したすべてのコンテンツが表示され、簡単にアクセスできます。",
  "button.follow": "友達を探す",
  "button.try_again": "再試行する",
  "error.general_error_title": "友達フィードのロードに失敗しました。",
  "error.offline_title": "友達フィードはオフラインでは表示できません",
  "error.offline_subtitle": "友達フィードをロードするには、インターネットに接続してください",
  "header.inactive_friends": "その他フォロー中",
  "header.inactive_friends_tooltip": "最近の再生アクティビティを公開していない友達",
  "timeago.minutes": "{0}分前",
  "timeago.hours": "{0}時間前",
  "timeago.days": "{0}日前",
  "timeago.weeks": "{0}週間前",
  "timeago.now": "現在",
  "surround.buddy_list.title": "友達のアクティビティ",
  "qbe.greeting_title": "ようこそ",
  "qbe.greeting1": "ようこそ {0}さん",
  "qbe.greeting1_tagline": "無料でPremiumにアップグレード",
  "qbe.greeting2": "あと少しで完了です！",
  "qbe.greeting2_tagline": "ヒントを得るにはタスクをクリックしてください",
  "qbe.greeting3": "すべて完了です！",
  "qbe.greeting3_tagline": "さあ、広告なしで高音質ミュージックを楽しもう",
  "qbe.tasks.sign_in_to_spotify.title": "Spotifyにログインする",
  "qbe.tasks.search.title": "曲を検索",
  "qbe.tasks.search.header": "お好きなものをなんでも検索。",
  "qbe.tasks.search.description": "アーティストや曲を見つけるために、検索機能を使用する人がほとんどですが、アルバム、プレイリスト、プロフィールも検索できることをご存知ですか？",
  "qbe.tasks.play_song.title": "曲を再生する",
  "qbe.tasks.play_song.header": "聴きたい曲を再生してみよう。",
  "qbe.tasks.play_song.description": "トラックをダブルクリック、または曲の左側にある再生ボタンを押すと、途切れることなくストリーミングが行われます。",
  "qbe.tasks.create_playlist.title": "プレイリストを作成する",
  "qbe.tasks.create_playlist.header": "お気に入りのトラックを集めよう。",
  "qbe.tasks.create_playlist.description": "プレイリストは、ユーザーがあらゆるムードやシーンにぴったりの曲を集めたコレクション。想像力を働かせて、好きなだけプレイリストを作ろう。",
  "qbe.tasks.add_songs_to_playlist.title": " {0} 曲プレイリストに追加しよう。",
  "qbe.tasks.add_songs_to_playlist.header": "曲でいっぱいにしよう！",
  "qbe.tasks.add_songs_to_playlist.description": "曲が入っていなければプレイリストとは呼べません。トラックの右側にある三つのボタンをクリックすると、プレイリストに追加するオプションが出てきます。お試しください！",
  "qbe.reward.description": "タスクを完了すると、Spotify Premiumの7日間無料トライアルをご利用いただけます。",
  "qbe.reward.what_is_premium": "Premiumとは？",
  "qbe.reward.cta": "Premiumを有効化する",
  "qbe.reward.activated": "Premium無料トライアルが有効化されました！",
  "qbe.reward.activated_description": "トライアルが有効化しました。今から7日間無料でSpotify Premiumをご利用いただけます。ぜひお楽しみください！",
  "qbe.modal.heading": "Spotify Premiumでできること",
  "qbe.modal.download.title": "ミュージックをダウンロードできる。",
  "qbe.modal.download.subtitle": "どこでもミュージックを聴ける。",
  "qbe.modal.ads.title": "広告なし。",
  "qbe.modal.ads.subtitle": "ノンストップでミュージックを楽しめる。",
  "qbe.modal.play.title": "好きな曲を好きな順番で再生できる。",
  "qbe.modal.play.subtitle": "スマホでも再生できる。",
  "qbe.modal.skips.title": "無制限にスキップできる。",
  "qbe.modal.skips.subtitle": "スキップするには、［次へ］ボタンを押すだけ。"
}
},{}],15:[function(require,module,exports){
module.exports={
  "app.name": "Feed van vrienden",
  "app.description": "Feed van vrienden",
  "nux.description": "Ontdek waar je vrienden naar luisteren",
  "nux.recently_played_description": "Hier vind je snel al je recent afgespeelde content.",
  "button.follow": "Vrienden zoeken",
  "button.try_again": "Probeer het nog eens",
  "error.general_error_title": "Hmm, de vriendenfeed kon niet worden geladen.",
  "error.offline_title": "Vriendenfeed is niet offline beschikbaar",
  "error.offline_subtitle": "Ga online om je vriendenfeed te laden",
  "header.inactive_friends": "Meer vrienden",
  "header.inactive_friends_tooltip": "Vrienden zonder recente openbare luisteractiviteit",
  "timeago.minutes": "{0} m",
  "timeago.hours": "{0} u",
  "timeago.days": "{0} d",
  "timeago.weeks": "{0} w",
  "timeago.now": "nu",
  "surround.buddy_list.title": "Activiteit van vrienden",
  "qbe.greeting_title": "Welkom",
  "qbe.greeting1": "Welkom {0}!",
  "qbe.greeting1_tagline": "Krijg Premium gratis",
  "qbe.greeting2": "Nog een paar stappen te gaan!",
  "qbe.greeting2_tagline": "Klik op een taak voor een hint",
  "qbe.greeting3": "Voor elkaar!",
  "qbe.greeting3_tagline": "Geniet nu advertentievrij van muziek met hoge geluidskwaliteit",
  "qbe.tasks.sign_in_to_spotify.title": "Aanmelden bij Spotify ",
  "qbe.tasks.search.title": "Zoek een nummer",
  "qbe.tasks.search.header": "Vind alles.",
  "qbe.tasks.search.description": "De meeste mensen gebruiken de zoekfunctie om een artiest of nummer te vinden. Maar wist je dat je ook kunt zoeken naar albums, afspeellijsten en profielen?",
  "qbe.tasks.play_song.title": "Een nummer afspelen",
  "qbe.tasks.play_song.header": "Het allerbelangrijkste.",
  "qbe.tasks.play_song.description": "Dubbelklik op een nummer of klik op Afspelen aan de linkerkant van een titel om te beginnen met het oneindig streamen van nummers.",
  "qbe.tasks.create_playlist.title": "Een afspeellijst maken",
  "qbe.tasks.create_playlist.header": "Verzamel je nummers.",
  "qbe.tasks.create_playlist.description": "Afspeellijsten zijn verzamelingen van nummers die jij en anderen kunnen samenstellen voor elke stemming, elk evenement enzovoort. Je kunt zo veel afspeellijsten maken als je wilt. Laat je fantasie de vrije loop!",
  "qbe.tasks.add_songs_to_playlist.title": "{0} nummers toevoegen aan een afspeellijst",
  "qbe.tasks.add_songs_to_playlist.header": "Zet hem vol!",
  "qbe.tasks.add_songs_to_playlist.description": "Een afspeellijst hoort niet leeg te zijn. Als je op de drie stippen aan de rechterzijde van een titel klikt, kun je het nummer toevoegen aan een afspeellijst. Probeer het eens!",
  "qbe.reward.description": "Voltooi je taken om een gratis proefabonnement van 7 dagen op Spotify Premium te ontgrendelen.",
  "qbe.reward.what_is_premium": "Wat is Premium",
  "qbe.reward.cta": "Premium activeren",
  "qbe.reward.activated": "Je proefabonnement op Premium is geactiveerd!",
  "qbe.reward.activated_description": "Je proefabonnement is geactiveerd en je kunt nu 7 dagen gratis genieten van Spotify Premium. We hopen dat je het leuk vindt!",
  "qbe.modal.heading": "Dit is Spotify Premium",
  "qbe.modal.download.title": "Download muziek.",
  "qbe.modal.download.subtitle": "Luister overal.",
  "qbe.modal.ads.title": "Geen advertenties.",
  "qbe.modal.ads.subtitle": "Geniet van ononderbroken muziek.",
  "qbe.modal.play.title": "Speel elk nummer af dat je wilt.",
  "qbe.modal.play.subtitle": "Zelfs op mobiel.",
  "qbe.modal.skips.title": "Onbeperkt nummers overslaan.",
  "qbe.modal.skips.subtitle": "Druk gewoon op Volgende."
}
},{}],16:[function(require,module,exports){
module.exports={
  "app.name": "Przekaz znajomego",
  "app.description": "Przekaz znajomego",
  "nux.description": "Zobacz, czego słuchają Twoi znajomi",
  "nux.recently_played_description": "Uzyskaj szybko dostęp do całej ostatnio odtwarzanej zawartości w tym miejscu.",
  "button.follow": "Znajdź znajomych",
  "button.try_again": "Spróbuj ponownie",
  "error.general_error_title": "Hmm...Nie udało się wyświetlić kanału informacyjnego znajomego.",
  "error.offline_title": "Kanał jest niedostępny w trybie offline",
  "error.offline_subtitle": "Przejdź do trybu online, aby załadować kanał informacyjny znajomego",
  "header.inactive_friends": "Więcej znajomych",
  "header.inactive_friends_tooltip": "Znajomi nieudostępniający ostatnio odtwarzanych utowrów",
  "timeago.minutes": "{0} min",
  "timeago.hours": "{0} godz.",
  "timeago.days": "{0} dni",
  "timeago.weeks": "{0} tyg",
  "timeago.now": "teraz",
  "surround.buddy_list.title": "Aktywność znajomych",
  "qbe.greeting_title": "Witamy",
  "qbe.greeting1": "Cześć {0}!",
  "qbe.greeting1_tagline": "Przejdź na Premium za darmo",
  "qbe.greeting2": "Jeszcze tylko kilka kroków!",
  "qbe.greeting2_tagline": "Kliknij zadanie, aby otrzymać wskazówki",
  "qbe.greeting3": "Świetnie!",
  "qbe.greeting3_tagline": "A teraz ciesz się najwyższej jakości muzyką bez reklam",
  "qbe.tasks.sign_in_to_spotify.title": "Zaloguj się do Spotify",
  "qbe.tasks.search.title": "Szukaj utworu",
  "qbe.tasks.search.header": "Znajdź wszystko.",
  "qbe.tasks.search.description": "Większość użytkowników wyszukuje artystów lub utwory. Nie wszyscy wiedzą jednak, że wyszukiwać można też albumy, playlisty i profile.",
  "qbe.tasks.play_song.title": "Odtwórz utwór",
  "qbe.tasks.play_song.header": "Włącz muzykę.",
  "qbe.tasks.play_song.description": "Kliknij dwa razy utwór lub naciśnij odtwórz po lewej stronie utworu, aby rozpocząć niekończące się strumieniowe przesyłanie muzyki.",
  "qbe.tasks.create_playlist.title": "Stwórz playlistę",
  "qbe.tasks.create_playlist.header": "Kolekcjonuj utwory.",
  "qbe.tasks.create_playlist.description": "Playlisty to kolekcje utworów, które Ty oraz inni użytkownicy tworzycie na specjalne okazje, nastroje itd. Możesz stworzyć tyle playlist, ile chcesz. Ogranicza Cię jedynie własna wyobraźnia.",
  "qbe.tasks.add_songs_to_playlist.title": "Dodaj {0} utworów do playlisty",
  "qbe.tasks.add_songs_to_playlist.header": "Wypełnij ją!",
  "qbe.tasks.add_songs_to_playlist.description": "Playlista nie powinna być pusta. Klikając trzy kropki po prawej stronie utworu, możesz dodać utwór do playlisty. Spróbuj!",
  "qbe.reward.description": "Dokończ, aby rozpocząć 7 darmowych dni Spotify Premium.",
  "qbe.reward.what_is_premium": "Co to jest konto Premium",
  "qbe.reward.cta": "Aktywuj Premium",
  "qbe.reward.activated": "Aktywowano okres próbny Premium!",
  "qbe.reward.activated_description": "Aktywowano okres próbny. Możesz teraz przez 7 dni korzystać ze Spotify Premium. Mamy nadzieję, że Ci się spodoba.",
  "qbe.modal.heading": "To jest Spotify Premium",
  "qbe.modal.download.title": "Pobieraj muzykę.",
  "qbe.modal.download.subtitle": "Słuchaj wszędzie.",
  "qbe.modal.ads.title": "Bez reklam.",
  "qbe.modal.ads.subtitle": "Ciesz się muzyką cały czas.",
  "qbe.modal.play.title": "Odtwarzaj wszystkie utwory.",
  "qbe.modal.play.subtitle": "Nawet na telefonie.",
  "qbe.modal.skips.title": "Nieograniczona liczba pominięć.",
  "qbe.modal.skips.subtitle": "Wystarczy nacisnąć Dalej."
}
},{}],17:[function(require,module,exports){
module.exports={
  "app.name": "Feed de amigos",
  "app.description": "Feed de amigos",
  "nux.description": "Veja o que seus amigos estão tocando",
  "nux.recently_played_description": "Acesso rápido a tudo que você escutou recentemente.",
  "button.follow": "Encontrar amigos",
  "button.try_again": "Tente de novo",
  "error.general_error_title": "Pôxa, ocorreu uma falha no carregamento do Feed de amigos.",
  "error.offline_title": "O feed de amigos não está disponível offline. ",
  "error.offline_subtitle": "Fique online para carregar o feed de amigos",
  "header.inactive_friends": "Mais amigos",
  "header.inactive_friends_tooltip": "Amigos sem atividade de audição pública recente",
  "timeago.minutes": "{0} m",
  "timeago.hours": "{0} h",
  "timeago.days": "{0} d",
  "timeago.weeks": "{0} s",
  "timeago.now": "agora",
  "surround.buddy_list.title": "Atividade de amigos",
  "qbe.greeting_title": "Bem-vindo",
  "qbe.greeting1": "Olá, {0}!",
  "qbe.greeting1_tagline": "Experimente o Premium grátis",
  "qbe.greeting2": "Faltam só alguns passos!",
  "qbe.greeting2_tagline": "Clique em uma tarefa para ver uma dica",
  "qbe.greeting3": "Bom trabalho!",
  "qbe.greeting3_tagline": "Agora, aproveite música sem anúncios com som de alta qualidade",
  "qbe.tasks.sign_in_to_spotify.title": "Entre no Spotify",
  "qbe.tasks.search.title": "Busque uma música",
  "qbe.tasks.search.header": "Encontre o que você quiser.",
  "qbe.tasks.search.description": "A maioria das pessoas busca por uma música ou um artista. Mas você sabia que também dá para buscar por álbuns, playlists e perfis?",
  "qbe.tasks.play_song.title": "Toque uma música",
  "qbe.tasks.play_song.header": "Solte o som.",
  "qbe.tasks.play_song.description": "Clique duas vezes em uma faixa ou aperte o botão de play à esquerda para começar a ouvir música sem parar.",
  "qbe.tasks.create_playlist.title": "Crie uma playlist",
  "qbe.tasks.create_playlist.header": "Reúna suas músicas favoritas.",
  "qbe.tasks.create_playlist.description": "As playlists são coleções de músicas que qualquer usuário pode montar para um determinado astral, evento e muito mais. Você pode criar quantas playlists quiser, sua imaginação é o limite.",
  "qbe.tasks.add_songs_to_playlist.title": "Adicione {0} músicas a uma playlist",
  "qbe.tasks.add_songs_to_playlist.header": "Acrescente faixas à vontade!",
  "qbe.tasks.add_songs_to_playlist.description": "Uma playlist não deveria estar vazia. Clique no ícone de três pontos à direita de uma faixa para ver a opção de adicioná-la a uma playlist. Experimente!",
  "qbe.reward.description": "Conclua essas tarefas para acessar um teste grátis de 7 dias do Spotify Premium.",
  "qbe.reward.what_is_premium": "O que é o Premium?",
  "qbe.reward.cta": "Ativar o Premium",
  "qbe.reward.activated": "Seu teste do Premium foi ativado!",
  "qbe.reward.activated_description": "Seu teste foi ativado e você vai ter 7 dias para curtir Spotify Premium de graça. Aproveite!",
  "qbe.modal.heading": "O Spotify Premium é assim",
  "qbe.modal.download.title": "Baixe músicas.",
  "qbe.modal.download.subtitle": "Ouça em qualquer lugar.",
  "qbe.modal.ads.title": "Sem anúncios.",
  "qbe.modal.ads.subtitle": "Ouça música sem parar.",
  "qbe.modal.play.title": "Escute qualquer música.",
  "qbe.modal.play.subtitle": "Mesmo no celular.",
  "qbe.modal.skips.title": "Pule quantas faixas quiser.",
  "qbe.modal.skips.subtitle": "Passe a música a qualquer momento."
}
},{}],18:[function(require,module,exports){
module.exports={
  "app.name": "Vänflöde",
  "app.description": "Vänflöde",
  "nux.description": "Se vad dina vänner spelar",
  "nux.recently_played_description": "Här kan du snabbt komma åt nyligen spelat innehåll.",
  "button.follow": "Hitta vänner",
  "button.try_again": "Försök igen",
  "error.general_error_title": "Hmm, det gick inte att läsa in vänflödet.",
  "error.offline_title": "Vänflödet är inte tillgängligt offline",
  "error.offline_subtitle": "Gå online om du vill läsa in vänflödet",
  "header.inactive_friends": "Fler vänner",
  "header.inactive_friends_tooltip": "Vänner utan nyligen registrerad lyssningsaktivitet",
  "timeago.minutes": "{0} m",
  "timeago.hours": "{0} t",
  "timeago.days": "{0} d",
  "timeago.weeks": "{0} v",
  "timeago.now": "nu",
  "surround.buddy_list.title": "Vänaktivitet",
  "qbe.greeting_title": "Välkommen!",
  "qbe.greeting1": "Välkommen {0}!",
  "qbe.greeting1_tagline": "Få Premium gratis",
  "qbe.greeting2": "Bara några steg kvar!",
  "qbe.greeting2_tagline": "Klicka på en uppgift för ett tips",
  "qbe.greeting3": "Bra gjort!",
  "qbe.greeting3_tagline": "Nu kan du njuta av reklamfri musik med hög ljudkvalitet",
  "qbe.tasks.sign_in_to_spotify.title": "Logga in på Spotify",
  "qbe.tasks.search.title": "Sök efter en låt",
  "qbe.tasks.search.header": "Hitta allting.",
  "qbe.tasks.search.description": "De flesta använder sökfunktionen för att hitta en artist eller en låt. Men visste du att du också kan söka efter album, spellistor och profiler?",
  "qbe.tasks.play_song.title": "Spela upp en låt",
  "qbe.tasks.play_song.header": "Låt musiken flöda.",
  "qbe.tasks.play_song.description": "Dubbelklicka på en låt eller tryck på Spela upp till vänster om låtraden för att börja streama oavbruten musik.",
  "qbe.tasks.create_playlist.title": "Skapa en spellista",
  "qbe.tasks.create_playlist.header": "Samla dina låtar.",
  "qbe.tasks.create_playlist.description": "Spellistor är låtsamlingar som du eller övriga användare kan skapa för varje humör, händelse osv. Du kan skapa så många spellistor som du vill. Den enda begränsningen är din fantasi.",
  "qbe.tasks.add_songs_to_playlist.title": "Lägg till {0} låtar i en spellista",
  "qbe.tasks.add_songs_to_playlist.header": "Fyll på den!",
  "qbe.tasks.add_songs_to_playlist.description": "En spellista ska inte vara tom. Om du klickar på de tre knapparna till höger om en låtrad ges du möjligheten att lägga till en spellista. Försök själv!",
  "qbe.reward.description": "Slutför dina uppgifter och få en 7 dagars gratis testperiod på Spotify Premium",
  "qbe.reward.what_is_premium": "Vad är Premium",
  "qbe.reward.cta": "Aktivera Premium",
  "qbe.reward.activated": "Din testperiod på Premium har aktiverats!",
  "qbe.reward.activated_description": "Din testperiod har aktiverats och du har nu Spotify Premium gratis i 7 dagar. Hoppas du gillar det!",
  "qbe.modal.heading": "Det här är Spotify Premium",
  "qbe.modal.download.title": "Ladda ner musik",
  "qbe.modal.download.subtitle": "Lyssna överallt.",
  "qbe.modal.ads.title": "Ingen reklam. ",
  "qbe.modal.ads.subtitle": "Njut av oavbruten musik.",
  "qbe.modal.play.title": "Spela vilken låt som helst.",
  "qbe.modal.play.subtitle": "Till och med på mobilen.",
  "qbe.modal.skips.title": "Obegränsade låtbyten.",
  "qbe.modal.skips.subtitle": "Bara tryck på nästa."
}
},{}],19:[function(require,module,exports){
module.exports={
  "app.name": "Arkadaş Akışı",
  "app.description": "Arkadaş Akışı",
  "nux.description": "Arkadaşlarının ne dinlediğini gör",
  "nux.recently_played_description": "Son zamanlarda çalınan içeriklerin tümüne buradan hızlıca eriş.",
  "button.follow": "Arkadaşları Bul",
  "button.try_again": "Tekrar dene",
  "error.general_error_title": "Arkadaş Akışı yüklenemedi.",
  "error.offline_title": "Arkadaş akışı çevrimdışı olarak kullanılamaz",
  "error.offline_subtitle": "Arkadaş akışını yüklemek için lütfen çevrimiçi ol",
  "header.inactive_friends": "Diğer Arkadaşlar",
  "header.inactive_friends_tooltip": "Yakın zamanda herkese açık dinleme etkinliği gerçekleştirmemiş arkadaşlar",
  "timeago.minutes": "{0} dk.",
  "timeago.hours": "{0} sa.",
  "timeago.days": "{0} gün",
  "timeago.weeks": "{0} hafta",
  "timeago.now": "şimdi",
  "surround.buddy_list.title": "Arkadaş aktivitesi",
  "qbe.greeting_title": "Hoş geldin",
  "qbe.greeting1": "Hoşgeldin {0}!",
  "qbe.greeting1_tagline": "Ücretsiz Premium edin",
  "qbe.greeting2": "Sadece birkaç adım kaldı!",
  "qbe.greeting2_tagline": "Bir ipucu için herhangi bir göreve tıkla",
  "qbe.greeting3": "Aferin!",
  "qbe.greeting3_tagline": "Haydi, şimdi yüksek ses kalitesine sahip reklamsız müziğin keyfini çıkaralım",
  "qbe.tasks.sign_in_to_spotify.title": "Spotify'a kaydol",
  "qbe.tasks.search.title": "Şarkı ara",
  "qbe.tasks.search.header": "İstediğin her şeyi bul.",
  "qbe.tasks.search.description": "Birçok kişi bir sanatçı ya da şarkı bulmak için arama özelliğini kullanıyor. Peki ya aynı zamanda albümler, çalma listeleri ve profiller için de arama özelliğini kullanabileceğini biliyor musun?",
  "qbe.tasks.play_song.title": "Bir şarkı çal",
  "qbe.tasks.play_song.header": "Ona şarkı söylet.",
  "qbe.tasks.play_song.description": "İnternet üzerinden sonsuz sayıda şarkı yayını başlatmak için herhangi bir parçayı çift tıkla ya da bir parça sırasının solundaki çalma tuşuna bas.",
  "qbe.tasks.create_playlist.title": "Bir çalma listesi oluştur",
  "qbe.tasks.create_playlist.header": "Parçalarını bir araya getir.",
  "qbe.tasks.create_playlist.description": "Çalma listeleri, senin ya da diğerlerinin her zevk anlayışına, etkinliğe vb. göre yapılandırabileceği parçalardan oluşan koleksiyonlardır. İstediğin kadar çok çalma listesi oluşturabilirsin; tek sınır hayal gücün.",
  "qbe.tasks.add_songs_to_playlist.title": "Bir çalma listesine {0} şarkı ekle",
  "qbe.tasks.add_songs_to_playlist.header": "Hadi doldur!",
  "qbe.tasks.add_songs_to_playlist.description": "Çalma listeleri boş olmamalıdır. Herhangi bir parça sırasının sağındaki üç düğmeye tıklayarak bir çalma listesi ekleme seçeneğine kavuşabilirsin. Bunu dene!",
  "qbe.reward.description": "Ücretsiz 7 günlük Spotify Premium deneme kilidini açmak için görevlerini tamamla.",
  "qbe.reward.what_is_premium": "Premium nedir?",
  "qbe.reward.cta": "Premium'u Etkinleştir",
  "qbe.reward.activated": "Premium denemen etkinleştirildi!",
  "qbe.reward.activated_description": "Denemen etkinleştirildi ve artık 7 gün boyunca ücretsiz Spotify Premium'un var. Umarız tadını çıkarırsın! ",
  "qbe.modal.heading": "Bu Spotify Premium",
  "qbe.modal.download.title": "Müzik indir.",
  "qbe.modal.download.subtitle": "Her yerde dinle.",
  "qbe.modal.ads.title": "Reklam yok.",
  "qbe.modal.ads.subtitle": "Kesintisiz müziğin tadını çıkar.",
  "qbe.modal.play.title": "İstediğin her şarkıyı çalabilirsin.",
  "qbe.modal.play.subtitle": "Mobil cihazlarda bile.",
  "qbe.modal.skips.title": "Sınırsız atlama hakkı.",
  "qbe.modal.skips.subtitle": "Tek yapman gereken \"sonraki\" seçeneğine dokunmak."
}
},{}],20:[function(require,module,exports){
module.exports={
  "app.name": "好友動態",
  "app.description": "好友動態",
  "nux.description": "看看好友正在播放什麼",
  "nux.recently_played_description": "從這裡快速存取你最近播放的所有內容。",
  "button.follow": "尋找好友",
  "button.try_again": "再試一次",
  "error.general_error_title": "很抱歉，無法載入好友動態。",
  "error.offline_title": "好友消息無法離線閱覽。",
  "error.offline_subtitle": "請上線以載入好友消息",
  "header.inactive_friends": "更多好友",
  "header.inactive_friends_tooltip": "好友沒有最近的公開聆聽個人動態",
  "timeago.minutes": "{0} 分鐘",
  "timeago.hours": "{0} 小時",
  "timeago.days": "{0} 天",
  "timeago.weeks": "{0} 週",
  "timeago.now": "現在",
  "surround.buddy_list.title": "好友個人動態",
  "qbe.greeting_title": "歡迎",
  "qbe.greeting1": "{0}，歡迎！",
  "qbe.greeting1_tagline": "免費享受 Premium",
  "qbe.greeting2": "只差幾步了！",
  "qbe.greeting2_tagline": "按一下任務來查看提示",
  "qbe.greeting3": "做得好！",
  "qbe.greeting3_tagline": "現在就開始來享受高音質、全無廣告的音樂吧",
  "qbe.tasks.sign_in_to_spotify.title": "登入 Spotify",
  "qbe.tasks.search.title": "搜尋歌曲",
  "qbe.tasks.search.header": "什麼都能找。",
  "qbe.tasks.search.description": "大多數人都使用搜尋功能找藝人、找歌。但你知道嗎？你還可以搜尋專輯、播放清單和個人檔案。",
  "qbe.tasks.play_song.title": "播放歌曲",
  "qbe.tasks.play_song.header": "讓它發光發熱。",
  "qbe.tasks.play_song.description": "按兩下歌曲，或按一下歌曲列左側的播放，即可開始串流播放無窮無盡的歌曲。",
  "qbe.tasks.create_playlist.title": "建立播放清單",
  "qbe.tasks.create_playlist.header": "收集歌曲。",
  "qbe.tasks.create_playlist.description": "所謂的播放清單，是指你和其他人針對各種心情、活動等打造的歌單。只要想的出來，你想建多少個播放清單都沒問題。",
  "qbe.tasks.add_songs_to_playlist.title": "新增 {0} 首歌曲至播放清單",
  "qbe.tasks.add_songs_to_playlist.header": "新增幾首歌吧！",
  "qbe.tasks.add_songs_to_playlist.description": "播放清單中不應該空空如也。按一下任何歌曲列右側的三點圖示，即會顯示新增至播放清單的選項。試試看吧！",
  "qbe.reward.description": "完成各項任務，即可免費試用 Spotify Premium 7 天。",
  "qbe.reward.what_is_premium": "什麼是 Premium",
  "qbe.reward.cta": "啟用 Premium",
  "qbe.reward.activated": "你的 Premium 試用期已啟用！",
  "qbe.reward.activated_description": "你的試用期已啟用，自現在起，你可以免費試用 Spotify Premium 7 天。希望你會喜歡！",
  "qbe.modal.heading": "這是 Spotify Premium",
  "qbe.modal.download.title": "下載音樂。",
  "qbe.modal.download.subtitle": "自由自在，隨時享樂",
  "qbe.modal.ads.title": "沒有廣告。",
  "qbe.modal.ads.subtitle": "享樂不中斷。",
  "qbe.modal.play.title": "播放任何歌曲。",
  "qbe.modal.play.subtitle": "在手機上也能輕鬆享樂。",
  "qbe.modal.skips.title": "無限略過次數。",
  "qbe.modal.skips.subtitle": "點按「下一首」按鈕就行。"
}
},{}],21:[function(require,module,exports){
module.exports={
  "app.name": "Suapan Rakan",
  "app.description": "Suapan Rakan",
  "nux.description": "Lihat apa yang rakan anda mainkan",
  "nux.recently_played_description": "Dapatkan akses pantas kepada semua kandungan anda yang dimainkan baru-baru ini di sini.",
  "button.follow": "Cari Rakan",
  "button.try_again": "Cuba lagi",
  "error.general_error_title": "Hmm, Suapan Rakan gagal dimuatkan.",
  "error.offline_title": "Suapan rakan tidak boleh didapati di luar talian",
  "error.offline_subtitle": "Sila masuk dalam talian untuk memuatkan Suapan rakan",
  "header.inactive_friends": "Lebih Banyak Rakan",
  "header.inactive_friends_tooltip": "Rakan tanpa aktiviti mendengar awam terkini",
  "timeago.minutes": "{0} m",
  "timeago.hours": "{0} j",
  "timeago.days": "{0} h",
  "timeago.weeks": "{0} m",
  "timeago.now": "kini",
  "surround.buddy_list.title": "Aktiviti rakan",
  "qbe.greeting_title": "Selamat Datang",
  "qbe.greeting1": "Selamat datang {0}!",
  "qbe.greeting1_tagline": "Dapatkan Premium secara percuma",
  "qbe.greeting2": "Hanya beberapa langkah sahaja lagi!",
  "qbe.greeting2_tagline": "Klik pada tugas untuk mendapatkan petunjuk",
  "qbe.greeting3": "Syabas!",
  "qbe.greeting3_tagline": "Sekarang mari nikmati muzik tanpa iklan dengan kualiti bunyi yang tinggi",
  "qbe.tasks.sign_in_to_spotify.title": "Daftar masuk ke Spotify",
  "qbe.tasks.search.title": "Cari lagu",
  "qbe.tasks.search.header": "Cari kesemuanya.",
  "qbe.tasks.search.description": "Kebanyakan orang menggunakan carian untuk mencari artis atau lagu. Tapi tahukah anda bahawa anda juga boleh mencari album, senarai main dan profil?",
  "qbe.tasks.play_song.title": "Mainkan lagu",
  "qbe.tasks.play_song.header": "Buatkan ia menyanyi.",
  "qbe.tasks.play_song.description": "Klik dua kali pada lagu atau tekan main di sebelah kiri barisan lagu untuk memulakan penstriman lagu tanpa kesudahan.",
  "qbe.tasks.create_playlist.title": "Buat senarai main",
  "qbe.tasks.create_playlist.header": "Kumpulkan lagu anda.",
  "qbe.tasks.create_playlist.description": "Senarai main adalah koleksi lagu yang anda dan orang lain boleh buat untuk setiap emosi, acara, dan lain-lain Anda boleh buat sebanyak mana senarai main yang anda suka, hanya imaginasi anda sahaja sebagai batasan.",
  "qbe.tasks.add_songs_to_playlist.title": "Tambahkan {0} lagu ke senarai main",
  "qbe.tasks.add_songs_to_playlist.header": "Penuhkannya!",
  "qbe.tasks.add_songs_to_playlist.description": "Senarai main tidak sepatutnya kosong. Mengklik tiga butang di sebelah kanan mana-mana barisan lagu memberikan anda pilihan untuk menambah senarai main. Cubalah!",
  "qbe.reward.description": "Selesaikan tugas anda untuk membuka 7 hari percubaan percuma Spotify Premium.",
  "qbe.reward.what_is_premium": "Apakah premium",
  "qbe.reward.cta": "Aktifkan Premium",
  "qbe.reward.activated": "Percubaan Premium anda telah diaktifkan!",
  "qbe.reward.activated_description": "Percubaan anda telah diaktifkan dan anda kini mempunyai Spotify Premium secara percuma selama 7 hari. Semoga anda menikmatinya!",
  "qbe.modal.heading": "Ini adalah Spotify Premium",
  "qbe.modal.download.title": "Muat turun muzik.",
  "qbe.modal.download.subtitle": "Dengarkan di mana-mana.",
  "qbe.modal.ads.title": "Tiada iklan",
  "qbe.modal.ads.subtitle": "Nikmati muzik tanpa henti.",
  "qbe.modal.play.title": "Mainkan mana-mana lagu.",
  "qbe.modal.play.subtitle": "Walaupun di telefon bimbit.",
  "qbe.modal.skips.title": "Langkauan tanpa had.",
  "qbe.modal.skips.subtitle": "Hanya tekan seterusnya."
}
},{}],22:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.GeneralError = exports.OfflineError = undefined;

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var OfflineError = exports.OfflineError = function OfflineError() {
  return _react2.default.createElement(
    'div',
    { className: 'error-wrapper container', 'data-log-context': 'error-and-offline' },
    _react2.default.createElement(
      'div',
      { className: 'error-content' },
      _react2.default.createElement(
        'h3',
        { className: 'hdr-sm' },
        _i18n2.default.get('error.offline_title')
      ),
      _react2.default.createElement(
        'div',
        { className: 'message' },
        _i18n2.default.get('error.offline_subtitle')
      )
    )
  );
};

var GeneralError = exports.GeneralError = function GeneralError(_ref) {
  var onClickReloadButton = _ref.onClickReloadButton;
  return _react2.default.createElement(
    'div',
    { className: 'error-wrapper container', 'data-log-context': 'error-and-offline' },
    _react2.default.createElement(
      'div',
      { className: 'error-content' },
      _react2.default.createElement(
        'h3',
        { className: 'hdr-sm' },
        _i18n2.default.get('error.general_error_title')
      ),
      _react2.default.createElement(
        'button',
        { className: 'button button-white try-again-button', 'data-log-click': 'error-escape', onClick: onClickReloadButton },
        _i18n2.default.get('button.try_again')
      )
    )
  );
};
GeneralError.propTypes = {
  onClickReloadButton: _react2.default.PropTypes.func
};

},{"../../i18n":1,"react":879}],23:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactAddonsCssTransitionGroup = require('react-addons-css-transition-group');

var _reactAddonsCssTransitionGroup2 = _interopRequireDefault(_reactAddonsCssTransitionGroup);

var _subFriends = require('../sub-friends');

var _subFriends2 = _interopRequireDefault(_subFriends);

var _FriendFeedTitle = require('./FriendFeedTitle');

var _FriendFeedTitle2 = _interopRequireDefault(_FriendFeedTitle);

var _Friend = require('./Friend');

var _Friend2 = _interopRequireDefault(_Friend);

var _InactiveFriendsDivider = require('./InactiveFriendsDivider');

var _InactiveFriendsDivider2 = _interopRequireDefault(_InactiveFriendsDivider);

var _FindFriends = require('./FindFriends');

var _FindFriends2 = _interopRequireDefault(_FindFriends);

var _Nux = require('./Nux');

var _Nux2 = _interopRequireDefault(_Nux);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Feed = function (_Component) {
  _inherits(Feed, _Component);

  function Feed(props) {
    _classCallCheck(this, Feed);

    var _this = _possibleConstructorReturn(this, (Feed.__proto__ || Object.getPrototypeOf(Feed)).call(this, props));

    _this.state = {
      isLoading: true,
      isShowingNux: false,
      activeFriends: [],
      inactiveFriends: [],
      divider: {
        key: 'divider',
        height: 44,
        component: _InactiveFriendsDivider2.default
      },
      findFriends: {
        key: 'findfriends',
        height: 100,
        component: _FindFriends2.default
      }
    };
    _this.stableCardIndices = {};
    _this.maxStableCardIndex = 0;

    _this.onFriends = _this.onFriends.bind(_this);
    return _this;
  }

  _createClass(Feed, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this.subFriendsCancelFunction = (0, _subFriends2.default)(this.onFriends);
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.subFriendsCancelFunction();
    }
  }, {
    key: 'onFriends',
    value: function onFriends(onFriendsError, friends) {
      if (this.props.onLoad) this.props.onLoad(onFriendsError);
      if (onFriendsError) return;

      var activeFriends = friends.filter(function (friend) {
        return friend.timestamp && friend.track;
      }).sort(function (a, b) {
        return b.timestamp - a.timestamp;
      }).map(function (friend) {
        return {
          data: friend,
          key: friend.user.uri,
          height: 116,
          component: _Friend2.default
        };
      });

      var inactiveFriends = friends.filter(function (friend) {
        return !(friend.timestamp && friend.track);
      }).sort(function (a, b) {
        return a.user.name.localeCompare(b.user.name);
      }).map(function (friend) {
        return {
          data: friend,
          key: friend.user.uri,
          height: 76,
          component: _Friend2.default
        };
      });

      this.setState({
        isLoading: false,
        isShowingNux: activeFriends.length === 0,
        activeFriends: activeFriends,
        inactiveFriends: inactiveFriends
      });
    }
  }, {
    key: 'getStableCardIndex',
    value: function getStableCardIndex(card) {
      return this.stableCardIndices[card.key] || (this.stableCardIndices[card.key] = this.maxStableCardIndex++);
    }
  }, {
    key: 'getCards',
    value: function getCards() {
      var _this2 = this;

      var hasDivider = this.state.activeFriends.length && this.state.inactiveFriends.length;
      var y = 0;
      return [].concat(_toConsumableArray(this.state.activeFriends), _toConsumableArray(hasDivider ? [this.state.divider] : []), _toConsumableArray(this.state.inactiveFriends), [this.state.findFriends]).map(function (card, i, arr) {
        var styledCard = _extends({}, card, {
          // This manual key-index is bit cumbersome, but is still needed to make
          // React play nice with CSS transitions.
          index: _this2.getStableCardIndex(card),
          style: {
            transform: 'translate3d(0, ' + y + 'px, 0)',
            zIndex: arr.length - i
          }
        });
        y += card.height;
        return styledCard;
      }).sort(function (a, b) {
        return a.index - b.index;
      });
    }
  }, {
    key: 'render',
    value: function render() {
      if (this.state.isLoading) {
        return _react2.default.createElement(
          'div',
          null,
          _react2.default.createElement(_FriendFeedTitle2.default, null),
          _react2.default.createElement(
            'div',
            { id: 'throbber' },
            _react2.default.createElement(
              'div',
              { style: { height: '300px', position: 'relative' } },
              _react2.default.createElement(
                'div',
                { className: 'throbber-initial' },
                _react2.default.createElement('div', null)
              )
            )
          )
        );
      } else if (this.state.isShowingNux) {
        return _react2.default.createElement(_Nux2.default, null);
      }

      return _react2.default.createElement(
        'div',
        null,
        _react2.default.createElement(_FriendFeedTitle2.default, null),
        _react2.default.createElement(
          'div',
          { className: 'cards-wrapper' },
          _react2.default.createElement(
            _reactAddonsCssTransitionGroup2.default,
            {
              transitionName: 'card',
              transitionEnterTimeout: 700 // These have to match the transition durations in CSS
              , transitionLeaveTimeout: 700 },
            this.getCards().map(function (card) {
              return _react2.default.createElement(
                'div',
                { key: card.key, className: 'card-wrapper', style: card.style },
                _react2.default.createElement(card.component, card.data)
              );
            })
          )
        )
      );
    }
  }]);

  return Feed;
}(_react.Component);

exports.default = Feed;

Feed.propTypes = {
  onLoad: _react2.default.PropTypes.func
};

},{"../sub-friends":34,"./FindFriends":24,"./Friend":25,"./FriendFeedTitle":27,"./InactiveFriendsDivider":28,"./Nux":29,"react":879,"react-addons-css-transition-group":729}],24:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  return _react2.default.createElement(
    'div',
    { className: 'buddy-card find-friends-button-container' },
    _react2.default.createElement(
      'a',
      { className: 'button button-with-stroke find-friends',
        href: 'spotify:app:follow',
        'data-log-click': 'go-to-follow-app-button' },
      _i18n2.default.get('button.follow')
    ),
    _react2.default.createElement(
      'a',
      { className: 'button button-icon-only find-friends-small', href: 'spotify:app:follow',
        'data-log-click': 'go-to-follow-app-button' },
      _react2.default.createElement('span', { className: 'spoticon-addfollowers-32' })
    )
  );
};

},{"../../i18n":1,"react":879}],25:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _card = require('../../../../libs/glue/templates/cards/card.hbs');

var _card2 = _interopRequireDefault(_card);

var _dataFormatters = require('../data-formatters');

var _player = require('../../../../libs/spotify-events/player');

var _player2 = _interopRequireDefault(_player);

var _spotifyLiburi = require('spotify-liburi');

var _spotifyLiburi2 = _interopRequireDefault(_spotifyLiburi);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var Friend = function (_React$Component) {
  _inherits(Friend, _React$Component);

  function Friend() {
    _classCallCheck(this, Friend);

    return _possibleConstructorReturn(this, (Friend.__proto__ || Object.getPrototypeOf(Friend)).apply(this, arguments));
  }

  _createClass(Friend, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      _player2.default.update((0, _reactDom.findDOMNode)(this));
    }
  }, {
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate(nextProps) {
      var _props = this.props,
          _props$timestamp = _props.timestamp,
          timestamp = _props$timestamp === undefined ? null : _props$timestamp,
          _props$user = _props.user;
      _props$user = _props$user === undefined ? {} : _props$user;
      var _props$user$uri = _props$user.uri,
          userUri = _props$user$uri === undefined ? null : _props$user$uri,
          _props$track = _props.track;
      _props$track = _props$track === undefined ? {} : _props$track;
      var _props$track$uri = _props$track.uri,
          trackUri = _props$track$uri === undefined ? null : _props$track$uri;
      var _nextProps$timestamp = nextProps.timestamp,
          nextTimestamp = _nextProps$timestamp === undefined ? null : _nextProps$timestamp,
          _nextProps$user = nextProps.user;
      _nextProps$user = _nextProps$user === undefined ? {} : _nextProps$user;
      var _nextProps$user$uri = _nextProps$user.uri,
          nextUserUri = _nextProps$user$uri === undefined ? null : _nextProps$user$uri,
          _nextProps$track = nextProps.track;
      _nextProps$track = _nextProps$track === undefined ? {} : _nextProps$track;
      var _nextProps$track$uri = _nextProps$track.uri,
          nextTrackUri = _nextProps$track$uri === undefined ? null : _nextProps$track$uri;

      return !(timestamp === nextTimestamp && trackUri === nextTrackUri && userUri === nextUserUri);
    }
  }, {
    key: 'render',
    value: function render() {
      var _friendFormatter = (0, _dataFormatters.friend)(this.props),
          track = _friendFormatter.track,
          user = _friendFormatter.user,
          playButtonMediaObject = _friendFormatter.playButtonMediaObject,
          timestamp = _friendFormatter.timestamp;

      var playCardData = track && playButtonMediaObject || user;
      return _react2.default.createElement(
        'div',
        { className: 'buddy-card friend clearfix',
          'data-track-uri': track && track.uri || null,
          'data-contextmenu-spy': true },
        _react2.default.createElement(
          'div',
          { className: (0, _classnames2.default)('user-image', track && 'has-context') },
          playCardData && _react2.default.createElement('div', { className: 'user-play-button', dangerouslySetInnerHTML: { __html: (0, _card2.default)(playCardData) } })
        ),
        _react2.default.createElement(
          'div',
          { className: 'context-info' },
          user && _react2.default.createElement(
            'div',
            { className: (0, _classnames2.default)('user', 'one-line', track && 'has-context') },
            _react2.default.createElement(
              'a',
              { className: 'name', href: user.uri,
                'data-uri': user.uri,
                'data-tooltip': user.name
              },
              user.name
            )
          ),
          track && _react2.default.createElement(
            'div',
            { className: 'song-title text-muted one-line' },
            _react2.default.createElement(
              'span',
              { 'data-contextmenu': true, 'data-uri': track.uri },
              _react2.default.createElement(
                'a',
                {
                  className: 'track-name',
                  'data-uri': track.uri,
                  'data-tooltip': track.name,
                  href: track.deepLinkedAlbumPageUri
                },
                track.name
              )
            )
          ),
          track && _react2.default.createElement(
            'div',
            { className: 'song-artist text-muted one-line' },
            _react2.default.createElement(
              'a',
              { className: 'artist-name', href: track.artist.uri,
                'data-tooltip': track.artist.name,
                'data-uri': track.artist.uri
              },
              track.artist.name
            )
          ),
          track && track.context && _react2.default.createElement(
            'div',
            { className: 'context text-muted one-line' },
            _react2.default.createElement('span', { className: 'context-icon spoticon-' + _spotifyLiburi2.default.from(track.context.uri).type + '-16' }),
            ' ',
            _react2.default.createElement(
              'a',
              {
                className: 'name', href: track.context.uri,
                'data-tooltip': track.context.name,
                'data-uri': track.context.uri },
              track.context.name
            )
          )
        ),
        timestamp ? _react2.default.createElement(ListeningStatus, { timestamp: timestamp }) : ''
      );
    }
  }]);

  return Friend;
}(_react2.default.Component);

exports.default = Friend;

Friend.propTypes = {
  timestamp: _react2.default.PropTypes.number,
  user: _react2.default.PropTypes.object,
  track: _react2.default.PropTypes.object
};

var ListeningStatus = function (_React$PureComponent) {
  _inherits(ListeningStatus, _React$PureComponent);

  function ListeningStatus(props) {
    _classCallCheck(this, ListeningStatus);

    var _this2 = _possibleConstructorReturn(this, (ListeningStatus.__proto__ || Object.getPrototypeOf(ListeningStatus)).call(this, props));

    _this2.state = {
      timestamp: props.timestamp,
      animationSuffix: 0
    };
    return _this2;
  }

  _createClass(ListeningStatus, [{
    key: 'update',
    value: function update() {
      this.setState({
        fromNow: (0, _dataFormatters.fromNowTimestamp)(this.state.timestamp),
        active: Date.now() - this.state.timestamp < 15 * 60 * 1000
      });
    }
  }, {
    key: 'componentWillMount',
    value: function componentWillMount() {
      this.interval = setInterval(this.update.bind(this), 30000);
      this.update();
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      var _this3 = this;

      if (this.props.timestamp !== nextProps.timestamp) {
        // What on earth is this animation suffix you might ask? Well, it's the
        // least crazy way I could figure out how to let React re-trigger a CSS
        // animation at will. We basically have two identical CSS animations that
        // we toggle between using this suffix in a class definition in `render`.
        //
        // If an updated timestamp came in, it might be that we should restart
        // the animation, so we toggle animation-suffix to make that possible.
        this.setState({
          animationSuffix: this.state.animationSuffix === 0 ? 1 : 0,
          timestamp: nextProps.timestamp
        }, function () {
          return _this3.update();
        });
      }
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      clearInterval(this.interval);
    }
  }, {
    key: 'render',
    value: function render() {
      var _state = this.state,
          active = _state.active,
          fromNow = _state.fromNow,
          animationSuffix = _state.animationSuffix;

      var content = void 0;
      if (active) {
        content = _react2.default.createElement(
          'div',
          { className: 'active-indicator animation-' + animationSuffix },
          _react2.default.createElement('span', { className: 'active-indicator-wave active-indicator-wave-1 spoticon-volume-16' }),
          _react2.default.createElement('span', { className: 'active-indicator-wave active-indicator-wave-2 spoticon-volume-twowave-16' }),
          _react2.default.createElement('span', { className: 'active-indicator-wave active-indicator-wave-3 spoticon-volume-onewave-16' })
        );
      } else content = _react2.default.createElement(
        'div',
        { className: 'from-now' },
        fromNow
      );
      return _react2.default.createElement(
        'div',
        { className: 'status-containers' },
        content
      );
    }
  }]);

  return ListeningStatus;
}(_react2.default.PureComponent);

},{"../../../../libs/glue/templates/cards/card.hbs":156,"../../../../libs/spotify-events/player":287,"../data-formatters":32,"classnames":576,"react":879,"react-dom":731,"spotify-liburi":899}],26:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _subOnline = require('../sub-online');

var _subOnline2 = _interopRequireDefault(_subOnline);

var _Feed = require('./Feed');

var _Feed2 = _interopRequireDefault(_Feed);

var _Errors = require('./Errors');

var _FriendFeedTitle = require('./FriendFeedTitle');

var _FriendFeedTitle2 = _interopRequireDefault(_FriendFeedTitle);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FriendFeed = function (_Component) {
  _inherits(FriendFeed, _Component);

  function FriendFeed(props) {
    _classCallCheck(this, FriendFeed);

    var _this = _possibleConstructorReturn(this, (FriendFeed.__proto__ || Object.getPrototypeOf(FriendFeed)).call(this, props));

    _this.state = {
      feedLoadError: null,
      isOnline: null
    };

    _this.onClickReloadButton = _this.onClickReloadButton.bind(_this);
    _this.onFeedLoad = _this.onFeedLoad.bind(_this);
    return _this;
  }

  _createClass(FriendFeed, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      var _this2 = this;

      this.subOnlineCancelFunction = (0, _subOnline2.default)(function (isOnline) {
        _this2.setState({ isOnline: isOnline });
        if (isOnline) _this2.setState({ feedLoadError: null });
      });
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.subOnlineCancelFunction();
    }
  }, {
    key: 'onFeedLoad',
    value: function onFeedLoad(feedLoadError) {
      this.setState({ feedLoadError: feedLoadError });
    }
  }, {
    key: 'onClickReloadButton',
    value: function onClickReloadButton() {
      this.setState({ feedLoadError: null });
    }
  }, {
    key: 'render',
    value: function render() {
      if (this.state.isOnline === false) {
        return _react2.default.createElement(
          'div',
          null,
          _react2.default.createElement(_FriendFeedTitle2.default, null),
          _react2.default.createElement(_Errors.OfflineError, null)
        );
      }if (this.state.feedLoadError) {
        return _react2.default.createElement(
          'div',
          null,
          _react2.default.createElement(_FriendFeedTitle2.default, null),
          _react2.default.createElement(_Errors.GeneralError, { onClickReloadButton: this.onClickReloadButton })
        );
      }
      return _react2.default.createElement(_Feed2.default, { onLoad: this.onFeedLoad });
    }
  }]);

  return FriendFeed;
}(_react.Component);

exports.default = FriendFeed;

},{"../sub-online":35,"./Errors":22,"./Feed":23,"./FriendFeedTitle":27,"react":879}],27:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _sticky = require('../../../../libs/spotify-events/sticky');

var _sticky2 = _interopRequireDefault(_sticky);

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var FriendFeedTitle = function (_React$Component) {
  _inherits(FriendFeedTitle, _React$Component);

  function FriendFeedTitle() {
    _classCallCheck(this, FriendFeedTitle);

    return _possibleConstructorReturn(this, (FriendFeedTitle.__proto__ || Object.getPrototypeOf(FriendFeedTitle)).apply(this, arguments));
  }

  _createClass(FriendFeedTitle, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      _sticky2.default.update();
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      _sticky2.default.update();
    }
  }, {
    key: 'render',
    value: function render() {
      return _react2.default.createElement(
        'div',
        { className: 'buddy-list-title' },
        _react2.default.createElement(
          'div',
          { className: 'section-divider-sticky-wrapper' },
          _react2.default.createElement(
            'div',
            {
              className: 'section-divider',
              'data-sticky': true,
              'data-sticky-single': true
            },
            _react2.default.createElement(
              'h3',
              null,
              _i18n2.default.get('surround.buddy_list.title')
            )
          )
        )
      );
    }
  }]);

  return FriendFeedTitle;
}(_react2.default.Component);

exports.default = FriendFeedTitle;

},{"../../../../libs/spotify-events/sticky":303,"../../i18n":1,"react":879}],28:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  return _react2.default.createElement(
    'div',
    { className: 'buddy-card inactive-friends-divider' },
    _react2.default.createElement(
      'div',
      { className: 'section-divider' },
      _react2.default.createElement(
        'h3',
        { 'data-tooltip': _i18n2.default.get('header.inactive_friends_tooltip') },
        _i18n2.default.get('header.inactive_friends')
      )
    )
  );
};

},{"../../i18n":1,"react":879}],29:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _i18n = require('../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = function () {
  return _react2.default.createElement(
    'div',
    { className: 'nux', 'data-log-context': 'nux' },
    _react2.default.createElement(
      'div',
      { className: 'nux-cta' },
      _react2.default.createElement(
        'h4',
        null,
        _i18n2.default.get('nux.description')
      ),
      _react2.default.createElement(
        'a',
        {
          className: 'button button-with-stroke find-friends',
          href: 'spotify:app:follow',
          'data-log-click': 'go-to-follow-app-button'
        },
        _i18n2.default.get('button.follow')
      ),
      _react2.default.createElement('span', { className: 'find-friends-small spoticon-addfollowers-32' })
    ),
    _react2.default.createElement('div', { className: 'nux-feed-example' })
  );
};

},{"../../i18n":1,"react":879}],30:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _sticky = require('../../../../libs/spotify-events/sticky');

var _sticky2 = _interopRequireDefault(_sticky);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var SurfaceHubAppRenderer = function (_Component) {
  _inherits(SurfaceHubAppRenderer, _Component);

  function SurfaceHubAppRenderer() {
    _classCallCheck(this, SurfaceHubAppRenderer);

    return _possibleConstructorReturn(this, (SurfaceHubAppRenderer.__proto__ || Object.getPrototypeOf(SurfaceHubAppRenderer)).apply(this, arguments));
  }

  _createClass(SurfaceHubAppRenderer, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      this._update(this.props.surfaceHubApp);
    }
  }, {
    key: 'componentWillReceiveProps',
    value: function componentWillReceiveProps(nextProps) {
      if (nextProps.surfaceHubApp !== this.surfaceHubApp) {
        this._update(nextProps.surfaceHubApp);
      }
    }
  }, {
    key: 'shouldComponentUpdate',
    value: function shouldComponentUpdate() {
      return false;
    }
  }, {
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      this.surfaceHubApp.destroy();
    }
  }, {
    key: '_update',
    value: function _update(surfaceHubApp) {
      if (this.surfaceHubApp) this.surfaceHubApp.destroy();
      this.surfaceHubApp = surfaceHubApp;
      this.surfaceHubApp.mountRootViewIn(this.container);

      var sectionTitles = this.container.querySelectorAll('.section-divider');
      [].concat(_toConsumableArray(sectionTitles)).forEach(function (titleNode) {
        titleNode.setAttribute('data-sticky', '');
        titleNode.setAttribute('data-sticky-single', '');
      });
      _sticky2.default.update();
    }
  }, {
    key: 'render',
    value: function render() {
      var _this2 = this;

      return _react2.default.createElement('div', { className: this.props.className, ref: function ref(container) {
          _this2.container = container;
        } });
    }
  }]);

  return SurfaceHubAppRenderer;
}(_react.Component);

exports.default = SurfaceHubAppRenderer;


SurfaceHubAppRenderer.propTypes = {
  surfaceHubApp: _react2.default.PropTypes.object,
  className: _react2.default.PropTypes.string
};

},{"../../../../libs/spotify-events/sticky":303,"react":879}],31:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _sticky = require('../../../../libs/spotify-events/sticky');

var _sticky2 = _interopRequireDefault(_sticky);

var _SurfaceHubAppRenderer = require('./SurfaceHubAppRenderer');

var _SurfaceHubAppRenderer2 = _interopRequireDefault(_SurfaceHubAppRenderer);

var _questBasedEducation = require('../surround/quest-based-education');

var _questBasedEducation2 = _interopRequireDefault(_questBasedEducation);

var _reactCssTransitionReplace = require('react-css-transition-replace');

var _reactCssTransitionReplace2 = _interopRequireDefault(_reactCssTransitionReplace);

var _surround = require('../surround');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var ANIMATION_DURATION_MS = 300;

var Surround = function (_Component) {
  _inherits(Surround, _Component);

  function Surround() {
    var _ref;

    _classCallCheck(this, Surround);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = Surround.__proto__ || Object.getPrototypeOf(Surround)).call.apply(_ref, [this].concat(args)));

    _this.state = {};
    return _this;
  }

  _createClass(Surround, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      (0, _surround.subscribeToSurroundState)(this.setState.bind(this));
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps, prevState) {
      var didMoreLikeThisPlaylistChange = this.state.moreLikeThisPlaylist && !prevState.moreLikeThisPlaylist || !this.state.moreLikeThisPlaylist && prevState.moreLikeThisPlaylist;
      var didQuestBasedEducationChange = this.state.showQuestBasedEducation !== prevState.showQuestBasedEducation;

      if (didMoreLikeThisPlaylistChange || didQuestBasedEducationChange) {
        // Update sticky section titles twice:
        // 1. Half-way through the animation. When a section is added or removed
        //    it does so with an animation, which means right when it's set as
        //    removed it is still visible in the same position. At some point in
        //    the animation it will have moved away far enough to not have the
        //    sticky title anymore (for the removed section) and then the section
        //    title below needs to be updated to be pushed up. Doing this only at
        //    the end of the animation is too jarring as it will jump a bit. Doing
        //    it half-way through the animation helps a bit.
        // 2. When animation is finished. This is to make sure things are in the
        //    correct places when all the things have stopped moving.
        setTimeout(function () {
          _sticky2.default.update();
        }, ANIMATION_DURATION_MS / 2);
        setTimeout(function () {
          _sticky2.default.update();
        }, ANIMATION_DURATION_MS);
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _ref2 = this.state || {},
          showQuestBasedEducation = _ref2.showQuestBasedEducation,
          tasks = _ref2.tasks,
          questCompleted = _ref2.questCompleted,
          moreLikeThisPlaylist = _ref2.moreLikeThisPlaylist;

      var transition = {
        transitionName: 'cross-fade',
        transitionEnterTimeout: ANIMATION_DURATION_MS,
        transitionLeaveTimeout: ANIMATION_DURATION_MS
      };

      return _react2.default.createElement(
        'div',
        { className: 'surround' },
        _react2.default.createElement(
          _reactCssTransitionReplace2.default,
          transition,
          showQuestBasedEducation && _react2.default.createElement(_questBasedEducation2.default, {
            tasks: tasks,
            complete: questCompleted
          })
        ),
        _react2.default.createElement(
          _reactCssTransitionReplace2.default,
          transition,
          moreLikeThisPlaylist && _react2.default.createElement(_SurfaceHubAppRenderer2.default, {
            key: moreLikeThisPlaylist.key,
            className: 'more-like-this-playlist',
            surfaceHubApp: moreLikeThisPlaylist
          })
        )
      );
    }
  }]);

  return Surround;
}(_react.Component);

exports.default = Surround;

},{"../../../../libs/spotify-events/sticky":303,"../surround":36,"../surround/quest-based-education":43,"./SurfaceHubAppRenderer":30,"react":879,"react-css-transition-replace":730}],32:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.friend = friend;
exports.fromNowTimestamp = fromNowTimestamp;

var _i18n = require('../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _spotifyLiburi = require('spotify-liburi');

var _spotifyLiburi2 = _interopRequireDefault(_spotifyLiburi);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function friend(_ref) {
  var track = _ref.track,
      user = _ref.user,
      timestamp = _ref.timestamp;

  var albumURI = track && _spotifyLiburi2.default.from(track.album.uri);
  var trackURI = track && _spotifyLiburi2.default.from(track.uri);
  var contextURI = track && _spotifyLiburi2.default.from(track.context.uri);
  return {
    timestamp: timestamp || 0,
    track: track && {
      album: {
        name: track.album.name,
        uri: track.album.uri
      },
      artist: {
        name: track.artist.name,
        uri: track.artist.uri
      },
      context: {
        index: track.context.index,
        name: track.context.name,
        uri: track.context.uri
      },
      name: track.name,
      uri: track.uri,
      // This is likely a private api of the album app, but it works to prevent
      // playback on track link click in legacy desktop.
      deepLinkedAlbumPageUri: 'spotify:app:album:' + albumURI.getBase62Id() + ':' + trackURI.getBase62Id()
    },
    user: user,
    playButtonMediaObject: track && user && {
      name: track.name,
      trackUri: track.uri,
      imageUrl: user.imageUrl,
      playButtonOnly: true,
      // We can't easily load up the "rows" that make up an artist context,
      // since it's actually just the rows on an artist page and this is
      // not defined cross-platform, as far as we know. Play the album instead.
      uri: contextURI.type === _spotifyLiburi2.default.Type.ARTIST ? track.album.uri : track.context.uri,

      // Stash the original album uri to be able to fallback if the context is
      // a playlist and the track uri cannot be found within.
      albumUri: track.album.uri
    }
  };
}

function fromNowTimestamp(timestamp) {
  if (!timestamp || timestamp === '0') return '';

  var now = Date.now();
  var diff = now - timestamp;
  var minutes = Math.round(diff / 1000 / 60);
  var hours = Math.round(diff / 1000 / 60 / 60);
  var days = Math.round(diff / 1000 / 60 / 60 / 24);
  var weeks = Math.round(diff / 1000 / 60 / 60 / 24 / 7);

  if (days > 7) return _i18n2.default.get('timeago.weeks', weeks);
  if (hours > 24) return _i18n2.default.get('timeago.days', days);
  if (minutes > 60) return _i18n2.default.get('timeago.hours', hours);
  if (minutes > 0) return _i18n2.default.get('timeago.minutes', minutes);
  return _i18n2.default.get('timeago.now');
}

},{"../i18n":1,"spotify-liburi":899}],33:[function(require,module,exports){
'use strict';

var _spotifyHandlebars = require('../../../libs/spotify-handlebars');

var _spotifyHandlebars2 = _interopRequireDefault(_spotifyHandlebars);

var _helpers = require('../../../libs/spotify-handlebars/helpers');

var _helpers2 = _interopRequireDefault(_helpers);

var _i18n = require('../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _player = require('../../../libs/spotify-events/player');

var _player2 = _interopRequireDefault(_player);

var _spotifyEvents = require('../../../libs/spotify-events');

var _spotifyEvents2 = _interopRequireDefault(_spotifyEvents);

var _player3 = require('../../../libs/spotify-live-models/player');

var _player4 = _interopRequireDefault(_player3);

var _application = require('../../../libs/spotify-live-models/application');

var _application2 = _interopRequireDefault(_application);

var _client = require('../../../libs/spotify-live-models/client');

var _client2 = _interopRequireDefault(_client);

var _add = require('../../../libs/spotify-live-models/add');

var _add2 = _interopRequireDefault(_add);

var _clientStorage = require('../../../libs/spotify-live-models/client-storage');

var _clientStorage2 = _interopRequireDefault(_clientStorage);

var _sessionStorage = require('../../../libs/spotify-live-models/session-storage');

var _sessionStorage2 = _interopRequireDefault(_sessionStorage);

var _playlist = require('../../../libs/spotify-live-models/playlist');

var _playlist2 = _interopRequireDefault(_playlist);

var _listVariant = require('../../../libs/spotify-live-models/list-variant');

var _listVariant2 = _interopRequireDefault(_listVariant);

var _surround = require('./surround');

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _FriendFeed = require('./components/FriendFeed');

var _FriendFeed2 = _interopRequireDefault(_FriendFeed);

var _Surround = require('./components/Surround');

var _Surround2 = _interopRequireDefault(_Surround);

var _bridge = require('../../../libs/spotify-expose-dev-mode-debug-globals/bridge');

var _bridge2 = _interopRequireDefault(_bridge);

var _live = require('../../../libs/spotify-expose-dev-mode-debug-globals/live');

var _live2 = _interopRequireDefault(_live);

var _cosmos = require('../../../libs/spotify-expose-dev-mode-debug-globals/cosmos');

var _cosmos2 = _interopRequireDefault(_cosmos);

var _spfetch = require('../../../libs/spotify-expose-dev-mode-debug-globals/spfetch');

var _spfetch2 = _interopRequireDefault(_spfetch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_helpers2.default.loc.register(_i18n2.default.glueStrings());
_helpers2.default.loc.register(_i18n2.default.appStrings());
_helpers2.default.loc.setLocale(_i18n2.default.locale());
_helpers2.default.numeral.setLocale(_i18n2.default.locale());
_spotifyHandlebars2.default.register(_helpers2.default);

_player2.default.setMode('uids');
_spotifyEvents2.default.attach();

_player4.default.register();
_application2.default.register();
_client2.default.register();
_add2.default.register();
_clientStorage2.default.register();
_sessionStorage2.default.register();
_playlist2.default.register();
_listVariant2.default.register();

(0, _surround.init)();

_reactDom2.default.render(_react2.default.createElement(
  'div',
  null,
  _react2.default.createElement(_Surround2.default, null),
  _react2.default.createElement(_FriendFeed2.default, null)
), document.getElementById('root'));

_bridge2.default.init();
_live2.default.init();
_cosmos2.default.init();
_spfetch2.default.init();

},{"../../../libs/spotify-events":279,"../../../libs/spotify-events/player":287,"../../../libs/spotify-expose-dev-mode-debug-globals/bridge":314,"../../../libs/spotify-expose-dev-mode-debug-globals/cosmos":315,"../../../libs/spotify-expose-dev-mode-debug-globals/live":317,"../../../libs/spotify-expose-dev-mode-debug-globals/spfetch":318,"../../../libs/spotify-handlebars":334,"../../../libs/spotify-handlebars/helpers":324,"../../../libs/spotify-live-models/add":465,"../../../libs/spotify-live-models/application":472,"../../../libs/spotify-live-models/client":475,"../../../libs/spotify-live-models/client-storage":474,"../../../libs/spotify-live-models/list-variant":478,"../../../libs/spotify-live-models/player":484,"../../../libs/spotify-live-models/playlist":488,"../../../libs/spotify-live-models/session-storage":489,"../i18n":1,"./components/FriendFeed":26,"./components/Surround":31,"./surround":36,"react":879,"react-dom":731}],34:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = subFriends;

var _spotifyBridgeRequest = require('../../../libs/spotify-bridge-request');

var _spotifyBridgeRequest2 = _interopRequireDefault(_spotifyBridgeRequest);

var _spotifyLiburi = require('spotify-liburi');

var _spotifyLiburi2 = _interopRequireDefault(_spotifyLiburi);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function subFriends(callback) {
  // { username : subhandle, sp://messages/v1/followstate : subhandle, etc }
  var subscriptions = {};
  var friendsByUsername = {};

  function runCallback() {
    callback(null, Object.keys(friendsByUsername).map(function (username) {
      return friendsByUsername[username];
    }));
  }

  function onFriend(error, friend) {
    if (error) return;

    var _liburi$from = _spotifyLiburi2.default.from(friend.user.uri),
        username = _liburi$from.username;

    friendsByUsername[username] = friend;
    runCallback();
  }

  _spotifyBridgeRequest2.default.cosmosJSON({
    method: 'GET',
    uri: 'hm://presence-view/v1/buddylist'
  }, function (presenceViewError) {
    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        _ref$friends = _ref.friends,
        friends = _ref$friends === undefined ? [] : _ref$friends;

    if (presenceViewError) {
      callback(presenceViewError);
      return;
    }

    friends.forEach(function (friend) {
      var _liburi$from2 = _spotifyLiburi2.default.from(friend.user.uri),
          username = _liburi$from2.username;

      friendsByUsername[username] = friend;
      subscriptions[username] = subFriend(username, onFriend);
    });

    var endpoint = 'sp://messages/v1/followstate';
    subscriptions[endpoint] = _spotifyBridgeRequest2.default.cosmosJSON({
      uri: endpoint,
      method: 'SUB'
    }, function (err) {
      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          uri = _ref2.uri,
          isFollowing = _ref2.isFollowing;

      if (err) return;
      // NOTE: for some reason, followstate is broadcasted twice. Keep this
      // mind to ensure double subs / deletes do not happen.

      var _liburi$from3 = _spotifyLiburi2.default.from(uri),
          type = _liburi$from3.type,
          username = _liburi$from3.username;

      if (type !== _spotifyLiburi.Type.PROFILE) return;

      var isRemoved = subscriptions[username] && !isFollowing;
      var isAdded = !subscriptions[username] && isFollowing;
      if (isRemoved) {
        subscriptions[username]();
        delete subscriptions[username];
        delete friendsByUsername[username];
        runCallback();
      } else if (isAdded) {
        subscriptions[username] = subFriend(username, onFriend);
        getFriend(username, onFriend);
      }
    });

    runCallback();
  });

  return function cancel() {
    Object.keys(subscriptions).forEach(function (key) {
      var cancelFunction = subscriptions[key];
      if (cancelFunction) cancelFunction();
    });
    subscriptions = {};
    friendsByUsername = null;
  };
}

function subFriend(username, callback) {
  return _spotifyBridgeRequest2.default.cosmosJSON({
    method: 'SUB',
    uri: 'hm://presence2/user/' + encodeURIComponent(username)
  }, function (subFriendError) {
    if (subFriendError) return;
    getFriend(username, function (getFriendError, data) {
      // We do get a timestamp from the backend, but from time to time it's off, so
      // to make sure the ordering is correct we just set it to "now".
      // The reason it's off is unclear but might be that it's based on when the track
      // was started instead of when the pub was sent, which would explain the weird behaviour.
      if (data) data.timestamp = Date.now();
      callback(getFriendError, data);
    });
  });
}

function getFriend(username, callback) {
  _spotifyBridgeRequest2.default.cosmosJSON({
    method: 'GET',
    uri: 'hm://presence-view/v1/user/' + encodeURIComponent(username)
  }, callback);
}

},{"../../../libs/spotify-bridge-request":225,"spotify-liburi":899}],35:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = subOnline;

var _spotifyLive = require('../../../libs/spotify-live');

var _spotifyLive2 = _interopRequireDefault(_spotifyLive);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function subOnline(callback) {
  var client = (0, _spotifyLive2.default)('spotify:client');
  var onSessionUpdate = function onSessionUpdate(properties) {
    if ('online' in properties) callback(properties.online);
  };

  client.query('session(online)', function (error, data) {
    callback(data.session.online);
    client.get('session').on('update', onSessionUpdate);
  });

  return function cancel() {
    client.get('session').off('update', onSessionUpdate);
  };
}

},{"../../../libs/spotify-live":512}],36:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.processMessages = processMessages;
exports.init = init;
exports.subscribeToSurroundState = subscribeToSurroundState;

var _spotifyLiburi = require('spotify-liburi');

var _spotifyLiburi2 = _interopRequireDefault(_spotifyLiburi);

var _cancellationTokenSource = require('../../../../libs/cancellation-token-source');

var _cancellationTokenSource2 = _interopRequireDefault(_cancellationTokenSource);

var _surroundMessages = require('../../../../libs/surround-messages');

var _HubFactory = require('../../../../libs/spotify-hub-framework/scripts/modular/HubFactory');

var _HubFactory2 = _interopRequireDefault(_HubFactory);

var _questBasedEducation = require('./quest-based-education');

var questBasedEducation = _interopRequireWildcard(_questBasedEducation);

var _moreLikeThisPlaylist = require('./more-like-this-playlist');

var moreLikeThisPlaylist = _interopRequireWildcard(_moreLikeThisPlaylist);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MESSAGE_ACCUMULATION_PERIOD = 300;

var callback = void 0;

var initialMessagesState = {
  messages: [],
  lastProcessTime: 0,
  processTimeoutId: null
};

var initialSurroundState = {
  playlistUri: null,
  moreLikeThisPlaylist: null,
  showQuestBasedEducation: null,
  tasks: [],
  questCompleted: false
};

// Customize here to add a new Surround unit and/or handle messages send by
// `libs/surround-messages`.

function shouldAccumulateMessage(message) {
  // Surround messages are accumulated for MESSAGE_ACCUMULATION_PERIOD ms which
  // means there will be some delay until messages are actually handled.
  //
  // We have this to avoid taking precious bandwidth to load recommendations
  // when more important content needs to be loaded in the main iframe (e.g. a
  // playlist). The delay also avoids unecessary requests to the backend when
  // the user is performing actions quickly (e.g. clicking around playlists) and
  // unecessary updates of the right sidebar that may be distracting and degrade
  // the user experience that should be focused on the main content.
  //
  // But some messages are urgent and should not have a delay before processing.
  // When that's the case, return `false` here.
  switch (message.type) {
    case _surroundMessages.COMPLETE_QBE_TASK:
    case _surroundMessages.SONG_ADDED_TO_PLAYLIST:
    case _surroundMessages.SHOW_MODAL:
    case _surroundMessages.TRIAL_ACTIVATED:
    case _surroundMessages.SESSION_ONLINE_STATUS_CHANGE:
      return false;
    default:
      return true;
  }
}

function processMessages(surroundState, messages) {
  var oldSurroundState = Object.assign({}, surroundState);

  messages.forEach(function (message) {
    switch (message.action) {
      case _surroundMessages.OPEN_APP:
        if (message.appId !== 'playlist-desktop' && message.appId !== 'chart') {
          surroundState.playlistUri = null;
        }
        break;
      case _surroundMessages.OPEN_PLAYLIST:
        surroundState.playlistUri = message.playlistUri;
        break;
      case _surroundMessages.ADD_URI:
        try {
          var uri = _spotifyLiburi2.default.fromString(message.uri);
          if (uri && uri.type === _spotifyLiburi2.default.Type.PLAYLIST) {
            surroundState.playlistUri = message.uri;
          }
        } catch (e) {
          // Unable to parse the URI
          console.error(e);
        }
        break;
      case _surroundMessages.SHOW_QBE:
        questBasedEducation.init();
        surroundState.tasks = questBasedEducation.getTaskList();
        surroundState.showQuestBasedEducation = true;
        break;
      case _surroundMessages.TRIAL_ACTIVATED:
        surroundState.questCompleted = message.success === true;
        break;
      case _surroundMessages.SONG_ADDED_TO_PLAYLIST:
        questBasedEducation.countSongsAdded(message);
        break;
      case _surroundMessages.COMPLETE_QBE_TASK:
        surroundState.tasks = questBasedEducation.updateTasks(surroundState.tasks, message);
        break;
      case _surroundMessages.SESSION_ONLINE_STATUS_CHANGE:
        surroundState.isOnline = message.online;
        break;
      default:
        console.warn('Surround: message with action ' + message.action + ' is not being handled.');
        break;
    }
  });

  var cancellationToken = surroundState.cancellationTokenSource.token();

  // Remove more like this recommentation from interface if ...
  if (surroundState.showQuestBasedEducation || // ... QBE kicks in
  surroundState.isOnline === false || // ... user goes offline
  surroundState.playlistUri === null // ... navigated to non-playlist
  ) {
      surroundState.moreLikeThisPlaylist = null;
    }

  var promises = [];

  var playlistHasChanged = surroundState.playlistUri !== oldSurroundState.playlistUri;
  var shouldRefreshMoreLikeThis = !!surroundState.playlistUri && surroundState.isOnline === true && moreLikeThisPlaylist.isUserPolicyEnabled() && !surroundState.showQuestBasedEducation && (!surroundState.moreLikeThisPlaylist || playlistHasChanged);

  if (shouldRefreshMoreLikeThis) {
    promises.push(new Promise(function (resolve, reject) {
      moreLikeThisPlaylist.getView(_HubFactory2.default, surroundState.playlistUri, cancellationToken, function (error, surfaceHubApp) {
        if (error) {
          reject(error);
          return;
        }
        resolve(surfaceHubApp);
      });
    }).then(function (surfaceHubApp) {
      surroundState.moreLikeThisPlaylist = surfaceHubApp;
    }).catch(function (error) {
      // Cancellations are expected. No need to log them though.
      if (error.name !== 'OperationCanceledError') {
        console.error(error);
      }
      surroundState.moreLikeThisPlaylist = null;
    }));
  }

  return Promise.all(promises).then(function () {
    if (typeof callback === 'function') callback(surroundState);
  });
}

function processAccumulatedMessagesAndResetState(surroundState, messagesState) {
  var messages = messagesState.messages;
  messagesState.messages = [];
  messagesState.processTimeoutId = null;
  messagesState.lastProcessTime = Date.now();
  exports.processMessages(surroundState, messages);
}

function shouldShowQuestBasedEducation() {
  return Promise.all([questBasedEducation.isInABBAGroup(), questBasedEducation.isEligibleForTrial()]).then(function (_ref) {
    var _ref2 = _slicedToArray(_ref, 2),
        isInABBAGroup = _ref2[0],
        isEligibleForTrial = _ref2[1];

    return isInABBAGroup && isEligibleForTrial;
  });
}

function init() {
  var surroundState = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialSurroundState;
  var messagesState = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : initialMessagesState;

  surroundState.cancellationTokenSource = new _cancellationTokenSource2.default();

  (0, _surroundMessages.subscribeToMessages)(function (error, messagesArray) {
    if (error) {
      console.error(error);
      return;
    }

    messagesArray.forEach(function (message) {
      if (shouldAccumulateMessage(message)) {
        if (messagesState.lastProcessTime === 0) {
          messagesState.lastProcessTime = Date.now();
        }
        surroundState.cancellationTokenSource.cancel();
        messagesState.messages.push(message);
        if (messagesState.processTimeoutId === null) {
          messagesState.processTimeoutId = setTimeout(processAccumulatedMessagesAndResetState.bind(null, surroundState, messagesState), MESSAGE_ACCUMULATION_PERIOD);
        }
      } else {
        // If it's an urgent message, process it right now
        processMessages(surroundState, [message]);
      }
    });
  });

  shouldShowQuestBasedEducation().then(function (result) {
    if (result) {
      (0, _surroundMessages.dispatchShowQBE)();
      questBasedEducation.showWelcomeModal();
    }
  }).catch(function (err) {
    return console.error(err);
  });

  (0, _surroundMessages.watchSessionChange)();
}

function subscribeToSurroundState(_callback) {
  callback = _callback;
}

},{"../../../../libs/cancellation-token-source":124,"../../../../libs/spotify-hub-framework/scripts/modular/HubFactory":356,"../../../../libs/surround-messages":559,"./more-like-this-playlist":37,"./quest-based-education":43,"spotify-liburi":899}],37:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isUserPolicyEnabled = isUserPolicyEnabled;
exports.getView = getView;
function isUserPolicyEnabled() {
  return global.__spotify && global.__spotify.product_state && global.__spotify.product_state['ab-playlist-more-like-this'] === '1';
}

function getView(HubFactory, playlistUri, cancellationToken, callback) {
  var hubFactory = new HubFactory({ 'style/small-cards': true });

  hubFactory.newVanillaUriBuilder().setSpace('recommendations-in-playlist').addSignal('playlistURI', playlistUri).build(function (uri) {
    var surfaceHubApp = hubFactory.newSurfaceHubApp(uri);
    var wrapper = global.document.createElement('div');
    wrapper.className = 'more-like-this-playlist';

    function destroy() {
      surfaceHubApp.destroy();
      surfaceHubApp = null;
      hubFactory = null;
      wrapper = null;
    }

    surfaceHubApp.loadViewComponentTree(function (hubsError, view) {
      var anyError = hubsError || cancellationToken.errorIfCanceled();
      if (anyError) {
        destroy();
        callback(anyError);
        return;
      }

      // Hubs view only contain actual content if we have any child views.
      // If not, we return `null` to avoid messing up Surround transitions.
      var hasContent = view && view.childViews && view.childViews.length;
      if (hasContent) {
        surfaceHubApp.key = uri;
        callback(null, surfaceHubApp);
      } else {
        destroy();
        callback(null, null);
      }
    });
  });
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],38:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _i18n = require('../../../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _sticky = require('../../../../../../libs/spotify-events/sticky');

var _sticky2 = _interopRequireDefault(_sticky);

var _Greeting = require('./Greeting');

var _Greeting2 = _interopRequireDefault(_Greeting);

var _CircularProgressBar = require('./CircularProgressBar');

var _CircularProgressBar2 = _interopRequireDefault(_CircularProgressBar);

var _TaskList = require('./TaskList');

var _TaskList2 = _interopRequireDefault(_TaskList);

var _surroundMessages = require('../../../../../../libs/surround-messages');

var _modalTask = require('../modal-task.hbs');

var _modalTask2 = _interopRequireDefault(_modalTask);

var _modalPremium = require('../modal-premium.hbs');

var _modalPremium2 = _interopRequireDefault(_modalPremium);

var _GlueButton = require('../../../../../../libs/glue/components/GlueButton');

var _GlueButton2 = _interopRequireDefault(_GlueButton);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var onTaskClick = function onTaskClick(task) {
  if (!task || !task.image) {
    return;
  }

  var _window$location = window.location,
      protocol = _window$location.protocol,
      host = _window$location.host;

  var modalContent = Object.assign({}, task, {
    image: protocol + '//' + host + '/img/tasks/' + task.image
  });

  (0, _surroundMessages.dispatchShowModal)(modalContent.title, (0, _modalTask2.default)(modalContent));
};

var App = function (_React$Component) {
  _inherits(App, _React$Component);

  function App() {
    _classCallCheck(this, App);

    return _possibleConstructorReturn(this, (App.__proto__ || Object.getPrototypeOf(App)).apply(this, arguments));
  }

  _createClass(App, [{
    key: 'componentDidMount',
    value: function componentDidMount() {
      _sticky2.default.update();
    }
  }, {
    key: 'componentDidUpdate',
    value: function componentDidUpdate() {
      _sticky2.default.update();
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          tasks = _props.tasks,
          complete = _props.complete,
          onActivateReward = _props.onActivateReward;


      var amountCompleted = tasks.filter(function (t) {
        return t.complete;
      }).length;
      var progress = amountCompleted / tasks.length;
      var username = global.__spotify && global.__spotify.username;
      var showPremiumModal = function showPremiumModal() {
        return (0, _surroundMessages.dispatchShowModal)(null, (0, _modalPremium2.default)());
      };

      var questCompleteScreen = _react2.default.createElement(
        'div',
        { className: 'quest-complete-screen' },
        _react2.default.createElement('span', { className: 'spoticon-check-32 tick' }),
        _react2.default.createElement(
          'h3',
          null,
          _i18n2.default.get('qbe.reward.activated')
        ),
        _react2.default.createElement(
          'p',
          null,
          _i18n2.default.get('qbe.reward.activated_description')
        )
      );
      var taskListScreen = _react2.default.createElement(
        'div',
        null,
        _react2.default.createElement(_TaskList2.default, { onTaskClick: onTaskClick, tasks: tasks }),
        _react2.default.createElement(
          'div',
          { className: 'reward-row' },
          _react2.default.createElement('span', { className: 'spoticon-locked-16 icon' }),
          _react2.default.createElement(
            'span',
            null,
            _i18n2.default.get('qbe.reward.description')
          )
        )
      );
      var activateRewardScreen = _react2.default.createElement(
        'div',
        { className: 'activate-reward-screen' },
        _react2.default.createElement(_GlueButton2.default, { type: 'green', text: _i18n2.default.get('qbe.reward.cta'), onClick: onActivateReward })
      );

      return !tasks.length ? null : _react2.default.createElement(
        'div',
        { className: 'quest-based-education-app' },
        _react2.default.createElement(
          'div',
          { className: 'section-divider-sticky-wrapper' },
          _react2.default.createElement(
            'div',
            {
              className: 'section-divider',
              'data-sticky': true,
              'data-sticky-single': true
            },
            _react2.default.createElement(
              'h2',
              { className: 'section-divider-title' },
              _i18n2.default.get('qbe.greeting_title')
            )
          )
        ),
        complete ? questCompleteScreen : _react2.default.createElement(
          'div',
          null,
          _react2.default.createElement(_CircularProgressBar2.default, { progress: progress }),
          _react2.default.createElement(_Greeting2.default, { name: username, progress: progress }),
          progress < 1 ? taskListScreen : activateRewardScreen
        ),
        _react2.default.createElement(
          'a',
          { className: 'what-is-premium', onClick: showPremiumModal },
          _i18n2.default.get('qbe.reward.what_is_premium')
        )
      );
    }
  }]);

  return App;
}(_react2.default.Component);

exports.default = App;


App.defaultProps = {
  tasks: [],
  complete: false
};

App.propTypes = {
  tasks: _react2.default.PropTypes.array.isRequired,
  onActivateReward: _react2.default.PropTypes.func.isRequired,
  complete: _react2.default.PropTypes.bool
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../../../../libs/glue/components/GlueButton":127,"../../../../../../libs/spotify-events/sticky":303,"../../../../../../libs/surround-messages":559,"../../../../i18n":1,"../modal-premium.hbs":44,"../modal-task.hbs":45,"./CircularProgressBar":39,"./Greeting":40,"./TaskList":42,"react":879}],39:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = require("react");

var _react2 = _interopRequireDefault(_react);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var CircularProgressBar = function CircularProgressBar(_ref) {
  var progress = _ref.progress;

  var percentage = Math.floor(progress * 100);
  var strokeWidth = 6;
  var radius = 50 - strokeWidth / 2;
  var pathDescription = "\n    M 50,50 m 0,-" + radius + "\n    a " + radius + "," + radius + " 0 1 1 0," + 2 * radius + "\n    a " + radius + "," + radius + " 0 1 1 0,-" + 2 * radius + "\n  ";

  var diameter = Math.PI * 2 * radius;
  var progressStyle = {
    strokeDasharray: diameter + "px " + diameter + "px",
    strokeDashoffset: (1 - progress) * diameter + "px"
  };

  return _react2.default.createElement(
    "svg",
    {
      className: "circular-progress-bar",
      viewBox: "0 0 100 100"
    },
    _react2.default.createElement("path", {
      className: "circular-progress-bar-trail",
      d: pathDescription,
      strokeWidth: strokeWidth
    }),
    _react2.default.createElement("path", {
      className: "circular-progress-bar-progress",
      d: pathDescription,
      strokeWidth: strokeWidth,
      style: progressStyle
    }),
    _react2.default.createElement(
      "text",
      {
        className: "circular-progress-bar-text",
        x: 50,
        y: 50
      },
      percentage,
      "%"
    )
  );
};

CircularProgressBar.propTypes = {
  progress: _react2.default.PropTypes.number.isRequired
};

exports.default = CircularProgressBar;

},{"react":879}],40:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _i18n = require('../../../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Greeting = function Greeting(_ref) {
  var progress = _ref.progress,
      name = _ref.name;

  var greeting = 'qbe.greeting1';
  var tagline = 'qbe.greeting1_tagline';

  if (progress === 1) {
    greeting = 'qbe.greeting3';
    tagline = 'qbe.greeting3_tagline';
  } else if (progress >= 0.5) {
    greeting = 'qbe.greeting2';
    tagline = 'qbe.greeting2_tagline';
  }

  return _react2.default.createElement(
    'div',
    { className: 'greeting' },
    _react2.default.createElement(
      'p',
      { className: 'greeting-title' },
      _i18n2.default.get(greeting, name)
    ),
    _react2.default.createElement(
      'p',
      { className: 'greeting-subtitle' },
      _i18n2.default.get(tagline)
    )
  );
};

Greeting.propTypes = {
  name: _react2.default.PropTypes.string.isRequired,
  progress: _react2.default.PropTypes.number.isRequired
};

exports.default = Greeting;

},{"../../../../i18n":1,"react":879}],41:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames = require('classnames');

var _classnames2 = _interopRequireDefault(_classnames);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var Task = function Task(_ref) {
  var task = _ref.task,
      onTaskClick = _ref.onTaskClick;
  var title = task.title,
      complete = task.complete;


  var classes = (0, _classnames2.default)('task', {
    'task-done': complete
  });

  return _react2.default.createElement(
    'p',
    { className: classes, onClick: function onClick() {
        return onTaskClick(task);
      } },
    _react2.default.createElement(
      'span',
      { className: 'task-title' },
      title
    )
  );
};

Task.defaultProps = {
  complete: false,
  onTaskClick: function onTaskClick() {}
};

Task.propTypes = {
  task: _react2.default.PropTypes.shape({
    title: _react2.default.PropTypes.string.isRequired,
    complete: _react2.default.PropTypes.bool
  }),
  onTaskClick: _react2.default.PropTypes.func
};

exports.default = Task;

},{"classnames":576,"react":879}],42:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _Task = require('./Task');

var _Task2 = _interopRequireDefault(_Task);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TaskList = function TaskList(_ref) {
  var tasks = _ref.tasks,
      onTaskClick = _ref.onTaskClick;
  return _react2.default.createElement(
    'div',
    { className: 'tasklist\'' },
    tasks.map(function (task) {
      return _react2.default.createElement(_Task2.default, { key: task.id, task: task, onTaskClick: onTaskClick });
    })
  );
};

TaskList.defaultProps = {
  tasks: [],
  onTaskClick: function onTaskClick() {}
};

TaskList.propTypes = {
  onTaskClick: _react2.default.PropTypes.func,
  tasks: _react2.default.PropTypes.array.isRequired
};

exports.default = TaskList;

},{"./Task":41,"react":879}],43:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.isInABBAGroup = exports.isEligibleForTrial = exports.updateTasks = exports.countSongsAdded = exports.getTaskList = exports.showWelcomeModal = exports.init = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _spotifyCosmosApi = require('spotify-cosmos-api');

var _spotifyCosmosApi2 = _interopRequireDefault(_spotifyCosmosApi);

var _abba = require('../../../../../libs/abba');

var _abba2 = _interopRequireDefault(_abba);

var _App = require('./components/App');

var _App2 = _interopRequireDefault(_App);

var _modalWelcome = require('./modal-welcome.hbs');

var _modalWelcome2 = _interopRequireDefault(_modalWelcome);

var _tasks = require('./tasks');

var _surroundMessages = require('../../../../../libs/surround-messages');

var _spotifyLocalStorage = require('../../../../../libs/spotify-local-storage');

var _spotifyLocalStorage2 = _interopRequireDefault(_spotifyLocalStorage);

var _reducers = require('./reducers');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var TRIAL = '7d';
var DEVICE_ID = 'fake-device-id-ab-quest-based-education';
var ABBA_FLAG = 'ab-quest-based-education';
var ABBA_GROUP = 'Enabled';
var KEY_SHOWN_WELCOME_MODAL = 'quest-based-education:shown_welcome_modal';

var initialised = false;
var songsAdded = 0;

function onActivateReward() {
  var country = global.__spotify && global.__spotify.product_state && global.__spotify.product_state.country_code;

  (0, _surroundMessages.activateTrial)({
    device_id: DEVICE_ID,
    trial: TRIAL,
    country: country
  });
}

var init = exports.init = function init() {
  if (!initialised) {
    initialised = true;

    (0, _tasks.initTaskListeners)();
    songsAdded = (0, _tasks.getAmountOfSongsAdded)();
  }
};

var showWelcomeModal = exports.showWelcomeModal = function showWelcomeModal() {
  if (_spotifyLocalStorage2.default.get(KEY_SHOWN_WELCOME_MODAL) !== '1') {
    (0, _surroundMessages.dispatchShowModal)(null, (0, _modalWelcome2.default)({ name: global.__spotify.username }));
    _spotifyLocalStorage2.default.set(KEY_SHOWN_WELCOME_MODAL, '1');
  }
};

var getTaskList = exports.getTaskList = _tasks.getTasks;

var countSongsAdded = exports.countSongsAdded = function countSongsAdded(_ref) {
  var _ref$amount = _ref.amount,
      amount = _ref$amount === undefined ? 0 : _ref$amount;

  songsAdded += amount;
  if (songsAdded >= _tasks.AMOUNT_OF_SONGS) {
    (0, _surroundMessages.dispatchCompleteTask)('add_songs_to_playlist');
  }
  (0, _tasks.setAmountOfSongsAdded)(songsAdded);
};

var updateTasks = exports.updateTasks = function updateTasks(state, message) {
  var newState = (0, _reducers.tasks)(state, message);
  (0, _tasks.saveTasks)(newState);
  return newState;
};

var isEligibleForTrial = exports.isEligibleForTrial = function isEligibleForTrial() {
  return new Promise(function (resolve, reject) {
    _spotifyCosmosApi2.default.resolver.get({
      url: 'hm://login-trial/v2/viable',
      body: {
        device_id: DEVICE_ID,
        trial: TRIAL
      }
    }, function (err, res) {
      if (err) {
        reject(err);
        return;
      }

      var result = res.getJSONBody();
      resolve(result && result.viable === true);
    });
  });
};

var isInABBAGroup = exports.isInABBAGroup = function isInABBAGroup() {
  return new Promise(function (resolve, reject) {
    _abba2.default.get(ABBA_FLAG, function (err, cell) {
      if (err) {
        reject(err);
        return;
      }

      resolve(cell === ABBA_GROUP);
    });
  });
};

var QuestBasedEducation = function QuestBasedEducation(props) {
  return _react2.default.createElement(_App2.default, _extends({ onActivateReward: onActivateReward }, props));
};
exports.default = QuestBasedEducation;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../../../libs/abba":49,"../../../../../libs/spotify-local-storage":517,"../../../../../libs/surround-messages":559,"./components/App":38,"./modal-welcome.hbs":46,"./reducers":47,"./tasks":48,"react":879,"spotify-cosmos-api":890}],44:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;


  buffer += "<div class=\"quest-based-education-premium-modal\">\n  <h1>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "qbe.modal.heading", options) : helperMissing.call(depth0, "loc", "qbe.modal.heading", options)))
    + "</h1>\n  <div class=\"items-container\">\n    <div class=\"item-download\">\n      <p class=\"icon\"></p>\n      <h2>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "qbe.modal.download.title", options) : helperMissing.call(depth0, "loc", "qbe.modal.download.title", options)))
    + "</h2>\n      <h3>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "qbe.modal.download.subtitle", options) : helperMissing.call(depth0, "loc", "qbe.modal.download.subtitle", options)))
    + "</h3>\n    </div>\n    <div class=\"item-warning\">\n      <p class=\"icon\"></p>\n      <h2>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "qbe.modal.ads.title", options) : helperMissing.call(depth0, "loc", "qbe.modal.ads.title", options)))
    + "</h2>\n      <h3>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "qbe.modal.ads.subtitle", options) : helperMissing.call(depth0, "loc", "qbe.modal.ads.subtitle", options)))
    + "</h3>\n    </div>\n    <div class=\"item-play\">\n      <p class=\"icon\"></p>\n      <h2>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "qbe.modal.play.title", options) : helperMissing.call(depth0, "loc", "qbe.modal.play.title", options)))
    + "</h2>\n      <h3>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "qbe.modal.play.subtitle", options) : helperMissing.call(depth0, "loc", "qbe.modal.play.subtitle", options)))
    + "</h3>\n    </div>\n    <div class=\"item-skip-forward\">\n      <p class=\"icon\"></p>\n      <h2>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "qbe.modal.skips.title", options) : helperMissing.call(depth0, "loc", "qbe.modal.skips.title", options)))
    + "</h2>\n      <h3>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "qbe.modal.skips.subtitle", options) : helperMissing.call(depth0, "loc", "qbe.modal.skips.subtitle", options)))
    + "</h3>\n    </div>\n  </div>\n</div>";
  return buffer;
  });

},{"hbsfy/runtime":615}],45:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<div class=\"quest-based-education-modal\">\n  <img class=\"quest-based-education-modal-image\" src=\"";
  if (helper = helpers.image) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.image); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" />\n  <div class=\"quest-based-education-modal-info\">\n    <h2>";
  if (helper = helpers.header) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.header); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</h2>\n    <p>";
  if (helper = helpers.description) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.description); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</p>\n  </div>\n</div>";
  return buffer;
  });

},{"hbsfy/runtime":615}],46:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<div class=\"quest-based-education-welcome-modal\">\n  <svg class=\"circular-progress-bar\" viewBox=\"0 0 100 100\">\n    <path class=\"circular-progress-bar-trail\" d=\"\n      M 50,50 m 0,-47\n      a 47,47 0 1 1 0,94\n      a 47,47 0 1 1 0,-94\n    \" />\n    <path class=\"circular-progress-bar-progress\" d=\"\n      M 50,50 m 0,-47\n      a 47,47 0 1 1 0,94\n      a 47,47 0 1 1 0,-94\n    \" />\n\n    <text class=\"circular-progress-bar-text\" x=\"50\" y=\"50\">20%</text>\n  </svg>\n\n  <p class=\"heading\">Welcome ";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "!</p>\n  <p class=\"info\">Want to get Spotify Premium for free? Complete a few simple tasks and we will give you Premium for 7 days.</p>\n  <button type=\"button\" class=\"button button-white js-close\">Got it</button>\n</div>";
  return buffer;
  });

},{"hbsfy/runtime":615}],47:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tasks = undefined;

var _surroundMessages = require('../../../../../libs/surround-messages');

var task = function task() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var message = arguments[1];

  switch (message.action) {
    case _surroundMessages.COMPLETE_QBE_TASK:
      if (state.id !== message.id) {
        return state;
      }

      return Object.assign({}, state, {
        complete: true
      });
    default:
      return state;
  }
};

var tasks = exports.tasks = function tasks() {
  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var message = arguments[1];

  switch (message.action) {
    case _surroundMessages.COMPLETE_QBE_TASK:
      return state.map(function (t) {
        return task(t, message);
      });
    default:
      return state;
  }
};

},{"../../../../../libs/surround-messages":559}],48:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initTaskListeners = exports.setAmountOfSongsAdded = exports.getAmountOfSongsAdded = exports.saveTasks = exports.getTasks = exports.AMOUNT_OF_SONGS = undefined;

var _spotifyCosmosApi = require('spotify-cosmos-api');

var _spotifyCosmosApi2 = _interopRequireDefault(_spotifyCosmosApi);

var _i18n = require('../../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _spotifyLive = require('../../../../../libs/spotify-live');

var _spotifyLive2 = _interopRequireDefault(_spotifyLive);

var _spotifyLocalStorage = require('../../../../../libs/spotify-local-storage');

var _spotifyLocalStorage2 = _interopRequireDefault(_spotifyLocalStorage);

var _surroundMessages = require('../../../../../libs/surround-messages');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var KEY_TASKS_STATE = 'quest-based-education:tasks';
var KEY_COUNT_SONGS_ADDED = 'quest-based-education:songs_added';

var AMOUNT_OF_SONGS = exports.AMOUNT_OF_SONGS = 5;

var defaultTasks = [{
  id: 'signup',
  title: _i18n2.default.get('qbe.tasks.sign_in_to_spotify.title'),
  complete: true
}, {
  id: 'search',
  title: _i18n2.default.get('qbe.tasks.search.title'),
  header: _i18n2.default.get('qbe.tasks.search.header'),
  description: _i18n2.default.get('qbe.tasks.search.description'),
  image: '01_Search_for_a_song.png',
  complete: false
}, {
  id: 'play_song',
  title: _i18n2.default.get('qbe.tasks.play_song.title'),
  header: _i18n2.default.get('qbe.tasks.play_song.header'),
  description: _i18n2.default.get('qbe.tasks.play_song.description'),
  image: '02_Play_a_song.png',
  complete: false
}, {
  id: 'create_playlist',
  title: _i18n2.default.get('qbe.tasks.create_playlist.title'),
  header: _i18n2.default.get('qbe.tasks.create_playlist.header'),
  description: _i18n2.default.get('qbe.tasks.create_playlist.description'),
  image: '03_Create_a_playlist.png',
  complete: false
}, {
  id: 'add_songs_to_playlist',
  title: _i18n2.default.get('qbe.tasks.add_songs_to_playlist.title', AMOUNT_OF_SONGS),
  header: _i18n2.default.get('qbe.tasks.add_songs_to_playlist.header'),
  description: _i18n2.default.get('qbe.tasks.add_songs_to_playlist.description'),
  image: '04_Add_songs_to_playlist.png',
  complete: false
}];

function loadFromStorage(id) {
  var state = _spotifyLocalStorage2.default.get(id);
  return state ? JSON.parse(state) : null;
}

function saveToStorage(id, data) {
  _spotifyLocalStorage2.default.set(id, JSON.stringify(data));
}

function createTaskList(tasks, loadedState) {
  return tasks.map(function (task) {
    return task.id in loadedState ? Object.assign({}, task, loadedState[task.id]) : task;
  });
}

var getTasks = exports.getTasks = function getTasks() {
  var completionState = loadFromStorage(KEY_TASKS_STATE) || {};
  return createTaskList(defaultTasks, completionState);
};

var saveTasks = exports.saveTasks = function saveTasks(tasks) {
  var completionState = tasks.reduce(function (a, task) {
    a[task.id] = { complete: task.complete };
    return a;
  }, {});

  return saveToStorage(KEY_TASKS_STATE, completionState);
};

var getAmountOfSongsAdded = exports.getAmountOfSongsAdded = function getAmountOfSongsAdded() {
  return loadFromStorage(KEY_COUNT_SONGS_ADDED) || 0;
};
var setAmountOfSongsAdded = exports.setAmountOfSongsAdded = function setAmountOfSongsAdded(amount) {
  return saveToStorage(KEY_COUNT_SONGS_ADDED, amount);
};

// Sets up event listeners for tasks
// Each listener should call `dispatchCompleteTask(<id>)` when the task criteria have been met
var initTaskListeners = exports.initTaskListeners = function initTaskListeners() {
  // `Search for a Song` task
  _spotifyCosmosApi2.default.resolver.subscribe('sp://messages/v1/suggest', function (error, response) {
    var _JSON$parse = JSON.parse(response.getBody()),
        text = _JSON$parse.text;

    if (text) {
      (0, _surroundMessages.dispatchCompleteTask)('search');
    }
  });

  // `Play a Song` task
  var handler = function handler(_ref) {
    var isPaused = _ref.isPaused,
        track = _ref.track;

    if (!isPaused && track && track.uri) {
      (0, _surroundMessages.dispatchCompleteTask)('play_song');
      (0, _spotifyLive2.default)('spotify:player').off('update', handler);
    }
  };
  (0, _spotifyLive2.default)('spotify:player').on('update', handler);
};

},{"../../../../../libs/spotify-live":512,"../../../../../libs/spotify-local-storage":517,"../../../../../libs/surround-messages":559,"../../../i18n":1,"spotify-cosmos-api":890}],49:[function(require,module,exports){
'use strict';

var cosmos = require('spotify-cosmos-api');

var subscriptions = [];

/**
 * The Public API
 */
module.exports = {
  get: get,
  subscribe: subscribe,
  clearSubscriptions: clearSubscriptions
};

/**
 * Debug API
 * Exposed on the window for debugging and TA tests
 */
if (typeof window !== 'undefined') {
  window.abba = {
    get: get
  };
}

function get(flag, callback) {
  var overrides = readOverrides();
  if (overrides.hasOwnProperty(flag)) {
    console.warn('Abba: Override for ' + flag + ' : ' + overrides[flag]);
    setTimeout(function () {
      return callback(null, overrides[flag]);
    }, 0);
    return;
  }

  cosmos.resolver.post({
    url: 'sp://abba/v1/flags',
    body: {
      flags: [flag]
    }
  }, function (err, response) {
    if (err) {
      callback(err, null);
      return;
    }
    var body = response.getJSONBody();
    var flags = body && body.flags || [];
    var featureFlagCell = flags[0] && flags[0].featureName === flag && flags[0].cell;
    callback(null, featureFlagCell || null);
  });
}

function subscribe(flag, callback) {
  var oldValue = void 0;

  var update = function update(newValue) {
    // ABBA might pub even though the value we're after haven't actually
    // changed, so must make sure that the flag we're tracking actually
    // changed value.
    if (newValue !== oldValue) {
      oldValue = newValue;
      callback(null, newValue);
    }
  };

  var cosmosSubscription = cosmos.resolver.subscribe({
    url: 'sp://abba/v1/flags',
    body: {
      flags: [flag]
    }
  }, function (subscribeError) {
    if (subscribeError) {
      callback(subscribeError);
      return;
    }

    get(flag, function (err, newValue) {
      if (err) {
        callback(err);
        return;
      }
      update(newValue);
    });
  });

  var subscription = {
    cancel: function cancel() {
      if (cosmosSubscription) cosmosSubscription.cancel();
      var index = subscriptions[flag].indexOf(subscription);
      if (index !== -1) {
        subscriptions[flag].splice(index, 1);
      }
      subscription = cosmosSubscription = null;
    },
    _update: update
  };

  if (!(flag in subscriptions)) subscriptions[flag] = [];
  subscriptions[flag].push(subscription);

  return subscription;
}

function clearSubscriptions() {
  subscriptions = [];
}

function safeParseJson(value) {
  try {
    return JSON.parse(value);
  } catch (e) {
    console.error('error parsing value=%o, error=%o', value, e);
    return {};
  }
}

function readOverrides() {
  var value = typeof __spotify !== 'undefined' && __spotify.product_state ? __spotify.product_state.abbaOverrides || __spotify.product_state.abbaoverrides : '';
  if (value) {
    return safeParseJson(value);
  }
  return {};
}

},{"spotify-cosmos-api":890}],50:[function(require,module,exports){
'use strict';

// This file will likely become a generated file in the future. Please
// avoid adding extra APIs or exports here.

var i18n = require('../../spotify-i18n');

var locales = {
  'cs': require('./json/cs.json'),
  'de': require('./json/de.json'),
  'el': require('./json/el.json'),
  'en': require('./json/en.json'),
  'es': require('./json/es.json'),
  'es-419': require('./json/es-419.json'),
  'fi': require('./json/fi.json'),
  'fr': require('./json/fr.json'),
  'fr-CA': require('./json/fr-CA.json'),
  'hu': require('./json/hu.json'),
  'id': require('./json/id.json'),
  'it': require('./json/it.json'),
  'ja': require('./json/ja.json'),
  'nl': require('./json/nl.json'),
  'pl': require('./json/pl.json'),
  'pt-BR': require('./json/pt-BR.json'),
  'sv': require('./json/sv.json'),
  'tr': require('./json/tr.json'),
  'zh-Hant': require('./json/zh-Hant.json'),
  'zsm': require('./json/zsm.json')
};

module.exports = i18n(locales);

},{"../../spotify-i18n":456,"./json/cs.json":51,"./json/de.json":52,"./json/el.json":53,"./json/en.json":54,"./json/es-419.json":55,"./json/es.json":56,"./json/fi.json":57,"./json/fr-CA.json":58,"./json/fr.json":59,"./json/hu.json":60,"./json/id.json":61,"./json/it.json":62,"./json/ja.json":63,"./json/nl.json":64,"./json/pl.json":65,"./json/pt-BR.json":66,"./json/sv.json":67,"./json/tr.json":68,"./json/zh-Hant.json":69,"./json/zsm.json":70}],51:[function(require,module,exports){
module.exports={
  "HideAnnouncements": "Skrýt oznámení",
  "Sponsored": "Sponzorováno",
  "Advertisement": "Reklama",
  "Promoted": "Propagováno",
  "PresentedBy": "Přináší",
  "AdClick": "Zobrazit podrobnosti",
  "WatchWithSound": "Sledovat se zvukem",
  "LearnMore": "Více informací"
}
},{}],52:[function(require,module,exports){
module.exports={
  "HideAnnouncements": "Ankündigungen ausblenden",
  "Sponsored": "Gesponsert",
  "Advertisement": "Werbung",
  "Promoted": "Beworben",
  "PresentedBy": "Präsentiert von",
  "AdClick": "Für weitere Infos klicken",
  "WatchWithSound": "Mit Ton ansehen",
  "LearnMore": "Weitere Infos"
}
},{}],53:[function(require,module,exports){
module.exports={
  "HideAnnouncements": "Απόκρυψη ανακοινώσεων",
  "Sponsored": "Χορηγία",
  "Advertisement": "Διαφήμιση",
  "Promoted": "Προώθηση",
  "PresentedBy": "Παρουσιάζεται από:",
  "AdClick": "Κάνε κλικ για περισσότερες πληροφορίες",
  "WatchWithSound": "Παρακολούθηση με ήχο",
  "LearnMore": "Μάθε περισσότερα"
}
},{}],54:[function(require,module,exports){
module.exports={
  "HideAnnouncements": "Hide Announcements",
  "Sponsored": "Sponsored",
  "Advertisement": "Advertisement",
  "Promoted": "Promoted",
  "PresentedBy": "Presented By",
  "AdClick": "Click for more info",
  "WatchWithSound": "Watch with sound",
  "LearnMore": "Learn More"
}
},{}],55:[function(require,module,exports){
module.exports={
  "HideAnnouncements": "Ocultar Noticias",
  "Sponsored": "Patrocinado",
  "Advertisement": "Anuncio",
  "Promoted": "Promocionados",
  "PresentedBy": "Presentado por",
  "AdClick": "Haz clic para más información",
  "WatchWithSound": "Watch with sound",
  "LearnMore": "Learn More"
}
},{}],56:[function(require,module,exports){
module.exports={
  "HideAnnouncements": "Ocultar mensajes",
  "Sponsored": "Patrocinado",
  "Advertisement": "Publicidad",
  "Promoted": "Promocionados",
  "PresentedBy": "Ofrecido por",
  "AdClick": "Pulsa para saber más",
  "WatchWithSound": "Watch with sound",
  "LearnMore": "Learn More"
}
},{}],57:[function(require,module,exports){
module.exports={
  "HideAnnouncements": "Piilota ilmoitukset",
  "Sponsored": "Sponsoroitu",
  "Advertisement": "Mainos",
  "Promoted": "Nostettu",
  "PresentedBy": "Listan tarjoaa",
  "AdClick": "Lue lisää napsauttamalla.",
  "WatchWithSound": "Katso äänen kanssa",
  "LearnMore": "Lisätietoja"
}
},{}],58:[function(require,module,exports){
module.exports={
  "HideAnnouncements": "Masquer les publicités",
  "Sponsored": "Commandité",
  "Advertisement": "Publicité",
  "Promoted": "Commanditée",
  "PresentedBy": "Présenté par",
  "AdClick": "Clique pour en savoir plus",
  "WatchWithSound": "Visionnez avec du son!",
  "LearnMore": "En savoir plus"
}
},{}],59:[function(require,module,exports){
module.exports={
  "HideAnnouncements": "Masquer",
  "Sponsored": "Sponsorisé",
  "Advertisement": "Publicité",
  "Promoted": "Sponsorisé",
  "PresentedBy": "Présenté(e) par",
  "AdClick": "Cliquez pour en savoir plus",
  "WatchWithSound": "Visionner avec le son",
  "LearnMore": "Plus d'infos"
}
},{}],60:[function(require,module,exports){
module.exports={
  "HideAnnouncements": "Hírek elrejtése",
  "Sponsored": "Fizetett hirdetés",
  "Advertisement": "Reklám",
  "Promoted": "Szponzorált",
  "PresentedBy": "Szponzor:",
  "AdClick": "Kattints a további információkért",
  "WatchWithSound": "Hang bekapcsolása",
  "LearnMore": "Részletek"
}
},{}],61:[function(require,module,exports){
module.exports={
  "HideAnnouncements": "Sembunyikan Pemberitahuan",
  "Sponsored": "Disponsori",
  "Advertisement": "Iklan",
  "Promoted": "Dipromosikan",
  "PresentedBy": "Disajikan Oleh",
  "AdClick": "Klik untuk info selengkapnya",
  "WatchWithSound": "Menonton dengan suara",
  "LearnMore": "Pelajari Lebih Lanjut"
}
},{}],62:[function(require,module,exports){
module.exports={
  "HideAnnouncements": "Nascondi annunci",
  "Sponsored": "Sponsorizzato",
  "Advertisement": "Pubblicità",
  "Promoted": "Promossi",
  "PresentedBy": "Presentato da",
  "AdClick": "Clicca per maggiori informazioni",
  "WatchWithSound": "Riproduci audio",
  "LearnMore": "Ulteriori info"
}
},{}],63:[function(require,module,exports){
module.exports={
  "HideAnnouncements": "お知らせを非表示にする",
  "Sponsored": "スポンサー付き",
  "Advertisement": "広告",
  "Promoted": "プロモーション済み",
  "PresentedBy": "提供元:",
  "AdClick": "詳細を見る",
  "WatchWithSound": "音声を聴く。",
  "LearnMore": "詳細はこちら "
}
},{}],64:[function(require,module,exports){
module.exports={
  "HideAnnouncements": "Aankondigingen verbergen",
  "Sponsored": "Gesponsord",
  "Advertisement": "Advertentie",
  "Promoted": "Aangeboden",
  "PresentedBy": "Gepresenteerd door",
  "AdClick": "Klik voor meer informatie",
  "WatchWithSound": "Afspelen met geluid",
  "LearnMore": "Meer info"
}
},{}],65:[function(require,module,exports){
module.exports={
  "HideAnnouncements": "Ukryj ogłoszenia",
  "Sponsored": "Sponsorowane",
  "Advertisement": "Reklama",
  "Promoted": "Promowane",
  "PresentedBy": "Prezentuje",
  "AdClick": "Kliknij, aby uzyskać więcej informacji.",
  "WatchWithSound": "Zobacz z dźwiękiem",
  "LearnMore": "Dowiedz się więcej"
}
},{}],66:[function(require,module,exports){
module.exports={
  "HideAnnouncements": "Ocultar",
  "Sponsored": "Patrocinado",
  "Advertisement": "Propaganda",
  "Promoted": "Promocional",
  "PresentedBy": "Apresentadas por",
  "AdClick": "Clique para mais informações",
  "WatchWithSound": "Assistir com som",
  "LearnMore": "Saiba mais"
}
},{}],67:[function(require,module,exports){
module.exports={
  "HideAnnouncements": "Dölj musikaviseringar",
  "Sponsored": "Sponsrad",
  "Advertisement": "Reklam",
  "Promoted": "Sponsrat",
  "PresentedBy": "Presenteras av",
  "AdClick": "Klicka här för mer information",
  "WatchWithSound": "Titta med ljud",
  "LearnMore": "Läs mer"
}
},{}],68:[function(require,module,exports){
module.exports={
  "HideAnnouncements": "Duyuruları Gizle",
  "Sponsored": "Sponsorlu",
  "Advertisement": "Reklam",
  "Promoted": "Tanıtılan",
  "PresentedBy": "Sunan",
  "AdClick": "Daha fazla bilgi için tıklayın",
  "WatchWithSound": "Sesli izle",
  "LearnMore": "Daha Fazla Bilgi"
}
},{}],69:[function(require,module,exports){
module.exports={
  "HideAnnouncements": "隱藏公告",
  "Sponsored": "贊助",
  "Advertisement": "廣告",
  "Promoted": "已宣傳",
  "PresentedBy": "贊助商：",
  "AdClick": "按一下了解更多資訊",
  "WatchWithSound": "開啟聲音來觀賞",
  "LearnMore": "了解更多"
}
},{}],70:[function(require,module,exports){
module.exports={
  "HideAnnouncements": "Sembunyikan Pengumuman",
  "Sponsored": "Tajaan",
  "Advertisement": "Iklan",
  "Promoted": "Dipromosikan",
  "PresentedBy": "Dipersembahkan Oleh",
  "AdClick": "Klik untuk maklumat lanjut",
  "WatchWithSound": "Menonton dengan suara",
  "LearnMore": "Ketahui Lebih Lanjut"
}
},{}],71:[function(require,module,exports){
module.exports = '<svg width="150px" height="20px" viewBox="0 0 147 20" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:sketch="http://www.bohemiancoding.com/sketch/ns">\n    <title>spotify spotlight svg 2</title>\n    <desc>Created with Sketch.</desc>\n    <defs></defs>\n    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" sketch:type="MSPage">\n        <rect id="Rectangle-1" fill="#FFFFFF" sketch:type="MSShapeGroup" x="70" y="5" width="1" height="11"></rect>\n        <g id="Imported-Layers" sketch:type="MSLayerGroup">\n            <path d="M10.001005,0.0447 C4.48874372,0.0447 0.0198994975,4.491 0.0198994975,9.9758 C0.0198994975,15.461 4.48874372,19.9071 10.001005,19.9071 C15.5135678,19.9071 19.9821106,15.461 19.9821106,9.9758 C19.9821106,4.491 15.5135678,0.0447 10.001005,0.0447" id="Fill-1" fill="#84BD00" sketch:type="MSShapeGroup"></path>\n            <path d="M15.5438191,10.6003 C12.4630151,8.7165 7.95648241,8.1864 4.33135678,9.2809 C3.92060302,9.4054 3.68844221,9.8371 3.81246231,10.2466 C3.93748744,10.6553 4.3720603,10.8861 4.78361809,10.7624 C7.95698492,9.804 12.0471357,10.2792 14.7294472,11.9197 C15.0951759,12.1435 15.5740704,12.0292 15.799799,11.6648 C16.0247236,11.3012 15.9095477,10.8244 15.5438191,10.6003" id="Fill-2" fill="#000000" sketch:type="MSShapeGroup"></path>\n            <path d="M16.8580905,7.2513 C13.1541709,5.0637 7.29326633,4.858 3.76753769,5.9229 C3.27396985,6.072 2.9958794,6.5906 3.14532663,7.0816 C3.29477387,7.5724 3.81628141,7.8494 4.30954774,7.7005 C7.38090452,6.773 12.6878392,6.9478 15.9051256,8.8489 C16.3477387,9.111 16.9211055,8.9655 17.1842211,8.5241 C17.4472362,8.0834 17.3017085,7.5133 16.8580905,7.2513" id="Fill-3" fill="#000000" sketch:type="MSShapeGroup"></path>\n            <path d="M14.3720603,13.5178 C11.7413065,11.9182 8.4798995,11.546 4.67788945,12.4108 C4.34231156,12.4868 4.13326633,12.8189 4.21005025,13.152 C4.28633166,13.485 4.62,13.6938 4.95487437,13.6174 C8.42914573,12.8277 11.3792965,13.1496 13.7231156,14.575 C14.0160804,14.7533 14.3990955,14.6616 14.5784925,14.369 C14.7577889,14.0772 14.6654271,13.696 14.3720603,13.5178" id="Fill-4" fill="#000000" sketch:type="MSShapeGroup"></path>\n        </g>\n        <g id="Imported-Layers" sketch:type="MSLayerGroup" transform="translate(25.000000, 5.000000)" fill="#FFFFFF">\n            <path d="M3.80616092,4.19354545 C2.22942529,3.82181818 1.9485977,3.56090909 1.9485977,3.01281818 C1.9485977,2.49481818 2.44193103,2.14636364 3.17535632,2.14636364 C3.88643678,2.14636364 4.59135632,2.411 5.33057471,2.95590909 C5.35291954,2.97236364 5.38096552,2.979 5.40845977,2.97472727 C5.43604598,2.97063636 5.46050575,2.95563636 5.47668966,2.93309091 L6.24662069,1.86009091 C6.27816092,1.816 6.2696092,1.75509091 6.22694253,1.72127273 C5.34721839,1.02336364 4.3565977,0.684090909 3.19871264,0.684090909 C1.49627586,0.684090909 0.307126437,1.69418182 0.307126437,3.13936364 C0.307126437,4.68918182 1.33287356,5.23790909 3.10556322,5.66145455 C4.61443678,6.00509091 4.86905747,6.29290909 4.86905747,6.80754545 C4.86905747,7.37772727 4.3542069,7.73227273 3.52551724,7.73227273 C2.60514943,7.73227273 1.85443678,7.42572727 1.01462069,6.70672727 C0.99383908,6.689 0.965241379,6.68081818 0.938850575,6.68236364 C0.91108046,6.68463636 0.885701149,6.69736364 0.868045977,6.71836364 L0.0047816092,7.734 C-0.0314482759,7.77618182 -0.0268505747,7.83909091 0.0149885057,7.87563636 C0.992091954,8.738 2.19374713,9.19354545 3.49057471,9.19354545 C5.32514943,9.19354545 6.51062069,8.20254545 6.51062069,6.66863636 C6.51062069,5.37236364 5.72717241,4.65545455 3.80616092,4.19354545" id="Fill-1" sketch:type="MSShapeGroup"></path>\n            <path d="M10.6611494,2.65618182 C9.86593103,2.65618182 9.21370115,2.96581818 8.67586207,3.60027273 L8.67586207,2.88618182 C8.67586207,2.82981818 8.6296092,2.78390909 8.5725977,2.78390909 L7.16082759,2.78390909 C7.10381609,2.78390909 7.05765517,2.82981818 7.05765517,2.88618182 L7.05765517,10.8211818 C7.05765517,10.8775455 7.10381609,10.9234545 7.16082759,10.9234545 L8.5725977,10.9234545 C8.6296092,10.9234545 8.67586207,10.8775455 8.67586207,10.8211818 L8.67586207,8.31645455 C9.2137931,8.91336364 9.86611494,9.20490909 10.6611494,9.20490909 C12.1386667,9.20490909 13.6342989,8.08045455 13.6342989,5.93090909 C13.6342989,3.78090909 12.1386667,2.65618182 10.6611494,2.65618182 L10.6611494,2.65618182 Z M11.9928276,5.93090909 C11.9928276,7.02545455 11.3108046,7.78936364 10.3343448,7.78936364 C9.36891954,7.78936364 8.64064368,6.99072727 8.64064368,5.93090909 C8.64064368,4.87118182 9.36891954,4.07254545 10.3343448,4.07254545 C11.2950805,4.07254545 11.9928276,4.85390909 11.9928276,5.93090909 L11.9928276,5.93090909 Z" id="Fill-2" sketch:type="MSShapeGroup"></path>\n            <path d="M17.4683218,2.65618182 C15.5654253,2.65618182 14.0747586,4.10472727 14.0747586,5.95427273 C14.0747586,7.78372727 15.5552184,9.21709091 17.4449655,9.21709091 C19.3544828,9.21709091 20.8497471,7.77336364 20.8497471,5.93090909 C20.8497471,4.09454545 19.3647816,2.65618182 17.4683218,2.65618182 L17.4683218,2.65618182 Z M17.4683218,7.80081818 C16.4561839,7.80081818 15.6931494,6.99681818 15.6931494,5.93090909 C15.6931494,4.86054545 16.4297931,4.08372727 17.4449655,4.08372727 C18.4635402,4.08372727 19.2318161,4.88763636 19.2318161,5.95427273 C19.2318161,7.02445455 18.4901149,7.80081818 17.4683218,7.80081818 L17.4683218,7.80081818 Z" id="Fill-3" sketch:type="MSShapeGroup"></path>\n            <path d="M24.9131954,2.78390909 L23.3595402,2.78390909 L23.3595402,1.21345455 C23.3595402,1.15709091 23.3134713,1.11127273 23.2564598,1.11127273 L21.8447816,1.11127273 C21.7876782,1.11127273 21.7413333,1.15709091 21.7413333,1.21345455 L21.7413333,2.78390909 L21.0624368,2.78390909 C21.0056092,2.78390909 20.9595402,2.82981818 20.9595402,2.88618182 L20.9595402,4.08572727 C20.9595402,4.142 21.0056092,4.188 21.0624368,4.188 L21.7413333,4.188 L21.7413333,7.292 C21.7413333,8.54636364 22.3727816,9.18236364 23.6182989,9.18236364 C24.1246897,9.18236364 24.5448276,9.079 24.9407816,8.857 C24.9729655,8.83918182 24.9930115,8.80490909 24.9930115,8.76845455 L24.9930115,7.62618182 C24.9930115,7.59090909 24.9744368,7.55763636 24.944,7.53918182 C24.9131954,7.52009091 24.8749425,7.51909091 24.8434023,7.53454545 C24.5714023,7.66981818 24.3084138,7.73227273 24.0146207,7.73227273 C23.5616552,7.73227273 23.3595402,7.52890909 23.3595402,7.07327273 L23.3595402,4.188 L24.9131954,4.188 C24.9702069,4.188 25.0161839,4.142 25.0161839,4.08572727 L25.0161839,2.88618182 C25.0161839,2.82981818 24.9702069,2.78390909 24.9131954,2.78390909" id="Fill-4" sketch:type="MSShapeGroup"></path>\n            <path d="M30.326069,2.79 L30.326069,2.59709091 C30.326069,2.02963636 30.546023,1.77663636 31.0397241,1.77663636 C31.333977,1.77663636 31.5703908,1.83445455 31.8352184,1.92181818 C31.8677701,1.93190909 31.9018851,1.92681818 31.9283678,1.90754545 C31.9555862,1.88827273 31.9710345,1.85736364 31.9710345,1.82454545 L31.9710345,0.648363636 C31.9710345,0.603454545 31.9417011,0.563545455 31.898023,0.550363636 C31.6182989,0.468090909 31.2604138,0.383636364 30.7245057,0.383636364 C29.4204138,0.383636364 28.7312184,1.10963636 28.7312184,2.48236364 L28.7312184,2.77781818 L28.0529655,2.77781818 C27.996046,2.77781818 27.9493333,2.82363636 27.9493333,2.88 L27.9493333,4.08572727 C27.9493333,4.142 27.996046,4.188 28.0529655,4.188 L28.7312184,4.188 L28.7312184,8.97572727 C28.7312184,9.03209091 28.7771954,9.078 28.8341149,9.078 L30.245977,9.078 C30.3029885,9.078 30.3494253,9.03209091 30.3494253,8.97572727 L30.3494253,4.188 L31.6675862,4.188 L33.6868966,8.97454545 C33.4576552,9.47745455 33.2321839,9.57754545 32.9245057,9.57754545 C32.6757701,9.57754545 32.4137931,9.50409091 32.146023,9.35918182 C32.1207356,9.34554545 32.0909425,9.34318182 32.0637241,9.35154545 C32.0367816,9.361 32.014069,9.38072727 32.0026667,9.40672727 L31.5241379,10.4446364 C31.5013333,10.4936364 31.5208276,10.5512727 31.5686437,10.5766364 C32.0681379,10.8440909 32.5191724,10.9582727 33.0764138,10.9582727 C34.1188966,10.9582727 34.6951724,10.4781818 35.2031264,9.18663636 L37.6525057,2.92927273 C37.6648276,2.89781818 37.6611494,2.86227273 37.6415632,2.83436364 C37.6222529,2.80663636 37.5908966,2.79 37.5566897,2.79 L36.0868966,2.79 C36.0429425,2.79 36.0034943,2.81763636 35.9891494,2.85845455 L34.4834943,7.11027273 L32.8342989,2.85572727 C32.8192184,2.81609091 32.7806897,2.79 32.7378391,2.79 L30.326069,2.79" id="Fill-5" sketch:type="MSShapeGroup"></path>\n            <path d="M27.188046,2.78390909 L25.7761839,2.78390909 C25.7191724,2.78390909 25.6727356,2.82981818 25.6727356,2.88618182 L25.6727356,8.97572727 C25.6727356,9.03209091 25.7191724,9.078 25.7761839,9.078 L27.188046,9.078 C27.2449655,9.078 27.2914943,9.03209091 27.2914943,8.97572727 L27.2914943,2.88618182 C27.2914943,2.82981818 27.2449655,2.78390909 27.188046,2.78390909" id="Fill-6" sketch:type="MSShapeGroup"></path>\n            <path d="M26.4892874,0.0110909091 C25.930023,0.0110909091 25.4761379,0.458727273 25.4761379,1.01172727 C25.4761379,1.565 25.930023,2.01309091 26.4892874,2.01309091 C27.0483678,2.01309091 27.5017931,1.565 27.5017931,1.01172727 C27.5017931,0.458727273 27.0483678,0.0110909091 26.4892874,0.0110909091" id="Fill-7" sketch:type="MSShapeGroup"></path>\n            <path d="M38.8578391,4.74172727 C38.2991264,4.74172727 37.8642759,4.29809091 37.8642759,3.75936364 C37.8642759,3.22063636 38.3048276,2.77190909 38.8630805,2.77190909 C39.4217931,2.77190909 39.8565517,3.21554545 39.8565517,3.75372727 C39.8565517,4.29254545 39.4164598,4.74172727 38.8578391,4.74172727 L38.8578391,4.74172727 Z M38.8630805,2.86963636 C38.3542069,2.86963636 37.9690115,3.26954545 37.9690115,3.75936364 C37.9690115,4.24890909 38.3513563,4.64354545 38.8578391,4.64354545 C39.3666207,4.64354545 39.7521839,4.24381818 39.7521839,3.75372727 C39.7521839,3.26427273 39.3695632,2.86963636 38.8630805,2.86963636 L38.8630805,2.86963636 Z M39.0833103,3.85481818 L39.3644138,4.24381818 L39.1274483,4.24381818 L38.8744828,3.887 L38.6569195,3.887 L38.6569195,4.24381818 L38.4585747,4.24381818 L38.4585747,3.21272727 L38.9236782,3.21272727 C39.165977,3.21272727 39.3253333,3.33527273 39.3253333,3.54163636 C39.3253333,3.71063636 39.2265747,3.81390909 39.0833103,3.85481818 L39.0833103,3.85481818 Z M38.9156782,3.38963636 L38.6569195,3.38963636 L38.6569195,3.71572727 L38.9156782,3.71572727 C39.0447816,3.71572727 39.1218391,3.65327273 39.1218391,3.55254545 C39.1218391,3.44645455 39.0447816,3.38963636 38.9156782,3.38963636 L38.9156782,3.38963636 Z" id="Fill-8" sketch:type="MSShapeGroup"></path>\n        </g>\n        <path d="M79.9,13.12 C81.7,13.12 82.27,12.09 82.27,11.23 C82.27,8.74 78.27,9.68 78.27,7.97 C78.27,7.25 78.94,6.74 79.83,6.74 C80.58,6.74 81.26,7 81.74,7.58 L82.12,7.16 C81.6,6.57 80.86,6.22 79.86,6.22 C78.65,6.22 77.67,6.91 77.67,8 C77.67,10.33 81.67,9.31 81.67,11.27 C81.67,11.84 81.28,12.6 79.91,12.6 C78.96,12.6 78.26,12.13 77.83,11.63 L77.46,12.06 C77.97,12.68 78.8,13.12 79.9,13.12 L79.9,13.12 Z M86.51,13 L86.51,10.23 L88.44,10.23 C89.71,10.23 90.45,9.33 90.45,8.28 C90.45,7.23 89.72,6.33 88.44,6.33 L85.94,6.33 L85.94,13 L86.51,13 Z M88.38,9.71 L86.51,9.71 L86.51,6.85 L88.38,6.85 C89.26,6.85 89.85,7.44 89.85,8.28 C89.85,9.12 89.26,9.71 88.38,9.71 L88.38,9.71 Z M96.9399999,13.12 C98.8899999,13.12 100.18,11.62 100.18,9.67 C100.18,7.72 98.8899999,6.22 96.9399999,6.22 C94.9799999,6.22 93.6999999,7.72 93.6999999,9.67 C93.6999999,11.62 94.9799999,13.12 96.9399999,13.12 L96.9399999,13.12 Z M96.9399999,12.6 C95.3199999,12.6 94.2999999,11.35 94.2999999,9.67 C94.2999999,7.97 95.3199999,6.74 96.9399999,6.74 C98.5399999,6.74 99.5799999,7.97 99.5799999,9.67 C99.5799999,11.35 98.5399999,12.6 96.9399999,12.6 L96.9399999,12.6 Z M105.88,13 L105.88,6.85 L108.06,6.85 L108.06,6.33 L103.12,6.33 L103.12,6.85 L105.3,6.85 L105.3,13 L105.88,13 Z M115.34,13 L115.34,12.48 L112.11,12.48 L112.11,6.33 L111.54,6.33 L111.54,13 L115.34,13 Z M119.45,13 L119.45,6.33 L118.88,6.33 L118.88,13 L119.45,13 Z M126.54,13.13 C127.59,13.13 128.48,12.68 129.07,12.02 L129.07,9.69 L125.98,9.69 L125.98,10.2 L128.5,10.2 L128.5,11.8 C128.13,12.17 127.43,12.61 126.54,12.61 C124.97,12.61 123.76,11.39 123.76,9.67 C123.76,7.93 124.97,6.74 126.54,6.74 C127.39,6.74 128.15,7.11 128.62,7.67 L129.05,7.36 C128.44,6.66 127.64,6.22 126.54,6.22 C124.67,6.22 123.16,7.61 123.16,9.67 C123.16,11.73 124.67,13.13 126.54,13.13 L126.54,13.13 Z M138.2,13 L138.2,6.33 L137.62,6.33 L137.62,9.31 L133.39,9.31 L133.39,6.33 L132.82,6.33 L132.82,13 L133.39,13 L133.39,9.83 L137.62,9.83 L137.62,13 L138.2,13 Z M144.43,13 L144.43,6.85 L146.61,6.85 L146.61,6.33 L141.67,6.33 L141.67,6.85 L143.85,6.85 L143.85,13 L144.43,13 Z" id="SPOTLIGHT" fill="#FFFFFF" sketch:type="MSShapeGroup"></path>\n    </g>\n</svg>';
},{}],72:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _src = require('./src');

Object.keys(_src).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function get() {
      return _src[key];
    }
  });
});

},{"./src":113}],73:[function(require,module,exports){
module.exports={
  "name": "spotify-ad-formats",
  "version": "8.4.1",
  "description": "Component to render ads in the Spotify desktop client and web player",
  "keywords": [
    "ads",
    "leaderboard",
    "hpto",
    "video",
    "companion",
    "billboard"
  ],
  "author": {
    "name": "CREAM team",
    "email": "cream@spotify.com"
  },
  "contributors": [
    "Brice Lin <blin@spotify.com>",
    "Jason Palmer <jpalmer@spotify.com>",
    "Jo Blake <jblake@spotify.com"
  ],
  "browserify": {
    "transform": [
      [
        "hbsfy",
        {
          "traverse": true
        }
      ],
      [
        "partialify",
        {
          "alsoAllow": "svg"
        }
      ]
    ]
  },
  "license": "UNLICENSED",
  "repository": {
    "type": "git",
    "url": "https://ghe.spotify.net/ads/spotify-ad-formats.git"
  },
  "scripts": {
    "dev": "echo App scripts have been removed. Please see docs/app-development.md for more information. && exit 1",
    "prod": "echo App scripts have been removed. Please see docs/app-development.md for more information. && exit 1",
    "spa": "echo App scripts have been removed. Please see docs/app-development.md for more information. && exit 1",
    "enable": "echo App scripts have been removed. Please see docs/app-development.md for more information. && exit 1"
  },
  "main": "./index.js",
  "bugs": {
    "url": "https://ghe.spotify.net/ads/spotify-ad-formats/issues"
  },
  "publishConfig": {
    "registry": "http://npm-registry.spotify.net"
  },
  "private": true
}
},{}],74:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var spotlightSvg = null;

/**
 * Singleton class definining the global configuration.
 * This is going to be injected by index.js and bootstrap.js (tests).
 *
 * @api public
 */
var config = {
  /**
   * Gets spotlight svg
   *
   * @return spotlight svg file
   */
  getSpotlightSvg: function getSpotlightSvg() {
    return spotlightSvg;
  },


  /**
   * @param {svg} svg - spotlight svg file
   */
  setSpotlightSvg: function setSpotlightSvg(svg) {
    spotlightSvg = svg;
  }
};

exports.default = config;

},{}],75:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _spotifyCosmosApi = require('spotify-cosmos-api');

var _spotifyCosmosApi2 = _interopRequireDefault(_spotifyCosmosApi);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = require('debug')('saf:cosmos-connector');

var sessionId = Date.now();

/**
 * Resource URIs
 */

// Hermes
var AD_CONFIG_ENDPOINT = 'hm://ads/v2/config';
var AD_SLOT_ENDPOINT = 'hm://ads/v1/ads';
var LASERTAG_ENDPOINT = 'hm://lasertag/v1/adtag?alt=json';
var PREVIEW_URI = 'hm://asp/v2/preview/{adId}';
var SPONSORED_URI = 'hm://sponsoredplaylist/v1/sponsored';

// Core
var SLOT_URI = 'sp://ads/v1/slots';
var FORMAT_URI = 'sp://ads/v1/formats/';
var TARGETING_URI = 'sp://ads/v1/targeting';
var STREAMTIME_URI = 'sp://ads/v1/testing/playtime';
var EVENT_URI = 'sp://ads/v1/events/{eventType}/{adId}';
var SETTINGS_URI = 'sp://ads/v1/settings';
var LOG_URI = 'sp://logging/v1/log';
var ABBA_FLAG_URI = 'sp://abba/v1/flags';
var REQ_HEADER_URI = SETTINGS_URI + '/request_header';

// Desktop
var CRASH_DATA_URI = 'sp://crash-data/v1/value';

var FORMATS = ['audio', 'video', 'banner'];
var JSON_HEADER = { 'Content-Type': 'application/json' };

// These can get overridden by debugging-utils.
var adSlotEndpoint = AD_SLOT_ENDPOINT;
var sponsoredUri = SPONSORED_URI;

/**
 * Resolve a Cosmos request.
 *
 * @api private
 * @param {Cosmos.Request} request Request to resolve.
 * @return {Promise}
 */

function handleResolve(request) {
  return new Promise(function (resolve, reject) {
    _spotifyCosmosApi2.default.resolver.resolve(request, function (err, res) {
      debug('resolve req=%o, err=%o, res=%o', request, err, res);
      if (err) reject(new Error(err));else resolve(res);
    });
  });
}

/**
 * Resolve a cosmos request, and return the JSON result.
 *
 * NOTE: This won't work with SUB requests since the promise will only
 * execute once.
 *
 * @api private
 * @param {Cosmos.Request} request Request to resolve.
 * @return {Promise}
 */

function resolveJSON(request) {
  return handleResolve(request).then(function (res) {
    return res.getJSONBody();
  });
}

/**
 * Fetch targeting data from Ads Resolver via Cosmos.
 *
 * @api public
 * @return {Promise}
 */
function getTargeting() {
  return new Promise(function (resolve, reject) {
    var req = new _spotifyCosmosApi2.default.Request('GET', TARGETING_URI, {});

    _spotifyCosmosApi2.default.resolver.resolve(req, function (err, res) {
      if (err) reject(new Error(err));else resolve(res.getJSONBody());
    });
  });
}

/**
 * Subscribe to a format.
 *
 * @api public
 * @param {String} formatType - E.g "banner"
 * @param {Function} callback
 * @return {Promise}
 */
function subscribeToFormat(formatType, callback) {
  var request = new _spotifyCosmosApi2.default.Request('SUB', FORMAT_URI + formatType, {});
  _spotifyCosmosApi2.default.resolver.resolve(request, function (err, res) {
    if (!err) callback(res.getJSONBody());
  });
}

/**
 * Get the configuration for a given slot.
 *
 * @param {string} slot Name of the slot to get the configuration for.
 * @return {Promise}
 */

function getSlotConfigurations(slot) {
  return handleResolve(new _spotifyCosmosApi2.default.Request('GET', SETTINGS_URI + '/' + slot, JSON_HEADER, {}));
}

/**
 * @api private
 * Trigger an action on a given slot.
 */
function triggerSlot(slot, type) {
  return resolveJSON(new _spotifyCosmosApi2.default.Request('POST', SLOT_URI + '/' + slot + '/' + type, {}));
}

/**
 * Singleton util for making cosmos requests in SAF context.
 *
 * @api public
 * @return {void} Constructor
 */
exports.default = {
  getTargeting: getTargeting,
  subscribeToFormat: subscribeToFormat,
  getSlotConfigurations: getSlotConfigurations,

  /**
   * Fetch all local targeting, including UI-specific properties such as
   * client width/height.  The returned promise is guaranteed to resolve successfully.
   *
   * @api public
   * @return {Promise}
   */
  getLocalTargeting: function getLocalTargeting() {
    return getTargeting().catch(function (e) {
      debug('error retrieving targeting: %o', e);
      return {};
    }).then(function (targeting) {
      return Object.assign(targeting, {
        client_width: document.body.clientWidth,
        client_height: document.body.clientHeight
      });
    });
  },


  /**
   * Fetch targeting data from Hermes Resolver via Cosmos.
   *
   * @api public
   * @return {Promise}
   */
  getTargetingFromLasertag: function getTargetingFromLasertag() {
    return resolveJSON(new _spotifyCosmosApi2.default.Request('GET', LASERTAG_ENDPOINT, {}));
  },


  /**
   * Fetch ad slot config from Spotify Ad Service
   * @api public
   * @param {String} slot The slot id (e.g. leaderboard)
   * @return {Promise<Response>} where Response has the shape:
   *   {
   *      "config_ttl_ms": 300000,
   *      "request_when": {
   *         "focus_time_elapsed_ms": number
   *      },
   *      "iframe_sandboxed_attrs": arrayOf(string)
   *      "app_blacklist": arrayOf(string)   // blacklisted app ids
   *      "app_whitelist": arrayOf(string)   // whitelisted app ids
   *   }
   */
  getAdSlotConfig: function getAdSlotConfig(slot) {
    return resolveJSON(new _spotifyCosmosApi2.default.Request('GET', AD_CONFIG_ENDPOINT, {})).then(function (response) {
      return response[slot];
    });
  },


  /**
   * Fetch an ad from Spotify Ad Service
   * @api public
   * @param {String} slot The slot id (e.g. leaderboard)
   * @param {Object} [flags] Optional map of flag values
   * @return {Promise<Response>} where Response has the shape:
   *   {
   *      "pod": {
   *        "leaderboard": [{
   *          "type": oneOf("text/html"),
   *          "html": string  // html to inject into the iframe
   *        }]
   *      }]
   *   }
   */
  getAdForSlot: function getAdForSlot(targeting, slot, flags) {
    debug('fetch ad for slot=%o, localTargeting=%o', slot, targeting, adSlotEndpoint);
    var endpoint = adSlotEndpoint !== AD_SLOT_ENDPOINT ? adSlotEndpoint : adSlotEndpoint + '/' + slot;
    var req = new _spotifyCosmosApi2.default.Request('GET', endpoint, {}, {
      targeting: targeting,
      pod: {},
      session_id: sessionId,
      overrides: flags || {}
    });
    return resolveJSON(req).then(function (res) {
      if (!res.pod) {
        throw new Error('pod-not-defined');
      }
      if (!res.pod[slot]) {
        throw new Error('slot-not-defined');
      }
      if (res.pod[slot].length === 0) {
        throw new Error('no-ads');
      }
      return res.pod[slot][0];
    });
  },


  /*
   * Fetch preview ad from ASP.
   *
   * @api public
   * @param {String} preview ad id (gid)
   * @return {Promise}
   */

  getPreviewAd: function getPreviewAd(adId) {
    return resolveJSON(new _spotifyCosmosApi2.default.Request('GET', PREVIEW_URI.replace('{adId}', adId), {}));
  },


  /**
   * Patch targeting by key to value.
   *
   * @api public
   * @param {String|Number} key
   * @param {Object} value (NOTE: this value is not stringified before being sent)
   * @return {Promise}
   */

  patchTargeting: function patchTargeting(key, value) {
    return new Promise(function (resolve, reject) {
      var putTargetingRequest = new _spotifyCosmosApi2.default.Request('PUT', TARGETING_URI + '/' + key, { 'Content-Type': 'application/json' }, {
        value: value
      });

      _spotifyCosmosApi2.default.resolver.resolve(putTargetingRequest, function (err) {
        debug('patchTargeting key=%o val=%o req=%o err=%o', key, value, putTargetingRequest, err);
        if (err) reject(new Error(err));else resolve(true);
      });
    });
  },


  /**
   * Set crash data information in the Desktop app, which will be visible in crash reporting.
   * This is useful for tracking information about resource-heavy ads that might crash CEF.
   *
   * @api public
   * @param {String} key
   * @param {String} value
   * @return {Promise} resolving when the cosmos operation has succeeded.
   */
  putCrashData: function putCrashData(key, value) {
    var putRequest = new _spotifyCosmosApi2.default.Request('PUT', CRASH_DATA_URI + '/' + key, { 'Content-Type': 'application/json' }, String(value));
    return new Promise(function (resolve, reject) {
      _spotifyCosmosApi2.default.resolver.resolve(putRequest, function (err) {
        if (err) reject(new Error(err));else resolve(true);
      });
    });
  },


  /**
   * Increment stream time to receive the next ad break (audio/video).
   *
   * @api public
   * @param {Number} increment in seconds
   * @return {Promise}
   */
  increaseStreamTime: function increaseStreamTime(increment) {
    return new Promise(function (resolve, reject) {
      var streamTimeIncreaseRequest = new _spotifyCosmosApi2.default.Request('POST', STREAMTIME_URI, { 'Content-Type': 'application/json' }, {
        value: increment
      });

      _spotifyCosmosApi2.default.resolver.resolve(streamTimeIncreaseRequest, function (err) {
        debug('increaseStreamTime inc=%o err=%o', increment, err);
        if (err) reject(new Error(err));else resolve(true);
      });
    });
  },


  /**
   * Adds a new adslot to a spotlet by ad type
   *
   * @api public
   * @param {String} slotId - E.g. "stream"
   * @param {String} format - E.g. "video"
   * @return {Promise}
   */
  addNewSlot: function addNewSlot(slotId, format) {
    return new Promise(function (resolve, reject) {
      var createSlotRequest = new _spotifyCosmosApi2.default.Request('PUT', SLOT_URI + '/' + slotId, { 'Content-Type': 'application/json' }, { formats: [format] });

      _spotifyCosmosApi2.default.resolver.resolve(createSlotRequest, function (err) {
        debug('addNewSlot slotId=%o format=%o err=%o', slotId, format, err);
        if (err) reject('addNewSlot error: ', new Error(err));else resolve(SLOT_URI + '/' + slotId + '/' + format);
      });
    });
  },


  /**
   * Subscribe to an adslot at `uri'
   *
   * @api public
   * @param {String} slotUri - E.g "sp://ads/v1/slots/stream/video"
   * @param {Function} callback
   * @return {void}
   */
  subscribeToSlot: function subscribeToSlot(slotUri, callback) {
    var request = new _spotifyCosmosApi2.default.Request('SUB', slotUri, {});
    _spotifyCosmosApi2.default.resolver.resolve(request, function (err, res) {
      debug('slot updated uri=%o err=%o res=%o', slotUri, err, res);
      if (!err) callback(res.getJSONBody());
    });
  },


  /**
   * Subscribe to an adslot type. E.g "sp://ads/v1/slots/preview"
   *
   * @api public
   * @param {String} slotType - E.g "preview"
   * @param {Function} callback
   * @return {Promise}
   */
  subscribeToSlotType: function subscribeToSlotType(slotType, callback) {
    var request = new _spotifyCosmosApi2.default.Request('SUB', SLOT_URI + '/' + slotType, {});
    _spotifyCosmosApi2.default.resolver.resolve(request, function (err, res) {
      debug('slot updated type=%o err=%o res=%o', slotType, err, res);
      if (!err) callback(res.getJSONBody());
    });
  },
  subscribeToAllFormats: function subscribeToAllFormats(callback) {
    FORMATS.map(function (format) {
      subscribeToFormat(format, function (ev) {
        callback(format, ev);
      });
    });
  },


  /**
   * POST ad event.
   *
   * @api public
   * @param {String} adId
   * @param {String} eventType - https://ghe.spotify.net/pages/ads/client-core/api/#submit-event
   * @param {Object} payload
   * @return {Promise}
   */
  postEvent: function postEvent(adId, eventType, payload) {
    var eventURI = EVENT_URI.replace('{adId}', adId).replace('{eventType}', eventType);

    var eventData = payload ? payload.event_data : false;
    if (eventData) {
      var invalidEventData = Object.keys(eventData).some(function (key) {
        return typeof eventData[key] !== 'string';
      });
      if (invalidEventData) {
        return Promise.reject(new TypeError('Invalid Payload. All event_data values need to be strings'));
      }
    }

    return new Promise(function (resolve, reject) {
      var postEventRequest = new _spotifyCosmosApi2.default.Request('POST', eventURI, {
        'Content-Type': 'application/json'
      }, payload || {});

      _spotifyCosmosApi2.default.resolver.resolve(postEventRequest, function (err, res) {
        debug('posted event type=%o adId=%o req=%o err=%o res=%o', eventType, adId, postEventRequest, err, res);
        if (err) {
          var msg = res ? res.getJSONBody().error : 'unknown';
          reject(new Error('postEvent error: ' + msg));
        } else {
          resolve(res);
        }
      });
    });
  },


  /**
   * POST to ad slot
   *
   * @api public
   * @param {String} slotId
   * @param {String} intent
   * @params {Object} payload
   * @return {Promise}
   */
  postToSlot: function postToSlot(slotId, intent, payload) {
    var slotURI = SLOT_URI + '/' + slotId + '/' + intent;
    return new Promise(function (resolve, reject) {
      var postSlotIdRequest = new _spotifyCosmosApi2.default.Request('POST', slotURI, {
        'Content-Type': 'application/json'
      }, payload || {});

      _spotifyCosmosApi2.default.resolver.resolve(postSlotIdRequest, function (err, res) {
        debug('posted to slot id=%o req=%o err=%o res=%o', slotId, postSlotIdRequest, err, res);
        if (err) reject(new Error(err));else resolve(res);
      });
    });
  },


  /**
   * Get a specific configuration for a given slot.
   *
   * @param {String} slot Name of the slot.
   * @param {String} key Name of the configuration.
   * @return {Promise} Promise that get's resolved with the result.
   */
  getSlotConfiguration: function getSlotConfiguration(slot, key) {
    return getSlotConfigurations(slot).then(function (response) {
      var result = void 0;
      response.getJSONBody().settings.forEach(function (setting) {
        if (setting.id === slot) {
          result = setting[key];
        }
      });
      return result;
    });
  },


  /**
   * Configure an ad slot.
   *
   * @api public
   * @param {string} slot Name of the slot to configure.
   * @param {string} key Name of the key to configure.
   * @param {string} value New value of the key.
   * @return {Promise}
   */

  configureSlot: function configureSlot(slot, key, value) {
    return handleResolve(new _spotifyCosmosApi2.default.Request('PUT', SETTINGS_URI + '/' + slot + '/' + key, JSON_HEADER, { value: value }));
  },


  /**
   * Force enable a slot
   * e.g. HPTO which should be enabled for all users (free and premium)
   * @api public
   * @param {string} slot Name of the slot to enable
   * @return {Promise}
   */
  enableSlot: function enableSlot(slot) {
    return handleResolve(new _spotifyCosmosApi2.default.Request('PUT', SETTINGS_URI + '/' + slot + '/slot_enabled', JSON_HEADER, { value: true }));
  },
  logMessage: function logMessage(body) {
    return handleResolve(new _spotifyCosmosApi2.default.Request('POST', LOG_URI, JSON_HEADER, body));
  },


  /**
   * Get list of sponsored uris from Sponsored Playlist service
   *
   * @api public
   * @return {Promise}
   */

  getSponsoredUris: function getSponsoredUris() {
    return resolveJSON(new _spotifyCosmosApi2.default.Request('GET', SPONSORED_URI, {}));
  },


  /**
   * Get sponsorship ad from Sponsored Playlist service
   *
   * @api public
   * @param {String} playlistUri - playlist uri
   * @return {Promise}
   */

  getSponsorshipAd: function getSponsorshipAd(playlistUri) {
    var uri = sponsoredUri !== SPONSORED_URI ? sponsoredUri : SPONSORED_URI + '/' + playlistUri;
    debug('getSponsorshipAd', uri);
    return resolveJSON(new _spotifyCosmosApi2.default.Request('GET', uri, {}));
  },
  subToState: function subToState(cb) {
    var req = new _spotifyCosmosApi2.default.Request('SUB', 'sp://ads/v1/state', {});

    _spotifyCosmosApi2.default.resolver.resolve(req, function (err, res) {
      debug('state update err=%o, res=%o', err, res);
      if (!err) cb(res.getJSONBody());
    });
  },
  getState: function getState() {
    return resolveJSON(new _spotifyCosmosApi2.default.Request('GET', 'sp://ads/v1/state', {}));
  },


  /**
   * Fetch feature flags from ABBA
   *
   * @api public
   * @param {Array} flags - array of flags to fetch
   * @return {Promise}
   */

  getFeatureFlags: function getFeatureFlags(flags) {
    return resolveJSON(new _spotifyCosmosApi2.default.Request('POST', ABBA_FLAG_URI, JSON_HEADER, { flags: flags }));
  },


  /**
   * For TA tests, so we can capture requests to the AD_SLOT_ENDPOINT
   * @param {String} endpoint
   */
  setAdSlotEndpoint: function setAdSlotEndpoint(endpoint) {
    adSlotEndpoint = endpoint;
    debug('setAdSlotEndpoint', endpoint);
  },


  /**
   * For TA tests, so we can capture requests to the SPONSORED_URI
   * @param {String} endpoint
   */
  setSponsoredUri: function setSponsoredUri(endpoint) {
    sponsoredUri = endpoint;
    debug('setSponsoredUri', endpoint);
  },


  /**
   * Trigger a fetch action on a given slot, which will cause ads to be fetched and
   * inserted onto the slot.
   *
   * @param {String} slot The slot to fetch on.
   */
  triggerSlotFetch: function triggerSlotFetch(slot) {
    return triggerSlot(slot, 'fetch');
  },


  /**
   * Trigger a play action on a given slot, which will cause the next ad on the slot
   * to be made active and trigger a play event on slot/format subscribers.
   *
   * @param {String} slot The slot to fetch on.
   */
  triggerSlotPlay: function triggerSlotPlay(slot) {
    return triggerSlot(slot, 'now');
  },


  /**
   * Trigger a clear action on a given slot, which will remove all the ads from the
   * slot and emit discard slot events.
   *
   * @param {String} slot The slot to clear.
   */
  triggerSlotClear: function triggerSlotClear(slot) {
    return triggerSlot(slot, 'clear');
  },


  /**
   * Creates or updates a request header used by the Lasertag service.
   * @param {String} field
   * @param {String} value
   * @param {Boolean} refreshInventory
   */
  setRequestHeader: function setRequestHeader(field, value, refreshInventory) {
    return handleResolve(new _spotifyCosmosApi2.default.Request('PUT', REQ_HEADER_URI + '/' + field, JSON_HEADER, {
      value: value,
      refresh_inventory: refreshInventory
    }));
  },


  /**
   * Removes a request header used by the Lasertag service.
   * @param {String} field
   * @param {Boolean} refreshInventory
   */
  removeRequestHeader: function removeRequestHeader(field, refreshInventory) {
    return handleResolve(new _spotifyCosmosApi2.default.Request('DELETE', REQ_HEADER_URI + '/' + field, JSON_HEADER, {
      refresh_inventory: refreshInventory
    }));
  }
};

},{"debug":582,"spotify-cosmos-api":890}],76:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';

/**
 * Renders a pie chart like count down timer using SVG.
 *
 * Typical use case:
 *
 * var container = document.getElementById('animation-container');
 * var animation = new CountDownAnimation(container, 2000);
 * ...
 * animation.start(); // start the count down
 *
 * @param {Element} container - Container to render the count down in.
 * @param {Number} duration - Animation duration in ms.
 */

var CountDownAnimation = function () {
  function CountDownAnimation(container, duration) {
    _classCallCheck(this, CountDownAnimation);

    this._container = container;
    this._duration = duration;
    this._started = 0;
    this._remaining = 1.0;
    this._animate = this._animate.bind(this);
    this._setupDomNodes();
    this._draw(); // Render first frame
  }

  /**
   * Start the animation.
   *
   * @public
   */

  _createClass(CountDownAnimation, [{
    key: 'start',
    value: function start() {
      this._started = new Date().getTime();
      this._animate();
    }

    /**
     * Create the dom nodes needed for the animation.
     *
     * @private
     */

  }, {
    key: '_setupDomNodes',
    value: function _setupDomNodes() {
      this._svg = document.createElementNS(SVG_NAMESPACE, 'svg');
      this._svg.setAttribute('id', 'countdown');
      this._svg.setAttribute('width', '20');
      this._svg.setAttribute('height', '20');

      this._circle = document.createElementNS(SVG_NAMESPACE, 'circle');
      this._circle.setAttribute('cx', '10');
      this._circle.setAttribute('cy', '10');
      this._circle.setAttribute('r', '5');
      this._circle.setAttribute('fill', 'none');
      this._circle.setAttribute('stroke', '#dfe0e6');
      this._circle.setAttribute('stroke-width', '10');
      this._circle.setAttribute('stroke-dasharray', '0 31.4159 31.4159 0');
      this._circle.setAttribute('stroke-dashoffset', '0');
      this._circle.setAttribute('transform', 'rotate(-90 10 10)');

      this._svg.appendChild(this._circle);
      this._container.appendChild(this._svg);
    }

    /**
     * Draw the current state of the animation.
     *
     * @private
     */

  }, {
    key: '_draw',
    value: function _draw() {
      var offset = Math.max(this._remaining, 0) * Math.PI * 10;
      this._circle.setAttribute('stroke-dashoffset', offset);
    }

    /**
     * Start animating the count down timer.
     *
     * @private
     */

  }, {
    key: '_animate',
    value: function _animate() {
      var elapsed = new Date().getTime() - this._started;
      this._remaining = 1 - elapsed / this._duration;
      this._draw();
      if (this._remaining > 0) {
        requestAnimationFrame(this._animate);
      }
    }
  }]);

  return CountDownAnimation;
}();

exports.default = CountDownAnimation;

},{}],77:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _spotifyEventDispatcher = require('../../spotify-event-dispatcher');

var _spotifyEventDispatcher2 = _interopRequireDefault(_spotifyEventDispatcher);

var _cosmosConnector = require('./cosmos-connector');

var _cosmosConnector2 = _interopRequireDefault(_cosmosConnector);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _provider = require('./formats/hpto-ad/provider');

var _provider2 = _interopRequireDefault(_provider);

var _eventTypes = require('../../event-types');

var _eventTypes2 = _interopRequireDefault(_eventTypes);

var _billboardAd = require('./formats/billboard-ad');

var _billboardAd2 = _interopRequireDefault(_billboardAd);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = (0, _debug2.default)('saf:debug');

/**
 * Overrides a targeting attribute for debugging purpose
 *
 * E.g.
 *   patchTargeting('aduserid', 1111);
 *
 * @api protected
 * @param {String} key targeting key.
 * @param {String} value targeting value.
 */

function patchTargeting(key, value) {
  return _cosmosConnector2.default.patchTargeting(key, value);
}

/**
 * Override an aduserid (ppid) for ads targeting and frequency capping,
 * and refresh any display ad units that may be affected by user-level
 * targeting.
 */
function setAdUserId(value) {
  return patchTargeting('aduserid', value).then(function () {
    refreshHPTO();
    refreshLeaderboard();
  });
}

/**
 * Refreshes all active leaderboards
 */

function refreshLeaderboard() {
  _spotifyEventDispatcher2.default.dispatchEvent({
    'type': _eventTypes2.default.DEBUG_FORCE_REFRESH_LEADERBOARD,
    'params': {},
    'extra': {}
  });
}

/**
 * Refreshes all active hpto
 */

function refreshHPTO() {
  _spotifyEventDispatcher2.default.dispatchEvent({
    'type': _eventTypes2.default.DEBUG_FORCE_REFRESH_HPTO,
    'params': {},
    'extra': {}
  });
}

/**
 * Sets timeout for billboard
 */

function setBillboardTimeout(seconds) {
  _spotifyEventDispatcher2.default.dispatchEvent({
    'type': _eventTypes2.default.DEBUG_SET_BILLBOARD_TIMEOUT,
    'params': {
      timeout: seconds * 1000
    },
    'extra': {}
  });
}

/**
 * Sets timeout for billboard
 */

function triggerBillboard() {
  _spotifyEventDispatcher2.default.dispatchEvent({
    'type': _eventTypes2.default.DEBUG_FORCE_REFRESH_BILLBOARD,
    'params': {},
    'extra': {}
  });
}
/**
 * Trigger a video Billboard
 */

function triggerVideoBillboard() {
  var videoBillboardAdUser = 'betamaxbillboard';
  return patchTargeting('aduserid', videoBillboardAdUser).then(triggerBillboard);
}

/**
 * Increases user stream time
 */

function increaseStreamTime(seconds) {
  return _cosmosConnector2.default.increaseStreamTime(seconds);
}

/**
 * Retreive the ad server endpoint from core
 *
 * @param {string} slot The ad slot to get endpoint for
 * @return {Promise}
 */

function getAdServerEndpoint(slot) {
  return new Promise(function (resolve, reject) {
    var key = 'ad_server_endpoint';

    _cosmosConnector2.default.getSlotConfigurations(slot).then(function (res) {
      if (res.getStatusCode() === 200) {
        var endpoint = res.getJSONBody().settings[0][key];
        resolve(endpoint);
      } else {
        reject('Unable to get slot settings for slot ' + slot);
      }
    });
  });
}

/**
 * Tell core to request ads from ad mocker and not from DFP for a given ad slot.
 *
 * Endpoint should look like "http://foo.bar.net?foo=baz"
 *
 * @api public
 * @param {string} slot The ad slot to use ad mocker for.
 * @param {string} endpoint The endpoint to fetch ads from for the given slot.
 * @return {Promise}
 */

function overrideAdServerEndpoint(slot, endpoint) {
  return new Promise(function (resolve, reject) {
    var key = 'ad_server_endpoint';

    _cosmosConnector2.default.configureSlot(slot, key, endpoint).then(function (res) {
      if (res.getStatusCode() === 200) {
        resolve();
      } else {
        reject('Unable to set slot settings for slot ' + slot);
      }
    });
  });
}

/**
 * Override the 'ads/v1/' endpoint used in the cosmos-connector
 *
 * @api public
 * @param {string} endpoint The endpoint to fetch ads.
 * @return {Promise}
 */

function overrideAdSlotEndpoint(endpoint) {
  _cosmosConnector2.default.setAdSlotEndpoint(endpoint);
}

/**
 * Override the sponsored playlist endpoint used in the cosmos-connector
 *
 * @api public
 * @param {string} endpoint The endpoint to fetch ads.
 * @return {Promise}
 */

function overrideSponsoredPlaylistEndpoint(endpoint) {
  _cosmosConnector2.default.setSponsoredUri(endpoint);
}

/**
 * Tell core to request ads from ad mocker and not from DFP for a given ad slot.
 *
 * Endpoint should look like "http://foo.bar.net"
 *
 * @api public
 * @param {string} slot The ad slot to use ad mocker for.
 * @param {string} endpoint The endpoint to fetch ads from for the given slot.
 * @param {string} sessionId The test automation session id.
 * @return {Promise}
 */

function setAdServerEndpoint(slot, endpoint, sessionId) {
  return new Promise(function (resolve, reject) {
    var key = 'ad_server_endpoint';

    _cosmosConnector2.default.getSlotConfigurations(slot).then(function (resp) {
      if (resp.getStatusCode() === 200) {
        var updated = resp.getJSONBody().settings[0][key].replace('https://pubads.g.doubleclick.net', endpoint);
        updated += '&session_id=' + sessionId;

        _cosmosConnector2.default.configureSlot(slot, key, updated).then(function (res) {
          if (res.getStatusCode() === 200) {
            resolve();
          } else {
            reject('Unable to set slot settings for slot ' + slot);
          }
        });
      } else {
        reject('Unable to set slot settings for slot ' + slot);
      }
    });
  });
}

function getAdSlotConfigurations(slot, cb) {
  _cosmosConnector2.default.getSlotConfigurations(slot).then(function (res) {
    if (res.getStatusCode() === 200) {
      (cb || function () {
        debug('config for slot=%o, res=%o', slot, res);
      })(res.getJSONBody());
    } else {
      throw new Error('bad status code from slot config: ' + res.getStatusCode());
    }
  });
}

function setRequestHeader(field, value, refreshInventory) {
  _cosmosConnector2.default.setRequestHeader(field, value, refreshInventory).then(function (res) {
    if (res.getStatusCode() === 200) {
      debug('setRequestHeader: success');
    } else {
      debug('setRequestHeader: bad status code', res.getStatusCode());
    }
  }).catch(function (err) {
    console.error('setRequestHeader: error:', err.message);
  });
}

function removeRequestHeader(field, refreshInventory) {
  _cosmosConnector2.default.removeRequestHeader(field, refreshInventory).then(function (res) {
    if (res.getStatusCode() === 200) {
      debug('removeRequestHeader: success');
    } else {
      debug('removeRequestHeader: bad status code', res.getStatusCode());
    }
  }).catch(function (err) {
    console.error('removeRequestHeader: error:', err.message);
  });
}

/**
 * Get the spotify ad format version
 *
 * @return {String}
 */

function getVersion() {
  return require('../package.json').version;
}

/**
 * Clear an ad slot in core
 *
 * @param {String} slot The name of the slot to clear.
 * @return {Promise}
 */

function clearSlot(slot) {
  return _cosmosConnector2.default.postToSlot(slot, 'clear');
}

function configureSlot(slot, k, v) {
  return _cosmosConnector2.default.configureSlot(slot, k, v);
}

function subToState(cb) {
  return _cosmosConnector2.default.subToState(function (res) {
    if (cb) {
      cb(res);
    } else {
      debug('ads state updated: %o', res.state);
    }
  });
}

function subToFormats(cb) {
  return _cosmosConnector2.default.subscribeToAllFormats(function (fmt, ev) {
    (cb || function () {
      debug('event for format %o: %o', fmt, ev);
    })(fmt, ev);
  });
}

function getState(cb) {
  return _cosmosConnector2.default.getState().then(function (res) {
    if (cb) {
      cb(res);
    } else {
      debug('ads state: %o', res.state);
    }
  });
}

function setAdLeaderboardHtml(html) {
  _spotifyEventDispatcher2.default.dispatchEvent({
    'type': _eventTypes2.default.DEBUG_OVERRIDE_AD_LEADERBOARD_HTML,
    'params': {
      html: html
    },
    'extra': {}
  });
}

function setLeaderboardAdSlotFlags(flags) {
  _spotifyEventDispatcher2.default.dispatchEvent({
    type: _eventTypes2.default.DEBUG_OVERRIDE_AD_LEADERBOARD_FLAGS,
    params: {
      flags: flags
    }
  });
}

function setLeaderboardRefreshIntervalMs(ms) {
  _spotifyEventDispatcher2.default.dispatchEvent({
    type: _eventTypes2.default.DEBUG_OVERRIDE_AD_LEADERBOARD_REFRESH_INTERVAL,
    params: {
      interval: ms
    }
  });
}

function disableLeaderboardRefreshOnNavigateOrRefocus() {
  _spotifyEventDispatcher2.default.dispatchEvent({
    type: _eventTypes2.default.DEBUG_DISABLE_AD_LEADERBOARD_REFRESH_ON_NAVIGATE_OR_REFOCUS
  });
}

function enableLeaderboardRefreshOnNavigateOrRefocus() {
  _spotifyEventDispatcher2.default.dispatchEvent({
    type: _eventTypes2.default.DEBUG_ENABLE_AD_LEADERBOARD_REFRESH_ON_NAVIGATE_OR_REFOCUS
  });
}

function iabBillboardOn() {
  setLeaderboardAdSlotFlags({ iabBillboard: true });
}

function iabBillboardOff() {
  setLeaderboardAdSlotFlags({ iabBillboard: false });
}

var receivedAdLeaderboardHtml = '';
_spotifyEventDispatcher2.default.addEventListener(_eventTypes2.default.DEBUG_RECEIVED_AD_LEADERBOARD_HTML, function (e) {
  receivedAdLeaderboardHtml = e.params.html;
});

function getReceivedAdLeaderboardHtml() {
  return receivedAdLeaderboardHtml;
}

function debugOn(type) {
  var val = 'saf:' + (type || '*');
  _debug2.default.enable(val);
}

function clearHptoCache() {
  _provider2.default.clearLocalStorageAd();
}

exports.default = {
  patchTargeting: patchTargeting,
  refreshLeaderboard: refreshLeaderboard,
  refreshHPTO: refreshHPTO,
  setBillboardTimeout: setBillboardTimeout,
  triggerBillboard: triggerBillboard,
  triggerVideoBillboard: triggerVideoBillboard,
  increaseStreamTime: increaseStreamTime,
  getAdServerEndpoint: getAdServerEndpoint,
  overrideAdServerEndpoint: overrideAdServerEndpoint,
  overrideAdSlotEndpoint: overrideAdSlotEndpoint,
  overrideSponsoredPlaylistEndpoint: overrideSponsoredPlaylistEndpoint,
  setAdServerEndpoint: setAdServerEndpoint,
  getVersion: getVersion,
  clearSlot: clearSlot,
  subToState: subToState,
  subToFormats: subToFormats,
  getState: getState,
  configureSlot: configureSlot,
  debug: debug,
  BillboardAd: _billboardAd2.default,
  setAdUserId: setAdUserId,
  setAdLeaderboardHtml: setAdLeaderboardHtml,
  getReceivedAdLeaderboardHtml: getReceivedAdLeaderboardHtml,
  getAdSlotConfigurations: getAdSlotConfigurations,
  setLeaderboardAdSlotFlags: setLeaderboardAdSlotFlags,
  iabBillboardOn: iabBillboardOn,
  iabBillboardOff: iabBillboardOff,
  setLeaderboardRefreshIntervalMs: setLeaderboardRefreshIntervalMs,
  disableLeaderboardRefreshOnNavigateOrRefocus: disableLeaderboardRefreshOnNavigateOrRefocus,
  enableLeaderboardRefreshOnNavigateOrRefocus: enableLeaderboardRefreshOnNavigateOrRefocus,
  debugOn: debugOn,
  clearHptoCache: clearHptoCache,
  setRequestHeader: setRequestHeader,
  removeRequestHeader: removeRequestHeader
};

},{"../../event-types":125,"../../spotify-event-dispatcher":234,"../package.json":73,"./cosmos-connector":75,"./formats/billboard-ad":84,"./formats/hpto-ad/provider":98,"debug":582}],78:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = require('../utils');

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * DFP Request Network ID
 */

var NETWORK_ID = 6465052;

var TEMPLATES = {
  gpt: require('./templates/gpt.hbs')
};

/*
 * Returns template based on name
 *
 * @param {String} name
 * @return {hbs}
 */
function template(name) {
  return TEMPLATES[name];
}

/**
 * Create dfp inventory unit from device/product data
 * @param {String} platform
 * @param {Boolean} isPremium
 * @return {String} inventory unit
 */
function inventoryUnit(platform, isPremium) {
  var unit = isPremium ? 'premium-' + platform : platform;

  return '/' + NETWORK_ID + '/' + unit;
}

function parseHptoHtml(iframeDoc) {
  var tplSpans = iframeDoc.body.getElementsByTagName('span');
  var jsonContent = null;
  var html = '';

  for (var i = 0, len = tplSpans.length; i < len; i++) {
    var templateName = tplSpans[i].getAttribute('data-template');

    if (templateName === 'hpto-json') {
      try {
        jsonContent = JSON.parse(tplSpans[i].innerHTML);
      } catch (e) {
        return null;
      }
    } else if (templateName === 'hpto-html') {
      html = tplSpans[i].innerHTML;
    }
  }

  if (!jsonContent) {
    return null;
  }

  jsonContent.hpto.html = html;

  return jsonContent;
}

/**
 * @param {Object} data
 * @param {String} data.inventoryType
 * @param {String} data.width
 * @param {String} data.height
 * @param {String} data.inventoryUnit
 * @param {String} data.targetingData
 * @param {String} data.ppid
 * @return {String} compiled html
 */
function renderGPT(data) {
  var dfpSlotId = data.inventoryType + '-' + new Date().getTime();
  return TEMPLATES.gpt({
    slotId: dfpSlotId,
    width: data.width,
    height: data.height,
    inventoryUnit: data.inventoryUnit,
    targetingParameters: data.targetingData,
    ppid: data.ppid
  });
}

function fetchHptoAd(domEl, targetingData) {
  return new Promise(function (resolve, reject) {
    var iframe = _utils2.default.createSandboxedIframe();
    iframe.style.display = 'none';

    domEl.appendChild(iframe);

    var iframeDoc = iframe.contentDocument;

    iframeDoc.open();
    iframeDoc.write(renderGPT(targetingData));
    iframeDoc.close();

    iframeDoc.addEventListener('placementReady', function () {
      var hptoData = parseHptoHtml(iframeDoc);
      iframe.parentNode.removeChild(iframe);
      resolve(hptoData);
    });

    iframeDoc.addEventListener('eventEmpty', function () {
      reject(new Error('[HPTO dfp] Returned empty event'));
    });
  });
}

exports.default = {
  NETWORK_ID: NETWORK_ID,
  template: template,
  inventoryUnit: inventoryUnit,
  renderGPT: renderGPT,
  parseHptoHtml: parseHptoHtml,
  fetchHptoAd: fetchHptoAd
};

},{"../utils":120,"./templates/gpt.hbs":79}],79:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n          .setTargeting(\"";
  stack1 = ((stack1 = (data == null || data === false ? data : data.key)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\",\"";
  stack1 = (typeof depth0 === functionType ? depth0.apply(depth0) : depth0);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\")\n        ";
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n              '";
  stack1 = ((stack1 = (data == null || data === false ? data : data.key)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "': '";
  stack1 = (typeof depth0 === functionType ? depth0.apply(depth0) : depth0);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "',\n              ";
  return buffer;
  }

  buffer += "<html>\n  <head>\n    <script type=\"text/javascript\">\n      var googletag = googletag || {};\n      googletag.cmd = googletag.cmd || [];\n\n      (function() {\n        var useSSL = true;\n        var src = (useSSL ? 'https:' : 'http:') +\n                  '//www.googletagservices.com/tag/js/gpt.js';\n        document.write('<scr' + 'ipt src=\"' + src + '\"></scr' + 'ipt>');\n      })();\n\n      googletag.cmd.push(function() {\n        googletag.defineSlot('";
  if (helper = helpers.inventoryUnit) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.inventoryUnit); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "', [[";
  if (helper = helpers.width) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.width); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + ", ";
  if (helper = helpers.height) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.height); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "]],\n          '";
  if (helper = helpers.slotId) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.slotId); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "')\n          .addService(googletag.pubads().setPublisherProvidedId('";
  if (helper = helpers.ppid) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.ppid); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "'))\n\n        ";
  stack1 = helpers.each.call(depth0, (depth0 && depth0.targetingParameters), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ";\n\n        googletag.pubads().addEventListener(\"slotRenderEnded\", function(event) {\n          var msg = event.isEmpty ? \"eventEmpty\" : \"placementReady\";\n\n          // Attach data to the window for parent impression logging\n          window.slotRenderEndedObj = {\n            creativeId: event.creativeId,\n            lineItemId: event.lineItemId,\n            slot: '";
  if (helper = helpers.slotId) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.slotId); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "',\n            targetingParams: {\n              ";
  stack1 = helpers.each.call(depth0, (depth0 && depth0.targetingParameters), {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n            }\n          };\n\n          var e = new CustomEvent(msg);\n          document.dispatchEvent(e);\n        });\n\n        googletag.pubads().set(\"page_url\", \"http://www.spotify.com\");\n\n        googletag.pubads().enableSingleRequest();\n        googletag.pubads().enableSyncRendering();\n        googletag.enableServices();\n      });\n    </script>\n  </head>\n  <body style=\"margin:0px\">\n    <div id=\"";
  if (helper = helpers.slotId) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.slotId); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" style=\"width: ";
  if (helper = helpers.width) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.width); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "px; height: ";
  if (helper = helpers.height) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.height); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "px\">\n      <script type=\"text/javascript\">\n        googletag.cmd.push(function() { googletag.display(\"";
  if (helper = helpers.slotId) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.slotId); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"); });\n      </script>\n    </div>\n  </body>\n</html>\n";
  return buffer;
  });

},{"hbsfy/runtime":615}],80:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EventLogger = undefined;
exports.factory = factory;

var _debug2 = require('debug');

var _debug3 = _interopRequireDefault(_debug2);

var _cosmosConnector = require('./cosmos-connector');

var _cosmosConnector2 = _interopRequireDefault(_cosmosConnector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function factory(_ref) {
  var debug = _ref.debug,
      Promise = _ref.Promise;

  function EventLogger(adId) {
    if (!adId) throw new Error('adId is required');

    var promise = Promise.resolve();

    this.logEvent = function (eventName, payload) {
      promise = promise.catch(function () {}).then(function () {
        return _cosmosConnector2.default.postEvent(adId, eventName, payload);
      }).then(function () {
        debug(adId, eventName, payload);
        return true;
      }).catch(function (err) {
        debug(adId, eventName, payload, err);
        throw err;
      });

      return promise;
    };
  }

  return EventLogger;
}

var EventLogger = exports.EventLogger = factory({
  debug: (0, _debug3.default)('saf:event-logger'),
  Promise: Promise
});

},{"./cosmos-connector":75,"debug":582}],81:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var comscore = exports.comscore = 'http://b.scorecardresearch.com/p?c1=2&c2=15654041&c7=http%3A%2F%2Fwww.spotify-desktop.com&cv=2.0&cj=1';

},{}],82:[function(require,module,exports){
'use strict';

var _cosmosConnector = require('./cosmos-connector');

var _cosmosConnector2 = _interopRequireDefault(_cosmosConnector);

var _spotifyEventDispatcher = require('../../spotify-event-dispatcher');

var _spotifyEventDispatcher2 = _interopRequireDefault(_spotifyEventDispatcher);

var _eventTypes = require('../../event-types');

var _eventTypes2 = _interopRequireDefault(_eventTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Responsible for patching DFP targeting when the application has
 * lost/gained focus.
 *
 * @constructor
 */
function AdsFocusTracker() {
  this._onFocusLost = _cosmosConnector2.default.patchTargeting.bind(null, 'focus', 'false');
  this._onFocusGained = _cosmosConnector2.default.patchTargeting.bind(null, 'focus', 'true');
}

/**
 * Start listening for focus events
 */
AdsFocusTracker.prototype.start = function () {
  _spotifyEventDispatcher2.default.addEventListener(_eventTypes2.default.APPLICATION_FOCUS_LOST, this._onFocusLost);
  _spotifyEventDispatcher2.default.addEventListener(_eventTypes2.default.APPLICATION_FOCUS_GAINED, this._onFocusGained);
};

/**
 * Stop listening for focus events
 */
AdsFocusTracker.prototype.stop = function () {
  _spotifyEventDispatcher2.default.removeEventListener(_eventTypes2.default.APPLICATION_FOCUS_LOST, this._onFocusLost);
  _spotifyEventDispatcher2.default.removeEventListener(_eventTypes2.default.APPLICATION_FOCUS_GAINED, this._onFocusGained);
};

module.exports = AdsFocusTracker;

},{"../../event-types":125,"../../spotify-event-dispatcher":234,"./cosmos-connector":75}],83:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _cosmosConnector = require('../cosmos-connector');

var _cosmosConnector2 = _interopRequireDefault(_cosmosConnector);

var _events = require('events');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var emitter = new _events.EventEmitter();

// EVENTS
var ENABLED = 'ENABLED';
var DISABLED = 'DISABLED';
var ACTIVE = 'ACTIVE';
var INACTIVE = 'INACTIVE';

var adId = null;
var element = null;
var isActive = false;
var isEnabled = false;
var isInitialized = false;

/**
 * @module AudioCompanionAd
 */
var AudioCompanionAd = {};

/**
 * @param {Object} opts
 * @param {HTMLElement} opts.element
 * @return {AudioCompanionAd}
 */
AudioCompanionAd.init = function (opts) {
  if (isInitialized) throwErrorMsg('already initialized');
  element = opts && opts.element;
  isInitialized = true;
  return AudioCompanionAd;
};

/**
 * @param {String} id
 * @return {AudioCompanionAd}
 */
AudioCompanionAd.setAdId = function (id) {
  adId = id;
  return AudioCompanionAd;
};

/**
 * @return {AudioCompanionAd}
 */
AudioCompanionAd.enable = function () {
  if (!isEnabled) {
    element.addEventListener('click', onCompanionClick);
    emitter.emit(ENABLED);
  }

  return AudioCompanionAd;
};

/**
 * @return {AudioCompanionAd}
 */
AudioCompanionAd.disable = function () {
  if (isEnabled) {
    element.removeEventListener('click', onCompanionClick);
    emitter.emit(DISABLED);
  }

  return AudioCompanionAd;
};

/**
 * @return {AudioCompanionAd}
 */
AudioCompanionAd.on = function (eventName, callback) {
  emitter.on(eventName, callback);
  return AudioCompanionAd;
};

/**
 * @param {String} eventName
 * @return {AudioCompanionAd}
 */
AudioCompanionAd.off = function (eventName, callback) {
  emitter.removeListener(eventName, callback);
  return AudioCompanionAd;
};

/**
 * @return {Boolean} isEnabled
 */
AudioCompanionAd.isEnabled = function () {
  return isEnabled;
};

/**
 * @return {Boolean} isActive
 */
AudioCompanionAd.isActive = function () {
  return isActive;
};

AudioCompanionAd.EVENTS = {
  ENABLED: ENABLED,
  DISABLED: DISABLED,
  ACTIVE: ACTIVE,
  INACTIVE: INACTIVE
};

emitter.on(ENABLED, function () {
  isEnabled = true;
  emitter.emit(ACTIVE);
});

emitter.on(DISABLED, function () {
  isEnabled = false;
  emitter.emit(INACTIVE);
});

emitter.on(ACTIVE, function () {
  isActive = true;
});

emitter.on(INACTIVE, function () {
  isActive = false;
});

function throwErrorMsg(errMsg) {
  throw new Error('AudioCompanionAd: ' + errMsg);
}

function postEvent(eventName) {
  if (!adId) throwErrorMsg('adId not set');
  _cosmosConnector2.default.postEvent(adId, eventName).catch(function (err) {
    console.error(err);
  });
}

function onCompanionClick(e) {
  e.preventDefault();
  postEvent('clicked');
}

exports.default = AudioCompanionAd;

},{"../cosmos-connector":75,"events":584}],84:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _events = require('events');

var _spotifyLiburi = require('spotify-liburi');

var _spotifyLiburi2 = _interopRequireDefault(_spotifyLiburi);

var _spotifyEventDispatcher = require('../../../../spotify-event-dispatcher');

var _spotifyEventDispatcher2 = _interopRequireDefault(_spotifyEventDispatcher);

var _eventTypes = require('../../../../event-types');

var _eventTypes2 = _interopRequireDefault(_eventTypes);

var _cosmosConnector = require('../../cosmos-connector');

var _cosmosConnector2 = _interopRequireDefault(_cosmosConnector);

var _audioCompanionAd = require('../audio-companion-ad');

var _audioCompanionAd2 = _interopRequireDefault(_audioCompanionAd);

var _view = require('./view');

var _view2 = _interopRequireDefault(_view);

var _formatEvents = require('../format-events');

var _formatEvents2 = _interopRequireDefault(_formatEvents);

var _AdControlEvent = require('../../../../spotify-logger/messages/AdControlEvent1');

var _AdControlEvent2 = _interopRequireDefault(_AdControlEvent);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var emitter = new _events.EventEmitter();
var debug = require('debug')('saf:billboard-ad');

var PREVIEW_SLOT_ID = 'preview';
var SLOT_ID = 'billboard';
var INVENTORY_TYPE = 'video';

var BLACKLISTED_URIS = ['ad', 'browse', 'charts', 'discover', 'hub', 'glue-reference', 'diag', 'app-manager'];

var SECONDS_MS = 1000;
var MINUTES_MS = SECONDS_MS * 60;
var DEFAULT_FOCUS_TIMEOUT_MS = 3 * MINUTES_MS;
var LOAD_RETRY_MS = 5 * SECONDS_MS;
var DFP_FETCH_RETRY_MS = 10 * SECONDS_MS;

var INITIAL_CLIENT_STATE = {
  audioAdIsPlaying: false,
  videoAdIsPlaying: false,
  isUserActive: true,
  hasFocus: true,
  currentUri: '',
  pageIsBlackListed: false
};

var clientState = Object.assign({}, INITIAL_CLIENT_STATE);

var INITIAL_BILLBOARD_STATE = {
  containerEl: null,
  view: null,
  isInitialized: false,
  isActive: false,
  isEnabled: false,
  overrideTimeoutMs: null,
  timerSetupView: null,
  timerFetchRetry: null,
  timerDfpRetry: null
};

var billboardState = Object.assign({}, INITIAL_BILLBOARD_STATE);

/**
 * @module BillboardAd
 */
var BillboardAd = {};
BillboardAd.EVENTS = _formatEvents2.default;

/**
 * @api private
 * @VisibleForTesting
 */
BillboardAd._resetState = function () {
  ['timerSetupView', 'timerFetchRetry', 'timerDfpRetry'].forEach(function (timerKey) {
    if (billboardState[timerKey]) {
      clearTimeout(billboardState[timerKey]);
    }
  });
  Object.assign(billboardState, INITIAL_BILLBOARD_STATE);
  Object.assign(clientState, INITIAL_CLIENT_STATE);
};

/**
 * @api private
 * @VisibleForTesting
 */
BillboardAd._setTimeoutMs = function (ms) {
  billboardState.overrideTimeoutMs = ms;
};

/**
 * @api private
 * @VisibleForTesting
 */
BillboardAd._setView = function (view) {
  billboardState.view = view;
};

/**
 * @param {Object} opts
 * @param {HTMLElement} opts.element
 * @return {BillboardAd}
 */
BillboardAd.init = function (opts) {
  if (!billboardState.isInitialized) {
    billboardState.containerEl = opts && opts.element;
    billboardState.isInitialized = true;
  }
  return BillboardAd;
};

/**
 * @return {BillboardAd}
 */
BillboardAd.enable = function () {
  if (!billboardState.isInitialized) throw new Error('Not initialized yet');

  if (!billboardState.isEnabled) {
    addListeners();

    _cosmosConnector2.default.subscribeToSlotType(SLOT_ID, onCoreMessage);

    emitter.emit(BillboardAd.EVENTS.ENABLED);
    debug('enabled');
  }

  return BillboardAd;
};

/**
 * Disable the billboard component inside the container.
 * @return {BillboardAd}
 */
BillboardAd.disable = function () {
  if (billboardState.isEnabled) {
    removeListeners();
    finish();

    emitter.emit(BillboardAd.EVENTS.DISABLED);
    debug('disabled');
  }

  return BillboardAd;
};

/**
 * @param  {String} eventName
 * @param  {Function} callback
 * @return {BillboardAd}
 */
BillboardAd.on = function (eventName, callback) {
  emitter.on(eventName, callback);
  return BillboardAd;
};

/**
 * @param  {String} eventName
 * @param  {Function} callback
 * @return {BillboardAd}
 */
BillboardAd.off = function (eventName, callback) {
  emitter.removeListener(eventName, callback);
  return BillboardAd;
};

/**
 * @return {Boolean} pageIsBlackListed
 *
 * Return true if the current app in view does not permit billboard placements.
 */
BillboardAd.pageIsBlackListed = function () {
  return clientState.pageIsBlackListed;
};

/**
 * @return {Boolean} isEnabled
 */
BillboardAd.isEnabled = function () {
  return billboardState.isEnabled;
};

/**
 * @return {Boolean} isActive
 *
 * Return true if a billboard is visible and active.
 */
BillboardAd.isActive = function () {
  return billboardState.isActive;
};

/**
 * Update the left offset of the billboard
 * when the navigation bar size changes.
 * @param {String} left e.g. 200px
 */
BillboardAd.updateOffSetLeft = function (left) {
  if (billboardState.view) {
    billboardState.view.updateOffSetLeft(left);
  }
};

/**
 * @private For testing only
 * @param {EventEmitter} _emitter
 * @return {void}
 */
BillboardAd._setEmitter = function (_emitter) {
  emitter = _emitter;
};

// TODO move responsibility to activitytracker
BillboardAd.setApplicationInactive = function () {
  clearTimeout(billboardState.timerSetupView);

  if (billboardState.view && billboardState.view.isActive()) {
    return;
  }

  fetchFromDFPWhenPossible();

  clientState.isUserActive = false;
};

function getFocusTimeoutMs() {
  if (billboardState.overrideTimeoutMs) {
    debug('use overrideTimeoutMs: %o', billboardState.overrideTimeoutMs);
    return Promise.resolve(billboardState.overrideTimeoutMs);
  }
  return _cosmosConnector2.default.getSlotConfiguration(SLOT_ID, 'display_time_interval').then(function (triggerAfterFocusLostS) {
    if (triggerAfterFocusLostS && triggerAfterFocusLostS > 0) {
      debug('using billboard slot config focus time (seconds): %o', triggerAfterFocusLostS);
      return triggerAfterFocusLostS * 1000;
    }
    throw new Error('triggerAfterFocusLostS is not a positive integer: ' + triggerAfterFocusLostS);
  }).catch(function (err) {
    debug('error getting display time interval: %o', err);
    return DEFAULT_FOCUS_TIMEOUT_MS;
  });
}
BillboardAd.getFocusTimeoutMs = getFocusTimeoutMs;

emitter.on(BillboardAd.EVENTS.ENABLED, function () {
  billboardState.isEnabled = true;
});

emitter.on(BillboardAd.EVENTS.DISABLED, function () {
  billboardState.isEnabled = false;
});

emitter.on(BillboardAd.EVENTS.ACTIVE, function () {
  billboardState.isActive = true;
});

emitter.on(BillboardAd.EVENTS.INACTIVE, function () {
  billboardState.isActive = false;
});

/**
 * Initialize format with listeners / subscriptions
 * @return {Promise}
 */
function addListeners() {
  _view2.default.on('INACTIVE', function () {
    emitter.emit(BillboardAd.EVENTS.INACTIVE);
    debug('inactive');
  });

  _audioCompanionAd2.default.on(_audioCompanionAd2.default.EVENTS.ACTIVE, onAudioAdChange.bind(null, true));

  _audioCompanionAd2.default.on(_audioCompanionAd2.default.EVENTS.INACTIVE, onAudioAdChange.bind(null, false));

  _spotifyEventDispatcher2.default.addEventListener(_eventTypes2.default.AD_VIDEO_STARTED, onVideoAdChange.bind(null, true));

  _spotifyEventDispatcher2.default.addEventListener(_eventTypes2.default.AD_VIDEO_FINISHED, onVideoAdChange.bind(null, false));

  _spotifyEventDispatcher2.default.addEventListener(_eventTypes2.default.AD_BILLBOARD_FINISHED, onBillboardAdFinished);

  _spotifyEventDispatcher2.default.addEventListener(_eventTypes2.default.AD_BILLBOARD_FOCUS_RECEIVED, onBillboardAdFocused);

  _spotifyEventDispatcher2.default.addEventListener(_eventTypes2.default.DEBUG_SET_BILLBOARD_TIMEOUT, onBillboardSetOverrideTimeout);

  _spotifyEventDispatcher2.default.addEventListener(_eventTypes2.default.DEBUG_FORCE_REFRESH_BILLBOARD, fetchFromDFP);

  _spotifyEventDispatcher2.default.addEventListener(_eventTypes2.default.APPLICATION_FOCUS_LOST, onApplicationFocusLost);

  _spotifyEventDispatcher2.default.addEventListener(_eventTypes2.default.APPLICATION_FOCUS_GAINED, onApplicationFocusGained);

  _spotifyEventDispatcher2.default.addEventListener(_eventTypes2.default.NAVIGATION_STATE_CHANGE, onNavigationStateChanged);

  _cosmosConnector2.default.subscribeToSlotType(PREVIEW_SLOT_ID, function (data) {
    return onPreview(data);
  });

  _cosmosConnector2.default.addNewSlot(SLOT_ID, INVENTORY_TYPE);

  return;
}

/**
 * @return {void}
 */
function removeListeners() {
  _audioCompanionAd2.default.off(_audioCompanionAd2.default.EVENTS.ACTIVE, onAudioAdChange.bind(null, true));

  _audioCompanionAd2.default.off(_audioCompanionAd2.default.EVENTS.INACTIVE, onAudioAdChange.bind(null, false));

  _spotifyEventDispatcher2.default.removeEventListener(_eventTypes2.default.AD_VIDEO_STARTED, onVideoAdChange.bind(null, true));

  _spotifyEventDispatcher2.default.removeEventListener(_eventTypes2.default.AD_VIDEO_FINISHED, onVideoAdChange.bind(null, false));

  _spotifyEventDispatcher2.default.removeEventListener(_eventTypes2.default.AD_BILLBOARD_FINISHED, onBillboardAdFinished);

  _spotifyEventDispatcher2.default.removeEventListener(_eventTypes2.default.AD_BILLBOARD_FOCUS_RECEIVED, onBillboardAdFocused);

  _spotifyEventDispatcher2.default.removeEventListener(_eventTypes2.default.DEBUG_SET_BILLBOARD_TIMEOUT, onBillboardSetOverrideTimeout);

  _spotifyEventDispatcher2.default.removeEventListener(_eventTypes2.default.DEBUG_FORCE_REFRESH_BILLBOARD, fetchFromDFP);

  _spotifyEventDispatcher2.default.removeEventListener(_eventTypes2.default.APPLICATION_FOCUS_LOST, onApplicationFocusLost);

  _spotifyEventDispatcher2.default.removeEventListener(_eventTypes2.default.APPLICATION_FOCUS_GAINED, onApplicationFocusGained);

  _spotifyEventDispatcher2.default.removeEventListener(_eventTypes2.default.NAVIGATION_STATE_CHANGE, onNavigationStateChanged);
}

function onPreview(data) {
  if (!data.ad.companion_ad) {
    return; // Preview for a leaderboard, just ignore
  }

  var triggerSlot = data.slot || PREVIEW_SLOT_ID;

  switch (data.event) {
    case 'available':
      // This will trigger a "play" event
      _cosmosConnector2.default.postToSlot(triggerSlot, 'now');
      break;
    case 'play':
      debug('play: data=%o', data);
      BillboardAd._render(data);
      emitter.emit(BillboardAd.EVENTS.ACTIVE);
      break;
    default:
      throw new Error('Unknown core event from preview slot: ' + data.event);
  }
}

function isPreview(ad) {
  var metadata = ad.metadata || {};
  return metadata.is_preview === 'true';
}

/**
 * Callback for ad slot messages from ads core.
 * @private
 * @param  {data} data Event data.
 * @return {void}
 */
function onCoreMessage(data) {
  if (isPreview(data.ad)) {
    onPreview(data);
    return;
  }

  switch (data.event) {
    case 'available':
      debug('available & active', data);
      onAvailable(data);
      break;
    case 'play':
      debug('play: data=%o', data);
      onPlay(data);
      break;
    case 'discard':
      debug('discard: data=%o', data);
      onDiscard();
      break;
    default:
      throw String('[Billboard] Unsupported event type: ' + data.event);
  }
}

function onAvailable(data) {
  debug('onAvailable data=%o', data);
  var canRender = !reasonCannotRender();

  if (canRender) {
    BillboardAd._render(data);
    emitter.emit(BillboardAd.EVENTS.ACTIVE);
    debug('active');
  } else {
    logControlEvent(_AdControlEvent2.default.Event.DISCARD, reasonCannotRender());
    clearSlot();
  }
}

function reasonCannotRender() {
  return reasonCannotShow() || (clientState.hasFocus && clientState.isUserActive ? _AdControlEvent2.default.Reason.CLIENT_ACTIVE : null);
}

function onPlay() {
  billboardState.view.play();
}

/**
 * Handles discard message from core
 * This happens on two occasions:
 *  1) When we fire an intent 'clear' message
 *  2) When click url expires, core sends a discard message
 * @private
 * @return {void}
 */
function onDiscard() {
  if (billboardState.view) {
    (function () {
      var requestNewAd = !billboardState.view.isActive();

      billboardState.view.destroy().then(function () {
        // Refetch because click url expired
        if (requestNewAd) {
          billboardState.timerDfpRetry = setTimeout(fetchFromDFP, DFP_FETCH_RETRY_MS);
        }
      });

      billboardState.view = null;
    })();
  }
}

/**
 * Render an ad retrieved from core
 * @param  {Object} ad The ad from core
 * @return {void}
 */
BillboardAd._render = function (data) {
  billboardState.view = new _view2.default(billboardState.containerEl, data);
  billboardState.view.setup();
};

/**
 * Tell core to fetch a new ad from DFP
 * @private
 * @return {void}
 */
function fetchFromDFP() {
  if (billboardState.view) {
    debug('will not fetch: view exists');
    return;
  }
  debug('fetchFromDFP');
  _cosmosConnector2.default.postToSlot(SLOT_ID, 'fetch').catch(logError);
}

/**
 * Fetch a new billboard ad from DFP whenever one is allowed to show.
 * @private
 * @return {void}
 */
function fetchFromDFPWhenPossible() {
  clearTimeout(billboardState.timerFetchRetry);
  if (canShow()) {
    fetchFromDFP();
  } else {
    debug('cannot show, retrying in 5s');
    billboardState.timerFetchRetry = setTimeout(function () {
      fetchFromDFPWhenPossible();
    }, LOAD_RETRY_MS);
  }
}

/* --------------- *
 * Event callbacks *
 * --------------- */

/**
 * Callback for when the navigation history has changed
 * (when user visits a new page in the client)
 * @param {Event} e - dispatcher event.
 */
function onNavigationStateChanged(e) {
  var uri = _spotifyLiburi2.default.from(e.params.uri);
  if (uri && BLACKLISTED_URIS.indexOf(uri.id) > -1) {
    clientState.pageIsBlackListed = true;
    finish();
  } else {
    clientState.pageIsBlackListed = false;
    minimize();
  }
  if (uri && uri.id) {
    clientState.currentUri = uri.id;
  }
}

/**
 * Callback for when the app has received focus
 */
function onApplicationFocusGained() {
  clientState.hasFocus = true;
  clientState.isUserActive = true;
  clearTimeout(billboardState.timerFetchRetry);
  clearTimeout(billboardState.timerSetupView);
  if (billboardState.view) {
    if (canShow()) {
      billboardState.view.onFocusReceived();
    } else {
      finish();
    }
  }
}

/**
 * Callback for when the app has lost focus.
 */
function onApplicationFocusLost() {
  debug('applicationFocusLost');
  clientState.hasFocus = false;

  if (billboardState.view && billboardState.view.isActive()) {
    debug('view already active');
    billboardState.view.onFocusLost();
    return;
  }

  clearTimeout(billboardState.timerSetupView);
  getFocusTimeoutMs().then(function (timeoutMs) {
    logControlEvent(_AdControlEvent2.default.Event.TRIGGER_WAIT, _AdControlEvent2.default.Reason.OUT_OF_FOCUS, timeoutMs);
    debug('set fetch timeout (ms): %o', timeoutMs);
    billboardState.timerSetupView = setTimeout(fetchFromDFPWhenPossible, timeoutMs);
  });
}

function logControlEvent(event, reason, waitMs) {
  _AdControlEvent2.default.log({
    event: event,
    reason: reason || '',
    slot: _AdControlEvent2.default.Slot.BILLBOARD,
    in_focus: String(clientState.hasFocus),
    uri: clientState.currentUri,
    wait_ms: waitMs ? Number(waitMs) : 0
  });
}

/**
 * @param  {Boolean} isPlaying
 * @return {void}
 */
function onAudioAdChange(isPlaying) {
  clientState.audioAdIsPlaying = isPlaying;
  updateOnClientChange();
}

/**
 * @param  {Boolean} isPlaying
 * @return {void}
 */
function onVideoAdChange(isPlaying) {
  clientState.videoAdIsPlaying = isPlaying;
  updateOnClientChange();
}

function updateOnClientChange() {
  if (!billboardState.view) return; // No need to do anything

  if (canShow()) {
    // Ad break ended
    billboardState.view.fadeIn();
  } else {
    // Ad break started
    var reason = reasonCannotShow();
    debug('finish ad due to reason=%o', reason);
    finish(); // Prevent it from flashing between ads in an ad break
  }
}

/**
 * Set new timeout from devtools
 * @param  {Event} e - dispatcher event
 * @return {void}
 */
function onBillboardSetOverrideTimeout(e) {
  billboardState.overrideTimeoutMs = e.params.timeout;
}

/**
 * Callback for when the billboard ad view has received focus.
 * @param {Event} e The event triggered.
 */
function onBillboardAdFocused() {
  clientState.isUserActive = true;
}

/**
 * Callback for when billboard is finished
 */
function onBillboardAdFinished() {
  billboardState.view = null;
  // The billboard destroyed itself while out of focus
  debug('onBillboardAdFinished: will setTimeout to fetch ad: %o', !clientState.hasFocus);
  if (!clientState.hasFocus) {
    billboardState.timerDfpRetry = setTimeout(fetchFromDFP, DFP_FETCH_RETRY_MS);
  }
}

/* ---------------- *
 * Helper functions *
 * ---------------- */

function logError(err) {
  debug(err.message);
}

function clearSlot() {
  return _cosmosConnector2.default.postToSlot(SLOT_ID, 'clear').catch(logError);
}

function finish() {
  if (billboardState.view) {
    billboardState.view.finish();
  }
}

function minimize() {
  if (billboardState.view) {
    billboardState.view.minimize();
  }
}

function canShow() {
  return !reasonCannotShow();
}

/**
 * Return a loggable reason code for why the billboard can not be shown
 * in the current context.
 */
function reasonCannotShow() {
  if (clientState.audioAdIsPlaying) {
    return _AdControlEvent2.default.Reason.AUDIO_AD_ACTIVE;
  }
  if (clientState.videoAdIsPlaying) {
    return _AdControlEvent2.default.Reason.VIDEO_AD_ACTIVE;
  }
  if (clientState.pageIsBlackListed) {
    return _AdControlEvent2.default.Reason.URI_BLACKLISTED;
  }
  return undefined;
}

exports.default = BillboardAd;

},{"../../../../event-types":125,"../../../../spotify-event-dispatcher":234,"../../../../spotify-logger/messages/AdControlEvent1":523,"../../cosmos-connector":75,"../audio-companion-ad":83,"../format-events":89,"./view":88,"debug":582,"events":584,"spotify-liburi":899}],85:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _padStart = require('lodash/padStart');

var _padStart2 = _interopRequireDefault(_padStart);

var _moment = require('moment');

var _moment2 = _interopRequireDefault(_moment);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ProgressBar = function () {
  function ProgressBar(container, videoNode) {
    var _this = this;

    _classCallCheck(this, ProgressBar);

    this.container = container;
    this.videoNode = videoNode;
    this.finished = false;
    this.progressEl = container.querySelector('#progress');
    this.durationEl = container.querySelector('#duration');
    this.currentTimeEl = container.querySelector('#current');
    this._onVideoTimeUpdate = function () {
      _this.currentTimeEl.innerHTML = _this._formatTime(_this.videoNode.currentTime);
    };
  }

  _createClass(ProgressBar, [{
    key: 'start',
    value: function start() {
      this.durationEl.innerHTML = this._formatTime(this.videoNode.duration);
      this.videoNode.addEventListener('timeupdate', this._onVideoTimeUpdate);
      this._animationStep();
    }
  }, {
    key: 'finish',
    value: function finish() {
      this.videoNode.removeEventListener('timeupdate', this._onVideoTimeUpdate);
      this.finished = true;
    }
  }, {
    key: '_formatTime',
    value: function _formatTime(seconds) {
      var time = _moment2.default.duration(Math.round(seconds), 'seconds');
      var paddedSeconds = (0, _padStart2.default)(time.seconds(), 2, '0');
      return time.minutes() + ':' + paddedSeconds;
    }
  }, {
    key: '_animationStep',
    value: function _animationStep() {
      if (this.finished) return;

      var percentage = 100 / this.videoNode.duration * this.videoNode.currentTime;
      if (percentage < 100) {
        this.progressEl.value = percentage;
        window.requestAnimationFrame(this._animationStep.bind(this));
      }
    }
  }]);

  return ProgressBar;
}();

exports.default = ProgressBar;

},{"lodash/padStart":644,"moment":650}],86:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      <div class=\"billboard\">\n        <span class=\"disclaimer\">";
  if (helper = helpers.disclaimer) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.disclaimer); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</span>\n        <span class=title>";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</span>\n        <video muted ></video>\n        <div class=\"video-fade\">\n          <button id=\"watch-with-sound\" class=\"button spoticon-volume-off-16\">&nbsp;";
  if (helper = helpers.watchWithSound) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.watchWithSound); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</button>\n          <button class=\"button button-play\"></button>\n          <button id=\"learn-more\" class=\"button button-with-stroke\">\n            <a  href=\"";
  if (helper = helpers.clickUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.clickUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n              ";
  if (helper = helpers.learnMore) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.learnMore); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n            </a>\n          </button>\n          <div class=\"progress\">\n            <div id=\"current\" class=\"progress-timer\">0:00</div>\n            <progress id=\"progress\" value=\"0\" max=\"100\"></progress>\n            <div id=\"duration\" class=\"progres-timer\">0:00</div>\n          </div>\n        </div>\n      </div>\n    ";
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      <a class=\"billboard\" href=\"";
  if (helper = helpers.clickUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.clickUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n        <span class=\"disclaimer\">";
  if (helper = helpers.disclaimer) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.disclaimer); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</span>\n        <img src=\"";
  if (helper = helpers.mediaSrc) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.mediaSrc); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"/>\n      </a>\n    ";
  return buffer;
  }

  buffer += "<div class=\"countdown\"></div>\n<div class=\"footer\">\n  <a class=\"companion\" href=\"";
  if (helper = helpers.clickUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.clickUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n    <img src=\"";
  if (helper = helpers.companionSrc) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.companionSrc); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" />\n  </a>\n</div>\n<div class=\"billboard-wrapper\">\n  <button class=\"minimizer spoticon-x-24\"></button>\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.isVideo), {hash:{},inverse:self.program(3, program3, data),fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n";
  return buffer;
  });

},{"hbsfy/runtime":615}],87:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _spotifyVideoManager = require('../../../../spotify-video-manager');

var _spotifyVideoManager2 = _interopRequireDefault(_spotifyVideoManager);

var _eventLogger = require('../../event-logger');

var _vastEvents = require('../../vast-events');

var _vastEvents2 = _interopRequireDefault(_vastEvents);

var _index = require('../../moat-logger/index');

var MoatLogger = _interopRequireWildcard(_index);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var BillboardAdVideo = {};


BillboardAdVideo.create = function (opts) {
  var _logEvent = new _eventLogger.EventLogger(opts.adId).logEvent;
  var isEnded = false;
  var videoNode = opts.videoNode;
  var videoSrc = opts.videoSrc;
  var videoId = _spotifyVideoManager2.default.createVideo(videoNode, {
    'url': videoSrc,
    'type': opts.isDash ? 'dash' : null
  });
  var logMoatEvent = function logMoatEvent() {};

  if (opts.moatEnabled) {
    (function () {
      var _logMoatEvent = MoatLogger.create({
        container: opts.container,
        videoNode: videoNode,
        ids: opts.moatIds
      });

      logMoatEvent = function logMoatEvent(eventType) {
        _logMoatEvent(MoatLogger.getMoatEvent(eventType));
      };
    })();
  }

  var handleVideoEvent = function handleVideoEvent(eventType) {
    if (eventType === _vastEvents2.default.EVENTS.ENDED) {
      isEnded = true;
    }
    logMoatEvent(eventType);
    _logEvent(eventType);
  };
  var unsubscribeToVast = null;

  var video = {};

  function isActiveVideo() {
    var thisVideo = _spotifyVideoManager2.default.getVideo(videoId);
    var thisIsActiveVideo = thisVideo === _spotifyVideoManager2.default.getActiveVideo();
    return thisVideo && thisIsActiveVideo || false;
  }

  function deactivate() {
    if (isActiveVideo()) {
      unsubscribeToVast();
      _spotifyVideoManager2.default.clearActiveVideo();
    }
  }

  /**
  * @return {Promise} promise
  */
  function restart() {
    return new Promise(function (resolve) {
      if (videoNode.currentTime === 0) {
        resolve();
        return;
      }

      function onSeeked() {
        videoNode.removeEventListener('seeked', onSeeked);
        resolve();
      }

      videoNode.addEventListener('seeked', onSeeked);
      videoNode.currentTime = 0;
    });
  }

  /**
   * @return {BillboardAdVideo} video
   */
  video.activate = function () {
    if (!isActiveVideo()) {
      _spotifyVideoManager2.default.setActiveVideo(videoId);
      // should this be happening only if it wasnt the active video?
      unsubscribeToVast = _vastEvents2.default.subscribe(videoNode, handleVideoEvent);
    }

    return video;
  };

  /**
   * @return {BillboardAdVideo} video
   */
  video.skip = function () {
    if (!isEnded) logMoatEvent(_vastEvents2.default.EVENTS.SKIPPED);

    deactivate();
    _spotifyVideoManager2.default.destroy(videoId);
    return video;
  };

  /**
   * @return {BillboardAdVideo} promise
   */
  video.watchWithSound = function () {
    return new Promise(function (resolve) {
      restart().then(function () {
        videoNode.muted = false;
        video.play();
        resolve();
      });
    });
  };
  /**
   * @return {BillboardAdVideo} video
   */
  video.play = function () {
    videoNode.play();
    return video;
  };

  /**
   * @param  {Function} cb
   * @return {BillboardAdVideo} video
   */
  video.subscribe = function (cb) {
    _spotifyVideoManager2.default.subscribe(videoId, cb);
    return video;
  };

  return video;
};

exports.default = BillboardAdVideo;

},{"../../../../spotify-video-manager":552,"../../event-logger":80,"../../moat-logger/index":114,"../../vast-events":121}],88:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _once = require('lodash/once');

var _once2 = _interopRequireDefault(_once);

var _i18n = require('../../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _events = require('events');

var _spotifyEventDispatcher = require('../../../../spotify-event-dispatcher');

var _spotifyEventDispatcher2 = _interopRequireDefault(_spotifyEventDispatcher);

var _template = require('./template.hbs');

var _template2 = _interopRequireDefault(_template);

var _progressBar = require('./progress-bar');

var _progressBar2 = _interopRequireDefault(_progressBar);

var _countDownAnimation = require('../../count-down-animation');

var _countDownAnimation2 = _interopRequireDefault(_countDownAnimation);

var _cosmosConnector = require('../../cosmos-connector');

var _cosmosConnector2 = _interopRequireDefault(_cosmosConnector);

var _videoUtils = require('../../video-utils');

var _videoUtils2 = _interopRequireDefault(_videoUtils);

var _eventTypes = require('../../../../event-types');

var _eventTypes2 = _interopRequireDefault(_eventTypes);

var _video = require('./video');

var _video2 = _interopRequireDefault(_video);

var _index = require('../../moat-logger/index');

var _abba = require('../../../../../libs/abba');

var _abba2 = _interopRequireDefault(_abba);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var debug = require('debug')('saf:billboard-ad-view');

var emitter = new _events.EventEmitter();

var AUTO_TEAR_DOWN_AFTER_MS = 30000; // 30 seconds after focus received
var AUTO_MINIMIZE_AFTER_MS = 2000; // 2 seconds after focus received
var FADE_OUT_ANIMATION_LENGTH = 500;

var TEMPLATE_MANIFEST_URL = 'video-manifest-url';
var STREAMING_TYPE = 'dash+webm';

// EVENTS
var VIEWED = 'viewed';
var CLICKED = 'clicked';
var ENDED = 'ended';
var COLLAPSED = 'collapsed';
var TERMINATED = 'terminated';

// ABBA Groups
// Don't dismiss the ad if viewed and then user went back out of focus
var ENABLED_NO_DISMISS = 'EnabledNoDismiss';
// Dismiss the ad if viewed and then user went back out of focus
var ENABLED_DISMISS = 'EnabledDismiss';

var STATES = {
  INACTIVE: 0,
  VIEWED: 1,
  MINIMIZED: 2,
  FINISHED: 3,
  DESTROYED: 4
};

var BillboardAdView = function () {
  function BillboardAdView(container, data) {
    var _this = this;

    _classCallCheck(this, BillboardAdView);

    // Properties
    this.container = container;
    this.state = STATES.INACTIVE;
    this.adData = parseData(data);
    this.isDummyAd = !this.adData.mediaSrc;
    this.shouldAutoMinimize = true;
    this.viewedTimestamp = 0;
    this.adsDesktopOverlayCoCountdownCell = 'Control';

    // Timers
    this.timerAutoMinimize = null;
    this.timerAutoTearDown = null;

    // Bind event listeners to correct context
    Object.getOwnPropertyNames(Object.getPrototypeOf(this)).forEach(function (key) {
      var method = _this[key];
      if (typeof method === 'function' && key !== 'constructor') {
        _this[key] = method.bind(_this);
      }
    });

    // For Unit Tests
    this._states = STATES;
  }

  /**
   * Setup method, renders the dom and adds event listeners.
   */


  _createClass(BillboardAdView, [{
    key: 'setup',
    value: function setup() {
      this.container.classList.remove('minimized');

      if (!this.adData.isValid) {
        this.finish();
        return;
      }

      if (this.isDummyAd) {
        this._setupDummy();
      } else {
        this._setupNormal();
      }

      window.addEventListener('mousemove', this._onWindowMouseMoved);
      this._dispatchEvent(_eventTypes2.default.AD_BILLBOARD_STARTED);
    }
  }, {
    key: '_setupDummy',
    value: function _setupDummy() {
      // todo handle dummy ad better
      this.container.classList.add('dummy');
      debug('Dummy billboard ad rendered');
    }
  }, {
    key: '_setupNormal',
    value: function _setupNormal() {
      var _this2 = this;

      this.container.innerHTML = (0, _template2.default)(this.adData);
      this.container.setAttribute('data-contextmenu', '');
      this.container.setAttribute('data-uri', JSON.stringify({
        creativeId: this.adData.creativeId,
        lineItemId: this.adData.lineItemId
      }));

      var billboard = this.container.querySelector('.billboard');
      var companion = this.container.querySelector('.companion');

      document.body.addEventListener('click', this._onBodyClicked);
      companion.addEventListener('click', this._onCompanionClicked);

      if (this.adData.isVideo) {
        this.shouldAutoMinimize = false;
        this._setupVideo(billboard);
      } else {
        _abba2.default.get('ads_desktop_overlay_no_countdown', function (err, cell) {
          if (cell === ENABLED_NO_DISMISS || cell === ENABLED_DISMISS) {
            _this2.adsDesktopOverlayCoCountdownCell = cell;
            _this2.shouldAutoMinimize = false;
            var minimizer = _this2.container.querySelector('.minimizer');
            minimizer.classList.add('visible');
          } else {
            _this2.countdown = new _countDownAnimation2.default(_this2.container.querySelector('.countdown'), AUTO_MINIMIZE_AFTER_MS);
          }
          debug('ads_desktop_overlay_no_countdown => ', cell);
        });
        this._setupImage(billboard);
      }
    }
  }, {
    key: '_setupVideo',
    value: function _setupVideo(billboard) {
      var _this3 = this;

      this.billboard = billboard;
      this.container.classList.add('video');
      this._media = billboard.querySelector('video');

      // useCapture = true allows this to trigger before the container's click handler
      this.billboard.addEventListener('click', this.onWatchWithSound, true);
      var link = billboard.querySelector('#learn-more');
      link.addEventListener('click', this._clickOpenLink);

      var videoArgs = {
        adId: this.adData.id,
        videoNode: this._media,
        videoSrc: this.adData.mediaSrc,
        isDash: this.adData.isDash,
        moatEnabled: this.adData.moatEnabled
      };

      if (this.adData.moatEnabled) {
        videoArgs.container = this.container;
        videoArgs.moatIds = this._getMoatIds();
      }
      this._video = _video2.default.create(videoArgs);

      this._video.subscribe(function (err) {
        if (err) {
          debug(err);
          _this3.finish();
        }
      });

      this._media.addEventListener('canplay', (0, _once2.default)(this.fadeIn));
      this._media.addEventListener('error', this._onError);
    }
  }, {
    key: '_setupImage',
    value: function _setupImage(billboard) {
      billboard.addEventListener('click', this._clickOpenLink);
      this._media = billboard.querySelector('img');
      this._media.addEventListener('load', (0, _once2.default)(this.fadeIn));
      this._media.addEventListener('error', this._onError);
    }
  }, {
    key: 'onWatchWithSound',
    value: function onWatchWithSound(event) {
      debug('Video sound enabled');
      event.stopPropagation();
      event.preventDefault();
      this.billboard.removeEventListener('click', this.onWatchWithSound, true);
      this.progressBar = new _progressBar2.default(this.billboard, this._media);
      this.billboard.classList.add('sound-enabled');
      this.progressBar.start();
      this.play();
    }
  }, {
    key: 'updateOffSetLeft',
    value: function updateOffSetLeft(left) {
      var footer = this.container.querySelector('.footer');
      footer.style.left = left;
    }
  }, {
    key: '_getMoatIds',
    value: function _getMoatIds() {
      return (0, _index.extractMoatIds)(this.adData.metadata);
    }
  }, {
    key: 'isActive',
    value: function isActive() {
      return this.state !== STATES.INACTIVE;
    }

    /**
     * Auto Tears Down if the ad has been viewed
     * and the client goes back out of focus.
     */

  }, {
    key: 'onFocusLost',
    value: function onFocusLost() {
      var _this4 = this;

      if (this.adsDesktopOverlayCoCountdownCell !== ENABLED_DISMISS || this.state !== STATES.VIEWED || this.timerAutoTearDown) {
        return;
      }
      debug('onFocusLost: setting auto tear down');
      this.timerAutoTearDown = setTimeout(function () {
        _this4.finish();
      }, AUTO_TEAR_DOWN_AFTER_MS);
    }

    /**
     * Start the animations, should be called when the application receives
     * focus again.
     */

  }, {
    key: 'onFocusReceived',
    value: function onFocusReceived() {
      debug('onFocusReceived');

      if (this.state >= STATES.VIEWED) return; // Prevent multiple starts

      this.state = STATES.VIEWED;

      window.removeEventListener('mousemove', this._onWindowMouseMoved);

      if (this.shouldAutoMinimize) {
        this.timerAutoMinimize = setTimeout(this.minimize, AUTO_MINIMIZE_AFTER_MS);
        if (this.countdown) {
          this.countdown.start();
        }
      }

      this._dispatchEvent(_eventTypes2.default.AD_BILLBOARD_FOCUS_RECEIVED);

      // Dummy ad impressions get tracked on intent 'now'
      if (!this.isDummyAd) {
        this.viewedTimestamp = new Date().getTime();
        this._logEvent(VIEWED);
      }

      if (this.adData.isVideo) {
        this._video.play();
      } else {
        _cosmosConnector2.default.postToSlot('billboard', 'now');
      }
    }

    /**
     * Finish this billboard ad.
     * @return {Promise}
     */

  }, {
    key: 'finish',
    value: function finish() {
      var _this5 = this;

      if (this.state >= STATES.FINISHED) {
        return Promise.resolve();
      }
      var previousState = this.state;
      this.state = STATES.FINISHED;
      debug('finish');
      // vast logger handles logging ended/terminated events
      if (!this.adData.isVideo) {
        if (previousState === STATES.INACTIVE) {
          this._logEvent(TERMINATED);
        } else {
          this._logEvent(ENDED);
        }
      }

      return this.destroy().then(function () {
        _this5._dispatchEvent(_eventTypes2.default.AD_BILLBOARD_FINISHED);
        return _cosmosConnector2.default.postToSlot('billboard', 'clear');
      });
    }

    /**
     * @return {Promise}
     */

  }, {
    key: 'destroy',
    value: function destroy() {
      var _this6 = this;

      if (this.state >= STATES.DESTROYED) {
        return Promise.resolve();
      }
      this.state = STATES.DESTROYED;
      return new Promise(function (resolve) {
        document.body.removeEventListener('click', _this6._onBodyClicked);
        window.removeEventListener('mousemove', _this6._onWindowMouseMoved);

        if (_this6.progressBar) {
          _this6.progressBar.finish();
        }

        clearTimeout(_this6.timerAutoMinimize);
        clearTimeout(_this6.timerAutoTearDown);

        _this6.fadeOut().then(function () {
          _this6.container.innerHTML = '';
          _this6.container.classList.remove('dummy');
          _this6.container.classList.remove('minimized');
          _this6.container.classList.remove('video');
          _this6._dispatchEvent(_eventTypes2.default.AD_BILLBOARD_DISCARDED);
          emitter.emit('INACTIVE');
          resolve();
        });
      });
    }

    /**
     * Fade the ad in
     * @return {Promise}
     */

  }, {
    key: 'fadeIn',
    value: function fadeIn() {
      var _this7 = this;

      debug('fadeIn');
      return new Promise(function (resolve) {
        _this7.container.classList.add('visible');
        setTimeout(function () {
          // El needs to be visible first in order to animate
          _this7.container.classList.add('ready'); // Triggers the fade
          setTimeout(function () {
            // Fade in animation takes 0.5 seconds
            _this7._dispatchEvent(_eventTypes2.default.AD_BILLBOARD_VISIBLE);
            resolve();
          }, FADE_OUT_ANIMATION_LENGTH);
        }, 100);
      });
    }

    /**
     * Fade the ad out
     * @return {Promise}
     */

  }, {
    key: 'fadeOut',
    value: function fadeOut() {
      var _this8 = this;

      debug('fadeOut');
      return new Promise(function (resolve) {
        _this8.container.classList.remove('ready'); // Triggers the fade

        setTimeout(function () {
          // Fade out animation takes 0.5 seconds
          _this8.container.classList.remove('visible'); // Hides it
          _this8._dispatchEvent(_eventTypes2.default.AD_BILLBOARD_HIDDEN);
          resolve();
        }, FADE_OUT_ANIMATION_LENGTH);
      });
    }

    /**
     * Minimize this billboard ad view.
     */

  }, {
    key: 'minimize',
    value: function minimize() {
      var _this9 = this;

      if (this.state >= STATES.MINIMIZED) {
        return;
      }
      this.state = STATES.MINIMIZED;
      this._dispatchEvent(_eventTypes2.default.AD_BILLBOARD_MINIMIZED);
      this._logEvent(COLLAPSED, {
        'event_data': {
          'msSinceViewed': String(new Date().getTime() - this.viewedTimestamp)
        }
      });
      this.container.classList.add('minimized');
      this.timerAutoTearDown = setTimeout(function () {
        _this9.finish();
      }, AUTO_TEAR_DOWN_AFTER_MS);

      if (this.adData.isVideo) {
        this._media.removeEventListener('ended', this.finish);
        this._media.removeEventListener('error', this._onError);
        this._video.skip();
        this._dispatchEvent(_eventTypes2.default.AD_CLICK_VIDEO_ENDED);
      }
    }
  }, {
    key: 'play',
    value: function play() {
      var _this10 = this;

      if (!this.adData.isVideo) return;

      this._video.watchWithSound().then(function () {
        _this10._video.activate();
        _this10._media.play();
        _spotifyEventDispatcher2.default.dispatchEvent({
          type: _eventTypes2.default.AD_CLICK_VIDEO_STARTED
        });
      });
    }
  }, {
    key: '_onError',
    value: function _onError() {
      debug('Failed to load billboard ' + this.adData.mediaSrc);
      this.finish();
    }
  }, {
    key: '_dispatchEvent',
    value: function _dispatchEvent(type) {
      _spotifyEventDispatcher2.default.dispatchEvent({
        type: type,
        params: {
          id: this.adData.id,
          isDummyAd: this.isDummyAd
        },
        extra: {}
      });
    }
  }, {
    key: '_logEvent',
    value: function _logEvent(eventType, payload) {
      _cosmosConnector2.default.postEvent(this.adData.id, eventType, payload);
    }

    /**
     * Callback for when the mouse has been moved over the window, used
     * to trigger the animation more quickly than the focus interval check,
     * which is once per second.
     *
     * Note that mousemove may be received when the window is composited behind
     * another window (OS-dependent), so we need to check that the document
     * is in focus before starting the countdown.
     */

  }, {
    key: '_onWindowMouseMoved',
    value: function _onWindowMouseMoved() {
      if (document.hasFocus()) {
        this.onFocusReceived();
      }
    }

    /**
     * Event listener for when the billboard has been clicked.
     * Clicks on the billboard when minimized should just maximize it.
     * @param {Event} e The event triggered.
     */

  }, {
    key: '_clickOpenLink',
    value: function _clickOpenLink(e) {
      e.stopPropagation();
      e.preventDefault();

      if (this.adData.accountUpgrade) {
        debug('account-upgrade');
        _spotifyEventDispatcher2.default.dispatchEvent({
          type: _eventTypes2.default.NAVIGATION_UPGRADE,
          params: {
            tracking: this.adData.accountUpgradeTracking
          }
        });
      } else {
        window.open(this.adData.clickUrl);
      }

      if (!this.shouldAutoMinimize) {
        this.minimize();
      }
      this._logEvent(CLICKED);
    }

    /**
     * Event listener for when the companion banner has been clicked.
     * @param {Event} e The event triggered.
     */

  }, {
    key: '_onCompanionClicked',
    value: function _onCompanionClicked(e) {
      e.stopPropagation();
      this._logEvent(CLICKED);
    }

    /**
     * Event listener for when the container has been clicked.
     */

  }, {
    key: '_onBodyClicked',
    value: function _onBodyClicked() {
      if (!this.shouldAutoMinimize) {
        this.minimize();
      }
    }
  }, {
    key: '_setFadeOutAnimationLength',


    /**
     * Exposed for unit tests only
     */
    value: function _setFadeOutAnimationLength(ms) {
      FADE_OUT_ANIMATION_LENGTH = ms;
    }
  }, {
    key: '_setAutoMinimizeAfterMs',
    value: function _setAutoMinimizeAfterMs(ms) {
      AUTO_MINIMIZE_AFTER_MS = ms;
    }
  }, {
    key: '_setAutoTearDownAfterMs',
    value: function _setAutoTearDownAfterMs(ms) {
      AUTO_TEAR_DOWN_AFTER_MS = ms;
    }
  }], [{
    key: 'on',
    value: function on(eventName, callback) {
      emitter.on(eventName, callback);
    }
  }]);

  return BillboardAdView;
}();

function getPreferredVideo(ad, videoState) {
  var videos = ad.videos || [];
  var adaptiveVideo = videos.filter(function (video) {
    return video.video_hex_id;
  }).shift() || ad.metadata.videoPlaylistID;
  if (adaptiveVideo) {
    videoState.mediaSrc = manifestUrlForSourceID(adaptiveVideo);
    videoState.isDash = true;
  } else {
    var preferredFlatVideo = _videoUtils2.default.getPreferredVideoMetadata(videos);
    videoState.mediaSrc = preferredFlatVideo && preferredFlatVideo.url;
  }
}

function manifestUrlForSourceID(sourceID) {
  return global.__spotify.product_state[TEMPLATE_MANIFEST_URL].replace(/\{type\}/i, STREAMING_TYPE).replace(/\{source_id\}/i, encodeURIComponent(sourceID));
}

function parseData(data) {
  var metadata = data.ad.metadata || {};
  var ret = {
    id: data.ad.id,
    isDash: false,
    isVideo: false,
    clickUrl: data.ad.click_url,
    mediaSrc: null,
    isValid: true,
    disclaimer: _i18n2.default.get('Advertisement'),
    accountUpgradeTracking: metadata.accountUpgradeTracking,
    accountUpgrade: metadata.accountUpgrade,
    creativeId: metadata.creative_id,
    lineItemId: metadata.lineitem_id
  };

  switch (data.format) {
    case 'video':
      var moatEnabled = metadata['moat.enabled'] === 'true';
      ret.isVideo = true;
      ret.companionSrc = data.ad.companion_ad.url;
      ret.moatEnabled = moatEnabled;
      ret.metadata = metadata;
      ret.title = data.ad.title;
      ret.watchWithSound = _i18n2.default.get('WatchWithSound');
      ret.learnMore = _i18n2.default.get('LearnMore');
      getPreferredVideo(data.ad, ret);
      break;
    case 'banner':
      ret.companionSrc = data.ad.companion_ad.url;
      ret.mediaSrc = data.ad && data.ad.images && data.ad.images[0] && data.ad.images[0].url;
      break;
    case 'unknown':
      // its a dummy ad - used to measure billboard opportunity
      break;
    default:
      ret.isValid = false;
      break;
  }

  return ret;
}

exports.default = BillboardAdView;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../../../libs/abba":49,"../../../../event-types":125,"../../../../spotify-event-dispatcher":234,"../../../i18n":50,"../../cosmos-connector":75,"../../count-down-animation":76,"../../moat-logger/index":114,"../../video-utils":122,"./progress-bar":85,"./template.hbs":86,"./video":87,"debug":582,"events":584,"lodash/once":643}],89:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  ENABLED: 'ENABLED',
  DISABLED: 'DISABLED',
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE'
};

},{}],90:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.init = init;
exports.destroy = destroy;
exports.getAdsHptoSas = getAdsHptoSas;

var _abba = require('../../../../abba');

var _abba2 = _interopRequireDefault(_abba);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = require('debug')('saf:hpto:abba');

var abbaResolved = false;
var abbaPromise = void 0;
var isAdsHptoSasEnabled = false;
var abbaSubscriber = { cancel: function cancel() {} };

function init() {
  abbaPromise = new Promise(function (resolve) {
    abbaSubscriber = _abba2.default.subscribe('ads_hpto_sas', function (err, cell) {
      if (err) return;
      isAdsHptoSasEnabled = cell === 'Enabled';
      abbaResolved = true;
      debug('isAdsHptoSasEnabled: %o.', isAdsHptoSasEnabled);
      resolve(isAdsHptoSasEnabled);
    });
    // just in case abba doesn't resolve
    setTimeout(function () {
      resolve(false);
    }, 2000);
  });
}

function destroy() {
  abbaSubscriber.cancel();
}

function getAdsHptoSas() {
  if (!abbaResolved) {
    return abbaPromise;
  }
  return Promise.resolve(isAdsHptoSasEnabled);
}

},{"../../../../abba":49,"debug":582}],91:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.get = get;

var _dfp = require('../../dfp');

var _dfp2 = _interopRequireDefault(_dfp);

var _targeter = require('../../targeter');

var _targeter2 = _interopRequireDefault(_targeter);

var _hptoResponse = require('./hpto-response');

var _hptoResponse2 = _interopRequireDefault(_hptoResponse);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = require('debug')('saf:hpto:get-ad-direct');

function get(sessionData, adContainer) {
  debug('get');
  var inventoryUnit = _dfp2.default.inventoryUnit(sessionData.platform, sessionData.isPremium);
  return _targeter2.default.getTargeting(inventoryUnit).then(function (data) {
    var targetingData = Object.assign({}, data, {
      inventoryType: 'hpto',
      width: 1200,
      height: 270
    });
    debug('fetch:targetingData=%o', targetingData);
    return _dfp2.default.fetchHptoAd(adContainer, targetingData);
  }).then(function (res) {
    return (0, _hptoResponse2.default)(res.hpto || res);
  });
}

},{"../../dfp":78,"../../targeter":119,"./hpto-response":93,"debug":582}],92:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.get = get;

var _messageProxy = require('../../../../message-proxy');

var _utils = require('../../utils');

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = require('debug')('saf:hpto:get-ad-proxy');

/**
 * Wait for the message from the loaderFrame, which is expected to have the shape:
 * {
 *   data: {
 *     // rendering properties used by views
 *   },
 *   adMetadata: {
 *     creativeId: Number,
 *     lineItemId: Number,
 *     slot: String,
 *     targetingParams: Object  // string mapping
 *   }
 * }
 *
 * When a successful inter-frame message is received, the above object will be
 * extended with the property "loaderFrame", which will contain a reference to
 * the loader iframe which is suitable for presentation by the HTML HPTO view.
 *
 * This method is only valid for SAS-based requests (useProxy = true).
 */
function get(sessionData, adContainer) {
  debug('get');
  return requestProxy().then(function (ad) {
    return getIframeMessage(ad, adContainer);
  });
}

/**
 * Request an HPTO ad template from zlink using the messageProxy
 *
 * @return Promise resolving to a display ad from cosmos.  This has a shape
 *   equivalent to the "ad" property of a cosmos adslot event, which can be
 *   seen here: https://ghe.spotify.net/pages/ads/ads-api/api/#subscribe-to-events
 */
function requestProxy() {
  return new Promise(function (resolve, reject) {
    (0, _messageProxy.messageProxy)({ method: 'GET', uri: 'hpto', target: 'top' }, function (err, response) {
      debug('hpto messageProxy response: %o, err: %o', response, err);
      if (err) {
        reject(err);
        return;
      }
      try {
        resolve(response.ad);
      } catch (e) {
        reject('error parsing message response: ' + e.message);
      }
    });
  });
}

function getIframeMessage(ad, adContainer) {
  var html = parseCosmosAdHtml(ad);
  var iframe = void 0;
  return new Promise(function (resolve, reject) {
    // Add the event listener before we create the iframe just in case
    window.addEventListener('message', function onWindowMessage(ev) {
      if (_typeof(ev.data) === 'object' && typeof ev.data.type === 'string') {
        var typeArray = ev.data.type.split(':');
        if (typeArray[0] !== 'ads' || typeArray[1] !== 'hpto') {
          return;
        }
        debug('message: %o', ev.data);
        if (typeArray[2] === 'error' || typeArray[2] === 'no-ad') {
          reject(typeArray[2]);
        } else if (typeArray[2] === 'init') {
          var adData = ev.data.data.data;
          adData.loaderFrame = iframe;
          resolve(adData);
        } else {
          reject('unsupported hpto message');
          debug('Unsupported Hpto Message', typeArray[2], ev.data);
        }
        window.removeEventListener('message', onWindowMessage);
      }
    });
    iframe = _utils2.default.createInteractiveIframe(html);
    iframe.style.display = 'none';
    adContainer.appendChild(iframe);
  });
}

/**
 * Parse an ad received via cosmos and extract the html from
 * the display media.
 *
 * @return {String} HTML of the ad.
 */
function parseCosmosAdHtml(ad) {
  debug('parse html from cosmos ad: %o', ad);
  var validDisplay = (ad.display || []).filter(function (disp) {
    return disp.mime_type === 'text/html';
  })[0];
  if (!validDisplay || !validDisplay.media) {
    throw new Error('no valid display found in ad with id: ' + ad.id);
  }
  return validDisplay.media;
}

},{"../../../../message-proxy":214,"../../utils":120,"debug":582}],93:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _utils = require('../../utils');

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = require('debug')('saf:hpto-response');

function getKeyByValue(v, obj) {
  return Object.keys(obj).find(function (k) {
    return obj[k] === v;
  });
}

/**
 * Rename image banner mode field to 'image'
 * (Historically has been set to 'html')
 *
 * @api private
 * @param  {Object} data - response from dfp
 * @return {Object} normalized data
 */

function _renameImageBannerField(data) {
  var oldBannerKey = getKeyByValue('html', data);
  delete data[oldBannerKey];

  return Object.assign({}, data, {
    bannerMode: 'image'
  });
}

/**
 * Normalize native elem data
 *
 * @api private
 * @param  {Object} data - response from dfp
 * @return {Object} normalized data
 */

function _handleNativeEl(data) {
  var doc = document.implementation.createHTMLDocument('');
  doc.documentElement.innerHTML = data.html;
  var badge = '';
  var nativeElNode = doc.getElementById('native-elements');
  var oldBannerKey = getKeyByValue('html', data);
  var badges = ['data-is-spotlight', 'data-is-exclusive', 'data-is-sponsored'];

  badges.some(function (b) {
    if (nativeElNode.hasAttribute(b)) {
      badge = b;
    }
    return badge;
  });

  badge = badge.split('-').pop() || '';

  delete data[oldBannerKey];

  return Object.assign({}, data, {
    version: 2,
    badge: badge,
    bannerMode: 'native',
    blurb: nativeElNode.getAttribute('data-blurb'),
    targetUri: nativeElNode.getAttribute('data-uri'),
    playBtnUri: nativeElNode.getAttribute('data-track-override')
  });
}

/**
 * Wrapper around normalizing data coming from DFP.
 *
 * @api public
 * @param {Object} data
 */

function parseHptoResponse(data) {
  debug('parseHptoResponse data=%o', data);
  var parsed = null;

  var isNativeEl = data.html && data.html.search(/id=\"native\-elements\"/) !== -1;

  var isImageEl = !data.html && _utils2.default.getProp('banner mode', data) === 'html';

  if (isNativeEl) {
    parsed = _handleNativeEl(data);
  } else if (isImageEl) {
    parsed = _renameImageBannerField(data);
  }

  parsed = parsed || data;
  parsed.bannerMode = _utils2.default.getProp('banner mode', parsed);

  if (!parsed.bannerMode) {
    throw new TypeError('hpto data looks invalid');
  }

  debug('parseHptoResponse result=%o', parsed);
  return parsed;
}

exports.default = parseHptoResponse;

},{"../../utils":120,"debug":582}],94:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _cosmosConnector = require('../../cosmos-connector');

var _cosmosConnector2 = _interopRequireDefault(_cosmosConnector);

var _spotifyLive = require('../../../../spotify-live');

var _spotifyLive2 = _interopRequireDefault(_spotifyLive);

var _spotifyPreferences = require('../../../../spotify-preferences');

var _spotifyPreferences2 = _interopRequireDefault(_spotifyPreferences);

var _messageProxy = require('../../../../message-proxy');

var _eventTypes = require('../../../../event-types');

var _eventTypes2 = _interopRequireDefault(_eventTypes);

var _utils = require('../../utils');

var _utils2 = _interopRequireDefault(_utils);

var _i18n = require('../../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _session = require('../../session');

var _session2 = _interopRequireDefault(_session);

var _settings = require('../../settings');

var _settings2 = _interopRequireDefault(_settings);

var _abba = require('./abba');

var abba = _interopRequireWildcard(_abba);

var _AdError = require('../../../../spotify-logger/messages/AdError2');

var _AdError2 = _interopRequireDefault(_AdError);

var _AdEvent = require('../../../../spotify-logger/messages/AdEvent4');

var _AdEvent2 = _interopRequireDefault(_AdEvent);

var _getAdDirect = require('./get-ad-direct');

var _getAdProxy = require('./get-ad-proxy.js');

var _hptoResponse = require('./hpto-response');

var _hptoResponse2 = _interopRequireDefault(_hptoResponse);

var _nativeHptoView = require('./views/native-hpto-view');

var nativeHptoView = _interopRequireWildcard(_nativeHptoView);

var _htmlHptoView = require('./views/html-hpto-view');

var htmlHptoView = _interopRequireWildcard(_htmlHptoView);

var _imageHptoView = require('./views/image-hpto-view');

var imageHptoView = _interopRequireWildcard(_imageHptoView);

var _productState = require('../../product-state');

var _productState2 = _interopRequireDefault(_productState);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = require('debug')('saf:hpto:index');

var VIEW_MAP = {
  'native': nativeHptoView,
  'html': htmlHptoView,
  'image': imageHptoView
};

/**
 * ProductState.isProxyAdRequester indicates whether we will request HPTO ad units via core/SAS (proxy-ad-request) or using local
 * GPT template injection.
 *
 * When using SAS, we will listen for ad payloads over cosmos (these will contain GPT), then inject the
 * payload contents into a loaderFrame which will send an init postMessage event with HPTO data for the
 * View. This loaderFrame will also be passed to the view and assumed to be suitable for rendering.
 *
 * When using (deprecated) local GPT injection, we will use the dfp.fetchHptoAd method which will create its
 * own private loaderFrame, and then pass the resolved data into the View.  In the case of HTML HPTO ads, the
 * View must create its own display frame, which will duplicate third party resource requests with the
 * private loaderFrame.  This is one of the reasons we are migrating to SAS-based requests.
 *
 * When SAS is rolled to 100%, the isProxyAdRequester and direct-rendering logic can be removed.
 *
 * Spec: https://ghe.spotify.net/ads/documentation/blob/master/proposals/hpto-sas/README.md
 */

var renderedView = null;
var enabling = false;
var accountUpgrade = false;
var accountUpgradeTracking = false;
var isPremium = false;
var unsubscribeHptoRefresh = void 0;
var application = void 0;
var uiPref = void 0;
var buttonData = {};
/**
 * The element which will contain the rendered HPTO, which will be mounted into another element
 * passed into the init method.
 */
var containerEl = void 0;
var mountNode = void 0;

/*
 * CSS Classes
 */
var AD_CONTAINER_CLASS = 'ad-container';
var HIDDEN_CLASS = 'hidden';
var HPTO_BUTTON_CLASS = 'hpto-button';
var PREVIOUS_AD_CONTAINER_CLASS = 'ad-container-old';
var HPTO_CLOSED_CLASS = 'hpto-closed';

/**
 * Event Subscribers (used instead of the event emitter)
 */
var RENDER_EVENT = 'Render';
var HIDE_EVENT = 'Hide';
var HPTO_EVENTS = [RENDER_EVENT, HIDE_EVENT];
var subscribers = HPTO_EVENTS.reduce(function (acc, event) {
  acc[event] = [];
  return acc;
}, {});

var initialzed = false;

/**
 * @module HptoAd
 */
var HPTO = {
  /**
   * - Listen for app updates
   * - Initialize the iframe message utility
   * - Subscribe to hpto-refresh messages from zlink.
   * - Auto enables if the application is active
   * @param  {HTMLElement} mountNodeParam
   */
  init: function init(mountNodeParam) {
    if (initialzed) {
      return null;
    }
    if (!mountNodeParam) {
      throw new Error('HPTO init requires a mountNode');
    }
    initialzed = true;
    debug('init');

    application = (0, _spotifyLive2.default)('spotify:application');
    containerEl = document.createElement('div');
    containerEl.id = 'hpto-container';
    uiPref = new _spotifyPreferences2.default('ui');
    mountNode = mountNodeParam;
    mountNode.appendChild(containerEl);
    abba.init();
    application.on('update', onApplicationUpdate);
    // Todo (jordalgo): remove this as it's pretty simple to just go to another app and come back to refresh hpto.
    unsubscribeHptoRefresh = (0, _messageProxy.messageProxy)({ method: 'SUB', uri: 'hpto-refresh' }, function () {
      debug('hpto-refresh');
      enable();
    });
    if (application.get('active')) {
      enable();
    }
    return undefined;
  },

  /**
   * Use only for unit tests at the moment
   * as apps will unload automatically
   */
  destroy: function destroy() {
    if (!initialzed) {
      return;
    }
    disable();
    abba.destroy();
    application.off('update', onApplicationUpdate);
    unsubscribeHptoRefresh();
    mountNode.removeChild(containerEl);
    Object.keys(subscribers).forEach(function (key) {
      subscribers[key] = [];
    });
    initialzed = false;
    debug('destroy');
  },
  /**
   * Event subscribers
   * (these can be generated dynamically but it's a bit easier to read and grep like this)
   */
  subscribeToRender: subscribe.bind(null, RENDER_EVENT),
  subscribeToHide: subscribe.bind(null, HIDE_EVENT),
  unsubscribeToRender: unsubscribe.bind(null, RENDER_EVENT),
  unsubscribeToHide: unsubscribe.bind(null, HIDE_EVENT)
};

exports.default = HPTO;


function clearCrashData() {
  _cosmosConnector2.default.putCrashData('hptoLineItemId', '');
  _cosmosConnector2.default.putCrashData('hptoCreativeId', '');
}

function setCrashData(adData) {
  _cosmosConnector2.default.putCrashData('hptoCreativeId', String(adData.creativeId));
  _cosmosConnector2.default.putCrashData('hptoLineItemId', String(adData.lineItemId));
}

function subscribe(event, fn) {
  var subs = subscribers[event];
  var foundIndex = subs.indexOf(fn);
  if (foundIndex === -1) {
    subs.push(fn);
  }
}

function unsubscribe(event, fn) {
  var subs = subscribers[event];
  var foundIndex = subs.indexOf(fn);
  if (foundIndex !== -1) {
    subs.splice(foundIndex, 1);
  }
}

function onApplicationUpdate(e) {
  if (e.hasOwnProperty('active')) {
    debug('handle application update active=%o', e.active);
    if (e.active) {
      enable();
    }
  } else if (isPreview(e.arguments)) {
    handlePreviewUri(e.arguments);
  }
}

function notify(type) {
  debug('notify', type);
  subscribers[type].forEach(function (s) {
    s();
  });
}

function onContainerClick(e) {
  debug('onContainerClick accountUpgrade=%o isPremium=%o', accountUpgrade, isPremium);
  if (e.target && e.target.className === HPTO_BUTTON_CLASS) {
    if (isPremium) {
      containerEl.classList.add(HPTO_CLOSED_CLASS);
      uiPref.set('hide_hpto', true);
      window.parent.sessionStorage['ui.hide_hpto'] = true;
      logEvent('event_collapsed', {}, buttonData);
      disable();
    }
    return;
  }
  if (accountUpgrade) {
    e.preventDefault();
    e.stopPropagation();
    window.parent.postMessage({
      type: _eventTypes2.default.NAVIGATION_UPGRADE,
      data: { tracking: accountUpgradeTracking }
    }, '*');
  }
}

function enable() {
  debug('enable');

  containerEl.addEventListener('click', onContainerClick);

  if (isPreview()) {
    handlePreviewUri();
    return;
  }

  if (enabling) {
    debug('enabling already');
    return;
  }
  enabling = true;

  var sessionData = _session2.default.get();
  var hptoSasEnabled = false;
  isPremium = sessionData.isPremium;
  debug('load session: %o', sessionData);

  abba.getAdsHptoSas().then(function (enabled) {
    hptoSasEnabled = enabled;
    return _settings2.default.getHidePref(sessionData.platform, sessionData.isPremium);
  }).then(function (isHidden) {
    if (!isHidden) {
      (function () {
        containerEl.classList.remove(HPTO_CLOSED_CLASS);
        var adContainer = createAndUpdateContainers();

        var useProxy = _productState2.default.isProxyAdRequester() && hptoSasEnabled;
        debug('render with data: %o. useProxy=%o', sessionData, useProxy);

        var getter = useProxy ? _getAdProxy.get : _getAdDirect.get;

        getter(sessionData, adContainer).then(function (adData) {
          addCreativeIdTo(adData, adContainer);
          return renderAd(adData, adData.loaderFrame, adContainer);
        }).then(function (adData) {
          enabling = false;
          logEvent('event_viewed', {}, adData);
          notify(RENDER_EVENT);
        }).catch(function (e) {
          logError('enable error: ' + e);
          adContainer = null;
          disable();
        });
      })();
    } else {
      logError('attempted to enable but user has hpto hidden');
      disable();
    }
  });
}

function createAndUpdateContainers() {
  var adContainer = document.createElement('div');
  adContainer.classList.add(AD_CONTAINER_CLASS);
  adContainer.classList.add(HIDDEN_CLASS);
  var previousAdContainer = containerEl.querySelector('.' + AD_CONTAINER_CLASS);
  if (previousAdContainer) {
    debug('adding classing to previousAdContainer');
    previousAdContainer.classList.add(PREVIOUS_AD_CONTAINER_CLASS);
  }
  containerEl.appendChild(adContainer);
  return adContainer;
}

function disable() {
  debug('disable');
  enabling = false;

  containerEl.innerHTML = '';
  if (renderedView) {
    renderedView.disable();
  }
  renderedView = null;
  clearCrashData();

  containerEl.removeEventListener('click', onContainerClick);
  notify(HIDE_EVENT);
}

/**
 * Reads the arguments for a GID and executes an HPTO preview request,
 * rendering the result if successful.
 * @private
 *
 * @param {Array} [args] List of app arguments containing the GID.  If this parameter
 *   is undefined, the initial app arguments will be used.
 */
function handlePreviewUri(args) {
  debug('handlePreviewUri');
  var gid = _utils2.default.parseGID(args || getAppArguments());

  _cosmosConnector2.default.getPreviewAd(gid).then(function (res) {
    var adContainer = createAndUpdateContainers();
    var ad = res.ad;
    var adData = (0, _hptoResponse2.default)(ad.hpto || ad);
    var loaderFrame = _utils2.default.createInteractiveIframe(adData.html || null);
    loaderFrame.style.display = 'none';
    adContainer.appendChild(loaderFrame);
    addCreativeIdTo(adData, adContainer);
    return renderAd(adData, loaderFrame, adContainer);
  }).then(function () {
    notify(RENDER_EVENT);
  }).catch(function (e) {
    logError('handlePreviewUri: ' + e.message);
    disable();
  });
}

function getAppArguments() {
  return application.get('arguments');
}

function isPreview(argsParam) {
  var args = argsParam || getAppArguments();
  return !!(args && _utils2.default.parseGID(args));
}

function addCreativeIdTo(data, adContainer) {
  debug('add creativeId from data: %o', data);
  adContainer.setAttribute('data-id', data.creativeId);

  var adInfo = {
    creativeId: data.creativeId,
    lineItemId: data.lineItemId
  };

  adContainer.setAttribute('data-uri', JSON.stringify(adInfo));
  adContainer.setAttribute('data-contextmenu', '');
}

function renderAd(adData, loaderFrame, adContainer) {
  debug('renderAd isPremium=%o, adData=%o', isPremium, adData);
  setCrashData(adData);
  renderedView = VIEW_MAP[adData.bannerMode];
  accountUpgrade = adData.accountUpgrade;
  accountUpgradeTracking = adData.accountUpgradeTracking;
  return renderedView.render({
    adData: adData,
    domEl: adContainer,
    isPremium: isPremium,
    loaderFrame: loaderFrame,
    onClick: viewOnClick.bind(null, adData, adContainer)
  }).then(function () {
    var previousAdContainer = containerEl.querySelector('.' + PREVIOUS_AD_CONTAINER_CLASS);
    if (previousAdContainer) {
      debug('remove previousAdContainer');
      containerEl.removeChild(previousAdContainer);
    }
    adContainer.classList.remove(HIDDEN_CLASS);
    appendHideButton(adData, adContainer);
    var urls = _utils2.default.getProp('tracking urls', adData);
    var url = _utils2.default.getProp('tracking url', adData);
    if (urls) {
      debug('tracking-urls', urls);
      urls.forEach(function (trackingUrl) {
        if (trackingUrl) {
          _utils2.default.appendTrackingPixel(trackingUrl, adContainer, 'view-tracking');
        }
      });
    } else if (url) {
      // This is a safety net to make sure we updated all the templates.
      console.error('HPTO template missing tracking-urls property. Update now!');
      _utils2.default.appendTrackingPixel(url, adContainer, 'view-tracking');
    }
    return adData;
  });
}

function viewOnClick(adData, adContainer, e, data) {
  if (adData.click) {
    _utils2.default.appendTrackingPixel(adData.click, adContainer, 'click-tracking');
  }
  if (data && data.context) {
    adData.context = data.context;
  }
  logEvent('event_clicked', {}, adData);
}

function logEvent(eventType, jsonData, adData) {
  debug('logEvent type=%o, jsonData=%o, adData=%o', eventType, jsonData, adData);
  return _AdEvent2.default.log({
    'slot': 'hpto',
    'event': eventType,
    'lineitem_id': String(adData.lineItemId),
    'creative_id': String(adData.creativeId),
    'ad_id': String(adData.creativeId),
    'ad_format': 'hpto ' + adData.bannerMode,
    'context': String(adData.context || ''),
    'jsondata': JSON.stringify(jsonData)
  });
}

function logError(message) {
  debug('logError message=%o', message);
  _AdError2.default.log({
    'request_type': 'hpto',
    'error_message': message
  });
}

function appendHideButton(data, adContainer) {
  // Don't show button for sponsored hptos
  if (!(_utils2.default.getProp('native hpto type', data) === 'sponsored')) {
    buttonData = data;
    var hideBtn = document.createElement('span');
    hideBtn.classList.add(HPTO_BUTTON_CLASS);

    if (isPremium) {
      hideBtn.innerHTML = _i18n2.default.get('HideAnnouncements');
    } else {
      hideBtn.innerHTML = _i18n2.default.get('Sponsored');
      hideBtn.classList.add('no-hover');
    }

    adContainer.appendChild(hideBtn);
  }
}

},{"../../../../event-types":125,"../../../../message-proxy":214,"../../../../spotify-live":512,"../../../../spotify-logger/messages/AdError2":524,"../../../../spotify-logger/messages/AdEvent4":525,"../../../../spotify-preferences":550,"../../../i18n":50,"../../cosmos-connector":75,"../../product-state":116,"../../session":117,"../../settings":118,"../../utils":120,"./abba":90,"./get-ad-direct":91,"./get-ad-proxy.js":92,"./hpto-response":93,"./views/html-hpto-view":99,"./views/image-hpto-view":100,"./views/native-hpto-view":101,"debug":582}],95:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  nativeEl: require('./native_element_ad_tpl.hbs'),
  sponsored: require('./sponsored_hpto_tpl.hbs')
};

},{"./native_element_ad_tpl.hbs":96,"./sponsored_hpto_tpl.hbs":97}],96:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  
  return "verified";
  }

function program3(depth0,data) {
  
  
  return "?action=browse";
  }

function program5(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n                ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.imageUrl), {hash:{},inverse:self.noop,fn:self.program(6, program6, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n              ";
  return buffer;
  }
function program6(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n                  <div class=\"mo-image-background-color\">\n	      <div class=\"mo-image-background\" style=\"background-image: url(";
  if (helper = helpers.smallImageUri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.smallImageUri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + ")\"></div>\n                  </div>\n                ";
  return buffer;
  }

function program8(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n            <img src=\"";
  if (helper = helpers.sponsoredLogo) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.sponsoredLogo); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"/>\n            <p>Presents</p>\n          ";
  return buffer;
  }

function program10(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <div class=\"ne-attrib\">\n    <a href=\"";
  if (helper = helpers.attributionUri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.attributionUri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.attributionUri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.attributionUri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"  id=\"ne-attrib-link\">";
  if (helper = helpers.attribution) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.attribution); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</a>\n        </div>\n        ";
  return buffer;
  }

function program12(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "\n              <div class=\"b-add-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Save", options) : helperMissing.call(depth0, "loc", "Save", options)))
    + "</div>\n              <div class=\"b-added-text b-alt-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Saved", options) : helperMissing.call(depth0, "loc", "Saved", options)))
    + "</div>\n              <div class=\"b-remove-text b-alt-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Remove", options) : helperMissing.call(depth0, "loc", "Remove", options)))
    + "</div>\n            ";
  return buffer;
  }

function program14(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "\n              <div class=\"b-add-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Follow", options) : helperMissing.call(depth0, "loc", "Follow", options)))
    + "</div>\n              <div class=\"b-added-text b-alt-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Following", options) : helperMissing.call(depth0, "loc", "Following", options)))
    + "</div>\n              <div class=\"b-remove-text b-alt-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Unfollow", options) : helperMissing.call(depth0, "loc", "Unfollow", options)))
    + "</div>\n            ";
  return buffer;
  }

  buffer += "<header class=\"header header-album ne-header\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n  <div class=\"ne-left-fade\"></div>\n\n  <section class=\"h-main-content container clearfix ne-container\">\n    <div class=\"ne-container-center\">\n      <div class=\"h-media\">\n        <div class=\"media-object media-object-simple media-object-link media-object-"
    + escapeExpression(((stack1 = (depth0 && depth0.type)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " "
    + escapeExpression(((stack1 = (depth0 && depth0.type)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.isVerified), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" data-context=\"\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-context=\"media-object\">\n          <div class=\"mo-image-wrapper\">\n            <a href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1);
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "track", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "track", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" title=\"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"media-image\" id=\"ne-image-link\">\n              <svg class=\"mo-placeholder\" viewBox=\"0 0 10 10\" preserveAspectRatio=\"xMidYMid meet\">\n                <text class=\"playlist-placeholder\" x=\"5\" y=\"9.8\"></text>\n                <text class=\"album-placeholder\" x=\"5\" y=\"9.8\"></text>\n                <text class=\"artist-placeholder\" x=\"5\" y=\"9.8\"></text>\n                <text class=\"user-placeholder\" x=\"5\" y=\"9.8\"></text>\n              </svg>\n              ";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "album", "playlist", "track", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "album", "playlist", "track", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n	<div class=\"mo-image\" style=\"background-image: url(";
  if (helper = helpers.smallImageUri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.smallImageUri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + ")\">\n                <span class=\"mo-verified\">\n                  <span class=\"spoticon-check-16\"></span>\n                </span>\n              </div>\n            </a>\n          </div>\n        </div>\n      </div>\n      <div class=\"h-data\">\n        <div class=\"h-label ";
  if (helper = helpers.badgeType) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.badgeType); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n          ";
  if (helper = helpers.typeLabel) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.typeLabel); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n          ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.sponsoredLogo), {hash:{},inverse:self.noop,fn:self.program(8, program8, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        </div>\n\n  <h1 class=\"h-title ne-title\" data-contextmenu>\n          <a href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1);
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "track", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "track", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" id=\"ne-name-link\">\n            <span class=\"ne-underline\">";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</span>\n          </a>\n        </h1>\n\n        ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.attribution), {hash:{},inverse:self.noop,fn:self.program(10, program10, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n        <div class=\"h-description\">\n          ";
  if (helper = helpers.blurb) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.blurb); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n        </div>\n\n        <div class=\"h-controllers\" data-context data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n    <button class=\"button button-green button-play\" data-context data-button=\"play\" id=\"ne-play-button\" data-uri=\"";
  if (helper = helpers.playBtnUri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.playBtnUri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n            <div class=\"b-play-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Play", options) : helperMissing.call(depth0, "loc", "Play", options)))
    + "</div>\n            <div class=\"b-pause-text b-alt-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Pause", options) : helperMissing.call(depth0, "loc", "Pause", options)))
    + "</div>\n          </button>\n          <button class=\"button button-with-stroke button-add\" data-button=\"add\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" id=\"ne-save-button\">\n            ";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(12, program12, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "track", "album", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "track", "album", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n            ";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(14, program14, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "playlist", "user", "artist", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "playlist", "user", "artist", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n          </button>\n          <button class=\"button button-icon-with-stroke spoticon-more-16\" data-button=\"contextmenu\" data-tooltip=\"More\" id=\"ne-more-button\"></button>\n        </div>\n      </div>\n    </div>\n  </section>\n\n  <div class=\"ne-right-fade\"></div>\n  <div class=\"ne-bottom-fade\"></div>\n  <div class=\"ne-bg-image bg-centered blurred ne-"
    + escapeExpression(((stack1 = (depth0 && depth0.type)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" style=\"background-image: url('";
  if (helper = helpers.backgroundImage) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.backgroundImage); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "');\"></div>\n</header>\n";
  return buffer;
  });

},{"hbsfy/runtime":615}],97:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  
  return "verified";
  }

function program3(depth0,data) {
  
  
  return "?action=browse";
  }

function program5(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n                ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.imageUrl), {hash:{},inverse:self.noop,fn:self.program(6, program6, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n              ";
  return buffer;
  }
function program6(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n                  <div class=\"mo-image-background-color\">\n                    <div class=\"mo-image-background\" style=\"background-image: url(";
  if (helper = helpers.smallImageUri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.smallImageUri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + ")\"></div>\n                  </div>\n                ";
  return buffer;
  }

function program8(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <div class=\"ne-attrib\">\n          <a href=\"";
  if (helper = helpers.attributionUri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.attributionUri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.attributionUri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.attributionUri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"  id=\"ne-attrib-link\">";
  if (helper = helpers.attribution) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.attribution); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</a>\n        </div>\n        ";
  return buffer;
  }

function program10(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "\n              <div class=\"b-add-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Save", options) : helperMissing.call(depth0, "loc", "Save", options)))
    + "</div>\n              <div class=\"b-added-text b-alt-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Saved", options) : helperMissing.call(depth0, "loc", "Saved", options)))
    + "</div>\n              <div class=\"b-remove-text b-alt-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Remove", options) : helperMissing.call(depth0, "loc", "Remove", options)))
    + "</div>\n            ";
  return buffer;
  }

function program12(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "\n              <div class=\"b-add-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Follow", options) : helperMissing.call(depth0, "loc", "Follow", options)))
    + "</div>\n              <div class=\"b-added-text b-alt-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Following", options) : helperMissing.call(depth0, "loc", "Following", options)))
    + "</div>\n              <div class=\"b-remove-text b-alt-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Unfollow", options) : helperMissing.call(depth0, "loc", "Unfollow", options)))
    + "</div>\n            ";
  return buffer;
  }

  buffer += "<header class=\"header-album\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-contextmenu>\n  <div class=\"ne-left-fade\" style=\"width:590px\"></div>\n\n  <section class=\"h-main-content container clearfix ne-container sponsored\" style=\"padding:16px\">\n    <div class=\"ne-container-center\" style=\"overflow:auto; margin:0\">\n      <div class=\"sponsorship\" style=\"overflow:auto;margin-bottom:48px\">\n        <div class=\"h-label\">\n          <p style=\"margin:0\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "PresentedBy", options) : helperMissing.call(depth0, "loc", "PresentedBy", options)))
    + "</p>\n          <img src=\"";
  if (helper = helpers.sponsoredLogo) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.sponsoredLogo); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" style=\"margin:4px 0;height:40px\"/>\n          <p style=\"text-transform:none;margin-top:2px\">";
  if (helper = helpers.logoBlurb) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.logoBlurb); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</p>\n        </div>\n      </div>\n      <div class=\"h-media\" style=\"width:172px\">\n        <div class=\"media-object media-object-simple media-object-link media-object-"
    + escapeExpression(((stack1 = (depth0 && depth0.type)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " "
    + escapeExpression(((stack1 = (depth0 && depth0.type)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.isVerified), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" data-context=\"\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-context=\"media-object\">\n          <div class=\"mo-image-wrapper\">\n            <a href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1);
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "track", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "track", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" title=\"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"media-image\" id=\"ne-image-link\">\n              <svg class=\"mo-placeholder\" viewBox=\"0 0 10 10\" preserveAspectRatio=\"xMidYMid meet\">\n                <text class=\"playlist-placeholder\" x=\"5\" y=\"9.8\"></text>\n                <text class=\"album-placeholder\" x=\"5\" y=\"9.8\"></text>\n                <text class=\"artist-placeholder\" x=\"5\" y=\"9.8\"></text>\n                <text class=\"user-placeholder\" x=\"5\" y=\"9.8\"></text>\n              </svg>\n              ";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "album", "playlist", "track", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "album", "playlist", "track", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n              <div class=\"mo-image\" style=\"background-image: url(";
  if (helper = helpers.smallImageUri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.smallImageUri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + ")\">\n                <span class=\"mo-verified\">\n                  <span class=\"spoticon-check-16\"></span>\n                </span>\n              </div>\n            </a>\n          </div>\n        </div>\n      </div>\n      <div class=\"h-data\">\n        <div class=\"h-label\">\n          ";
  if (helper = helpers.typeLabel) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.typeLabel); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        </div>\n\n        <h1 class=\"h-title ne-title\" data-contextmenu>\n          <a href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1);
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "track", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "track", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" id=\"ne-name-link\">\n            <span class=\"ne-underline\">";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</span>\n          </a>\n        </h1>\n\n        ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.attribution), {hash:{},inverse:self.noop,fn:self.program(8, program8, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n        <div class=\"h-description\">\n          ";
  if (helper = helpers.blurb) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.blurb); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n        </div>\n\n        <div class=\"h-controllers\" data-context data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" style=\"bottom:16px\">\n          <button class=\"button button-green button-play\" data-context data-button=\"play\" id=\"ne-play-button\" data-uri=\"";
  if (helper = helpers.playBtnUri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.playBtnUri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n            <div class=\"b-play-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Play", options) : helperMissing.call(depth0, "loc", "Play", options)))
    + "</div>\n            <div class=\"b-pause-text b-alt-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Pause", options) : helperMissing.call(depth0, "loc", "Pause", options)))
    + "</div>\n          </button>\n          <button class=\"button button-with-stroke button-add\" data-button=\"add\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" id=\"ne-save-button\">\n            ";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(10, program10, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "track", "album", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "track", "album", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n            ";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(12, program12, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "playlist", "user", "artist", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "playlist", "user", "artist", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n          </button>\n          <button class=\"button button-icon-with-stroke spoticon-more-16\" data-button=\"contextmenu\" data-tooltip=\"More\" id=\"ne-more-button\"></button>\n        </div>\n      </div>\n    </div>\n    <img class=\"sponsored-credits\" src=\"";
  if (helper = helpers.credits) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.credits); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"/>\n  </section>\n\n  <div class=\"ne-bottom-fade\"></div>\n  <div class=\"ne-bg-image ne-"
    + escapeExpression(((stack1 = (depth0 && depth0.type)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" style=\"background-image: url('";
  if (helper = helpers.backgroundImage) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.backgroundImage); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "');\"></div>\n</header>\n";
  return buffer;
  });

},{"hbsfy/runtime":615}],98:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _spotifyEventDispatcher = require('../../../../spotify-event-dispatcher');

var _spotifyEventDispatcher2 = _interopRequireDefault(_spotifyEventDispatcher);

var _messageProxy = require('../../../../message-proxy');

var _eventTypes = require('../../../../event-types');

var _eventTypes2 = _interopRequireDefault(_eventTypes);

var _cosmosConnector = require('../../cosmos-connector');

var _cosmosConnector2 = _interopRequireDefault(_cosmosConnector);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _spotifyLocalStorage = require('../../../../spotify-local-storage');

var _spotifyLocalStorage2 = _interopRequireDefault(_spotifyLocalStorage);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = (0, _debug2.default)('saf:hpto:provider');

var SLOT_HPTO = 'hpto';
var SLOT_TYPE_DISPLAY = 'banner';
var AVAILABLE = 'available';
var PLAY = 'play';
var ON_EVENT = [AVAILABLE, PLAY].reduce(function (acc, ev) {
  acc[ev] = [];
  return acc;
}, {});
var SETTINGS_KEY_AD = 'saf:hpto:ad';

var currentAd = void 0;
var initialized = false;
var fetching = false; // this will be an active promise or false
var unsubscribeHptoReply = function unsubscribeHptoReply() {};

var API = {
  init: function init() {
    if (initialized) {
      return;
    }
    initialized = true;

    debug('init');

    var val = _spotifyLocalStorage2.default.get(SETTINGS_KEY_AD);
    try {
      currentAd = JSON.parse(val);
    } catch (e) {
      debug('error parsing locally stored ad: %o', e);
    }

    _cosmosConnector2.default.addNewSlot(SLOT_HPTO, SLOT_TYPE_DISPLAY).then(function () {
      _cosmosConnector2.default.enableSlot(SLOT_HPTO);
      _cosmosConnector2.default.subscribeToSlotType(SLOT_HPTO, consumeEvent);
      _spotifyEventDispatcher2.default.addEventListener(_eventTypes2.default.DEBUG_FORCE_REFRESH_HPTO, onHptoRefresh);
      fetching = fetchAd();
    });
    unsubscribeHptoReply = (0, _messageProxy.messageProxy)({ method: 'REPLY', uri: 'hpto' }, onHptoReply);
  },
  destroy: function destroy() {
    if (!initialized) {
      return;
    }
    initialized = false;
    unsubscribeHptoReply();
    _spotifyEventDispatcher2.default.removeEventListener(_eventTypes2.default.DEBUG_FORCE_REFRESH_HPTO, onHptoRefresh);
  },
  clearLocalStorageAd: function clearLocalStorageAd() {
    _spotifyLocalStorage2.default.remove(SETTINGS_KEY_AD, function (e) {
      if (!e) {
        debug('localStorage cleared');
      }
    });
  }
};

exports.default = API;


function fetchAd() {
  debug('fetchAd');
  return triggerFetch().then(triggerPlay).then(function (ad) {
    debug('storeAd: %o', ad);
    currentAd = ad;
    _spotifyLocalStorage2.default.set(SETTINGS_KEY_AD, JSON.stringify(currentAd));
    _cosmosConnector2.default.triggerSlotClear(SLOT_HPTO);
    return currentAd;
  }).catch(function () {
    debug('fetchAd error');
    return false;
  }).then(function (res) {
    fetching = false;
    return res;
  });
}

function triggerFetch() {
  debug('triggerFetch');
  return new Promise(function (resolve, reject) {
    _cosmosConnector2.default.triggerSlotFetch(SLOT_HPTO).catch(function (e) {
      ON_EVENT[AVAILABLE] = []; // clear out the stored resolve;
      reject(e);
    });
    ON_EVENT[AVAILABLE].push(resolve);
  });
}

function triggerPlay() {
  debug('triggerPlay');
  return new Promise(function (resolve, reject) {
    _cosmosConnector2.default.triggerSlotPlay(SLOT_HPTO).catch(function (e) {
      ON_EVENT[PLAY] = []; // clear out the stored resolve;
      reject(e);
    });
    ON_EVENT[PLAY].push(resolve);
  });
}

/**
 * Handles a cosmos event and fires any queued handlers for the event type, which
 * may resolve promises waiting for these events to occur.
 */
function consumeEvent(event) {
  if (event.event in ON_EVENT) {
    debug('cosmos event: %o', event);
    ON_EVENT[event.event].forEach(function (cb) {
      return cb(event.ad);
    });
    ON_EVENT[event.event] = []; // clear out the Promise.resolve
  }
}

function onHptoRefresh() {
  fetchAd().then(function () {
    (0, _messageProxy.messageProxy)({ method: 'POST', uri: 'hpto-refresh' });
  });
}

function onHptoReply(req, reply) {
  debug('onHptoReply currentAd=%o fetching=%o', currentAd, Boolean(fetching));
  if (currentAd) {
    reply(null, { ad: currentAd });
    fetching = fetchAd(); // refresh the ad everytime this request is made
    return;
  }
  if (!fetching) {
    fetching = fetchAd();
  }
  fetching.then(function (ad) {
    if (!ad) {
      reply('no ad from hpto:provider available');
    } else {
      reply(null, { ad: ad });
    }
  });
}

},{"../../../../event-types":125,"../../../../message-proxy":214,"../../../../spotify-event-dispatcher":234,"../../../../spotify-local-storage":517,"../../cosmos-connector":75,"debug":582}],99:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.render = render;
exports.disable = disable;

var _utils = require('../../../utils');

var _utils2 = _interopRequireDefault(_utils);

var _externalTags = require('../../../external-tags');

var _viewUtils = require('./view-utils');

var _viewUtils2 = _interopRequireDefault(_viewUtils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var cleanUp = [];

function onContainerClick(url, onClick, e) {
  window.open(url);
  onClick(e);
}

/**
 * Even though these are sync they need to return a Promise
 * because Native Hpto Returns a promise.
 * @return {Promise}
 */
function render(opts) {
  var data = opts.adData;
  var bgImg = _utils2.default.getProp('background image', data);
  var loaderFrame = opts.loaderFrame;

  if (!data.html && !bgImg && !loaderFrame) {
    throw new Error('[Html HPTO] Missing image / html / loaderFrame');
  }

  var domEl = opts.domEl;

  if (bgImg) {
    domEl.style.backgroundImage = 'url(' + _viewUtils2.default.getImageLink(bgImg) + ')';
  }

  domEl.classList.add('min-width');

  // Fire comscore pixel
  _utils2.default.appendTrackingPixel(_externalTags.comscore, domEl);

  var frame = void 0;
  if (loaderFrame) {
    loaderFrame.style.display = '';
    frame = loaderFrame;
  } else {
    frame = _utils2.default.createInteractiveIframe(data.html);
    domEl.appendChild(frame);
  }

  var bgUrl = _utils2.default.getProp('background url', data);
  if (bgUrl) {
    (function () {
      var boundClickListener = onContainerClick.bind(null, bgUrl, opts.onClick);
      domEl.addEventListener('click', boundClickListener);
      domEl.classList.add('interactive');

      cleanUp.push(function () {
        domEl.removeEventListener('click', boundClickListener);
      });
    })();
  }

  var bgColor = _utils2.default.getProp('background color', data);
  if (bgColor) {
    domEl.style.backgroundColor = (bgColor[0] === '#' ? '' : '#') + bgColor;
  }

  return Promise.resolve(true);
}

function disable() {
  cleanUp.forEach(function (fn) {
    fn();
  });
  cleanUp = [];
}

},{"../../../external-tags":81,"../../../utils":120,"./view-utils":102}],100:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.render = render;
exports.disable = disable;

var _utils = require('../../../utils');

var _utils2 = _interopRequireDefault(_utils);

var _viewUtils = require('./view-utils');

var _viewUtils2 = _interopRequireDefault(_viewUtils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var cleanUp = [];

/**
 * Even though these are sync they need to return a Promise
 * because Native Hpto Returns a promise.
 * @return {Promise}
 */
function render(opts) {
  if (!_utils2.default.getProp('background image', opts.adData)) {
    throw new Error('[Image HPTO] Missing background image');
  }

  var data = opts.adData;
  var domEl = opts.domEl;
  var bgImg = _utils2.default.getProp('background image', data);
  var bgColor = _utils2.default.getProp('background color', data);
  var bgUrl = _utils2.default.getProp('background url', data);
  var clickThrough = bgUrl && bgUrl.replace(/&amp;/g, '&');

  domEl.style.backgroundImage = 'url(' + _viewUtils2.default.getImageLink(bgImg) + ')';

  if (bgColor) {
    domEl.style.backgroundColor = (bgColor[0] === '#' ? '' : '#') + bgColor;
  }

  var image = document.createElement('a');
  image.classList.add('hpto-interactive');
  image.setAttribute('data-id', 'dfp-' + Date.now());

  domEl.appendChild(image);

  function onAdClick(e) {
    e.preventDefault();
    if (!data.accountUpgrade) {
      window.open(clickThrough);
    }
    if (opts.onClick) {
      opts.onClick(e);
    }
  }

  domEl.addEventListener('click', onAdClick);
  cleanUp.push(function () {
    domEl.removeEventListener('click', onAdClick);
  });

  return Promise.resolve(true);
}

function disable() {
  cleanUp.forEach(function (fn) {
    fn();
  });
  cleanUp = [];
}

},{"../../../utils":120,"./view-utils":102}],101:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.render = render;
exports.disable = disable;

var _spotifyLive = require('../../../../../spotify-live');

var _spotifyLive2 = _interopRequireDefault(_spotifyLive);

var _utils = require('../../../utils');

var _utils2 = _interopRequireDefault(_utils);

var _nativeTpl = require('../native-tpl');

var _nativeTpl2 = _interopRequireDefault(_nativeTpl);

var _configuration = require('../../../configuration');

var _configuration2 = _interopRequireDefault(_configuration);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = require('debug')('saf:native-hpto-view');

var CLICK_TRACKING_ELEMENT_IDS = ['ne-play-button', 'ne-save-button', 'ne-more-button', 'ne-image-link', 'ne-name-link', 'ne-attrib-link'];

var LIVE_QUERY_PARAMS = {
  'playlist': 'name, image, annotatedImage',
  'album': 'name, image, artists(name, uri)',
  'track': 'name, image, artists(uri)',
  'artist': 'name, image'
};

var TYPE_LABELS = {
  'track': 'single',
  'album': 'album',
  'artist': 'artist',
  'playlist': 'playlist'
};

var cleanUp = [];

function render(opts) {
  if (!_utils2.default.getProp('target uri', opts.adData)) {
    throw new Error('[Native HPTO] Missing a target uri');
  }

  var data = opts.adData;
  var domEl = opts.domEl;
  var onClick = opts.onClick;
  var dfpProps = parseDfpProps(data);

  return getLiveProps(dfpProps.uri, dfpProps.uriType).then(function (liveProps) {
    var mergedData = mergeProps(dfpProps, liveProps);
    var tpl = void 0;

    switch (mergedData.nativeHptoType) {
      case 'original':
        tpl = _nativeTpl2.default.nativeEl;
        break;
      case 'sponsored':
        tpl = _nativeTpl2.default.sponsored;
        break;
      default:
        throw new Error('Invalid hpto type: ' + mergedData.nativeHptoType);
    }

    domEl.innerHTML = tpl(mergedData);

    CLICK_TRACKING_ELEMENT_IDS.forEach(function (id) {
      var el = domEl.querySelector('#' + id);
      if (!el) return;
      var boundOnClick = onBtnClick.bind(null, id, mergedData, onClick);
      el.addEventListener('click', boundOnClick);
      cleanUp.push(function () {
        return el.removeEventListener('click', boundOnClick);
      });
    });
  });
}

function parseDfpProps(data) {
  var props = {};
  props.uri = _utils2.default.getProp('target uri', data);
  props.playBtnUri = _utils2.default.getProp('play btn uri', data) || props.uri;
  props.uriType = _utils2.default.getType(props.uri);
  props.bgImage = _utils2.default.getProp('background image', data) || '';
  props.badgeType = (data.badge || '').toLowerCase();
  props.typeLabel = typeLabel(props.badgeType) || TYPE_LABELS[props.uriType];
  return Object.assign({}, data, props);
}

function typeLabel(badge) {
  if (badge === 'exclusive') {
    return 'spotify exclusive';
  } else if (badge === 'spotlight') {
    return _configuration2.default.getSpotlightSvg();
  }
  return null;
}

function getLiveProps(uri, uriType) {
  return new Promise(function (res, rej) {
    (0, _spotifyLive2.default)(uri).query(LIVE_QUERY_PARAMS[uriType], function (err, data) {
      if (err) rej(err);

      Object.keys(data).forEach(function (key) {
        if (!data[key]) debug('Returned empty field for:', key);
      });

      res(data);
    }, 5000);
  });
}

function mergeProps(dfpProps, liveProps) {
  var PLAYLIST_BG = 'http://i.scdn.co/image/03fa7db6aae8ffb4a936d0fe5a4f419199c313a9';
  var props = {};

  props.isVerified = !!(dfpProps.uriType === 'artist' && liveProps.name);
  props.name = liveProps.name;

  var preferredImage = liveProps.annotatedImage || liveProps.image;
  props.smallImageUri = preferredImage;
  props.backgroundImage = preferredImage;

  switch (dfpProps.uriType) {
    case 'track':
      props.attribution = liveProps.name;
      props.attributionUri = liveProps.artists[0].uri;
      break;
    case 'album':
      props.attribution = liveProps.artists[0].name;
      props.attributionUri = liveProps.artists[0].uri;
      break;
    case 'playlist':
      props.backgroundImage = dfpProps.bgImage || preferredImage || PLAYLIST_BG;
      break;
    default:
      console.error('Bad type: ' + dfpProps.type);
  }

  return Object.assign({}, dfpProps, props);
}

function onBtnClick(id, data, onClick, e) {
  var customTracking = (e.target.getAttribute('data-log-click') || '').split('-')[0];
  var tracking = id + (customTracking ? ':' + customTracking : '');
  _utils2.default.appendTrackingPixel(data.click, e.target);
  if (onClick) {
    onClick(e, {
      'context': tracking
    });
  }
}

function disable() {
  cleanUp.forEach(function (fn) {
    fn();
  });
  cleanUp = [];
}

},{"../../../../../spotify-live":512,"../../../configuration":74,"../../../utils":120,"../native-tpl":95,"debug":582}],102:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var CDN_URL = 'http://d3rt1990lpmkn.cloudfront.net/unbranded/';
var viewUtils = {};

/**
 * Returns a platform specific image URL
 * This returns a CDN URL when on web rather than the play.spotify.com URL
 * returned by .toSpotifyLink()
 *
 * @param  {String} param
 * @return {String}
 */
viewUtils.getImageLink = function (link) {
  if (/^[a-zA-Z0-9]{40}$/.test(link)) {
    return 'spotify:image:' + link;
  } else if (!/^http(s)?:\/\/.*$/.test(link)) {
    return CDN_URL + link;
  }
  return link;
};

exports.default = viewUtils;

},{}],103:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  REFRESH_INTERVAL_KEY: 'leaderboard_refresh_interval',
  DEFAULT_REFRESH_INTERVAL_MS: 30000,
  DEFAULT_CLOSE_LIFETIME_MS: 60 * 60 * 1000,
  DEFAULT_SANDBOX_PARAMS: ['allow-forms', 'allow-pointer-lock', 'allow-popups', 'allow-same-origin', 'allow-scripts'],
  LEADERBOARD_SLOT_ID: 'leaderboard'
};

},{}],104:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _spotifyEventDispatcher = require('../../../../spotify-event-dispatcher');

var _spotifyEventDispatcher2 = _interopRequireDefault(_spotifyEventDispatcher);

var _cosmosConnector = require('../../cosmos-connector');

var _cosmosConnector2 = _interopRequireDefault(_cosmosConnector);

var _AdError = require('../../../../spotify-logger/messages/AdError2');

var _AdError2 = _interopRequireDefault(_AdError);

var _CONSTANTS = require('./CONSTANTS');

var _CONSTANTS2 = _interopRequireDefault(_CONSTANTS);

var _util = require('./util');

var _util2 = _interopRequireDefault(_util);

var _eventTypes = require('../../../../event-types');

var _eventTypes2 = _interopRequireDefault(_eventTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var debug = require('debug')('saf:leaderboard');

var DEFAULT_AD_WIDTH = 728;
var DEFAULT_AD_HEIGHT = 90;

/**
 * Leaderboard ad view class, which makes hm://ads/ requests
 * to retrieve configuration details and display 728x90 or 970x250 ads.
 */

var LeaderboardAd = function () {
  function LeaderboardAd(domElement) {
    var _this = this;

    _classCallCheck(this, LeaderboardAd);

    debug('init leaderboard v3');
    this.domElement = domElement;
    this.refreshInterval = _CONSTANTS2.default.DEFAULT_REFRESH_INTERVAL_MS;
    this.sandboxParams = _CONSTANTS2.default.DEFAULT_SANDBOX_PARAMS;
    this.refreshTimer = undefined;
    this.closeLifetimeMs = _CONSTANTS2.default.DEFAULT_CLOSE_LIFETIME_MS;
    var leaderboardVersion = 3;

    this.onLeaderboardMessage = _util2.default.leaderboardMessageHandler(_spotifyEventDispatcher2.default, domElement, leaderboardVersion);

    _spotifyEventDispatcher2.default.addEventListener(_eventTypes2.default.DEBUG_OVERRIDE_AD_LEADERBOARD_HTML, function (e) {
      _this._overrideAdHtml = e.params.html;
    });
    _spotifyEventDispatcher2.default.addEventListener(_eventTypes2.default.DEBUG_FORCE_REFRESH_LEADERBOARD, function () {
      _this.disable();
      _this.enable();
    });
    _spotifyEventDispatcher2.default.addEventListener(_eventTypes2.default.DEBUG_OVERRIDE_AD_LEADERBOARD_FLAGS, function (e) {
      _this._adSlotFlags = e.params.flags;
    });
    _spotifyEventDispatcher2.default.addEventListener(_eventTypes2.default.DEBUG_OVERRIDE_AD_LEADERBOARD_REFRESH_INTERVAL, function (e) {
      _this._overrideRefreshInterval = e.params.interval;
      _this.enableRefresh();
    });

    _spotifyEventDispatcher2.default.addEventListener('open-url-block', function (e) {
      _util2.default.activateClickBlockOverlay(e.params['iframe-name'], e.params.url);
    });

    this.renderNext.bound = this.renderNext.bind(this);

    // Subscribe to preview events from core
    _util2.default.subscribeToPreview(_cosmosConnector2.default, document, this.domElement, this.disableRefresh.bind(this));

    // Used to defer enable() of leaderboard that is waiting to cleanup.
    this._cleanupGate = Promise.resolve(true);
  }

  /**
   * Enable the leaderboard component inside the container.
   *
   * @api public
   */


  _createClass(LeaderboardAd, [{
    key: 'enable',
    value: function enable() {
      var _this2 = this;

      if (this._disabling) {
        return Promise.reject(new Error('cannot enable while disabling leaderboard'));
      }
      if (this._closed) {
        return Promise.reject(new Error('cannot enable while leaderbard in a closed state'));
      }
      debug('enable leaderboard');
      this._enabled = true;
      return this._cleanupGate.then(function () {
        if (_this2._enabled) {
          window.addEventListener('message', _this2.onLeaderboardMessage);
          _this2.enableRefresh();
          return _this2.renderNext();
        }
        return Promise.reject(new Error('Leaderboard not enabled'));
      });
    }

    /**
     * Disable the leaderboard component inside the container.
     * @return Promise resolving when disabling is complete.
     * @api public
     */

  }, {
    key: 'disable',
    value: function disable() {
      var _this3 = this;

      debug('disable leaderboard');
      this._enabled = false;
      this.disableRefresh();
      this._disabling = true;
      return this.removeContent().then(function () {
        _this3._disabling = false;
        window.removeEventListener('message', _this3.onLeaderboardMessage);
      });
    }

    /**
     * Enable refreshing the ad, for example, if the user is in focus.
     *
     * @api public
     */

  }, {
    key: 'enableRefresh',
    value: function enableRefresh() {
      this.disableRefresh();
      var refreshInterval = this._overrideRefreshInterval || this.refreshInterval;
      debug('set refresh interval=%o', refreshInterval);
      this.refreshTimer = window.setInterval(this.renderNext.bound, refreshInterval);
    }

    /**
     * Disable refreshing the ad.
     *
     * @api public
     */

  }, {
    key: 'disableRefresh',
    value: function disableRefresh() {
      window.clearInterval(this.refreshTimer);
    }
  }, {
    key: 'onClose',
    value: function onClose() {
      var _this4 = this;

      this._closed = true;
      debug('closing for %o ms', this.closeLifetimeMs);
      setTimeout(function () {
        _this4._closed = false;
      }, this.closeLifetimeMs);
      this.onLeaderboardMessage.logClosed({
        closeLifetimeMs: this.closeLifetimeMs
      });
      return this.disable();
    }

    /**
     * Returns true if the leaderboard ad is in a closed state, which means that
     * enabling will have no effect.
     *
     * @return Boolean value of close state.
     * @api public
     */

  }, {
    key: 'isClosed',
    value: function isClosed() {
      return this._closed;
    }

    /**
     * Clear the content.
     *
     * @return Promise resolving when removing the content is complete.
     * @api public
     */

  }, {
    key: 'removeContent',
    value: function removeContent() {
      var _this5 = this;

      debug('removeContent');
      return this.cleanup().then(function () {
        debug('clearInnerHTML');
        _this5.domElement.innerHTML = '';
      });
    }

    /**
     * Perform cleanup operations on a leaderboard which will be imminently removed.
     *
     * @return Promise resolving when cleanup operation is complete.  This may be immediately
     *   invoked on the job queue if the cleanup_timeout_ms value was never provided by
     *   the backend.
     */

  }, {
    key: 'cleanup',
    value: function cleanup() {
      if (this._cleanup_timeout_ms) {
        this._cleanupGate = this.onLeaderboardMessage.cleanup(window, this._cleanup_timeout_ms);
      }
      return this._cleanupGate;
    }

    /**
     * Handle the config response from spotify-ad-service
     *
     * @api private
     */

  }, {
    key: 'handleConfig',
    value: function handleConfig(config) {
      if (config.focus_time_elapsed_ms) {
        this.refreshInterval = config.focus_time_elapsed_ms;
        this.enableRefresh();
      }
      if (config.iframe_sandboxed_attrs) {
        this.sandboxParams = config.iframe_sandboxed_attributes;
      }
      if (config.close_lifetime_ms) {
        var closeLifetimeMs = parseInt(config.close_lifetime_ms, 10);
        if (closeLifetimeMs) {
          this.closeLifetimeMs = closeLifetimeMs;
        }
      }
    }

    /**
     * Fetch targeting parameters and render the iframe that loads gpt that
     * fetches and renders an ad.
     *
     * @api private
     * @return {Promise}
     */

  }, {
    key: 'renderNext',
    value: function renderNext() {
      var _this6 = this;

      if (this._rendering) {
        return Promise.resolve();
      }
      this._rendering = true;
      return _cosmosConnector2.default.getAdSlotConfig(_CONSTANTS2.default.LEADERBOARD_SLOT_ID).then(function (config) {
        _this6.handleConfig(config);
        debug('received config', config);
      }).catch(function (e) {
        var mesg = e.message ? e.message : String(e);
        _AdError2.default.log({
          'request_type': 'leaderboard:on:config',
          'error_message': mesg
        });
        debug('renderNext:config error: ' + mesg);
      }).then(_cosmosConnector2.default.getLocalTargeting).then(function (targeting) {
        return _cosmosConnector2.default.getAdForSlot(targeting, _CONSTANTS2.default.LEADERBOARD_SLOT_ID, _this6._adSlotFlags);
      }).then(function (ad) {
        debug('received ad', ad);
        if (!_this6._enabled) {
          throw new Error('leaderboard-unit-disabled');
        }

        if (ad.cleanup_timeout_ms) {
          _this6._cleanup_timeout_ms = ad.cleanup_timeout_ms;
        }

        var adDisplay = ad.display.filter(function (display) {
          return display.mimetype === 'text/html';
        })[0];

        var metadata = ad.metadata || {};
        var closeableAfterMs = metadata.closeable_after_ms ? parseInt(metadata.closeable_after_ms, 10) : null;

        var html = adDisplay ? adDisplay.media_file : ad.html;
        var width = adDisplay ? adDisplay.width : DEFAULT_AD_WIDTH;
        var height = adDisplay ? adDisplay.height : DEFAULT_AD_HEIGHT;

        if (!html) {
          throw new Error('ad has no html');
        }

        if (ad.same_frame) {
          _this6.renderSameFrameAd(html, width, height, closeableAfterMs);
        } else {
          _this6.render(_util2.default.iframeWithContent(document, _this6._overrideAdHtml || html, _this6.sandboxParams), width, height, closeableAfterMs);
        }

        _spotifyEventDispatcher2.default.dispatchEvent({
          type: _eventTypes2.default.DEBUG_RECEIVED_AD_LEADERBOARD_HTML,
          params: { html: ad.html },
          extra: {}
        });
      }).catch(function (e) {
        var mesg = e.message ? e.message : String(e);
        _AdError2.default.log({
          'request_type': 'leaderboard:on:ad',
          'error_message': mesg
        });
        debug('renderNext error: ' + mesg);
      }).then(function () {
        _this6._rendering = false;
      });
    }

    /**
     * Render an ad in the top-level frame
     */

  }, {
    key: 'renderSameFrameAd',
    value: function renderSameFrameAd(html, width, height, closeableAfterMs) {
      var _this7 = this;

      this.cleanup().then(function () {
        var leaderboardDiv = document.createElement('div');
        _this7.render(leaderboardDiv, width, height, closeableAfterMs);
        _util2.default.setAndEvalTrustedHtml(document, leaderboardDiv, _this7._overrideAdHtml || html);
      });
    }

    /**
     * Render an iframe with given src attribute.
     *
     * @api private
     * @param {Element} node The DOM element containing the leaderboard
     * @param {Integer} width The styled width of the generated ad element
     * @param {Integer} width The styled height of the generated ad element
     * @param {Integer} [closeableAfterMs] If set, will render a close button
     */

  }, {
    key: 'render',
    value: function render(node, width, height, closeableAfterMs) {
      debug('render');
      _util2.default.renderLeaderboard(document, this.domElement, node, width, height);
      if (closeableAfterMs) {
        _util2.default.renderCloseButton(document, this.domElement, this.onClose.bind(this), closeableAfterMs);
      }
    }
  }]);

  return LeaderboardAd;
}();

exports.default = LeaderboardAd;

},{"../../../../event-types":125,"../../../../spotify-event-dispatcher":234,"../../../../spotify-logger/messages/AdError2":524,"../../cosmos-connector":75,"./CONSTANTS":103,"./util":105,"debug":582}],105:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _CONSTANTS = require('./CONSTANTS');

var _CONSTANTS2 = _interopRequireDefault(_CONSTANTS);

var _eventTypes = require('../../../../event-types');

var _eventTypes2 = _interopRequireDefault(_eventTypes);

var _uuidJs = require('uuid-js');

var _uuidJs2 = _interopRequireDefault(_uuidJs);

var _AdEvent = require('../../../../spotify-logger/messages/AdEvent4');

var _AdEvent2 = _interopRequireDefault(_AdEvent);

var _i18n = require('../../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = require('debug')('saf:leaderboard');

var slice = [].slice;
var WRAPPER_CLASS = 'leaderboard-ad-wrapper';
var BLOCK_OVERLAY_CLASS = 'click-block-overlay';

var DEFAULT_AD_WIDTH = 728;
var DEFAULT_AD_HEIGHT = 90;

/**
 * Set the innerHTML property of the given node, and then locate and
 * execute all scripts in order, with the following caveats:
 *
 * 1. The scripts MUST be asynchronous
 * 2. The html MUST come from a first-party source, given the security concerns.
 *
 * @param {DOM} document DOM used to generate elements.
 * @param {Element} node Element which will have its innerHTML property set.
 * @param {String} html HTML content which may contain script tags.
 */
function setAndEvalTrustedHtml(doc, node, html) {
  node.innerHTML = html;
  var scripts = slice.apply(node.getElementsByTagName('script'));

  var srcs = scripts.filter(function (script) {
    return script.src;
  }).map(function (script) {
    return script.src;
  });

  srcs.forEach(function (src) {
    var newScript = doc.createElement('script');
    newScript.src = src;
    newScript.async = 1;
    node.appendChild(newScript);
  });

  var bodies = scripts.filter(function (script) {
    return !script.src;
  }).map(function (script) {
    return script.text;
  }).filter(function (text) {
    return text;
  });

  bodies.forEach(function (body) {
    var newScript = doc.createElement('script');
    newScript.text = body;
    node.appendChild(newScript);
  });
}

/**
 * Create an iframe with the given content and sandbox attributes
 *
 * @param {DOM} document
 * @param {String} html HTML to set as the content of the iframe.
 * @param {Array<String>} [sandboxParams] List of sandboxed parameters.
 *   A sensible secure default will be provided which will allow
 *   scripts and same origin, but not top navigation.
 *
 */
function iframeWithContent(document, html) {
  var sandboxParams = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : _CONSTANTS2.default.DEFAULT_SANDBOX_PARAMS;

  var iframe = document.createElement('iframe');
  iframe.sandbox = sandboxParams.join(' ');
  iframe.srcdoc = html;
  iframe.scrolling = 'no';
  iframe.setAttribute('name', 'ads-iframe-' + _uuidJs2.default.create());
  return iframe;
}

/**
 * Render a leaderboard iframe in the provided container element.  The contents
 * of the container will be cleared, and standard styles/ids will be added to
 * the given iframe.
 * @param {DOM} document DOM object.
 * @param {Element} containerElement Element which will contain the leaderboard.
 * @param {Element} leaderboardElement Element with the rendered leaderboard
 *   contents.
 */
function renderLeaderboard(document, containerElement, leaderboardElement, width, height) {
  debug('renderLeaderboard', containerElement, leaderboardElement);
  containerElement.innerHTML = '';
  leaderboardElement.style.display = 'block';
  leaderboardElement.id = 'leaderboard-ad-element';
  if (width && height) {
    leaderboardElement.style.width = width + 'px';
    leaderboardElement.style.height = height + 'px';
    leaderboardElement.style.overflow = 'hidden';
  }
  var wrapper = document.createElement('div');
  wrapper.id = WRAPPER_CLASS;
  wrapper.appendChild(leaderboardElement);

  wrapper.appendChild(createClickBlockOverlay());
  containerElement.appendChild(wrapper);
}

function createClickBlockOverlay() {
  var clickBlockOverlay = document.createElement('a');
  clickBlockOverlay.setAttribute('class', BLOCK_OVERLAY_CLASS);

  var clickButtonWrapper = document.createElement('div');
  clickButtonWrapper.setAttribute('class', 'click-button-wrapper');

  var clickButton = document.createElement('button');
  clickButton.setAttribute('class', 'button button-small button-with-stroke');
  clickButton.setAttribute('type', 'button');
  clickButton.innerHTML = _i18n2.default.get('AdClick');

  clickButtonWrapper.appendChild(clickButton);
  clickBlockOverlay.appendChild(clickButtonWrapper);
  return clickBlockOverlay;
}

function activateClickBlockOverlay(iframeName, url) {
  debug('activateClickBlockOverlay', iframeName, url);
  var wrapper = document.querySelector('#' + WRAPPER_CLASS);
  var iframe = document.querySelector('iframe[name=' + iframeName + ']');
  if (wrapper && iframe) {
    var clickBlockOverlay = wrapper.querySelector('.' + BLOCK_OVERLAY_CLASS);
    clickBlockOverlay.setAttribute('href', url);
    clickBlockOverlay.classList.add('active');
  } else {
    debug('activateClickBlockOverlay: iframe or wrapper not available.');
  }
}

/**
 * Render a close button into the leaderboard container element.
 *
 * @param {DOM} doc The document object
 * @param {Element} containerElement The containing element for the leaderboard
 * @param {Function} onClose Event handler for when the close button is clicked
 * @param {Integer} [activeAfterMs] If provided, sets the "active" class on the
 *   close button after the given number of milliseconds.
 */
function renderCloseButton(doc, containerElement, onClose, activeAfterMs) {
  var closeContainer = doc.createElement('div');
  closeContainer.className = 'close-button-container';
  var button = doc.createElement('a');
  button.setAttribute('data-ta-id', 'leaderboard-close-button');
  button.href = '#';
  if (activeAfterMs) {
    button.className = 'close';
    setTimeout(function () {
      button.className = 'close active';
    }, activeAfterMs);
  } else {
    button.className = 'close active';
  }
  button.setAttribute('aria-hidden', 'true');
  button.innerHTML = '&times;';
  button.addEventListener('click', onClose);
  closeContainer.appendChild(button);
  if (containerElement.firstChild) {
    containerElement.insertBefore(closeContainer, containerElement.firstChild);
  } else {
    containerElement.appendChild(closeContainer);
  }
}

/**
 * Subscribe to leaderboard preview requests delivered via cosmos, and render
 * into the provided DOM element.
 *
 * @param {CosmosConnector} cosmosConnector An instance of cosmos connector
 * @param {DOM} document Root document for generating elements
 * @param {Element} domElement Leaderboard DOM element for setting TA attributes
 * @param {Function} onPreview Executed after a preview has been injected.
 */
function subscribeToPreview(cosmosConnector, document, domElement, onPreview) {
  cosmosConnector.subscribeToFormat('banner', function (data) {
    var display = data.ad.display;
    if (display && display[0].width !== 728) {
      return;
    }
    var html = display[0].media;
    var uri = data.ad.uri;
    var height = display[0].height || DEFAULT_AD_HEIGHT;
    var width = display[0].width || DEFAULT_AD_WIDTH;
    var iframe = iframeWithContent(document, html);
    domElement.setAttribute('data-ta-preview-uri', uri);
    renderLeaderboard(document, domElement, iframe, width, height);
    onPreview();
  });
}

function logEvent(eventType, jsonData, messageExtra) {
  var message = {
    'ad_format': 'banner',
    'slot': _CONSTANTS2.default.LEADERBOARD_SLOT_ID,
    'event': eventType,
    'jsondata': JSON.stringify(jsonData)
  };
  _AdEvent2.default.log(Object.assign(message, messageExtra));
}

/**
 * Generates a handler for leaderboard messages generated by the code
 * injected into the leaderboard iframe.  These messages are expected to
 * have the following shape:
 * {
 *   data: {
 *     type: oneOf(
 *       'ads-leaderboard-failed',
 *       'ads-leaderboard-rendered',
 *       'ads-upgrade-account'
 *     ),
 *     data: {
 *       lineItemId: string,
 *       creativeId: string,
 *     },
 *     click: string,
 *   })
 * }
 *
 * @param {EventDispatcher} eventDispatcher Event dispatcher for UI rendering
 *   purposes.
 * @param {Element} domElement Container element of leaderboard, used to
 *   set attributes for TA systems tests.
 */
function leaderboardMessageHandler(eventDispatcher, domElement, leaderboardVersion) {
  var currentUuid = null;
  var onCleanup = null;
  var renderedAdProps = null;

  var handler = function onLeaderboardMessage(e) {
    if (!e.data || !e.data.type) {
      return; // Not interested in the message
    }
    switch (e.data.type) {

      case 'ads-leaderboard-failed':
        debug('ads-leaderboard-failed: %o', e.data);
        renderedAdProps = null;

        eventDispatcher.dispatchEvent({
          type: _eventTypes2.default.AD_LEADERBOARD_PLACEMENT,
          params: {
            isEmpty: true
          }
        });

        logEvent('event_errored', { dfp_returned_empty: true });
        break;

      case 'ads-leaderboard-rendered':
        debug('ads-leaderboard-rendered: %o', e.data);
        renderedAdProps = {
          'lineitem_id': String(e.data.data.lineItemId),
          'creative_id': String(e.data.data.creativeId),
          'ad_id': String(e.data.data.creativeId)
        };
        var jsonData = { leaderboardVersion: leaderboardVersion };
        logEvent('event_viewed', jsonData, renderedAdProps);
        debug('Banner impression logged!');

        domElement.setAttribute('data-ta-rendered-at', new Date().getTime());
        domElement.setAttribute('data-ta-creative-id', e.data.data.creativeId);
        domElement.setAttribute('data-ta-line-item-id', e.data.data.lineItemId);
        domElement.setAttribute('data-contextmenu', '');
        domElement.setAttribute('data-uri', JSON.stringify({
          creativeId: e.data.data.creativeId,
          lineItemId: e.data.data.lineItemId
        }));

        eventDispatcher.dispatchEvent({
          type: _eventTypes2.default.AD_LEADERBOARD_PLACEMENT,
          params: {
            isEmpty: false
          }
        });
        break;

      case 'ads-upgrade-account':
        debug('ads-upgrade-account: %o', e.data);
        var match = e.data.click.match(/\?(.*)$/);
        var params = match && match[1] ? match[1] : '';
        eventDispatcher.dispatchEvent({
          type: _eventTypes2.default.NAVIGATION_UPGRADE,
          params: {
            tracking: params
          }
        });
        break;

      case 'spotify:ad:leaderboard:cleanup:done':
        if (onCleanup) {
          onCleanup(e.data);
        }
        break;

      case 'spotify:ad:leaderboard:init':
        // Note: we assume that there will only be one leaderboard initialized at
        // any given moment.  If this changes, we will want to keep track of all
        // initialized uuids and use the appropriate uuid on the cleanup routine.
        currentUuid = e.data.uuid;
        renderedAdProps = null;
        break;

      default:
        break;
    }
    if (e.data.type.match(/spotify:ad:leaderboard/)) {
      debug('Received leaderboard message: %o', e.data);
    }
  };

  handler.cleanup = function (leaderboardWindow, timeoutMs) {
    if (!currentUuid) {
      return Promise.resolve(true);
    }
    var cleanupDone = false;
    return Promise.race([new Promise(function (resolve) {
      onCleanup = function onCleanup(eventData) {
        if (eventData.uuid === currentUuid) {
          cleanupDone = true;
          resolve(true);
        }
      };
      debug('sending cleanup message to leaderboard with uuid: ' + currentUuid);
      leaderboardWindow.postMessage({
        uuid: currentUuid,
        type: 'spotify:ad:leaderboard:cleanup'
      }, '*');
    }), new Promise(function (resolve) {
      setTimeout(function () {
        if (currentUuid && !cleanupDone) {
          debug('warning: timed out on cleanup routine after ' + timeoutMs + 'ms');
        }
        resolve(true);
      }, timeoutMs);
    })]);
  };

  handler.logClosed = function (jsonData) {
    logEvent('event_closed', jsonData, renderedAdProps);
  };

  return handler;
}

exports.default = {
  iframeWithContent: iframeWithContent,
  renderLeaderboard: renderLeaderboard,
  renderCloseButton: renderCloseButton,
  setAndEvalTrustedHtml: setAndEvalTrustedHtml,
  subscribeToPreview: subscribeToPreview,
  leaderboardMessageHandler: leaderboardMessageHandler,
  logEvent: logEvent,
  activateClickBlockOverlay: activateClickBlockOverlay
};

},{"../../../../event-types":125,"../../../../spotify-logger/messages/AdEvent4":525,"../../../i18n":50,"./CONSTANTS":103,"debug":582,"uuid-js":908}],106:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _cosmosConnector = require('../../cosmos-connector');

var _cosmosConnector2 = _interopRequireDefault(_cosmosConnector);

var _eventTypes = require('../../../../event-types');

var _eventTypes2 = _interopRequireDefault(_eventTypes);

var _logoTemplate = require('./logo-template.hbs');

var _logoTemplate2 = _interopRequireDefault(_logoTemplate);

var _i18n = require('../../../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _AdEvent = require('../../../../spotify-logger/messages/AdEvent4');

var _AdEvent2 = _interopRequireDefault(_AdEvent);

var _AdError = require('../../../../spotify-logger/messages/AdError2');

var _AdError2 = _interopRequireDefault(_AdError);

var _utils = require('../../utils');

var _utils2 = _interopRequireDefault(_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = require('debug')('saf:sponsored-playlist');

var SponsoredPlaylist = {};

/**
 * @private
 * @param {Object} props
 * @param {String} props.lineItemId
 * @param {String} props.creativeId
 */
function logClicked(props) {
  var message = {
    'event': 'event_clicked',
    'ad_format': 'sponsored playlist',
    'lineitem_id': String(props.lineItemId),
    'creative_id': String(props.creativeId),
    'ad_id': String(props.creativeId)
  };
  _AdEvent2.default.log(message);
  debug('logClicked message=%o', message);
}

/**
 * @private
 * @param  {String} reason
 */
function logError(reason) {
  var message = {
    'request_type': 'sponsored playlist',
    'error_message': JSON.stringify({ reason: reason })
  };
  _AdError2.default.log(message);
  debug('logError message=%o', message);
}

/**
 * @private
 * @param {Object} props
 * @param {String} props.lineItemId
 * @param {String} props.creativeId
 */
function logViewed(props) {
  var message = {
    'event': 'event_viewed',
    'ad_format': 'sponsored playlist',
    'lineitem_id': String(props.lineItemId),
    'creative_id': String(props.creativeId),
    'ad_id': String(props.creativeId)
  };
  _AdEvent2.default.log(message);
  debug('logViewed message=%o', message);
}

/**
 * @private
 * @param {Object} props
 * @param {String} props.clickTracking
 * @param {String} props.clickThrough
 * @param {String} props.logoUrl
 * @param {String} props.impression
 * @param {String} props.thirdPartyImpression
 * @param {String} props.creativeId
 * @param {String} props.lineItemId
 * @return {HTMLElement} el
 */
function createLogoEl(props) {
  var el = document.createElement('div');

  el.className = 'sponsored-logo';

  el.innerHTML = (0, _logoTemplate2.default)({
    clickSrc: props.clickThrough,
    logoSrc: props.logoUrl,
    impSrc: props.impression,
    thirdPartyImpSrc: props.thirdPartyImpression
  });

  el.addEventListener('click', function () {
    logClicked(props);
    _utils2.default.appendTrackingPixel(props.clickTracking, el);
    debug('Logo clicked');
  });

  return el;
}

/**
 * @private
 * @param {HTMLElement} container
 * @param {Object} props
 * @param {String} props.lineItemId
 * @param {String} props.creativeId
 * @param {String} props.clickTracking
 * @param {String} props.clickThrough
 * @param {String} props.label
 * @param {String} props.logoUrl
 * @param {String} props.impression
 * @param {String} props.thirdPartyImpression
 * @param {String} props.advertiserName
 * @return {Object} sponsoredPlaylist
 */
function create(_props) {
  debug('create', _props);
  var sponsoredPlaylist = {};
  var props = parseProps(_props);
  var logoEl = createLogoEl(props);
  var hasStarted = false;

  sponsoredPlaylist.appendLogoTo = function (el) {
    if (!hasStarted) {
      hideLeaderboard();
      logViewed(props);
      debug('active');
      logoEl.classList.add('fade-in');
    } else {
      logoEl.classList.remove('fade-in');
    }

    el.appendChild(logoEl);

    hasStarted = true;
    return sponsoredPlaylist;
  };

  sponsoredPlaylist.getLabel = function () {
    return props.label;
  };

  return sponsoredPlaylist;
}

/**
 * @param  {Object} opts
 * @param  {String} opts.uri
 * @return {Promise}
 */
SponsoredPlaylist.fetch = function (opts) {
  var uri = opts.uri;
  debug('fetch on uri=%o', uri);

  return _cosmosConnector2.default.getSponsoredUris().then(function (res) {
    debug('sponsored uri response=%o', res);
    if (!checkIfSponsored(uri, res.sponsorships)) {
      debug('Playlist not sponsored');
      return false;
    }

    return _cosmosConnector2.default.getSponsorshipAd(uri).then(create).catch(logError.bind(null, 'ad_failed_to_retrieve'));
  });
};

/**
 * @param  {Function} cb
 * @return {void}
 */
SponsoredPlaylist.subscribeToPreviewUri = function (cb) {
  _cosmosConnector2.default.subscribeToFormat('banner', function (data) {
    // Only handle leaderboard previews
    if (data.ad.display && data.ad.display[0].width !== 300) return;

    var regex = /\{(\s)+"sponsoredPlaylist(.|\s)+\}(\s)+\}/;

    var adData = JSON.parse(data.ad.display[0].media.match(regex)[0]).sponsoredPlaylist;

    var sponsorship = create(Object.assign({}, adData, { logoUrl: adData.logo }));

    cb(sponsorship);
  });
};

/**
 * Check uri
 * @param  {String}   uri
 * @param  {Object[]} sponsorships
 * @return {Boolean}
 */
function checkIfSponsored(uri, sponsorships) {
  var time = Date.now() / 1000;

  return sponsorships.some(function (sponsorship) {
    var endTime = sponsorship.endTime || time + 1;

    return sponsorship.spotifyUri === uri && time >= sponsorship.startTime && time < endTime;
  });
}

function hideLeaderboard() {
  // todo revisit this
  debug('hideLeaderboard');
  window.parent.postMessage({ type: _eventTypes2.default.AD_SPONSORSHIP_ACTIVE }, 'http://zlink.app.spotify.com');
}

function parseProps(props) {
  return {
    lineItemId: props.lineItemId,
    creativeId: props.creativeId,
    clickTracking: props.clickTracking,
    clickThrough: props.clickThrough,
    logoUrl: props.logoUrl,
    impression: props.impression,
    thirdPartyImpression: props.thirdPartyImpression,
    advertiserName: props.advertiserName,
    label: [_i18n2.default.get('PresentedBy'), props.advertiserName].join(' ')
  };
}

exports.default = SponsoredPlaylist;

},{"../../../../event-types":125,"../../../../spotify-logger/messages/AdError2":524,"../../../../spotify-logger/messages/AdEvent4":525,"../../../i18n":50,"../../cosmos-connector":75,"../../utils":120,"./logo-template.hbs":107,"debug":582}],107:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n  <img class=\"3p-imp-pixel\" style=\"display:none;width:1px;height:1px;\" src=\"";
  if (helper = helpers.thirdPartyImpSrc) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.thirdPartyImpSrc); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" />\n";
  return buffer;
  }

  buffer += "<a href=\"";
  if (helper = helpers.clickSrc) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.clickSrc); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n  <img src=\"";
  if (helper = helpers.logoSrc) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.logoSrc); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" />\n</a>\n  <img class=\"imp-pixel\" style=\"display:none;width:1px;height:1px;\" src=\"";
  if (helper = helpers.impSrc) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.impSrc); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" />\n";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.thirdPartyImpSrc), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"hbsfy/runtime":615}],108:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _spotifyVideoManager = require('../../../../spotify-video-manager');

var _spotifyVideoManager2 = _interopRequireDefault(_spotifyVideoManager);

var _vastEvents = require('../../vast-events');

var _vastEvents2 = _interopRequireDefault(_vastEvents);

var _eventLogger = require('../../event-logger');

var _moatLogger = require('../../moat-logger');

var _template = require('./template.hbs');

var _template2 = _interopRequireDefault(_template);

var _events = require('events');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = require('debug')('saf:video:view');


var DESTROYING = 'DESTROYING';
var DESTROYED = 'DESTROYED';

var BUFFERING_FAIL_TIMEOUT = 5000;
var FAILURE_BUFFER_TIMEOUT = 'video_error_buffer_timeout';
var FAILURE_GENERAL = 'video_error_general_error';
var FAILURE_ON_START = 'video_error_start_failure';

var maxContainer = null;
var minContainer = null;

var View = {
  create: function create(ad) {
    debug('create: %o', ad);
    var el = createEl();
    var videoContainerEl = getVideoContainerEl(el);
    var emitter = new _events.EventEmitter();
    var EVENT = 'EVENT';
    var logEvent = new _eventLogger.EventLogger(ad.id).logEvent;
    var videoEl = null;
    var playerId = null;
    var fireOnStart = ad.metadata && ad.metadata.fireImpressionOnStart;
    var clickUrl = ad.click_url;
    var _nowPlaying = parseNowPlaying(ad);
    var moatEnabled = ad.metadata['moat.enabled'] === 'true';
    var isResizing = false;
    var isStarted = false;
    var _isDestroyed = false;
    var destroyPromise = null;
    var ignoreVastEvents = false;
    var logMoatEvent = function logMoatEvent() {};
    var unsubscribeVast = function unsubscribeVast() {};

    var view = {
      nowPlaying: function nowPlaying() {
        return _nowPlaying;
      },
      isDestroyed: function isDestroyed() {
        return _isDestroyed;
      },
      start: function start() {
        debug('start: isStarted=%o err=%o', isStarted, videoEl.error);
        try {
          if (isStarted) return view;

          if (videoEl.error) return view.fail();

          videoContainerEl.appendChild(videoEl);
          startListening();
          _spotifyVideoManager2.default.play(playerId);
          maximize(true);
          isStarted = true;
          if (fireOnStart) logEvent('viewed');
        } catch (e) {
          debug('error during video start', e);
          return view.fail(FAILURE_ON_START);
        }
        return view;
      },
      destroy: function destroy(silent) {
        debug('destroy');
        if (!destroyPromise) {
          emitter.emit(EVENT, DESTROYING);

          destroyPromise = new Promise(function (resolve) {
            if (isStarted) stopListening();
            if (el.parentNode) el.parentNode.removeChild(el);
            resolve();
          }).then(function () {
            if (silent) return null;
            if (!fireOnStart) logEvent('viewed');
            return null;
          }).catch(function (err) {
            debug('Error destroying view:', err);
          }).then(function () {
            _isDestroyed = true;
            emitter.emit(EVENT, DESTROYED);
            return view;
          });
        }

        return destroyPromise;
      },
      fail: function fail(reason) {
        debug('fail: reason=%o', reason);
        return logEvent('errored', {
          'event_version': reason || FAILURE_GENERAL
        }).then(function () {
          return view.destroy(true);
        });
      },
      minimize: function minimize(silent) {
        _minimize(silent);
        return view;
      },
      setVideoEl: function setVideoEl(_videoEl) {
        if (videoEl) throw new Error('videoEl already set');
        videoEl = _videoEl;
        return view;
      },
      setPlayerId: function setPlayerId(_playerId) {
        playerId = _playerId;
      },
      logClick: function logClick() {
        logEvent('clicked');
        return view;
      },
      subscribe: function subscribe(callback) {
        emitter.on(EVENT, callback);
        return emitter.removeListener.bind(emitter, EVENT, callback);
      },


      EVENTS: {
        DESTROYING: DESTROYING,
        DESTROYED: DESTROYED
      }
    };

    function startListening() {
      videoEl.addEventListener('error', onError);
      el.addEventListener('click', onClick);
      _spotifyVideoManager2.default.subscribe(playerId, onVideoPlayerChange);

      if (moatEnabled) {
        var moatIds = (0, _moatLogger.extractMoatIds)(ad.metadata);
        logMoatEvent = (0, _moatLogger.create)({
          container: el,
          videoNode: videoEl,
          ids: moatIds
        });
      }

      unsubscribeVast = _vastEvents2.default.subscribe(videoEl, onVastEvent);
    }

    function stopListening() {
      videoEl.removeEventListener('error', onError);
      el.removeEventListener('click', onClick);
      _spotifyVideoManager2.default.unsubscribe(playerId, onVideoPlayerChange);
      unsubscribeVast();
    }

    function onClick(e) {
      e.preventDefault();
      e.stopPropagation();

      if (e.target === videoEl) openUrl();else if (e.target.dataset.click === 'maximize') maximize();else if (e.target.dataset.click === 'minimize') _minimize();

      function openUrl() {
        logEvent('clicked');
        window.open(clickUrl);
      }
    }

    function onError() {
      view.fail();
    }

    function onVastEvent(eventName) {
      debug('vast event=%o', eventName);

      if (ignoreVastEvents) return;

      logMoatEvent((0, _moatLogger.getMoatEvent)(eventName));

      var events = _vastEvents2.default.EVENTS;
      var eventsHandledByCore = [events.STARTED, events.RESUMED, events.PAUSED, events.SKIPPED, events.ENDED];

      if (!eventsHandledByCore.includes(eventName) && eventName !== 'volumechange') {
        logEvent(eventName);
      }
      if (eventName === events.ENDED) {
        view.destroy();
      }
    }

    function isMinimized() {
      return el.parentNode === minContainer;
    }

    function isMaximized() {
      return el.parentNode === maxContainer;
    }

    function _minimize(silent) {
      if (isResizing || isMinimized()) return;
      isResizing = true;

      el.classList.add('will-minimize');

      setTimeout(function () {
        el.classList.add('minimize');
        setTimeout(function () {
          moveTo(minContainer, function () {
            el.classList.remove('will-minimize', 'minimize');
            isResizing = false;
            if (!silent) logEvent('collapsed');
          });
        }, 300);
      }, 0);
    }

    function maximize(silent) {
      if (isResizing || isMaximized()) return;
      isResizing = true;

      el.classList.add('will-maximize');

      moveTo(maxContainer, function () {
        setTimeout(function () {
          el.classList.add('maximize');
          setTimeout(function () {
            el.classList.remove('will-maximize', 'maximize');
            isResizing = false;
            if (!silent) logEvent('expanded');
          }, 300);
        }, 0);
      });
    }

    function moveTo(parentEl, callback) {
      var wasPlaying = !videoEl.paused;
      ignoreVastEvents = true;
      parentEl.appendChild(el);

      if (!wasPlaying || !videoEl.paused) {
        done();
        return;
      }

      videoEl.addEventListener('play', function onPlay() {
        videoEl.removeEventListener('play', onPlay);
        done();
      });

      _spotifyVideoManager2.default.play(playerId);

      function done() {
        ignoreVastEvents = false;
        if (callback) callback();
      }
    }

    function onVideoPlayerChange(err, p, c) {
      if (err) view.fail();
      // todo support betamax videos
      // todo refactor buffering logic
      if (c.isBuffering && c.timeBuffering >= BUFFERING_FAIL_TIMEOUT) {
        view.fail(FAILURE_BUFFER_TIMEOUT);
      }
    }

    return view;
  },
  appendMaxTo: function appendMaxTo(parentEl) {
    if (!maxContainer) maxContainer = createDiv('saf-video-takeover-max');
    parentEl.appendChild(maxContainer);
    return View;
  },
  appendMinTo: function appendMinTo(parentEl) {
    if (!minContainer) minContainer = createDiv('saf-video-takeover-min');
    parentEl.appendChild(minContainer);
    return View;
  }
};

function createEl() {
  var el = createDiv('saf-video-takeover');
  el.innerHTML = (0, _template2.default)();
  return el;
}

function createDiv(className) {
  var div = createElement('div');
  div.className = className;
  return div;
}

function getVideoContainerEl(el) {
  return el.getElementsByClassName('saf-video-takeover-video')[0];
}

function parseNowPlaying(ad) {
  var WIDTH = 300;
  var HEIGHT = 250;
  var mimeType = /^image\/(jpeg|png)$/;

  return {
    id: ad.id,
    title: ad.title,
    advertiser: ad.advertiser,
    clickUrl: ad.click_url,
    companionAd: getPreferredCompanionAd(ad)
  };

  function getPreferredCompanionAd() {
    var companionAd = void 0;
    var companionAds = ad.companion_ads;
    var l = companionAds && companionAds.length || 0;

    for (var i = 0; i < l; i++) {
      if (!companionAd && companionAds[i].url) {
        companionAd = companionAds[i];
      }

      if (isPreferred(companionAds[i])) {
        companionAd = companionAds[i];
        break;
      }
    }

    return {
      url: companionAd && companionAd.url,
      width: companionAd && companionAd.width,
      height: companionAd && companionAd.height
    };

    function isPreferred(props) {
      return props.width === WIDTH && props.height === HEIGHT && mimeType.test(props.mime_type);
    }
  }
}

function createElement(tagName) {
  return document.createElement(tagName);
}

exports.default = View;

},{"../../../../spotify-video-manager":552,"../../event-logger":80,"../../moat-logger":114,"../../vast-events":121,"./template.hbs":111,"debug":582,"events":584}],109:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _once = require('lodash/once');

var _once2 = _interopRequireDefault(_once);

var _cosmosConnector = require('../../cosmos-connector');

var _cosmosConnector2 = _interopRequireDefault(_cosmosConnector);

var _hasFocus2 = require('../../hasFocus');

var _events = require('events');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var emitter = new _events.EventEmitter();
var EVENT = 'EVENT';
var debug = require('debug')('saf:video:core');
var initOnce = (0, _once2.default)(init);

function init() {
  _cosmosConnector2.default.addNewSlot('stream', 'video').then(function (placementUri) {
    return _cosmosConnector2.default.subscribeToSlot(placementUri, onCoreMessage);
  }).catch(debug);

  function onFocusChange(_hasFocus) {
    _cosmosConnector2.default.patchTargeting('adbreak', _hasFocus ? 'video,adscore' : 'adscore');
  }

  _hasFocus2.hasFocus.subscribe(onFocusChange);
  onFocusChange((0, _hasFocus2.hasFocus)());

  function onCoreMessage(data) {
    debug('core message: ', data);
    emitter.emit(EVENT, data);
  }
}

var core = {
  subscribe: function subscribe(callback) {
    initOnce();
    emitter.on(EVENT, callback);
    return emitter.removeListener.bind(emitter, EVENT, callback);
  }
};

exports.default = core;

},{"../../cosmos-connector":75,"../../hasFocus":112,"debug":582,"events":584,"lodash/once":643}],110:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _once = require('lodash/once');

var _once2 = _interopRequireDefault(_once);

var _spotifyEventDispatcher = require('../../../../spotify-event-dispatcher');

var _spotifyEventDispatcher2 = _interopRequireDefault(_spotifyEventDispatcher);

var _eventTypes = require('../../../../event-types');

var _eventTypes2 = _interopRequireDefault(_eventTypes);

var _core = require('./core');

var _core2 = _interopRequireDefault(_core);

var _View = require('./View');

var _View2 = _interopRequireDefault(_View);

var _events = require('events');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = require('debug')('saf:video:index');

var initOnce = (0, _once2.default)(init);

var emitter = new _events.EventEmitter();
var EVENT = 'EVENT';
var views = {};
var currentView = null;

var ENABLED = 'ENABLED';
var DISABLED = 'DISABLED';
var ACTIVE = 'ACTIVE';
var INACTIVE = 'INACTIVE';

var _isEnabled = false;
var _isActive = false;

var VideoTakeoverAd = {
  appendMaxTo: function appendMaxTo(parentEl) {
    _View2.default.appendMaxTo(parentEl);
    return VideoTakeoverAd;
  },
  appendMinTo: function appendMinTo(parentEl) {
    _View2.default.appendMinTo(parentEl);
    return VideoTakeoverAd;
  },
  enable: function enable() {
    debug('enable');
    if (!_isEnabled) {
      initOnce();
      _isEnabled = true;
      emitter.emit(EVENT, ENABLED);
    }

    return VideoTakeoverAd;
  },
  disable: function disable() {
    debug('disable');
    if (_isEnabled) {
      if (currentView) currentView.destroy();
      _isEnabled = false;
      emitter.emit(EVENT, DISABLED);
    }

    return VideoTakeoverAd;
  },
  subscribe: function subscribe(callback) {
    emitter.on(EVENT, callback);
    return emitter.removeListener.bind(emitter, EVENT, callback);
  },
  playBetamaxVideo: function playBetamaxVideo(opts) {
    debug('playBetamaxVideo: %o', opts);
    var adId = opts.adId;
    var videoEl = opts.videoEl;
    var onDestroyed = opts.onDestroyed;
    var playerId = opts.playerId;
    var view = views[adId];

    var unsubscribe = view.subscribe(function (eventName) {
      if (eventName !== view.EVENTS.DESTROYED) return;
      unsubscribe();
      onDestroyed();
    });

    view.setVideoEl(videoEl);
    view.setPlayerId(playerId);
    playView(view);

    return VideoTakeoverAd;
  },
  getPreferredVideo: function getPreferredVideo(videos) {
    var targetBitRate = 640;
    var mimeTypes = ['video/webm'];

    var preferredVideo = videos && videos.filter(function (video) {
      return mimeTypes.indexOf(video.mimeType) > -1;
    }).sort(function (a, b) {
      var x = Math.abs(a.bitrate - targetBitRate);
      var y = Math.abs(b.bitrate - targetBitRate);
      if (x > y) return 1;
      if (y < x) return -1;
      return 0;
    })[0];

    debug('preferred video selected: videos=%o, preferred=%o', videos, preferredVideo);
    return preferredVideo && preferredVideo.url;
  },
  nowPlaying: function nowPlaying() {
    return currentView && currentView.nowPlaying();
  },
  logClick: function logClick(clickUrl) {
    debug('logClick: %o', clickUrl);
    if (_isActive) currentView.logClick(clickUrl);
    return VideoTakeoverAd;
  },
  isEnabled: function isEnabled() {
    return _isEnabled;
  },
  isActive: function isActive() {
    return _isActive;
  },


  EVENTS: {
    ENABLED: ENABLED,
    DISABLED: DISABLED,
    ACTIVE: ACTIVE,
    INACTIVE: INACTIVE
  }
};

function init() {
  proxyEventsToEventDispatcher();
  _core2.default.subscribe(onCoreMessage);
  subscribeToNavChanges();

  function subscribeToNavChanges() {
    _spotifyEventDispatcher2.default.addEventListener(_eventTypes2.default.NAVIGATION_STATE_CHANGE, onNavigationChange);
  }

  // for backwards compatability
  function proxyEventsToEventDispatcher() {
    VideoTakeoverAd.subscribe(function (eventName) {
      if (eventName === ACTIVE) {
        _spotifyEventDispatcher2.default.dispatchEvent({
          type: _eventTypes2.default.AD_VIDEO_STARTED
        });
      } else if (eventName === INACTIVE) {
        _spotifyEventDispatcher2.default.dispatchEvent({
          type: _eventTypes2.default.AD_VIDEO_FINISHED
        });
      }
    });
  }
}

function onNavigationChange() {
  if (_isActive) currentView.minimize();
}

function onCoreMessage(data) {
  debug('onCoreMessage: %o', data);
  var view = views[data.ad.id];

  if (data.event === 'available' || data.event === 'play') {
    if (!view || view.isDestroyed()) {
      view = views[data.ad.id] = _View2.default.create(data.ad);
    }
  }

  if (data.event === 'play') {
    debug('play isEnabled=%o haveView=%o', _isEnabled, !!view);
    if (!_isEnabled) view.destroy();
  }

  if (data.event === 'discard') {
    if (view) view.destroy(true);
    views[data.ad.id] = null;
  }
}

function playView(view) {
  debug('playView view=%o', view);
  if (_isActive) currentView.destroy();

  var unsubscribe = view.subscribe(function (eventName) {
    if (eventName === view.EVENTS.DESTROYED) {
      unsubscribe();
      if (currentView === view) currentView = null;
      if (!_isActive) return;
      _isActive = false;
      emitter.emit(EVENT, INACTIVE);
    }
  });

  currentView = view;

  _isActive = true;
  emitter.emit(EVENT, ACTIVE);
  view.start();
}

exports.default = VideoTakeoverAd;

},{"../../../../event-types":125,"../../../../spotify-event-dispatcher":234,"./View":108,"./core":109,"debug":582,"events":584,"lodash/once":643}],111:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  


  return "<div class=\"saf-video-takeover-video\" data-qa=\"saf-video-takeover-video\"></div>\n\n<button\n  type=\"button\"\n  class=\"saf-video-takeover-btn-min\"\n  data-qa=\"saf-video-takeover-btn-min\"\n  data-click=\"maximize\"\n>\n  <i class=\"spoticon-chevron-right-16\" data-click=\"maximize\"></i>\n</button>\n\n<button\n  type=\"button\"\n  class=\"saf-video-takeover-btn-max\"\n  data-qa=\"saf-video-takeover-btn-max\"\n  data-click=\"minimize\"\n>\n  <i class=\"spoticon-x-24\" data-click=\"minimize\"></i>\n</button>\n";
  });

},{"hbsfy/runtime":615}],112:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasFocus = undefined;
exports.factory = factory;

var _events = require('events');

var _once2 = require('lodash/once');

var _once3 = _interopRequireDefault(_once2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function factory(_ref) {
  var document = _ref.document,
      setInterval = _ref.setInterval,
      EventEmitter = _ref.EventEmitter,
      once = _ref.once;

  var emitter = new EventEmitter();
  var EVENT = 'EVENT';
  var _hasFocus = void 0;

  var initOnce = once(function () {
    _hasFocus = document.hasFocus();

    setInterval(function () {
      var hadFocus = _hasFocus;
      _hasFocus = document.hasFocus();
      if (hadFocus !== _hasFocus) {
        emitter.emit(EVENT, _hasFocus);
      }
    }, 500);
  });

  function hasFocus() {
    initOnce();
    return _hasFocus;
  }

  hasFocus.subscribe = function (callback) {
    initOnce();
    emitter.on(EVENT, callback);
    return emitter.removeListener.bind(emitter, EVENT, callback);
  };

  return hasFocus;
}

var hasFocus = exports.hasFocus = factory({
  document: typeof document !== 'undefined' && document,
  setInterval: setInterval,
  EventEmitter: _events.EventEmitter,
  once: _once3.default
});

},{"events":584,"lodash/once":643}],113:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.FocusTracker = exports.productState = exports.SponsoredPlaylistAd = exports.AudioCompanionAd = exports.VideoTakeoverAd = exports.hptoProvider = exports.HptoAd = exports.LeaderboardAd = exports.BillboardAd = undefined;

var _billboardAd = require('./formats/billboard-ad');

Object.defineProperty(exports, 'BillboardAd', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_billboardAd).default;
  }
});

var _leaderboardAd = require('./formats/leaderboard-ad');

Object.defineProperty(exports, 'LeaderboardAd', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_leaderboardAd).default;
  }
});

var _hptoAd = require('./formats/hpto-ad');

Object.defineProperty(exports, 'HptoAd', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_hptoAd).default;
  }
});

var _provider = require('./formats/hpto-ad/provider');

Object.defineProperty(exports, 'hptoProvider', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_provider).default;
  }
});

var _videoTakeoverAd = require('./formats/video-takeover-ad');

Object.defineProperty(exports, 'VideoTakeoverAd', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_videoTakeoverAd).default;
  }
});

var _audioCompanionAd = require('./formats/audio-companion-ad');

Object.defineProperty(exports, 'AudioCompanionAd', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_audioCompanionAd).default;
  }
});

var _sponsoredPlaylistAd = require('./formats/sponsored-playlist-ad');

Object.defineProperty(exports, 'SponsoredPlaylistAd', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_sponsoredPlaylistAd).default;
  }
});

var _productState = require('./product-state');

Object.defineProperty(exports, 'productState', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_productState).default;
  }
});

var _focusTracker = require('./focus-tracker');

Object.defineProperty(exports, 'FocusTracker', {
  enumerable: true,
  get: function get() {
    return _interopRequireDefault(_focusTracker).default;
  }
});

var _configuration = require('./configuration');

var _configuration2 = _interopRequireDefault(_configuration);

var _helpers = require('../../spotify-handlebars/helpers');

var _helpers2 = _interopRequireDefault(_helpers);

var _i18n = require('../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _debuggingUtils = require('./debugging-utils');

var _debuggingUtils2 = _interopRequireDefault(_debuggingUtils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var glueStrings = _i18n2.default.glueStrings();
var appStrings = _i18n2.default.appStrings();

_helpers2.default.loc.register(glueStrings);
_helpers2.default.loc.register(appStrings);

// Inject configuration
_configuration2.default.setSpotlightSvg(require('../images/logo_spotlight.svg'));

// Public exports

window.Ads = _debuggingUtils2.default;

},{"../../spotify-handlebars/helpers":324,"../i18n":50,"../images/logo_spotlight.svg":71,"./configuration":74,"./debugging-utils":77,"./focus-tracker":82,"./formats/audio-companion-ad":83,"./formats/billboard-ad":84,"./formats/hpto-ad":94,"./formats/hpto-ad/provider":98,"./formats/leaderboard-ad":104,"./formats/sponsored-playlist-ad":106,"./formats/video-takeover-ad":110,"./product-state":116}],114:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.extractMoatIds = extractMoatIds;
exports.getMoatEvent = getMoatEvent;
exports.create = create;

var _vendorMoatInit = require('./vendor-moat-init');

var vendorMoat = _interopRequireWildcard(_vendorMoatInit);

var _vastEvents = require('../vast-events');

var _vastEvents2 = _interopRequireDefault(_vastEvents);

var _AdError = require('../../../spotify-logger/messages/AdError2');

var _AdError2 = _interopRequireDefault(_AdError);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var debug = require('debug')('saf:moat');

// maps various events to VPAID events
var events = {};
events[_vastEvents2.default.EVENTS.STARTED] = 'AdVideoStart';
events[_vastEvents2.default.EVENTS.FIRST_QUARTILE] = 'AdVideoFirstQuartile';
events[_vastEvents2.default.EVENTS.MIDPOINT] = 'AdVideoMidpoint';
events[_vastEvents2.default.EVENTS.THIRD_QUARTILE] = 'AdVideoThirdQuartile';
events[_vastEvents2.default.EVENTS.PAUSED] = 'AdPaused';
events[_vastEvents2.default.EVENTS.RESUMED] = 'AdPlaying';
events[_vastEvents2.default.EVENTS.ENDED] = 'AdVideoComplete';
events[_vastEvents2.default.EVENTS.SKIPPED] = 'AdStopped';
// non VAST events
events.volumechange = 'AdVolumeChange';

/**
 * @param {Object} ad meta data
 * @return {Object} moat ids
 */
function extractMoatIds(metadata) {
  var ids = {
    level1: metadata.advertiser_id,
    level2: metadata.order_id,
    level3: metadata.lineitem_id,
    level4: metadata.creative_id
  };
  //
  if (metadata.dealId) {
    // SpotXChange ad
    Object.assign(ids, {
      dealId: metadata.dealId,
      domain: metadata.domain,
      channelId: metadata.channelId
    });
  } else if (metadata.zMoatVF) {
    // Videology ad
    Object.assign(ids, {
      zMoatCLUSTERID: metadata.zMoatCLUSTERID,
      zMoatLOne: metadata.zMoatLOne,
      zMoatLThree: metadata.zMoatLThree,
      zMoatLTwo: metadata.zMoatLTwo,
      zMoatSOne: metadata.zMoatSOne,
      zMoatSTwo: metadata.zMoatSTwo,
      zMoatVADID: metadata.zMoatVADID,
      zMoatVCP: metadata.zMoatVCP
    });
  }
  return ids;
}
/**
 * @param {String} vastEvent
 * @return {String} moatEvent
 */
function getMoatEvent(vastEvent) {
  var event = events[vastEvent];
  if (!event) {
    console.error('A Moat Event does not exist for', vastEvent);
    _AdError2.default.log({
      'request_type': 'moat:get-moat-event',
      'error_message': 'No moat event exists for ' + vastEvent
    });
  }
  return event;
}

var PARTNER_CODE = 'spotifynativeapp525794473702';

function getMoat(container, ids, videoNode) {
  return new Promise(function (resolve) {
    if (videoNode.readyState >= videoNode.HAVE_METADATA) {
      resolve(vendorMoat.initMoatTracking(container, ids, videoNode.duration, PARTNER_CODE));
      return;
    }

    videoNode.addEventListener('loadedmetadata', function onMetaData() {
      videoNode.removeEventListener('loadedmetadata', onMetaData);
      resolve(vendorMoat.initMoatTracking(container, ids, videoNode.duration, PARTNER_CODE));
    });
  });
}

function logMoatEvent(moatPromise, videoNode, eventType) {
  return moatPromise.then(function (moat) {
    var ev = {
      type: eventType,
      adVolume: videoNode.volume
    };

    debug(ev, moat.adData.ids);
    return moat.dispatchEvent(ev);
  }).catch(function (err) {
    debug(err);
    _AdError2.default.log({
      'request_type': 'moat:log-moat-event',
      'error_message': err.message
    });
  });
}

/**
 * Wrapper around vendor code
 * @param {Object} opts - should have container, ids, and videoNode keys
 * @return {Object} logMoatEvent
 */
function create(opts) {
  return logMoatEvent.bind(null, getMoat(opts.container, opts.ids, opts.videoNode), opts.videoNode);
}

},{"../../../spotify-logger/messages/AdError2":524,"../vast-events":121,"./vendor-moat-init":115,"debug":582}],115:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.initMoatTracking = initMoatTracking;
/*
 * Vendor code - don't alter
 */

/*eslint-disable */
function initMoatTracking(container, ids, duration, partnerCode, url) {
  var protocol = 'https:';
  var sub = protocol === 'https:' ? 'z' : 'js';
  var script = document.createElement("script");
  var events = [];

  var moatapi = {
    "adData": {
      "ids": ids,
      "duration": duration,
      "url": url
    },
    "dispatchEvent": function dispatchEvent(ev) {
      if (this.sendEvent) {
        if (events) {
          events.push(ev);
          ev = events;
          events = false;
        }
        this.sendEvent(ev);
      } else {
        events.push(ev);
      }
    }
  };

  var moatApiName = '_moatApi' + Math.floor(Math.random() * 100000000);

  window[moatApiName] = moatapi;

  script.type = 'text/javascript';
  container && container.insertBefore(script, container.childNodes[0] || null);
  script.src = protocol + '//' + sub + '.moatads.com/' + partnerCode + '/moatvideo.js#' + moatApiName;

  return moatapi;
}

},{}],116:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

function bool(key) {
  return function () {
    return !!Number(__spotify.product_state[key]);
  };
}

exports.default = {
  isProxyAdRequester: bool('ab-ad-requester')
};

},{}],117:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var PLATFORMS = {
  desktop: 'html5_desktop'
};

var session = {};

session.get = function () {
  var platform = PLATFORMS[window.__spotify.platform];
  var isPremium = window.__spotify.product_state.ads === '0';

  return {
    platform: platform,
    isPremium: isPremium
  };
};

exports.default = session;

},{}],118:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _spotifyPreferences = require('../../spotify-preferences');

var _spotifyPreferences2 = _interopRequireDefault(_spotifyPreferences);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var uiPref = new _spotifyPreferences2.default('ui');

var settings = {};

settings.getHidePref = function (device, isPremium) {
  return new Promise(function (res, rej) {
    if (!isPremium) {
      res(false);
    } else {
      switch (device) {
        case 'html5_desktop':
          res(getZeldaPref());
          break;
        case 'web':
          res(getWebPref());
          break;
        default:
          rej(new Error('[HPTO] No valid device detected'));
      }
    }
  });
};

function getZeldaPref() {
  return new Promise(function (res, rej) {
    uiPref.get('hide_hpto', function (err, isHidden) {
      if (err) return rej(err);

      return res(isHidden);
    });
  });
}

function getWebPref() {
  return new Promise(function (res, rej) {
    var hideState = false;

    switch (window.parent.localStorage['ui.hide_hpto']) {
      case 'true':
        hideState = true;
        break;
      case 'false':
        hideState = false;
        break;
      case undefined:
        // Set default hide hpto preference
        window.parent.localStorage['ui.hide_hpto'] = false;
        hideState = false;
        break;
      default:
        rej(new Error('[HPTO] Invalid hide state'));
    }

    res(hideState);
  });
}

exports.default = settings;

},{"../../spotify-preferences":550}],119:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _cosmosConnector = require('./cosmos-connector');

var _cosmosConnector2 = _interopRequireDefault(_cosmosConnector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var targeter = {};

/**
 * Get user targeting from lasertag
 * @param {String} inventoryUnit
 * @return {Promise}
 */
targeter.getTargeting = function (inventoryUnit) {
  function parseTargetData(data) {
    var obj = {};

    obj.ppid = data.ppid || data.aduserid;
    obj.inventoryUnit = inventoryUnit;
    obj.targetingData = data;

    return obj;
  }

  return _cosmosConnector2.default.getTargeting().then(parseTargetData);
};

exports.default = targeter;

},{"./cosmos-connector":75}],120:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var utils = {
  /**
   * Checks if various connected word strings exist in an object
   *
   * @param {String} prop - space separated words to be connected
   * @param {Object} obj - object to check prop in
   * @return {String}
   */

  getProp: function getProp(prop, obj) {
    var trimmedProp = prop.trim().toLowerCase();
    var snakeCase = trimmedProp.replace(/\s+/g, '-');

    var camelCase = trimmedProp.replace(/\s+([a-z])/g, function (str, char) {
      return char.toUpperCase();
    });

    var paramCase = trimmedProp.replace(/\s+/g, '_');

    return obj[snakeCase] || obj[camelCase] || obj[paramCase];
  },


  /**
   * Returns type part of a URI
   *
   * @api public
   * @param {String} uri
   * @return {String} type
   */

  getType: function getType(uri) {
    var parts = uri.split(':');
    var type = null;

    if (parts[1] !== 'user') {
      type = parts[1];
    } else if (parts.length > 3 && parts.length <= 5 && parts[2] !== 'facebook') {
      type = 'playlist';
    }

    return type;
  },


  /**
   * Creates an HTML document from a
   * given HTML string
   *
   * @api public
   * @param {String} html
   */

  makeDocument: function makeDocument(html) {
    var doc = document.implementation.createHTMLDocument('');
    doc.documentElement.innerHTML = html;
    return doc;
  },
  appendTrackingPixel: function appendTrackingPixel(url, domEl, optClass) {
    var pixel = this.createTrackingPixel(url);
    if (optClass) {
      pixel.classList.add(optClass);
    }
    domEl.appendChild(pixel);
  },


  /**
   * Creates a tracking pixel img
   *
   * @param {String} trackingUrl
   * @return {DOMElement} - img element
   */

  createTrackingPixel: function createTrackingPixel(trackingUrl) {
    var img = document.createElement('img');

    img.style.display = 'none';
    img.width = '1px';
    img.height = '1px';
    img.classList.add('pixel');

    // parse tracking url
    var dec = decodeURIComponent(trackingUrl.replace(/&amp;/g, '&'));
    img.src = decodeURIComponent(dec);

    return img;
  },


  /**
   * Creates an interactive iframe from given data
   * TODO: Deprecate after sandbox hpto rolls out 100%
   *
   * @api public
   * @param {String} html
   */

  createInteractiveIframe: function createInteractiveIframe(html) {
    var enc = encodeURIComponent(html);
    var iframe = document.createElement('iframe');
    iframe.className = 'ad-iframe';
    iframe.src = 'data:text/html;charset=utf-8,' + enc;
    iframe.srcdoc = html;
    iframe.scrolling = 'no';
    iframe.marginWidth = 0;
    iframe.marginHeight = 0;
    iframe.hspace = 0;
    iframe.vspace = 0;
    return iframe;
  },
  createSandboxedIframe: function createSandboxedIframe() {
    var iframe = document.createElement('iframe');
    var sandboxParams = ['allow-forms', 'allow-pointer-lock', 'allow-popups', 'allow-same-origin', 'allow-scripts'];

    iframe.sandbox = sandboxParams.join(' ');
    return iframe;
  },
  createSandboxedHptoIframe: function createSandboxedHptoIframe(url) {
    var iframe = this.createSandboxedIframe();
    iframe.className = 'ad-iframe';
    iframe.src = url;
    iframe.scrolling = 'no';
    iframe.marginWidth = 0;
    iframe.marginHeight = 0;
    iframe.hspace = 0;
    iframe.vspace = 0;
    return iframe;
  },


  /**
   * Sets data URL on a given element
   * from given data
   *
   * @api public
   * @param {Element} hptoElem
   * @param {Object} adData
   */
  setDataUrlOnElement: function setDataUrlOnElement(hptoElem, adData) {
    var bgUrl = utils.getProp('background url', adData);
    if (bgUrl) {
      bgUrl = bgUrl.replace(/&amp;/g, '&');
      hptoElem.setAttribute('data-url', bgUrl);
    }
  },


  /**
   * Delete array of nodes
   * @param  {Array} nodes - array of nodes to be deleted
   * @return {void}
   */
  deleteNodes: function deleteNodes(nodes) {
    var len = void 0;
    var i = void 0;

    if (nodes.length === 0) return;

    for (i = 0, len = nodes.length; i < len; i++) {
      var node = nodes[i];
      var parent = node.parentNode;

      parent.removeChild(node);
    }
  },


  /**
   * Parse spotify ad preview uri to get GID only
   * @param  {String} uri
   * @return {String}
   */
  parseGID: function parseGID(uri) {
    var parts = uri.split(':');
    if (parts.length >= 2 && parts[parts.length - 2] === 'ad') {
      return parts[parts.length - 1];
    }
    return null;
  }
};

exports.default = utils;

},{}],121:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _throttle = require('lodash/throttle');

var _throttle2 = _interopRequireDefault(_throttle);

var _once = require('lodash/once');

var _once2 = _interopRequireDefault(_once);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// VAST events
var STARTED = 'started';
var RESUMED = 'resumed';
var PAUSED = 'paused';
var MUTED = 'muted';
var UNMUTED = 'unmuted';
var FIRST_QUARTILE = 'first_quartile';
var MIDPOINT = 'midpoint';
var THIRD_QUARTILE = 'third_quartile';
var ENDED = 'ended';
var SKIPPED = 'skipped';
// Non-VAST event
var VOLUME_CHANGE = 'volumechange';

var VastEvents = {};

/**
 * @param {HTMLVideoElement} videoNode
 * @param {Function} callback
 */
VastEvents.subscribe = function (videoNode, callback) {
  var isStarted = false;
  var isMuted = videoNode.muted || videoNode.volume === 0;
  var hasBeenPaused = false;
  var emitFirstQuartile = (0, _once2.default)(emit.bind(null, FIRST_QUARTILE));
  var emitMidpoint = (0, _once2.default)(emit.bind(null, MIDPOINT));
  var emitThirdQuartile = (0, _once2.default)(emit.bind(null, THIRD_QUARTILE));
  var videoEvents = {};

  var unsubscribe = (0, _once2.default)(removeListeners);

  function start() {
    isStarted = true;
    emit(STARTED);
  }

  function emit(eventName) {
    callback(eventName);
  }

  function addEventListener(name, listener) {
    videoEvents[name] = listener;
    videoNode.addEventListener(name, listener);
  }

  function removeListeners() {
    for (var x in videoEvents) {
      if (videoEvents.hasOwnProperty(x)) {
        videoNode.removeEventListener(x, videoEvents[x]);
      }
    }
  }

  if (!videoNode.paused) start();

  addEventListener('play', function () {
    if (!isStarted) {
      start();
      return;
    }

    if (hasBeenPaused) emit(RESUMED);
  });

  addEventListener('pause', function (e) {
    // if paused on ended then do nothing
    if (e.target.currentTime === e.target.duration) return;
    hasBeenPaused = true;
    emit(PAUSED);
  });

  addEventListener('ended', function () {
    emit(ENDED);
    unsubscribe();
  });

  addEventListener('timeupdate', (0, _throttle2.default)(function (e) {
    var progress = e.target.currentTime / e.target.duration;
    if (progress >= 0.25) emitFirstQuartile();
    if (progress >= 0.50) emitMidpoint();
    if (progress >= 0.75) emitThirdQuartile();
  }, 500));

  addEventListener('volumechange', function (e) {
    emit(VOLUME_CHANGE);
    var wasMuted = isMuted;
    isMuted = e.target.muted || e.target.volume === 0;
    if (wasMuted === isMuted) return;
    emit(isMuted ? MUTED : UNMUTED);
  });

  return unsubscribe;
};

VastEvents.EVENTS = {
  STARTED: STARTED,
  RESUMED: RESUMED,
  PAUSED: PAUSED,
  MUTED: MUTED,
  UNMUTED: UNMUTED,
  FIRST_QUARTILE: FIRST_QUARTILE,
  MIDPOINT: MIDPOINT,
  THIRD_QUARTILE: THIRD_QUARTILE,
  ENDED: ENDED,
  SKIPPED: SKIPPED,
  VOLUME_CHANGE: VOLUME_CHANGE
};

exports.default = VastEvents;

},{"lodash/once":643,"lodash/throttle":645}],122:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var VIDEO_MAX_WIDTH = 1280;
exports.VIDEO_MAX_WIDTH = VIDEO_MAX_WIDTH;


var VIDEO_PROGRAMMATIC_WIDTHS = [1024, 800, 640];
exports.VIDEO_PROGRAMMATIC_WIDTHS = VIDEO_PROGRAMMATIC_WIDTHS;


var VIDEO_PREFERRED_WIDTHS = [VIDEO_MAX_WIDTH].concat(VIDEO_PROGRAMMATIC_WIDTHS);
exports.VIDEO_PREFERRED_WIDTHS = VIDEO_PREFERRED_WIDTHS;


var SUPPORTED_VIDEO_FORMATS = ['video/webm'];
exports.SUPPORTED_VIDEO_FORMATS = SUPPORTED_VIDEO_FORMATS;
exports.default = {

  /**
   * Return video metadata based on preferred formats/widths
   *
   * @param {Object[]} - array of video metadata
   * @param {String[]} - array of preferred video formats
   * @param {String[]} - array of preferred video sizes
   * @return {Object} - preferred video metadata
   */

  getPreferredVideoMetadata: function getPreferredVideoMetadata(videos) {
    var formats = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SUPPORTED_VIDEO_FORMATS;
    var widths = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : VIDEO_PREFERRED_WIDTHS;

    var maxPreferredWidth = Math.max.apply(null, widths);

    // Filter out unsupported mimetypes
    var supportedMimeType = function supportedMimeType(video) {
      return formats.indexOf(video.mime_type) > -1;
    };

    // Filter out widths larger than largest preferred width
    var preferredWidth = function preferredWidth(video) {
      return video.width <= maxPreferredWidth;
    };

    // Sort in descending width
    var descWidth = function descWidth(v1, v2) {
      return v2.width - v1.width;
    };

    // Return video with largest preferred width
    return videos.filter(supportedMimeType).filter(preferredWidth).sort(descWidth).shift();
  }
};

},{}],123:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

// Licensed to the Apache Software Foundation (ASF) under one or more
// contributor license agreements.  See the NOTICE file distributed with
// this work for additional information regarding copyright ownership.
// The ASF licenses this file to You under the Apache License, Version 2.0
// (the "License"); you may not use this file except in compliance with
// the License.  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

if (typeof require !== 'undefined') {
  var has = require('ramda/src/has');
  var rType = require('ramda/src/type');
  var equals = require('ramda/src/equals');
  var contains = require('ramda/src/contains');
  var all = require('ramda/src/all');
  var pluck = require('ramda/src/pluck');
}

function isString(a) {
  return rType(a) === 'String';
}
function isObject(a) {
  return rType(a) === 'Object';
}
function isNull(a) {
  return rType(a) === 'Null';
}
function isUndefined(a) {
  return a === void 0;
}
function isNumber(a) {
  return rType(a) === 'Number';
}
function isBoolean(a) {
  return rType(a) === 'Boolean';
}

var AvroSpec = {
  PrimitiveTypes: ['null', 'boolean', 'int', 'long', 'float', 'double', 'bytes', 'string'],
  ComplexTypes: ['record', 'enum', 'array', 'map', 'union', 'fixed']
};

var hexRegEx = /([0-9]|[a-f]|[A-F])/gm;

AvroSpec.Types = AvroSpec.PrimitiveTypes.concat(AvroSpec.ComplexTypes);

var InvalidSchemaError = function InvalidSchemaError(msg) {
  return new Error('InvalidSchemaError: ' + msg);
};
var InvalidProtocolError = function InvalidProtocolError(msg) {
  return new Error('InvalidProtocolError: ' + msg);
};
var ValidationError = function ValidationError(msg) {
  return new Error('ValidationError: ' + msg);
};
var ProtocolValidationError = function ProtocolValidationError(msg) {
  return new Error('ProtocolValidationError: ' + msg);
};

function Record(name, namespace, fields, typeName) {
  function validateArgs(name, namespace, fields) {
    if (!isString(name)) {
      throw new InvalidSchemaError('Record name must be string');
    }

    if (!isNull(namespace) && !isUndefined(namespace) && !isString(namespace)) {
      throw new InvalidSchemaError('Record namespace must be string or null');
    }

    if (!Array.isArray(fields)) {
      throw new InvalidSchemaError('Record name must be string');
    }
  }

  validateArgs(name, namespace, fields);

  this.name = name;
  this.typeName = typeName;
  this.namespace = namespace;
  this.fields = fields;
}

function isHex(input) {
  return typeof input === 'string' && (input.match(hexRegEx) || []).length === input.length;
}

function makeFullyQualifiedTypeName(schema, namespace) {
  var typeName = null;
  if (isString(schema)) {
    typeName = schema;
  } else if (isObject(schema)) {
    if (isString(schema.namespace)) {
      namespace = schema.namespace;
    }
    if (isString(schema.name)) {
      typeName = schema.name;
    } else if (isString(schema.type)) {
      typeName = schema.type;
    }
    /** BEGIN CHANGE BY drewp **/
    else if (has('valueSchema', schema) && isString(schema.valueSchema.type)) {
        typeName = schema.typeName;
      }
    /** END CHANGE BY drewp **/
  } else {
    throw new InvalidSchemaError('unable to determine fully qualified type name from schema ' + JSON.stringify(schema) + ' in namespace ' + namespace);
  }

  if (!isString(typeName)) {
    throw new InvalidSchemaError('unable to determine type name from schema ' + JSON.stringify(schema) + ' in namespace ' + namespace);
  }

  if (typeName.indexOf('.') !== -1) {
    return typeName;
  } else if (contains(typeName, AvroSpec.PrimitiveTypes)) {
    return typeName;
  } else if (isString(namespace)) {
    return namespace + '.' + typeName;
  } else {
    return typeName;
  }
}

function Union(typeSchemas, namespace, typeName) {
  this.branchNames = function () {
    return typeSchemas.map(function (typeSchema) {
      return makeFullyQualifiedTypeName(typeSchema, namespace);
    });
  };

  function validateArgs(typeSchemas) {
    if (!Array.isArray(typeSchemas) || !typeSchemas.length) {
      throw new InvalidSchemaError('Union must have at least 1 branch');
    }
  }

  validateArgs(typeSchemas);

  this.typeSchemas = typeSchemas;
  this.typeName = typeName;
  this.namespace = namespace;
}

function Enum(symbols, typeName) {

  function validateArgs(symbols) {
    if (!Array.isArray(symbols)) {
      throw new InvalidSchemaError('Enum must have array of symbols, got ' + JSON.stringify(symbols));
    }
    if (!all(function (symbol) {
      return isString(symbol);
    }, symbols)) {
      throw new InvalidSchemaError('Enum symbols must be strings, got ' + JSON.stringify(symbols));
    }
  }

  validateArgs(symbols);

  this.symbols = symbols;
  this.typeName = typeName;
}

function AvroArray(itemSchema, typeName) {

  function validateArgs(itemSchema) {
    if (isNull(itemSchema) || isUndefined(itemSchema)) {
      throw new InvalidSchemaError('Array "items" schema should not be null or undefined');
    }
  }

  validateArgs(itemSchema);

  this.itemSchema = itemSchema;
  this.typeName = typeName;
}

function Map(valueSchema, typeName) {
  function validateArgs(valueSchema) {
    if (isNull(valueSchema) || isUndefined(valueSchema)) {
      throw new InvalidSchemaError('Map "values" schema should not be null or undefined');
    }
  }

  validateArgs(valueSchema);

  this.valueSchema = valueSchema;
  this.typeName = typeName;
}

function Field(name, schema) {
  function validateArgs(name, schema) {
    if (!isString(name)) {
      throw new InvalidSchemaError('Field name must be string');
    }
  }

  this.name = name;
  this.schema = schema;
}

function Primitive(type) {
  function validateArgs(type) {
    if (!isString(type)) {
      throw new InvalidSchemaError('Primitive type name must be a string');
    }

    if (!contains(type, AvroSpec.PrimitiveTypes)) {
      throw new InvalidSchemaError('Primitive type must be one of: ' + JSON.stringify(AvroSpec.PrimitiveTypes) + '; got ' + type);
    }
  }

  validateArgs(type);

  this.type = type;
}

function Validator(schema, namespace, namedTypes) {
  this.validate = function (obj) {
    return _validate(this.schema, obj);
  };

  var _validate = function _validate(schema, obj, fieldName) {
    if (schema instanceof Record) {
      return _validateRecord(schema, obj);
    } else if (schema instanceof Union) {
      return _validateUnion(schema, obj, fieldName);
    } else if (schema instanceof Enum) {
      return _validateEnum(schema, obj);
    } else if (schema instanceof AvroArray) {
      return _validateArray(schema, obj);
    } else if (schema instanceof Map) {
      return _validateMap(schema, obj);
    } else if (schema instanceof Primitive) {
      return _validatePrimitive(schema, obj);
    } else {
      throw new InvalidSchemaError('validation not yet implemented: ' + JSON.stringify(schema));
    }
  };

  var _validateRecord = function _validateRecord(schema, obj) {
    if (!isObject(obj)) {
      throw new ValidationError('Expected record Javascript type to be non-array object, got ' + JSON.stringify(obj));
    }

    var schemaFieldNames = pluck('name', schema.fields).sort();
    var objFieldNames = Object.keys(obj).sort();
    if (!equals(schemaFieldNames, objFieldNames)) {
      throw new ValidationError('Expected record fields ' + JSON.stringify(schemaFieldNames) + '; got ' + JSON.stringify(objFieldNames));
    }
    return all(function (field) {
      return _validate(field.schema, obj[field.name], field.name);
    }, schema.fields);
  };

  var _validateUnion = function _validateUnion(schema, obj, fieldName) {
    if (isObject(obj)) {
      if (Array.isArray(obj)) {
        throw new ValidationError('Expected union Javascript type to be non-array object (or null), got ' + JSON.stringify(obj));
      } else if (Object.keys(obj).length !== 1) {
        throw new ValidationError('Expected union Javascript object to be object with exactly 1 key (or null), got ' + JSON.stringify(obj));
      } else {
        var unionBranch = Object.keys(obj)[0];
        if (unionBranch === "") {
          throw new ValidationError('Expected union Javascript object to contain non-empty string branch, got ' + JSON.stringify(obj));
        }
        if (contains(unionBranch, schema.branchNames())) {
          var typeIndex = schema.branchNames().indexOf(unionBranch);
          var unionBranchVal = obj[unionBranch];
          if (isNull(unionBranchVal) && contains('null', schema.branchNames()) || isUndefined(unionBranchVal)) {
            return true;
          }
          try {
            _validate(schema.typeSchemas[typeIndex], obj[unionBranch]);
            return true;
          } catch (e) {
            throw new ValidationError('Expected field name ' + fieldName + ' value to validate. Instead got an error: ' + e.message);
          }
        } else {
          throw new ValidationError('Expected union branch to be one of ' + JSON.stringify(schema.branchNames()) + '; got ' + JSON.stringify(unionBranch));
        }
      }
    } else if (isNull(obj)) {
      if (contains('null', schema.branchNames())) {
        return true;
      } else {
        throw new ValidationError('Expected union branch to be one of ' + JSON.stringify(schema.branchNames()) + '; got ' + JSON.stringify(obj));
      }
    } else if (Array.isArray(obj)) {
      throw new ValidationError('Expected union Javascript type to be non-array object (or null), got ' + JSON.stringify(obj));
    } else {
      throw new ValidationError('Expected union Javascript object to be non-array object of size 1 or null, got ' + JSON.stringify(obj));
    }
  };

  var _validateEnum = function _validateEnum(schema, obj) {
    if (isString(obj)) {
      if (contains(obj, schema.symbols)) {
        return true;
      } else {
        throw new ValidationError('Expected enum value to be one of ' + JSON.stringify(schema.symbols) + '; got ' + JSON.stringify(obj));
      }
    } else {
      throw new ValidationError('Expected enum Javascript object to be string, got ' + JSON.stringify(obj));
    }
  };

  var _validateArray = function _validateArray(schema, obj) {
    if (Array.isArray(obj)) {
      return all(function (member) {
        return _validate(schema.itemSchema, member);
      }, obj);
    } else {
      throw new ValidationError('Expected array Javascript object to be array, got ' + JSON.stringify(obj));
    }
  };

  var _validateMap = function _validateMap(schema, obj) {
    if (isObject(obj)) {
      return all(function (key) {
        return _validate(schema.valueSchema, obj[key]);
      }, Object.keys(obj));
    } else if (Array.isArray(obj)) {
      throw new ValidationError('Expected map Javascript object to be non-array object, got array ' + JSON.stringify(obj));
    } else {
      throw new ValidationError('Expected map Javascript object to be non-array object, got ' + JSON.stringify(obj));
    }
  };

  var _validatePrimitive = function _validatePrimitive(schema, obj) {
    switch (schema.type) {
      case 'null':
        if (isNull(obj) || isUndefined(obj)) {
          return true;
        } else {
          throw new ValidationError('Expected Javascript null or undefined for Avro null, got ' + JSON.stringify(obj));
        }
        break;
      case 'boolean':
        if (isBoolean(obj)) {
          return true;
        } else {
          throw new ValidationError('Expected Javascript boolean for Avro boolean, got ' + JSON.stringify(obj));
        }
        break;
      case 'int':
        if (isNumber(obj) && Math.floor(obj) === obj && Math.abs(obj) <= Math.pow(2, 31)) {
          return true;
        } else {
          throw new ValidationError('Expected Javascript int32 number for Avro int, got ' + JSON.stringify(obj));
        }
        break;
      case 'long':
        if (isNumber(obj) && Math.floor(obj) === obj && Math.abs(obj) <= Math.pow(2, 63)) {
          return true;
        } else {
          throw new ValidationError('Expected Javascript int64 number for Avro long, got ' + JSON.stringify(obj));
        }
        break;
      case 'float':
        if (isNumber(obj)) {
          // TODO: handle NaN?
          return true;
        } else {
          throw new ValidationError('Expected Javascript float number for Avro float, got ' + JSON.stringify(obj));
        }
        break;
      case 'double':
        if (isNumber(obj)) {
          // TODO: handle NaN?
          return true;
        } else {
          throw new ValidationError('Expected Javascript double number for Avro double, got ' + JSON.stringify(obj));
        }
        break;
      case 'bytes':
        if (isHex(obj)) {
          return true;
        } else {
          throw new ValidationError('Expected Javascript bytes for Avro byts, got ' + JSON.stringify(obj));
        }
      case 'string':
        if (isString(obj)) {
          // TODO: handle NaN?
          return true;
        } else {
          throw new ValidationError('Expected Javascript string for Avro string, got ' + JSON.stringify(obj));
        }
        break;
      default:
        throw new InvalidSchemaError('unrecognized primitive type: ' + schema.type);
    }
  };

  // TODO: namespace handling is rudimentary. multiple namespaces within a certain nested schema definition
  // are probably buggy.
  var _namedTypes = namedTypes || {};
  var _saveNamedType = function _saveNamedType(fullyQualifiedTypeName, schema) {
    if (has(fullyQualifiedTypeName, _namedTypes)) {
      if (!equals(_namedTypes[fullyQualifiedTypeName], schema)) {
        throw new InvalidSchemaError('conflicting definitions for type ' + fullyQualifiedTypeName + ': ' + JSON.stringify(_namedTypes[fullyQualifiedTypeName]) + ' and ' + JSON.stringify(schema));
      }
    } else {
      _namedTypes[fullyQualifiedTypeName] = schema;
    }
  };

  var _lookupTypeByFullyQualifiedName = function _lookupTypeByFullyQualifiedName(fullyQualifiedTypeName) {
    if (has(fullyQualifiedTypeName, _namedTypes)) {
      return _namedTypes[fullyQualifiedTypeName];
    } else {
      return null;
    }
  };

  var _parseNamedType = function _parseNamedType(schema, namespace) {
    if (contains(schema, AvroSpec.PrimitiveTypes)) {
      return new Primitive(schema);
    } else if (!isNull(_lookupTypeByFullyQualifiedName(makeFullyQualifiedTypeName(schema, namespace)))) {
      return _lookupTypeByFullyQualifiedName(makeFullyQualifiedTypeName(schema, namespace));
    } else {
      throw new InvalidSchemaError('unknown type name: ' + JSON.stringify(schema) + '; known type names are ' + JSON.stringify(Object.keys(_namedTypes)));
    }
  };

  var _parseSchema = function _parseSchema(schema, parentSchema, namespace) {
    if (isNull(schema) || isUndefined(schema)) {
      throw new InvalidSchemaError('schema is null, in parentSchema: ' + JSON.stringify(parentSchema));
    } else if (isString(schema)) {
      return _parseNamedType(schema, namespace);
    } else if (isObject(schema)) {
      if (schema.type === 'record') {
        var newRecord = new Record(schema.name, schema.namespace, schema.fields.map(function (field) {
          return new Field(field.name, _parseSchema(field.type, schema, schema.namespace || namespace));
        }), schema.type);
        _saveNamedType(makeFullyQualifiedTypeName(schema, namespace), newRecord);
        return newRecord;
      } else if (schema.type === 'enum') {
        if (has('symbols', schema)) {
          var newEnum = new Enum(schema.symbols, schema.type);
          _saveNamedType(makeFullyQualifiedTypeName(schema, namespace), newEnum);
          return newEnum;
        } else {
          throw new InvalidSchemaError('enum must specify symbols, got ' + JSON.stringify(schema));
        }
      } else if (schema.type === 'array') {
        if (has('items', schema)) {
          return new AvroArray(_parseSchema(schema.items, schema, namespace), schema.type);
        } else {
          throw new InvalidSchemaError('array must specify "items" schema, got ' + JSON.stringify(schema));
        }
      } else if (schema.type === 'map') {
        if (has('values', schema)) {
          return new Map(_parseSchema(schema.values, schema, namespace), schema.type);
        } else {
          throw new InvalidSchemaError('map must specify "values" schema, got ' + JSON.stringify(schema));
        }
      } else if (has('type', schema) && contains(schema.type, AvroSpec.PrimitiveTypes)) {
        return _parseNamedType(schema.type, namespace);
      } else {
        throw new InvalidSchemaError('not yet implemented: ' + schema.type);
      }
    } else if (Array.isArray(schema)) {
      if (!schema.length) {
        throw new InvalidSchemaError('unions must have at least 1 branch');
      }
      var branchTypes = schema.map(function (branchType) {
        return _parseSchema(branchType, schema, namespace);
      });
      return new Union(branchTypes, namespace, 'union');
    } else {
      throw new InvalidSchemaError('unexpected Javascript type for schema: ' + (typeof schema === 'undefined' ? 'undefined' : _typeof(schema)));
    }
  };

  this.rawSchema = schema;
  this.schema = _parseSchema(schema, null, namespace);
}

Validator.validate = function (schema, obj) {
  return new Validator(schema).validate(obj);
};

function ProtocolValidator(protocol) {
  this.validate = function (typeName, obj) {
    var fullyQualifiedTypeName = makeFullyQualifiedTypeName(typeName, protocol.namespace);
    if (!has(fullyQualifiedTypeName, _typeSchemaValidators)) {
      throw new ProtocolValidationError('Protocol does not contain definition for type ' + JSON.stringify(fullyQualifiedTypeName) + ' (fully qualified from input "' + typeName + '"); known types are ' + JSON.stringify(Object.keys(_typeSchemaValidators)));
    }
    return _typeSchemaValidators[fullyQualifiedTypeName].validate(obj);
  };

  var _typeSchemaValidators = {};
  var _initSchemaValidators = function _initSchemaValidators(protocol) {
    var namedTypes = {};
    if (!has('protocol', protocol) || !isString(protocol.protocol)) {
      throw new InvalidProtocolError('Protocol must contain a "protocol" attribute with a string value');
    }
    if (Array.isArray(protocol.types)) {
      protocol.types.forEach(function (typeSchema) {
        var schemaValidator = new Validator(typeSchema, protocol.namespace, namedTypes);
        var fullyQualifiedTypeName = makeFullyQualifiedTypeName(typeSchema, protocol.namespace);
        _typeSchemaValidators[fullyQualifiedTypeName] = schemaValidator;
      });
    }
  };

  _initSchemaValidators(protocol);
}

ProtocolValidator.validate = function (protocol, typeName, obj) {
  return new ProtocolValidator(protocol).validate(typeName, obj);
};

if (typeof exports !== 'undefined') {
  exports['Validator'] = Validator;
  exports['ProtocolValidator'] = ProtocolValidator;
}

},{"ramda/src/all":703,"ramda/src/contains":704,"ramda/src/equals":705,"ramda/src/has":706,"ramda/src/pluck":726,"ramda/src/type":728}],124:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _operationCanceledError = {
  name: 'OperationCanceledError',
  message: 'An async operation was cancelled'
};

var CancellationToken = function () {
  // Internal constructor: only a CancellationTokenSource should create
  // a CancellationToken.
  function CancellationToken(source) {
    _classCallCheck(this, CancellationToken);

    this.source = source;
    this.requestId = source.requestId;
  }

  _createClass(CancellationToken, [{
    key: 'isCanceled',
    value: function isCanceled() {
      return this.requestId !== this.source.requestId;
    }
  }, {
    key: 'throwIfCanceled',
    value: function throwIfCanceled() {
      if (this.isCanceled()) {
        throw _operationCanceledError;
      }
    }
  }, {
    key: 'errorIfCanceled',
    value: function errorIfCanceled() {
      if (this.isCanceled()) {
        return _operationCanceledError;
      }
      return undefined;
    }
  }, {
    key: 'operationCanceledError',
    value: function operationCanceledError() {
      return _operationCanceledError;
    }
  }]);

  return CancellationToken;
}();

var CancellationTokenSource = function () {
  function CancellationTokenSource() {
    _classCallCheck(this, CancellationTokenSource);

    this.requestId = 0;
  }

  // Create a new token that can be cancelled by canlling cancel() in the
  // CancellationTokenSource.


  _createClass(CancellationTokenSource, [{
    key: 'token',
    value: function token() {
      return new CancellationToken(this);
    }

    // Cancel all the tokens created so far.

  }, {
    key: 'cancel',
    value: function cancel() {
      this.requestId++;
    }
  }]);

  return CancellationTokenSource;
}();

exports.default = CancellationTokenSource;

},{}],125:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = {
  // App notifications
  APP_NOTIFY_LOADED: 'notify_loaded',

  // Connection state notifications
  CONNECTION_STATE_CHANGE: 'connection-state-change',
  CONNECTION_OFFLINE_ERROR: 'offline-error',

  // Window events
  WINDOW_ENTER_FULLSCREEN: 'enter_fullscreen',
  WINDOW_LEAVE_FULLSCREEN: 'leave_fullscreen',

  // Spotify Connect
  SPCONNECT_DEVICE_STATE: 'connectdevice',

  // Social / Facebook
  SOCIAL_ERROR: 'socialerror',

  // Navigation
  NAVIGATION_OPEN_URI: 'open_uri',
  NAVIGATION_LOGOUT: 'logout',
  NAVIGATION_HISTORY_BACK: 'browse_backward',
  NAVIGATION_HISTORY_CHANGE: 'historychange',
  NAVIGATION_HISTORY_FORWARD: 'browse_forward',
  NAVIGATION_HISTORY_GO: 'history_go',
  NAVIGATION_HISTORY_REMOVE: 'history_remove',
  NAVIGATION_STATE_CHANGE: 'statechange',
  NAVIGATION_SHOW_SHARE: 'show_share',
  NAVIGATION_SHOW_ABOUT: 'show_about',
  NAVIGATION_SHOW_PREFERENCES: 'show_preferences',
  NAVIGATION_SHOW_HELP: 'show_help',
  NAVIGATION_SHOW_COMMUNITY: 'show_community',
  NAVIGATION_SHOW_ACCOUNT: 'show_account',
  NAVIGATION_SHOW_LICENSES: 'show_licenses',
  NAVIGATION_SHOW_LICENSING_INFORMATION: 'show_licensing_information',
  NAVIGATION_SHOW_SCTA_INFORMATION: 'show_scta_information',
  NAVIGATION_SHOW_SEARCH: 'show_search',
  NAVIGATION_SHOW_FULL_SCREEN_MODAL: 'show_full_screen_modal',
  NAVIGATION_SHOW_FIND_FRIENDS: 'show_find_friends',
  NAVIGATION_SHOW_NPS_SURVEY: 'show_nps_survey',
  NAVIGATION_REFRESH_VIEWS: 'refresh-view',
  NAVIGATION_UPGRADE: 'upgrade_premium',

  // Views
  VIEW_LOADED: 'view_loaded',
  VIEW_UNLOADED: 'view_unloaded',

  // Context menu
  CONTEXT_CLIENT_SHOW_UI: 'client_show_context_ui',
  CONTEXT_SHOW_UI: 'show_context_ui',

  // Messages
  MESSAGE_NOTIFICATION: 'notification_message',
  MESSAGE_USER: 'user-message',

  // Player
  PLAYER_EVENT: 'player_event',
  PLAYER_PROGRESS: 'progress',
  PLAYER_SYNC_PROGRESS: 'sync_progress',
  PLAYER_VOLUME: 'volume',
  PLAYER_VOLUME_UP: 'volume_up',
  PLAYER_VOLUME_DOWN: 'volume_down',
  PLAYER_SEEK: 'seek',
  PLAYER_SHUFFLE: 'set_shuffle',
  PLAYER_REPEAT: 'set_repeat',
  PLAYER_PAUSE: 'pause',
  PLAYER_RESUME: 'resume',
  PLAYER_NEXT: 'skip_to_next',
  PLAYER_PREV: 'skip_to_prev',

  // Ads
  AD_AUDIO_STARTED: 'ad:audio:started',
  AD_AUDIO_FINISHED: 'ad:audio:finished',
  AD_BILLBOARD_STARTED: 'ad:billboard:started',
  AD_BILLBOARD_FINISHED: 'ad:billboard:finished',
  AD_BILLBOARD_DISCARDED: 'ad:billboard:discarded',
  AD_BILLBOARD_VISIBLE: 'ad:billboard:visible',
  AD_BILLBOARD_HIDDEN: 'ad:billboard:hidden',
  AD_BILLBOARD_FOCUS_RECEIVED: 'ad:billboard:focusreceived',
  AD_BILLBOARD_MINIMIZED: 'ad:billboard:minimized',
  AD_VIDEO_STARTED: 'ad:video:started',
  AD_VIDEO_FINISHED: 'ad:video:finished',
  AD_LEADERBOARD_PLACEMENT: 'ad:leaderboard:placement',
  AD_SPONSORSHIP_ACTIVE: 'ad:sponsorship:active',
  AD_CLICK_VIDEO_STARTED: 'ad:clickvideo:started',
  AD_CLICK_VIDEO_ENDED: 'ad:clickvideo:ended',
  AD_LEADERBOARD_ERROR: 'ad:leaderboard:error',
  AD_LEADERBOARD_USED_DEFAULT: 'ad:leaderboard:used:default',
  AD_PLAYER_STATE_EVENT: 'ad:player:event',

  DEBUG_SET_BILLBOARD_TIMEOUT: 'debug:ad:set:billboard_timeout',
  DEBUG_DISABLE_AD_LEADERBOARD_REFRESH_ON_NAVIGATE_OR_REFOCUS: 'debug:ad:override:leaderboard:refreshnavigation',
  DEBUG_ENABLE_AD_LEADERBOARD_REFRESH_ON_NAVIGATE_OR_REFOCUS: 'debug:ad:enable:leaderboard:refreshnavigation',
  DEBUG_FORCE_REFRESH_LEADERBOARD: 'debug:ad:force_refresh:leaderboard',
  DEBUG_FORCE_REFRESH_HPTO: 'debug:ad:force_refresh:hpto',
  DEBUG_FORCE_REFRESH_BILLBOARD: 'debug:ad:force_refresh:billboard',
  DEBUG_OVERRIDE_AD_LEADERBOARD_HTML: 'debug:ad:override:leaderboard:html',
  DEBUG_RECEIVED_AD_LEADERBOARD_HTML: 'debug:received:ad:leaderboard:html',
  DEBUG_OVERRIDE_AD_LEADERBOARD_FLAGS: 'debug:ad:override:leaderboard:flags',
  DEBUG_OVERRIDE_AD_LEADERBOARD_REFRESH_INTERVAL: 'debug:ad:override:leaderboard:refreshinterval',

  // UI
  UI_DRAG: 'drag',
  UI_DRAG_END: 'dragend',

  // Application
  APPLICATION_FOCUS_LOST: 'application:focus:lost',
  APPLICATION_FOCUS_GAINED: 'application:focus:gained',
  APPLICATION_INACTIVE: 'application:inactive',

  // Popovers
  POPOVER_OPENED: 'popover:opened',
  POPOVER_CLOSED: 'popover:closed',

  // Layout events
  LAYOUT_SIDEBAR_RESIZED: 'layout:sidebar:resized',

  // Playlist control messages
  CONTROL_MESSAGE_DELETE: 'delete',
  CONTROL_MESSAGE_NEW_PLAYLIST: 'create_new_playlist',
  CONTROL_MESSAGE_NEW_FOLDER: 'create_new_folder',
  CONTROL_MESSAGE_UNDO: 'undo_action',

  // Stations
  THUMB_UP: 'thumb-up',
  THUMB_DOWN: 'thumb-down',

  // Daily Mix
  HEART: 'heart',
  HEART_NOTIFY: 'heart-notify',
  BAN_TRACK: 'ban-track',
  BAN_TRACK_NOTIFY: 'ban-track-notify',
  BAN_ARTIST: 'ban-artist',
  BAN_ARTIST_NOTIFY: 'ban-artist-notify',

  // CAPPING  MESSAGES
  CAPPING_OPEN_UPSELL_MESSAGE: 'capping:open:upsellmessage',
  CAPPING_OPEN_WELCOME_MESSAGE: 'capping:open:welcomemessage',

  // Usable State
  USABLE_STATE_NOT_SUCCESSFUL: 'usable_state_not_successful',

  // ViewLoadTimer Debugging
  TOGGLE_VIEW_LOAD_TIMER_DEBUGGING: 'toggle_view_load_timer_debugging'
};

},{}],126:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addDebouncedScrollListener = addDebouncedScrollListener;
exports.removeDebouncedScrollListener = removeDebouncedScrollListener;
exports.requestFrame = requestFrame;
exports.cancelFrame = cancelFrame;
exports._reset = _reset;
var scrollNodeToListenerInfoList = new global.Map();
var idToScrollNode = {};
var frameListenerInfoList = [];
var hasQueuedScroll = false;
var lastScrollEvent = null;
var lastFrameRequestId = 0;
var globalIdCounter = 0;

function onScroll(event) {
  lastScrollEvent = event;

  if (!hasQueuedScroll) {
    (function () {
      hasQueuedScroll = true;

      var listenerInfoList = scrollNodeToListenerInfoList.get(event.target);
      if (listenerInfoList) {
        (function () {
          var list = void 0;
          requestFrame(function () {
            hasQueuedScroll = false;

            // Make a copy so that a potential handler that removes a handler
            // doesn't disturb the loop. This same copy will also be used in the
            // write handler, to prevent disturbing the write loop when handlers are
            // removed in the read loop.
            list = listenerInfoList.slice();

            callReadHandlers(list, lastScrollEvent);
          }, function () {
            callWriteHandlers(list, lastScrollEvent);
          });
        })();
      }
    })();
  }
}

function onFrame(timestamp) {
  lastFrameRequestId = 0;

  // Remove all current listeners as they are only valid for one frame. Just
  // like the regular requestAnimationFrame the handler needs to request a new
  // frame if it needs one.
  var listenerInfoList = frameListenerInfoList;
  frameListenerInfoList = [];

  callReadHandlers(listenerInfoList, timestamp);
  callWriteHandlers(listenerInfoList, timestamp);
}

function callReadHandlers(listenerInfoList, handlerArgument) {
  listenerInfoList.forEach(function (listenerInfo) {
    if (listenerInfo.readFunction) {
      listenerInfo.readFunction(handlerArgument);
    }
  });
}

function callWriteHandlers(listenerInfoList, handlerArgument) {
  listenerInfoList.forEach(function (listenerInfo) {
    if (typeof listenerInfo.writeFunction === 'function') {
      listenerInfo.writeFunction(handlerArgument);
    }
  });
}

function addDebouncedScrollListener(scrollNode, readFunction, writeFunction) {
  if (readFunction !== null && typeof readFunction !== 'function') {
    throw new TypeError('The callback provided to addDebouncedScrollListener as parameter 2 is ' + 'not a function.');
  }
  if (writeFunction !== undefined && typeof writeFunction !== 'function') {
    throw new TypeError('The callback provided to addDebouncedScrollListener as parameter 3 is ' + 'not a function.');
  }

  if (!scrollNodeToListenerInfoList.has(scrollNode)) {
    scrollNode.addEventListener('scroll', onScroll);
    scrollNodeToListenerInfoList.set(scrollNode, []);
  }

  var id = ++globalIdCounter;
  var listenerInfo = {
    id: id,
    readFunction: readFunction,
    writeFunction: writeFunction
  };

  idToScrollNode[id] = scrollNode;
  scrollNodeToListenerInfoList.get(scrollNode).push(listenerInfo);

  return id;
}

function removeDebouncedScrollListener(id) {
  var scrollNode = idToScrollNode[id];
  if (scrollNode) {
    delete idToScrollNode[id];

    var listenerInfoList = scrollNodeToListenerInfoList.get(scrollNode);
    if (listenerInfoList) {
      for (var i = 0; i < listenerInfoList.length; i++) {
        if (listenerInfoList[i].id === id) {
          listenerInfoList.splice(i, 1);
          break;
        }
      }
    }

    if (listenerInfoList.length === 0) {
      scrollNode.removeEventListener('scroll', onScroll);
      scrollNodeToListenerInfoList.delete(scrollNode);
    }
  }
}

function requestFrame(readFunction, writeFunction) {
  if (readFunction !== null && typeof readFunction !== 'function') {
    throw new TypeError('The callback provided to requestFrame as parameter 1 is not a function.');
  }
  if (writeFunction !== undefined && typeof writeFunction !== 'function') {
    throw new TypeError('The callback provided to requestFrame as parameter 2 is not a function.');
  }

  if (lastFrameRequestId === 0) {
    lastFrameRequestId = window.requestAnimationFrame(onFrame);
  }

  var id = ++globalIdCounter;
  var listenerInfo = {
    id: id,
    readFunction: readFunction,
    writeFunction: writeFunction
  };

  frameListenerInfoList.push(listenerInfo);

  return id;
}

function cancelFrame(id) {
  for (var i = 0; i < frameListenerInfoList.length; i++) {
    if (frameListenerInfoList[i].id === id) {
      frameListenerInfoList.splice(i, 1);
      break;
    }
  }

  if (lastFrameRequestId !== 0 && frameListenerInfoList.length === 0) {
    window.cancelAnimationFrame(lastFrameRequestId);
    lastFrameRequestId = 0;
  }
}

// Use only for testing, to be able to reset the state for each test
function _reset() {
  scrollNodeToListenerInfoList = new global.Map();
  idToScrollNode = {};
  frameListenerInfoList = [];
  hasQueuedScroll = false;
  lastScrollEvent = null;
  lastFrameRequestId = 0;
  globalIdCounter = 0;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],127:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _classnames2 = require('classnames');

var _classnames3 = _interopRequireDefault(_classnames2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// The display of a focus ring is implemented but not turned on yet since we
// don't want some buttons to have this and some not.
var ENABLE_FOCUS_DISPLAY = false;

var GlueButton = function (_React$PureComponent) {
  _inherits(GlueButton, _React$PureComponent);

  function GlueButton() {
    var _ref;

    _classCallCheck(this, GlueButton);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    var _this = _possibleConstructorReturn(this, (_ref = GlueButton.__proto__ || Object.getPrototypeOf(GlueButton)).call.apply(_ref, [this].concat(args)));

    _this.state = {
      hideFocus: ENABLE_FOCUS_DISPLAY ? false : true
    };

    if (ENABLE_FOCUS_DISPLAY) {
      _this.onDocumentMouseDown = _this.onDocumentMouseDown.bind(_this);
      _this.onDocumentKeyDown = _this.onDocumentKeyDown.bind(_this);

      document.addEventListener('mousedown', _this.onDocumentMouseDown);
      document.addEventListener('keydown', _this.onDocumentKeyDown);
    }
    return _this;
  }

  _createClass(GlueButton, [{
    key: 'componentWillUnmount',
    value: function componentWillUnmount() {
      if (ENABLE_FOCUS_DISPLAY) {
        document.removeEventListener('keydown', this.onDocumentMouseDown);
        document.removeEventListener('keydown', this.onDocumentKeyDown);
      }
    }
  }, {
    key: 'onDocumentMouseDown',
    value: function onDocumentMouseDown() {
      this.setState({ hideFocus: true });
    }
  }, {
    key: 'onDocumentKeyDown',
    value: function onDocumentKeyDown(event) {
      if (event.keyCode === 9) {
        // Tab key
        this.setState({ hideFocus: false });
      }
    }
  }, {
    key: 'getARIALabel',
    value: function getARIALabel() {
      var _props = this.props,
          text = _props.text,
          accessibleText = _props.accessibleText,
          texts = _props.texts,
          accessibleTexts = _props.accessibleTexts,
          activeTextIndex = _props.activeTextIndex;


      if (accessibleTexts.length > 0) {
        return accessibleTexts[activeTextIndex];
      }

      if (texts.length > 0) {
        return texts[activeTextIndex];
      }

      if (accessibleText) {
        return accessibleText;
      }

      return text;
    }
  }, {
    key: 'render',
    value: function render() {
      var _props2 = this.props,
          type = _props2.type,
          size = _props2.size,
          icon = _props2.icon,
          text = _props2.text,
          texts = _props2.texts,
          activeTextIndex = _props2.activeTextIndex,
          isDisabled = _props2.isDisabled,
          isActive = _props2.isActive,
          isDropTargetActive = _props2.isDropTargetActive,
          announceStateChange = _props2.announceStateChange,
          onClick = _props2.onClick;
      var hideFocus = this.state.hideFocus;


      return _react2.default.createElement(
        'button',
        {
          type: 'button',
          'aria-label': this.getARIALabel(),
          'aria-live': announceStateChange ? 'polite' : 'off',
          className: (0, _classnames3.default)('GlueButton', _defineProperty({

            // Pre-defined button styles
            'GlueButton--style-green': type === 'green',
            'GlueButton--style-white': type === 'white',
            'GlueButton--style-red': type === 'red',
            'GlueButton--style-blue': type === 'blue',
            'GlueButton--style-gray': type === 'gray',
            'GlueButton--style-facebook': type === 'facebook',
            'GlueButton--style-stroke': type === 'stroke',
            'GlueButton--style-icon': type === 'icon',
            'GlueButton--style-stroke-icon': type === 'icon-stroke',

            // Generic modifiers
            'GlueButton--with-focus': !hideFocus,
            'GlueButton--is-active': isActive,
            'GlueButton--is-drop-target-active': isDropTargetActive,
            'GlueButton--small': size === 'small',
            'GlueButton--normal': size === 'normal',
            'GlueButton--large': size === 'large'

          }, 'spoticon-' + icon + '-16', !!icon)),
          disabled: isDisabled,
          onClick: onClick
        },
        _react2.default.createElement('div', { className: 'GlueButton__focus-ring', 'aria-hidden': 'true' }),
        texts.length === 0 && text ? _react2.default.createElement(
          'span',
          { className: 'GlueButton__text GlueButton__text--is-active' },
          text
        ) : texts.map(function (value, index) {
          return _react2.default.createElement(
            'span',
            {
              key: index,
              className: (0, _classnames3.default)({
                'GlueButton__text': index === 0,
                'GlueButton__alt-text': index > 0,
                'GlueButton__alt-text--is-active': index > 0 && index === activeTextIndex,
                'GlueButton__text--is-active': index === 0 && index === activeTextIndex
              }),
              'aria-hidden': index !== activeTextIndex
            },
            value
          );
        })
      );
    }
  }]);

  return GlueButton;
}(_react2.default.PureComponent);

exports.default = GlueButton;


GlueButton.propTypes = {

  // Required
  type: _react2.default.PropTypes.oneOf(['green', 'white', 'red', 'blue', 'gray', 'facebook', 'stroke', 'icon', 'icon-stroke']).isRequired,

  // Optional
  size: _react2.default.PropTypes.oneOf(['small', 'normal', 'large']),
  icon: _react2.default.PropTypes.string,
  text: _react2.default.PropTypes.string,
  accessibleText: _react2.default.PropTypes.string,
  texts: _react2.default.PropTypes.array,
  accessibleTexts: _react2.default.PropTypes.array,
  activeTextIndex: _react2.default.PropTypes.number,
  isDisabled: _react2.default.PropTypes.bool,
  isActive: _react2.default.PropTypes.bool,
  isDropTargetActive: _react2.default.PropTypes.bool,
  announceStateChange: _react2.default.PropTypes.bool,
  onClick: _react2.default.PropTypes.func
};

GlueButton.defaultProps = {
  size: 'normal',
  icon: '',
  text: '',
  accessibleText: '',
  texts: [],
  accessibleTexts: [],
  activeTextIndex: 0,
  isDisabled: false,
  isActive: false,
  isDropTargetActive: false,
  announceStateChange: false,
  onClick: function onClick() {}
};

},{"classnames":576,"react":879}],128:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "a {0} další(ch)",
  "Artist": "Umělec",
  "By": "od",
  "Create Similar Playlist": "Vytvořit podobný playlist",
  "DateAdded": "Datum přidání",
  "Duration": "Délka",
  "Recommended Songs": "Doporučené skladby",
  "Filter": "Filtr",
  "Follow": "Sledovat",
  "Follower": "Sledující",
  "FollowersLabel": {
    "one": "sledující",
    "few": "sledující",
    "other": "sledujících"
  },
  "Following": "Sleduješ",
  "FollowingLabel": "Sleduješ",
  "ListenersLabel": "Posluchačů měsíčně",
  "FollowsYou": "Sleduje tě",
  "HoldToPreview": "Pro náhled klikni a podrž",
  "ListenCount": {
    "one": "{0} přehrání",
    "few": "{0} přehrání",
    "other": "{0} přehrání"
  },
  "ListenReactionMulti": "{0} posluchačů ve tvé síti",
  "ListenReactionSingle": "{0} uživatelů tohle poslouchá",
  "LocalFile": "Místní soubory",
  "More": "dalších",
  "MoreSongsLoad": "Během přehrávání se načtou další skladby.",
  "Pause": "Pozastavit",
  "Play": "Přehrát",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Přehrávání spustíš stisknutím klávesy Enter",
  "Popularity": "Popularita",
  "Remove": "Odstranit",
  "RemoveYourMusic": "Odstranit ze sbírky Tvoje hudba",
  "Save": "Uložit",
  "SaveYourMusic": "Uložit do sbírky Tvoje hudba",
  "Saved": "Uloženo",
  "Song": "Skladba",
  "StartRadio": "Spustit rádio",
  "Time": "Čas",
  "Toplist": "Top skladby",
  "Track": "Skladba",
  "Unfollow": "Přestat sledovat",
  "User": "Uživatel",
  "ViewAll": "Zobrazit vše",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Při zobrazování této stránky došlo k problému!",
  "ErrorMessage": "Tato stránka buď neexistuje, nebo došlo k chybě.",
  "OfflineTitle": "Tato stránka není dostupná offline!",
  "OfflineMessage": "Pro načtení přejdi prosím online."
}
},{}],129:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "und {0} weitere",
  "Artist": "Künstler",
  "By": "von",
  "Create Similar Playlist": "Ähnliche Playlist erstellen",
  "DateAdded": "Datum hinzugefügt",
  "Duration": "Dauer",
  "Recommended Songs": "Empfohlene Songs",
  "Filter": "Filter",
  "Follow": "Folgen",
  "Follower": "Follower",
  "FollowersLabel": {
    "one": "Follower",
    "other": "Follower"
  },
  "Following": "Folge ich",
  "FollowingLabel": "Folge ich",
  "ListenersLabel": "Monatliche Hörer",
  "FollowsYou": "Folgt dir",
  "HoldToPreview": "Zum Reinhören gedrückt halten",
  "ListenCount": {
    "one": "{0} Mal gespielt",
    "other": "{0} Mal gespielt"
  },
  "ListenReactionMulti": "{0} Hörer in Deinem Netzwerk",
  "ListenReactionSingle": "{0} hört sich das an",
  "LocalFile": "Lokale Datei",
  "More": "Mehr",
  "MoreSongsLoad": "Während du Musik hörst, werden weitere Songs geladen.",
  "Pause": "Pause",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Drück die Eingabetaste zum Abspielen",
  "Popularity": "Beliebtheit",
  "Remove": "Entfernen",
  "RemoveYourMusic": "Aus \"Deine Musik\" entfernen",
  "Save": "Speichern",
  "SaveYourMusic": "In \"Deine Musik\" speichern",
  "Saved": "Gespeichert",
  "Song": "Song",
  "StartRadio": "Radio starten",
  "Time": "Dauer",
  "Toplist": "Top-Songs",
  "Track": "Song",
  "Unfollow": "Nicht mehr folgen",
  "User": "Benutzer",
  "ViewAll": "Mehr Darstellung",
  "HoursShort": "{0} Std.",
  "MinutesShort": "{0} Min.",
  "SecondsShort": "{0} Sek.",
  "ErrorTitle": "Bei der Anzeige dieser Seite ist ein Fehler aufgetreten.",
  "ErrorMessage": "Diese Seite ist entweder nicht vorhanden oder es ist ein Fehler aufgetreten.",
  "OfflineTitle": "Diese Seite ist offline nicht verfügbar.",
  "OfflineMessage": "Geh zum Laden online."
}
},{}],130:[function(require,module,exports){
module.exports={
  "Album": "Άλμπουμ",
  "AndMore": "και άλλοι {0}",
  "Artist": "Καλλιτέχνης",
  "By": "από",
  "Create Similar Playlist": "Δημιουργία παρόμοιας playlist",
  "DateAdded": "Προστέθηκε ημερομηνία",
  "Duration": "Διάρκεια",
  "Recommended Songs": "Προτεινόμενα τραγούδια",
  "Filter": "Φίλτρο",
  "Follow": "Ακολούθησε",
  "Follower": "Οπαδός",
  "FollowersLabel": {
    "one": "Ακόλουθος",
    "other": "Ακόλουθοι"
  },
  "Following": "Aκολουθείται",
  "FollowingLabel": "Aκολουθείται",
  "ListenersLabel": "Μηνιαίοι ακροατές",
  "FollowsYou": "Σε ακολουθεί",
  "HoldToPreview": "Πάτησε και κράτησε πατημένο για προεπισκόπηση",
  "ListenCount": {
    "one": "{0} αναπαραγωγή",
    "other": "{0} αναπαραγωγές"
  },
  "ListenReactionMulti": "{0} ακροατές στο δίκτυό σου",
  "ListenReactionSingle": "Ο χρήστης {0} ακούει αυτό",
  "LocalFile": "Τοπικό αρχείο",
  "More": "Περισσότερα",
  "MoreSongsLoad": "Περισσότερα τραγούδια φορτώνουν ενώ ακούς",
  "Pause": "Παύση",
  "Play": "Αναπαραγωγή",
  "Playlist": "Λίστα",
  "PressEnterToPlay": "Πάτησε Enter για αναπαραγωγή",
  "Popularity": "Δημοφιλία",
  "Remove": "Αφαίρεση",
  "RemoveYourMusic": "Αφαίρεση από τη Mουσική σου",
  "Save": "Αποθήκευση",
  "SaveYourMusic": "Αποθήκευση στη Mουσική σου",
  "Saved": "Αποθηκεύτηκε",
  "Song": "Τραγούδι",
  "StartRadio": "Έναρξη ράδιο",
  "Time": "Διάρκεια",
  "Toplist": "Κορυφαία τραγούδια",
  "Track": "Τραγούδι",
  "Unfollow": "Άρση ακολούθησης",
  "User": "Χρήστης",
  "ViewAll": "Δες τα όλα",
  "HoursShort": "{0} ώρα",
  "MinutesShort": "{0} λεπ.",
  "SecondsShort": "{0} δευτ.",
  "ErrorTitle": "Παρουσιάστηκε πρόβλημα κατά την προβολή αυτής της σελίδας!",
  "ErrorMessage": "Αυτή η σελίδα δεν υπάρχει ή προέκυψε κάποιο σφάλμα.",
  "OfflineTitle": "Αυτή η σελίδα δεν είναι διαθέσιμη εκτός σύνδεσης!",
  "OfflineMessage": "Συνδέσου στο διαδίκτυο για να πραγματοποιηθεί φόρτωση."
}
},{}],131:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "and {0} more",
  "Artist": "Artist",
  "By": "by",
  "Create Similar Playlist": "Create Similar Playlist",
  "DateAdded": "Date Added",
  "Duration": "Duration",
  "Recommended Songs": "Recommended Songs",
  "Filter": "Filter",
  "Follow": "Follow",
  "Follower": "Follower",
  "FollowersLabel": {
    "one": "Follower",
    "other": "Followers"
  },
  "Following": "Following",
  "FollowingLabel": "Following",
  "ListenersLabel": "Monthly Listeners",
  "FollowsYou": "Follows You",
  "HoldToPreview": "Click and Hold to Preview",
  "ListenCount": {
    "one": "1 play",
    "other": "{0} plays"
  },
  "ListenReactionMulti": "{0} listeners in your network",
  "ListenReactionSingle": "{0} listens to this",
  "LocalFile": "Local File",
  "More": "More",
  "MoreSongsLoad": "More songs load as you listen",
  "Pause": "Pause",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Press Enter to play",
  "Popularity": "Popularity",
  "Remove": "Remove",
  "RemoveYourMusic": "Remove from Your Music",
  "Save": "Save",
  "SaveYourMusic": "Save to Your Music",
  "Saved": "Saved",
  "Song": "Song",
  "StartRadio": "Start Radio",
  "Time": "Time",
  "Toplist": "Top songs",
  "Track": "Song",
  "Unfollow": "Unfollow",
  "User": "User",
  "ViewAll": "View All",
  "HoursShort": "{0} hr",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} sec",
  "ErrorTitle": "There was a problem displaying this page!",
  "ErrorMessage": "This page either does not exist or an error occurred.",
  "OfflineTitle": "This page is not available offline!",
  "OfflineMessage": "Please go online to load."
}
},{}],132:[function(require,module,exports){
module.exports={
  "Album": "Álbum",
  "AndMore": "y {0} más",
  "Artist": "Artista",
  "By": "por",
  "Create Similar Playlist": "Crear playlist similar",
  "DateAdded": "Fecha agregada",
  "Duration": "Duración",
  "Recommended Songs": "Canciones recomendadas",
  "Filter": "Filtrar",
  "Follow": "Seguir",
  "Follower": "Seguidor",
  "FollowersLabel": {
    "one": "Seguidor",
    "other": "Seguidores"
  },
  "Following": "Siguiendo",
  "FollowingLabel": "Siguiendo",
  "ListenersLabel": "Oyentes mensuales",
  "FollowsYou": "Te sigue",
  "HoldToPreview": "Haz clic y mantén pulsado para oír la muestra preliminar",
  "ListenCount": {
    "one": "1 reproducción",
    "other": "{0} reproducciones"
  },
  "ListenReactionMulti": "{0} oyentes en tu red",
  "ListenReactionSingle": "{0} escucha esto",
  "LocalFile": "Archivo local",
  "More": "Más",
  "MoreSongsLoad": "Se cargarán más canciones a medida que escuchas",
  "Pause": "Pausa",
  "Play": "Reproducir",
  "Playlist": "Lista",
  "PressEnterToPlay": "Presiona Enter para reproducir",
  "Popularity": "Popularidad",
  "Remove": "Eliminar",
  "RemoveYourMusic": "Eliminar de Tu Música",
  "Save": "Guardar",
  "SaveYourMusic": "Guardar en Tu Música",
  "Saved": "Guardado",
  "Song": "Canción",
  "StartRadio": "Comenzar Radio",
  "Time": "Tiempo",
  "Toplist": "Canciones más reproducidas",
  "Track": "Canción",
  "Unfollow": "Dejar de seguir",
  "User": "Usuario",
  "ViewAll": "Ver todos",
  "HoursShort": "{0} hr",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} seg",
  "ErrorTitle": "Hubo un problema al mostrar esta página.",
  "ErrorMessage": "Puede ser que esta página no exista o que haya ocurrido un error.",
  "OfflineTitle": "Esta página no se encuentra disponible sin conexión.",
  "OfflineMessage": "Conéctate a la red para cargar."
}
},{}],133:[function(require,module,exports){
module.exports={
  "Album": "Álbum",
  "AndMore": "y {0} más",
  "Artist": "Artista",
  "By": "por",
  "Create Similar Playlist": "Crear playlist similar",
  "DateAdded": "Fecha en la que se añadió",
  "Duration": "Duración",
  "Recommended Songs": "Canciones recomendadas",
  "Filter": "Filtrar",
  "Follow": "Seguir",
  "Follower": "Seguidor",
  "FollowersLabel": {
    "one": "Seguidor",
    "other": "Seguidores"
  },
  "Following": "Siguiendo",
  "FollowingLabel": "Siguiendo",
  "ListenersLabel": "Oyentes mensuales",
  "FollowsYou": "Te sigue",
  "HoldToPreview": "Pulsa y mantén pulsado para oír la muestra preliminar",
  "ListenCount": {
    "one": "{0} reproducción",
    "other": "{0} reproducciones"
  },
  "ListenReactionMulti": "{0} oyentes en tu red",
  "ListenReactionSingle": "{0} escucha esto",
  "LocalFile": "Archivo local",
  "More": "Más",
  "MoreSongsLoad": "Se cargarán más canciones mientras escuchas",
  "Pause": "Pausar",
  "Play": "Reproducir",
  "Playlist": "Lista",
  "PressEnterToPlay": "Pulsa Intro para reproducir",
  "Popularity": "Popularidad",
  "Remove": "Retirar",
  "RemoveYourMusic": "Eliminar de Tu música",
  "Save": "Guardar",
  "SaveYourMusic": "Guardar en Tu música",
  "Saved": "Guardada",
  "Song": "Canción",
  "StartRadio": "Comenzar radio",
  "Time": "Tiempo",
  "Toplist": "Canciones más escuchadas",
  "Track": "Canción",
  "Unfollow": "Dejar de seguir",
  "User": "Usuario",
  "ViewAll": "Ver todos",
  "HoursShort": "{0} hr",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} seg",
  "ErrorTitle": "Se ha producido un problema al mostrar esta página.",
  "ErrorMessage": "Esta página no existe o se ha producido un error.",
  "OfflineTitle": "Esta página no está disponible sin conexión.",
  "OfflineMessage": "Por favor, conéctate para cargar."
}
},{}],134:[function(require,module,exports){
module.exports={
  "Album": "Albumi",
  "AndMore": "ja {0} muuta",
  "Artist": "Artisti",
  "By": "tekijältä",
  "Create Similar Playlist": "Luo samankaltainen soittolista",
  "DateAdded": "Lisäyspäivä",
  "Duration": "Kesto",
  "Recommended Songs": "Suositellut kappaleet",
  "Filter": "Suodatin",
  "Follow": "Seuraa",
  "Follower": "Seuraaja",
  "FollowersLabel": {
    "one": "Seuraaja",
    "other": "Seuraajat"
  },
  "Following": "Seurataan",
  "FollowingLabel": "Seurataan",
  "ListenersLabel": "Kuuntelijat kuukauden aikana",
  "FollowsYou": "Seuraa sinua",
  "HoldToPreview": "Kuuntele pätkä pitämällä tätä painettuna",
  "ListenCount": {
    "one": "1 toisto",
    "other": "{0} toistoa"
  },
  "ListenReactionMulti": "{0} kuuntelijaa verkostossasi",
  "ListenReactionSingle": "{0} kuuntelee tätä",
  "LocalFile": "Paikallinen tiedosto",
  "More": "Lisää",
  "MoreSongsLoad": "Lisää kappaleita ladataan kuuntelun aikana",
  "Pause": "Tauko",
  "Play": "Toista",
  "Playlist": "Soittolista",
  "PressEnterToPlay": "Toista painamalla Enter-näppäintä",
  "Popularity": "Suosio",
  "Remove": "Poista",
  "RemoveYourMusic": "Poista Omasta musiikista",
  "Save": "Tallenna",
  "SaveYourMusic": "Tallenna Omaan musiikkiin",
  "Saved": "Tallennettu",
  "Song": "Kappale",
  "StartRadio": "Käynnistä radio",
  "Time": "Kesto",
  "Toplist": "Suosituimmat kappaleet",
  "Track": "Kappale",
  "Unfollow": "Lopeta seuraaminen",
  "User": "Käyttäjä",
  "ViewAll": "Näytä kaikki",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Sivun näyttämisessä ilmeni ongelma!",
  "ErrorMessage": "Sivua ei ole, tai tapahtui virhe.",
  "OfflineTitle": "Sivu ei ole saatavilla offline-tilassa!",
  "OfflineMessage": "Siirry online-tilaan, jotta voit ladata."
}
},{}],135:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "et {0} autres",
  "Artist": "Artiste",
  "By": "par",
  "Create Similar Playlist": "Créer une liste de lecture semblable",
  "DateAdded": "Ajouté le",
  "Duration": "Durée",
  "Recommended Songs": "Chansons recommandées",
  "Filter": "Filtrer",
  "Follow": "Suivre",
  "Follower": "Abonné",
  "FollowersLabel": {
    "one": "Abonné",
    "other": "Abonnés"
  },
  "Following": "Suivis",
  "FollowingLabel": "Suivis",
  "ListenersLabel": "Auditeurs mensuels",
  "FollowsYou": "Vous suit",
  "HoldToPreview": "Cliquez longuement pour avoir un aperçu",
  "ListenCount": {
    "one": "1 écoute",
    "other": "{0} écoutes"
  },
  "ListenReactionMulti": "{0} auditeurs dans votre réseau",
  "ListenReactionSingle": "{0} écoute ceci",
  "LocalFile": "Fichier local",
  "More": "Plus",
  "MoreSongsLoad": "D'autres chansons se chargent pendant que vous écoutez",
  "Pause": "Pause",
  "Play": "Lecture",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Appuyez sur Entrée pour faire la lecture",
  "Popularity": "Popularité",
  "Remove": "Supprimer",
  "RemoveYourMusic": "Supprimer de Votre musique",
  "Save": "Sauvegarder",
  "SaveYourMusic": "Enregistrer dans Votre musique",
  "Saved": "Sauvegardé",
  "Song": "Titre",
  "StartRadio": "Lancer la radio",
  "Time": "Durée",
  "Toplist": "Meilleures chansons",
  "Track": "Titre",
  "Unfollow": "Ne plus suivre",
  "User": "Utilisateur",
  "ViewAll": "Voir tout",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Un problème est survenu lors de l'affichage de cette page!",
  "ErrorMessage": "Cette page n'existe pas ou une erreur s'est produite.",
  "OfflineTitle": "Cette page n'est pas accessible hors ligne!",
  "OfflineMessage": "Veuillez accéder à Internet pour charger le contenu."
}
},{}],136:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "et {0} autres",
  "Artist": "Artiste",
  "By": "par",
  "Create Similar Playlist": "Créer une playlist similaire",
  "DateAdded": "Ajouté le",
  "Duration": "Durée",
  "Recommended Songs": "Titres recommandés",
  "Filter": "Filtre",
  "Follow": "S'abonner",
  "Follower": "Abonné",
  "FollowersLabel": {
    "one": "Abonné",
    "other": "Abonnés"
  },
  "Following": "Abonné",
  "FollowingLabel": "Abonné",
  "ListenersLabel": "Nombres de personnes qui écoutent par mois",
  "FollowsYou": "Est abonné à vous",
  "HoldToPreview": "Cliquez longuement pour avoir un aperçu",
  "ListenCount": {
    "one": "1 écoute",
    "other": "{0} écoutes"
  },
  "ListenReactionMulti": "{0} auditeurs dans votre réseau",
  "ListenReactionSingle": "{0} écoute ceci.",
  "LocalFile": "Fichier local",
  "More": "Plus",
  "MoreSongsLoad": "D'autres titres se chargent pendant que vous écoutez.",
  "Pause": "Pause",
  "Play": "Lire",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Appuyez sur Entrée pour écouter",
  "Popularity": "Popularité",
  "Remove": "Supprimer",
  "RemoveYourMusic": "Supprimer de Ma musique",
  "Save": "Sauvegarder",
  "SaveYourMusic": "Sauvegarder dans Ma musique",
  "Saved": "Sauvegardé",
  "Song": "Titre",
  "StartRadio": "Ecouter la radio",
  "Time": "Durée",
  "Toplist": "Top titres",
  "Track": "Titre",
  "Unfollow": "Se désabonner",
  "User": "Utilisateur",
  "ViewAll": "Présentation tout",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Problème d'affichage !",
  "ErrorMessage": "Cette page n'existe pas, ou une erreur s'est produite.",
  "OfflineTitle": "Cette page n'est pas disponible hors connexion !",
  "OfflineMessage": "Connectez-vous pour procéder au chargement."
}
},{}],137:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "és még {0} felhasználó",
  "Artist": "Előadó",
  "By": "tőle:",
  "Create Similar Playlist": "Hasonló műsorlista létrehozása",
  "DateAdded": "Dátum hozzáadva",
  "Duration": "Időtartam",
  "Recommended Songs": "Ajánlott dalok",
  "Filter": "Szűrő",
  "Follow": "Követés",
  "Follower": "Követő",
  "FollowersLabel": {
    "one": "Követő",
    "other": "Követők"
  },
  "Following": "Követések",
  "FollowingLabel": "Követések",
  "ListenersLabel": "Hallgatók havonta",
  "FollowsYou": "Téged követ",
  "HoldToPreview": "Tartsd nyomva a belehallgatáshoz",
  "ListenCount": {
    "one": "{0} lejátszás",
    "other": "{0} lejátszás"
  },
  "ListenReactionMulti": "{0} ismerősöd hallgatta meg",
  "ListenReactionSingle": "{0} már meghallgatta",
  "LocalFile": "Helyi fájl",
  "More": "Több",
  "MoreSongsLoad": "Lesz még szám, csak hallgasd tovább",
  "Pause": "Szünet",
  "Play": "Lejátszás",
  "Playlist": "Lejátszási lista",
  "PressEnterToPlay": "Lejátszás az Enterrel",
  "Popularity": "Népszerűség",
  "Remove": "Eltávolítás",
  "RemoveYourMusic": "Törlés a Zenéid közül",
  "Save": "Mentés",
  "SaveYourMusic": "Mentés a Zenéid közé",
  "Saved": "Mentett",
  "Song": "Dal",
  "StartRadio": "Rádió bekapcsolása",
  "Time": "Idő",
  "Toplist": "Toplista",
  "Track": "Dal",
  "Unfollow": "Nem követem",
  "User": "Felhasználó",
  "ViewAll": "Mindent mutat",
  "HoursShort": "{0} óra",
  "MinutesShort": "{0} perc",
  "SecondsShort": "{0} mp",
  "ErrorTitle": "Hiba történt az oldal megjelenítésekor.",
  "ErrorMessage": "Az oldal nem létezik, vagy hiba történt.",
  "OfflineTitle": "Ez az oldal offline módban nem érhető el.",
  "OfflineMessage": "Csatlakozz az internethez, majd indítsd el."
}
},{}],138:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "dan {0} lagi",
  "Artist": "Artis",
  "By": "menurut",
  "Create Similar Playlist": "Buat Playlist Serupa",
  "DateAdded": "Tanggal Dimuat",
  "Duration": "Durasi",
  "Recommended Songs": "Lagu yang Direkomendasikan",
  "Filter": "Filter",
  "Follow": "Ikuti",
  "Follower": "Pengikut",
  "FollowersLabel": {
    "other": "Pengikut"
  },
  "Following": "Mengikuti",
  "FollowingLabel": "Mengikuti",
  "ListenersLabel": "Pendengar Bulanan",
  "FollowsYou": "Mengikutimu",
  "HoldToPreview": "Klik dan Tahan untuk Pratinjau",
  "ListenCount": {
    "other": "{0} pemutaran"
  },
  "ListenReactionMulti": "{0} pendengar di jaringanmu",
  "ListenReactionSingle": "{0} mendengarkan ini",
  "LocalFile": "File Lokal",
  "More": "Lainnya",
  "MoreSongsLoad": "Lebih banyak lagu dimuat saat kamu mendengarkan",
  "Pause": "Jeda",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Tekan Enter untuk memainkan",
  "Popularity": "Popularitas",
  "Remove": "Hapus",
  "RemoveYourMusic": "Hapus dari Musik Kamu",
  "Save": "Simpan",
  "SaveYourMusic": "Simpan ke Musik Kamu",
  "Saved": "Tersimpan",
  "Song": "Lagu",
  "StartRadio": "Mulai Radio",
  "Time": "Waktu",
  "Toplist": "Lagu teratas",
  "Track": "Lagu",
  "Unfollow": "Berhenti mengikuti",
  "User": "Pengguna",
  "ViewAll": "Lihat Semua",
  "HoursShort": "{0} jam",
  "MinutesShort": "{0} mnt",
  "SecondsShort": "{0} dtk",
  "ErrorTitle": "Ada masalah saat menampilkan halaman ini!",
  "ErrorMessage": "Halaman ini tidak ada atau terjadi kesalahan.",
  "OfflineTitle": "Halaman ini tidak tersedia secara offline!",
  "OfflineMessage": "Alihkan ke online untuk memuat."
}
},{}],139:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "e altri {0}",
  "Artist": "Artista",
  "By": "per",
  "Create Similar Playlist": "Crea playlist simile",
  "DateAdded": "Aggiunto il",
  "Duration": "Durata",
  "Recommended Songs": "Brani consigliati",
  "Filter": "Filtra",
  "Follow": "Segui",
  "Follower": "Follower",
  "FollowersLabel": {
    "one": "Follower",
    "other": "Follower"
  },
  "Following": "Following",
  "FollowingLabel": "Following",
  "ListenersLabel": "Ascoltatori questo mese",
  "FollowsYou": "Ti segue",
  "HoldToPreview": "Tieni premuto per un'anteprima",
  "ListenCount": {
    "one": "1 riproduzione",
    "other": "{0} riproduzioni"
  },
  "ListenReactionMulti": "{0} ascoltatori nella tua rete",
  "ListenReactionSingle": "{0} ascolta questo",
  "LocalFile": "File locale",
  "More": "Più",
  "MoreSongsLoad": "Durante l'ascolto vengono caricati altri brani",
  "Pause": "Pausa",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Premi Invio per riprodurre",
  "Popularity": "Popolarità",
  "Remove": "Rimuovi",
  "RemoveYourMusic": "Elimina da La tua musica",
  "Save": "Salva",
  "SaveYourMusic": "Salva in La tua musica",
  "Saved": "Salvato",
  "Song": "Brano",
  "StartRadio": "Crea una radio",
  "Time": "Durata",
  "Toplist": "Brani top",
  "Track": "Brano",
  "Unfollow": "Non seguire più",
  "User": "Utente",
  "ViewAll": "Visualizza tutto",
  "HoursShort": "{0} ore",
  "MinutesShort": "{0} min.",
  "SecondsShort": "{0} sec",
  "ErrorTitle": "Si è verificato un errore nella visualizzazione di questa pagina.",
  "ErrorMessage": "Questa pagina non esiste o si è verificato un errore.",
  "OfflineTitle": "Questa pagina non è disponibile offline.",
  "OfflineMessage": "Passa online per caricare."
}
},{}],140:[function(require,module,exports){
module.exports={
  "Album": "アルバム",
  "AndMore": "その他{0}人",
  "Artist": "アーティスト",
  "By": "/",
  "Create Similar Playlist": "同様のプレイリストを作成",
  "DateAdded": "追加日",
  "Duration": "期間",
  "Recommended Songs": "おすすめの曲",
  "Filter": "フィルター",
  "Follow": "フォロー",
  "Follower": "フォロワー",
  "FollowersLabel": {
    "other": "フォロワー"
  },
  "Following": "フォロー中",
  "FollowingLabel": "フォロー中",
  "ListenersLabel": "今月のリスナー",
  "FollowsYou": "あなたをフォローしています",
  "HoldToPreview": "プレビューするには、クリックを押しします",
  "ListenCount": {
    "other": "{0}回再生"
  },
  "ListenReactionMulti": "ネットワーク内で{0}人が聴いています",
  "ListenReactionSingle": "{0}さんはこれを聴いています",
  "LocalFile": "ローカルファイル",
  "More": "詳細",
  "MoreSongsLoad": "再生すると、さらに曲がロードされます",
  "Pause": "一時停止",
  "Play": "曲の再生",
  "Playlist": "プレイリスト",
  "PressEnterToPlay": "再生するにはEnterキーを押します",
  "Popularity": "人気",
  "Remove": "削除",
  "RemoveYourMusic": "My Musicから削除",
  "Save": "保存",
  "SaveYourMusic": "My Musicに保存",
  "Saved": "保存済み",
  "Song": "ソング",
  "StartRadio": "Radioを開始",
  "Time": "時間",
  "Toplist": "トップ曲",
  "Track": "ソング",
  "Unfollow": "フォローをやめる",
  "User": "ユーザー",
  "ViewAll": "すべて表示",
  "HoursShort": "{0} 時間",
  "MinutesShort": "{0} 分",
  "SecondsShort": "{0} 秒",
  "ErrorTitle": "このページの表示中に問題が発生しました。",
  "ErrorMessage": "このページは存在しないか、表示中にエラーが発生しました。",
  "OfflineTitle": "このページはオフラインでは利用できません。",
  "OfflineMessage": "ロードするには、インターネットに接続してください。"
}
},{}],141:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "en {0} meer",
  "Artist": "Artiest",
  "By": "van",
  "Create Similar Playlist": "Vergelijkbare afspeellijst maken",
  "DateAdded": "Datum toegevoegd",
  "Duration": "Duur",
  "Recommended Songs": "Aanbevolen nummers",
  "Filter": "Filter",
  "Follow": "Volgen",
  "Follower": "Volger",
  "FollowersLabel": {
    "one": "Volger",
    "other": "Volgers"
  },
  "Following": "Volgend",
  "FollowingLabel": "Volgend",
  "ListenersLabel": "Luisteraars per maand",
  "FollowsYou": "Volgt jou",
  "HoldToPreview": "Klikken en vasthouden om een stukje te horen",
  "ListenCount": {
    "one": "{0} keer afgespeeld",
    "other": "{0} keer afgespeeld"
  },
  "ListenReactionMulti": "{0} luisteraars in jouw netwerk",
  "ListenReactionSingle": "{0} luistert hiernaar",
  "LocalFile": "Lokaal bestand",
  "More": "Meer",
  "MoreSongsLoad": "Meer nummers worden geladen terwijl je luistert",
  "Pause": "Pauze",
  "Play": "Afspelen",
  "Playlist": "Afspeellijst",
  "PressEnterToPlay": "Druk op Enter om af te spelen",
  "Popularity": "Populariteit",
  "Remove": "Verwijderen",
  "RemoveYourMusic": "Verwijderen uit Jouw Muziek",
  "Save": "Opslaan",
  "SaveYourMusic": "Opslaan in Jouw Muziek",
  "Saved": "Opgeslagen",
  "Song": "Nummer",
  "StartRadio": "Radio starten",
  "Time": "Tijd",
  "Toplist": "Topnummers",
  "Track": "Nummer",
  "Unfollow": "Niet meer volgen",
  "User": "Gebruiker",
  "ViewAll": "Alles bekijken",
  "HoursShort": "{0} uur",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} sec",
  "ErrorTitle": "Er is een fout opgetreden bij het weergeven van deze pagina.",
  "ErrorMessage": "Deze weergave bestaat niet of er is een fout opgetreden.",
  "OfflineTitle": "Deze pagina is niet offline beschikbaar.",
  "OfflineMessage": "Ga online om te laden."
}
},{}],142:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "i {0} więcej",
  "Artist": "Wykonawca",
  "By": "według",
  "Create Similar Playlist": "Utwórz podobną playlistę",
  "DateAdded": "Data dodania",
  "Duration": "Czas trwania",
  "Recommended Songs": "Polecane utwory",
  "Filter": "Filtruj",
  "Follow": "Obserwuj",
  "Follower": "Obserwujący",
  "FollowersLabel": {
    "one": "Obserwator",
    "few": "Obserwatorzy",
    "many": "Obserwatorów",
    "other": "Obserwatorzy"
  },
  "Following": "Obserwujesz",
  "FollowingLabel": "Obserwujesz",
  "ListenersLabel": "Słuchacze w tym miesiącu",
  "FollowsYou": "Obserwuje Cię",
  "HoldToPreview": "Aby odsłuchać, kliknij i przytrzymaj.",
  "ListenCount": {
    "one": "{0} odtworzenie",
    "few": "{0} odtworzenia",
    "many": "{0} odtworzeń",
    "other": "{0} odtworzeń"
  },
  "ListenReactionMulti": "Liczba słuchaczy w Twojej sieci: {0}",
  "ListenReactionSingle": "Użytkownik {0} słucha tego",
  "LocalFile": "Plik lokalny",
  "More": "Więcej",
  "MoreSongsLoad": "Więcej utworów będzie się pojawiać w miarę słuchania",
  "Pause": "Pauza",
  "Play": "Odtwórz",
  "Playlist": "Playlista",
  "PressEnterToPlay": "Naciśnij Enter, aby odtworzyć",
  "Popularity": "Popularność",
  "Remove": "Usuń",
  "RemoveYourMusic": "Usuń z kolekcji Twoja muzyka",
  "Save": "Zapisz",
  "SaveYourMusic": "Zapisz w kolekcji Twoja muzyka",
  "Saved": "Zapisany",
  "Song": "Utwór",
  "StartRadio": "Włącz radio",
  "Time": "Czas",
  "Toplist": "Najpopularniejsze utwory",
  "Track": "Utwór",
  "Unfollow": "Przestań obserwować",
  "User": "Użytkownik",
  "ViewAll": "Wyświetl wszystko",
  "HoursShort": "{0} godz.",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Wystąpił błąd podczas wyświetlania tej strony!",
  "ErrorMessage": "Ta strona nie istnieje lub wystąpił błąd.",
  "OfflineTitle": "Ta strona nie jest dostępna w trybie offline!",
  "OfflineMessage": "Przejdź do trybu online, aby załadować."
}
},{}],143:[function(require,module,exports){
module.exports={
  "Album": "Álbum",
  "AndMore": "e mais {0}",
  "Artist": "Artista",
  "By": "de",
  "Create Similar Playlist": "Criar playlist similar",
  "DateAdded": "Adicionado em",
  "Duration": "Duração",
  "Recommended Songs": "Músicas recomendadas",
  "Filter": "Filtrar",
  "Follow": "Seguir",
  "Follower": "Seguidor",
  "FollowersLabel": {
    "one": "Seguidor",
    "other": "Seguidores"
  },
  "Following": "Seguindo",
  "FollowingLabel": "Seguindo",
  "ListenersLabel": "Ouvintes mensais",
  "FollowsYou": "Segue você",
  "HoldToPreview": "Clique e segure para a prévia",
  "ListenCount": {
    "one": "1 reprodução",
    "other": "{0} reproduções"
  },
  "ListenReactionMulti": "{0} ouvintes na sua rede",
  "ListenReactionSingle": "{0} ouvem isso",
  "LocalFile": "Arquivo local",
  "More": "Mais",
  "MoreSongsLoad": "Mais músicas serão carregadas à medida que você for escutando",
  "Pause": "Pause",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Pressione Enter para tocar",
  "Popularity": "Popularidade",
  "Remove": "Remover",
  "RemoveYourMusic": "Remover de Suas músicas",
  "Save": "Salvar",
  "SaveYourMusic": "Salvar em Suas músicas",
  "Saved": "Salvo",
  "Song": "Música",
  "StartRadio": "Abrir rádio",
  "Time": "Tempo",
  "Toplist": "Músicas mais tocadas",
  "Track": "Música",
  "Unfollow": "Deixar de seguir",
  "User": "Usuário",
  "ViewAll": "Ver tudo",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} m",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Tivemos um problema ao mostrar esta página!",
  "ErrorMessage": "Essa página não existe ou ocorreu um erro.",
  "OfflineTitle": "Essa página não está disponível offline!",
  "OfflineMessage": "Fique online para carregar."
}
},{}],144:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "och {0} till",
  "Artist": "Artist",
  "By": "av",
  "Create Similar Playlist": "Skapa en liknande spellista",
  "DateAdded": "Tillagd",
  "Duration": "Längd",
  "Recommended Songs": "Rekommenderade låtar",
  "Filter": "Filtrera",
  "Follow": "Följ",
  "Follower": "Följare",
  "FollowersLabel": {
    "one": "Följare",
    "other": "Följare"
  },
  "Following": "Följer",
  "FollowingLabel": "Följer",
  "ListenersLabel": "Lyssnare per månad",
  "FollowsYou": "Följer dig",
  "HoldToPreview": "Klicka och håll kvar för att förhandslyssna",
  "ListenCount": {
    "one": "1 uppspelning",
    "other": "{0} uppspelningar"
  },
  "ListenReactionMulti": "{0} lyssnare i ditt nätverk",
  "ListenReactionSingle": "{0} lyssnar på detta",
  "LocalFile": "Lokal fil",
  "More": "Mer",
  "MoreSongsLoad": "Fler låtar läses in medan du lyssnar",
  "Pause": "Pausa",
  "Play": "Spela upp",
  "Playlist": "Spellista",
  "PressEnterToPlay": "Tryck på Retur om du vill lyssna",
  "Popularity": "Popularitet",
  "Remove": "Ta bort",
  "RemoveYourMusic": "Ta bort från Din Musik",
  "Save": "Spara",
  "SaveYourMusic": "Spara i Din Musik",
  "Saved": "Sparade",
  "Song": "Låt",
  "StartRadio": "Starta radio",
  "Time": "Tid",
  "Toplist": "Topplåtar",
  "Track": "Låt",
  "Unfollow": "Sluta följa",
  "User": "Användare",
  "ViewAll": "Visa alla",
  "HoursShort": "{0} tim",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} sek",
  "ErrorTitle": "Det uppstod ett fel när den här sidan skulle visas!",
  "ErrorMessage": "Den här sidan finns inte eller så uppstod ett fel.",
  "OfflineTitle": "Den här sidan är inte tillgänglig offline!",
  "OfflineMessage": "Anslut till internet om du vill läsa in appen."
}
},{}],145:[function(require,module,exports){
module.exports={
  "Album": "Albüm",
  "AndMore": "ve {0} daha",
  "Artist": "Sanatçı",
  "By": "-",
  "Create Similar Playlist": "Benzer Çalma Listesi Oluştur",
  "DateAdded": "Tarih Eklendi",
  "Duration": "Süre",
  "Recommended Songs": "Önerilen Şarkılar",
  "Filter": "Filtrele",
  "Follow": "Takip Et",
  "Follower": "Takipçi",
  "FollowersLabel": {
    "one": "Takipçi",
    "other": "Takipçi"
  },
  "Following": "Takip Ediliyor",
  "FollowingLabel": "Takip Ediliyor",
  "ListenersLabel": "Aylık Dinleyici",
  "FollowsYou": "Seni Takip Ediyor",
  "HoldToPreview": "Basılı Tut ve Önizle",
  "ListenCount": {
    "one": "{0} dinleme",
    "other": "{0} dinleme"
  },
  "ListenReactionMulti": "Ağında {0} dinleyici",
  "ListenReactionSingle": "{0} bunu dinliyor",
  "LocalFile": "Yerel Dosya",
  "More": "Daha fazla",
  "MoreSongsLoad": "Sen dinledikçe daha fazla şarkı yüklenir",
  "Pause": "Duraklat",
  "Play": "Çal",
  "Playlist": "Çalma listesi",
  "PressEnterToPlay": "Çalmak için Enter'a bas",
  "Popularity": "Popülerlik",
  "Remove": "Çıkar",
  "RemoveYourMusic": "Müziklerin'den çıkar",
  "Save": "Kaydet",
  "SaveYourMusic": "Müziklerin'e kaydet",
  "Saved": "Kaydedildi",
  "Song": "Şarkı",
  "StartRadio": "Radyoyu Başlat",
  "Time": "Saat",
  "Toplist": "En çok dinlenen şarkılar",
  "Track": "Şarkı",
  "Unfollow": "Takip Etmeyi Bırak",
  "User": "Kullanıcı",
  "ViewAll": "Tümünü Görüntüle",
  "HoursShort": "{0} sa",
  "MinutesShort": "{0} dk",
  "SecondsShort": "{0} sn",
  "ErrorTitle": "Bu sayfa görüntülenirken bir sorun oluştu!",
  "ErrorMessage": "Bu sayfa yok veya bir hata oluştu.",
  "OfflineTitle": "Bu sayfa çevrimdışı kullanılamaz!",
  "OfflineMessage": "Yüklemek için lütfen çevrimiçi ol."
}
},{}],146:[function(require,module,exports){
module.exports={
  "Album": "專輯",
  "AndMore": "還有 {0} 首",
  "Artist": "藝人",
  "By": "－",
  "Create Similar Playlist": "建立相似的播放清單",
  "DateAdded": "已加入日期",
  "Duration": "長度",
  "Recommended Songs": "推薦歌曲",
  "Filter": "篩選",
  "Follow": "關注",
  "Follower": "粉絲",
  "FollowersLabel": {
    "other": "粉絲"
  },
  "Following": "正在關注",
  "FollowingLabel": "正在關注",
  "ListenersLabel": "每月聽眾",
  "FollowsYou": "關注你",
  "HoldToPreview": "按住即可預覽",
  "ListenCount": {
    "other": "播放了 {0} 次"
  },
  "ListenReactionMulti": "在你的社群網路中有 {0} 名聽眾",
  "ListenReactionSingle": "{0} 收聽了這首歌曲",
  "LocalFile": "本機檔案",
  "More": "更多",
  "MoreSongsLoad": "聆聽時載入更多歌曲",
  "Pause": "暫停",
  "Play": "播放",
  "Playlist": "播放列表",
  "PressEnterToPlay": "請按 Enter 播放",
  "Popularity": "流行",
  "Remove": "移除",
  "RemoveYourMusic": "從你的音樂中移除",
  "Save": "儲存",
  "SaveYourMusic": "儲存至你的音樂",
  "Saved": "已儲存",
  "Song": "歌曲",
  "StartRadio": "啟用電臺",
  "Time": "時間",
  "Toplist": "當紅歌曲",
  "Track": "歌曲",
  "Unfollow": "取消關注",
  "User": "使用者",
  "ViewAll": "檢視全部",
  "HoursShort": "{0} 小時",
  "MinutesShort": "{0} 分鐘",
  "SecondsShort": "{0} 秒鐘",
  "ErrorTitle": "顯示這個頁面時出現問題！",
  "ErrorMessage": "這個頁面可能不存在或發生錯誤。",
  "OfflineTitle": "離線時無法進入這個頁面！",
  "OfflineMessage": "請上網以載入。"
}
},{}],147:[function(require,module,exports){
module.exports={
  "Album": "Album",
  "AndMore": "dan {0} lagi",
  "Artist": "Artis",
  "By": "oleh",
  "Create Similar Playlist": "Cipta Senarai Main Serupa",
  "DateAdded": "Tarikh Ditambah",
  "Duration": "Tempoh",
  "Recommended Songs": "Lagu yang Dicadangkan",
  "Filter": "Penapis",
  "Follow": "Ikut",
  "Follower": "Pengikut",
  "FollowersLabel": {
    "other": "Pengikut"
  },
  "Following": "Mengikuti",
  "FollowingLabel": "Mengikuti",
  "ListenersLabel": "Pendengar Bulanan",
  "FollowsYou": "Megikuti Anda",
  "HoldToPreview": "Klik dan Tahan untuk Pratonton",
  "ListenCount": {
    "other": "{0} yang dimainkan"
  },
  "ListenReactionMulti": "{0} pendengar dalam rangkaian anda",
  "ListenReactionSingle": "{0} mendengar ini",
  "LocalFile": "Fail Setempat",
  "More": "Lebih banyak",
  "MoreSongsLoad": "Lebih banyak lagu dimuatkan semasa anda mendengar",
  "Pause": "Jeda",
  "Play": "Main",
  "Playlist": "Senarai main",
  "PressEnterToPlay": "Tekan Enter untuk main",
  "Popularity": "Populariti",
  "Remove": "Keluarkan",
  "RemoveYourMusic": "Keluarkan daripada Muzik Anda",
  "Save": "Simpan",
  "SaveYourMusic": "Simpan ke Muzik Anda",
  "Saved": "Disimpan",
  "Song": "Lagu",
  "StartRadio": "Mulakan Radio",
  "Time": "Masa",
  "Toplist": "Lagu popular",
  "Track": "Lagu",
  "Unfollow": "Nyahikut",
  "User": "Pengguna",
  "ViewAll": "Lihat Semua",
  "HoursShort": "{0} jam",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} saat",
  "ErrorTitle": "Terdapat masalah untuk memaparkan laman ini!",
  "ErrorMessage": "Laman ini sama ada tidak wujud atau ralat telah berlaku.",
  "OfflineTitle": "Laman ini tidak tersedia di luar talian!",
  "OfflineMessage": "Sila ke online untuk memuatkan."
}
},{}],148:[function(require,module,exports){
'use strict';

var _gridOverlay = require('./src/gridOverlay');

var gridOverlay = _interopRequireWildcard(_gridOverlay);

var _responsiveTitleType = require('./src/responsiveTitleType');

var responsiveTitleType = _interopRequireWildcard(_responsiveTitleType);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

exports.gridOverlay = gridOverlay;
exports.responsiveTitleType = responsiveTitleType;

},{"./src/gridOverlay":149,"./src/responsiveTitleType":150}],149:[function(require,module,exports){
(function (global){
'use strict';

var cosmos = require('spotify-cosmos-api');

var DEFAULT_GRID_COLOR = 'rgba(251, 74, 131, 0.22)';
var DEFAULT_GRID_COLOR_HIGHLIGHT = 'rgba(251, 74, 131, 0.8)';
var GRID_BASELINE = 8;

var overlayElement = null;
var baselineHighlightElement = null;
var gridColor = '';
var highlightGridColor = '';
var gridModes = ['off', 'column', 'baseline'];
var currentModeIndex = 0;

/**
 * Listen for control messages to toggle the grid when a menu item is clicked
 * or a keyboard shortcut is pressed. This only happens if the user is a global
 * app developer.
 */
function listen() {
  var spotify = global.__spotify;
  var productState = spotify && spotify.product_state;
  var appDeveloperFlag = productState && productState['app-developer'];

  if (appDeveloperFlag === '3' || appDeveloperFlag === '7') {
    cosmos.resolver.subscribe({
      url: 'sp://messages/v1/container/control'
    }, function (error, response) {
      if (error) return;
      var data = response.getJSONBody();
      if (data && data.type === 'toggle_grid') {
        toggle();
      }
    });
  }
}

/**
 * Toggle the grid overlay.
 */
function toggle() {
  var newIndex = currentModeIndex + 1;
  if (newIndex > gridModes.length - 1) {
    newIndex = 0;
  }

  var mode = gridModes[newIndex];

  if (mode === 'off') {
    disable();
  } else {
    enable(mode);
  }
}

/**
 * Enable the grid overlay.
 *
 * @param {string} mode The grid mode to enable, 'column' or 'baseline'.
 */
function enable(mode) {
  if (!mode) {
    return;
  }

  if (gridModes[currentModeIndex] === mode) {
    return;
  }

  currentModeIndex = gridModes.indexOf(mode);

  if (overlayElement && overlayElement.parentNode) {
    overlayElement.parentNode.removeChild(overlayElement);
  }

  if (mode === 'baseline') {
    document.addEventListener('mousemove', onMouseMove, false);
  }

  overlayElement = createOverlayElement();

  document.body.appendChild(overlayElement);
}

/**
 * Disable the grid overlay.
 */
function disable() {
  if (gridModes[currentModeIndex] === 'off') {
    return;
  }

  if (overlayElement && overlayElement.parentNode) {
    overlayElement.parentNode.removeChild(overlayElement);
  }

  currentModeIndex = gridModes.indexOf('off');
  overlayElement = null;
  baselineHighlightElement = null;

  document.removeEventListener('mousemove', onMouseMove, false);
}

/**
 * Set the color used for each grid column or baseline line.
 *
 * @param {string} color Any valid CSS color.
 * @param {string=} highlightColor Any valid CSS color. Can be omitted for
 *     column grid.
 */
function setColor(color, highlightColor) {
  gridColor = color;
  highlightGridColor = highlightColor;
}

/**
 * Reset all state in this module.
 */
function reset() {
  overlayElement = null;
  baselineHighlightElement = null;
  gridColor = '';
  highlightGridColor = '';
  currentModeIndex = 0;
}

/**
 * Mouse move handler that highlights the hovered baseline line.
 *
 * @param {Event} event A mousemove event object.
 *
 * @private
 */
function onMouseMove(event) {
  if (!baselineHighlightElement) {
    baselineHighlightElement = document.createElement('div');
    baselineHighlightElement.className = 'grid-overlay-baseline-highlight';
    baselineHighlightElement.style.backgroundColor = highlightGridColor || DEFAULT_GRID_COLOR_HIGHLIGHT;
    overlayElement.appendChild(baselineHighlightElement);
  }

  // Calculate the Y position for the baseline line closest to the pointer
  var pointerPos = event.clientY + window.scrollY;
  var yLineAbove = Math.floor(pointerPos / GRID_BASELINE) * GRID_BASELINE;
  var y = yLineAbove + (pointerPos % GRID_BASELINE > 4 ? GRID_BASELINE : 0);

  baselineHighlightElement.style.top = y - 1 + 'px';
}

/**
 * Create the DOM nodes needed for the overlay, with the correct class names
 * and styles.
 *
 * @return {HTMLElement} The container element for the overlay.
 *
 * @private
 */
function createOverlayElement() {
  var color = gridColor || DEFAULT_GRID_COLOR;

  var container = document.createElement('div');
  container.className = 'grid-overlay container';

  if (gridModes[currentModeIndex] === 'column') {
    var row = document.createElement('div');
    row.className = 'grid-overlay-row row';
    container.appendChild(row);

    var sizeLabel = createSizeLabel();
    container.appendChild(sizeLabel);

    var columnClassNames = 'col-xs-1 col-sm-1 col-md-1 col-lg-1';

    for (var i = 0; i < 12; i++) {
      var column = document.createElement('div');
      column.className = 'grid-overlay-col-' + (i + 1) + ' ' + columnClassNames;

      column.style.backgroundColor = color;

      row.appendChild(column);
    }
  } else if (gridModes[currentModeIndex] === 'baseline') {
    container.classList.add('grid-overlay-baseline');

    var baselinePercentage = (GRID_BASELINE - 1) / GRID_BASELINE * 100 + '%';

    var backgroundImage = ['linear-gradient(', 'to bottom, ', 'transparent, ', 'transparent ' + baselinePercentage + ', ', color + ' ' + baselinePercentage, ')'].join('');

    container.style.backgroundImage = backgroundImage;

    // Because JSDOM is using the package 'cssstyle', which is stupid and
    // doesn't support gradients as values...
    container.style._backgroundImage = backgroundImage;
  }

  return container;
}

/**
 * Create the DOM nodes needed for the grid size label.
 *
 * @return {HTMLElement} A DOM node.
 *
 * @private
 */
function createSizeLabel() {
  var sizes = [{ name: 'Extra Small', id: 'xs' }, { name: 'Small', id: 'sm' }, { name: 'Medium', id: 'md' }, { name: 'Large', id: 'lg' }];

  var labelContainer = document.createElement('div');
  labelContainer.className = 'grid-overlay-label';

  sizes.forEach(function (size) {
    var label = document.createElement('span');
    label.className = 'visible-' + size.id;
    label.textContent = size.name;
    labelContainer.appendChild(label);
  });

  return labelContainer;
}

exports.listen = listen;
exports.toggle = toggle;
exports.enable = enable;
exports.disable = disable;
exports.setColor = setColor;
exports.reset = reset;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"spotify-cosmos-api":890}],150:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadFont = loadFont;
exports.setSizeForTitle = setSizeForTitle;
/**
 * Usage:
 *
 * loadFont().then(() => {
 *   setSizeForTitle(titleNode, {
 *     useLargeTitle: true,
 *   });
 * });
 */

// There is a bottom padding in the title element, to allow the bottom border
// of links to be rendered correctly. This number here is specified as a
// percentage of the height of a single line.
var PADDING_BOTTOM_PERCENTAGE = 0.07;

var sizeSpecs = {
  default: {
    fontSizes: [[48, 36], [36, 28]],
    lineHeights: [[56, 44], [44, 36]]
  },
  large: {
    fontSizes: [[96, 72, 48], [48, 36, 28]],
    lineHeights: [[110, 82, 56], [56, 44, 36]]
  }
};

/**
 * The font must be loaded before any sizing can be done.
 *
 * @return {Promise}
 */
function loadFont() {
  return document.fonts.load('500 48px spotify-circular');
}

/**
 * Set the type size for the provided title node. The font must be loaded
 * before calling this function.
 *
 * @param {HTMLElement} node The title node.
 * @param {Object=} options An optional object with options:
 *   - useLargeTitle: true/false (default: false)
 */
function setSizeForTitle(node) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var sizeSpecId = options.useLargeTitle ? 'large' : 'default';
  var fontSizes = sizeSpecs[sizeSpecId].fontSizes;
  var lineHeights = sizeSpecs[sizeSpecId].lineHeights;

  var lineCount = 1;
  var sizeIndex = 0;
  var fontSize = fontSizes[0][0];
  var lineHeight = lineHeights[0][0];
  var renderedLineCount = lineCount + 1;
  var lastBottomPadding = Math.ceil(PADDING_BOTTOM_PERCENTAGE * lineHeight);

  // Set initial values (largest type, one line, but clamped to two lines to
  // allow for the text to wrap so we can detect that it doesn't fit).
  node.style.webkitLineClamp = renderedLineCount;
  node.style.fontSize = fontSize + 'px';
  node.style.lineHeight = lineHeight + 'px';
  node.style.paddingBottom = lastBottomPadding + 'px';
  node.style.marginBottom = '-' + lastBottomPadding + 'px';
  node.removeAttribute('title');

  while (lineCount <= fontSizes.length && node.offsetHeight - lastBottomPadding > lineHeight * lineCount) {
    sizeIndex++;

    if (!fontSizes[lineCount - 1][sizeIndex]) {
      sizeIndex = 0;
      lineCount++;
    }

    if (lineCount <= fontSizes.length) {
      fontSize = fontSizes[lineCount - 1][sizeIndex];
      lineHeight = lineHeights[lineCount - 1][sizeIndex];
      renderedLineCount = lineCount + 1;
      lastBottomPadding = Math.ceil(PADDING_BOTTOM_PERCENTAGE * lineHeight);

      node.style.webkitLineClamp = renderedLineCount;
      node.style.fontSize = fontSize + 'px';
      node.style.lineHeight = lineHeight + 'px';
      node.style.paddingBottom = lastBottomPadding + 'px';
      node.style.marginBottom = '-' + lastBottomPadding + 'px';
    }
  }

  if (lineCount > fontSizes.length) {
    // Add title attribute if the text still doesn't fit and gets truncated
    node.setAttribute('title', node.textContent.trim());
  }

  node.style.webkitLineClamp = renderedLineCount - 1;
}

},{}],151:[function(require,module,exports){
'use strict';

module.exports = {
  'cs': require('../i18n/json/cs.json'),
  'de': require('../i18n/json/de.json'),
  'el': require('../i18n/json/el.json'),
  'en': require('../i18n/json/en.json'),
  'es': require('../i18n/json/es.json'),
  'es-419': require('../i18n/json/es-419.json'),
  'fi': require('../i18n/json/fi.json'),
  'fr': require('../i18n/json/fr.json'),
  'fr-CA': require('../i18n/json/fr-CA.json'),
  'hu': require('../i18n/json/hu.json'),
  'id': require('../i18n/json/id.json'),
  'it': require('../i18n/json/it.json'),
  'ja': require('../i18n/json/ja.json'),
  'nl': require('../i18n/json/nl.json'),
  'pl': require('../i18n/json/pl.json'),
  'pt-BR': require('../i18n/json/pt-BR.json'),
  'sv': require('../i18n/json/sv.json'),
  'tr': require('../i18n/json/tr.json'),
  'zh-Hant': require('../i18n/json/zh-Hant.json'),
  'zsm': require('../i18n/json/zsm.json')
};

},{"../i18n/json/cs.json":128,"../i18n/json/de.json":129,"../i18n/json/el.json":130,"../i18n/json/en.json":131,"../i18n/json/es-419.json":132,"../i18n/json/es.json":133,"../i18n/json/fi.json":134,"../i18n/json/fr-CA.json":135,"../i18n/json/fr.json":136,"../i18n/json/hu.json":137,"../i18n/json/id.json":138,"../i18n/json/it.json":139,"../i18n/json/ja.json":140,"../i18n/json/nl.json":141,"../i18n/json/pl.json":142,"../i18n/json/pt-BR.json":143,"../i18n/json/sv.json":144,"../i18n/json/tr.json":145,"../i18n/json/zh-Hant.json":146,"../i18n/json/zsm.json":147}],152:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "\n  <div class=\"b-add-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Save", options) : helperMissing.call(depth0, "loc", "Save", options)))
    + "</div>\n  <div class=\"b-added-text b-alt-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Saved", options) : helperMissing.call(depth0, "loc", "Saved", options)))
    + "</div>\n  <div class=\"b-remove-text b-alt-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Remove", options) : helperMissing.call(depth0, "loc", "Remove", options)))
    + "</div>\n";
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "\n  <div class=\"b-add-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Follow", options) : helperMissing.call(depth0, "loc", "Follow", options)))
    + "</div>\n  <div class=\"b-added-text b-alt-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Following", options) : helperMissing.call(depth0, "loc", "Following", options)))
    + "</div>\n  <div class=\"b-remove-text b-alt-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Unfollow", options) : helperMissing.call(depth0, "loc", "Unfollow", options)))
    + "</div>\n";
  return buffer;
  }

  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "track", "album", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "track", "album", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "playlist", "user", "artist", "station", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "playlist", "user", "artist", "station", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"hbsfy/runtime":615}],153:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;


  buffer += "<div class=\"b-play-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Play", options) : helperMissing.call(depth0, "loc", "Play", options)))
    + "</div>\n<div class=\"b-pause-text b-alt-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Pause", options) : helperMissing.call(depth0, "loc", "Pause", options)))
    + "</div>\n";
  return buffer;
  });

},{"hbsfy/runtime":615}],154:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./internal/image.hbs');
HandlebarsCompiler.registerPartial('./internal/image.hbs', partial$0);
var partial$1 = require('./internal/controls-play-button.hbs');
HandlebarsCompiler.registerPartial('./internal/controls-play-button.hbs', partial$1);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, functionType="function", self=this, blockHelperMissing=helpers.blockHelperMissing;

function program1(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "card-type-station-"
    + escapeExpression((helper = helpers.type || (depth0 && depth0.type),options={hash:{},data:data},helper ? helper.call(depth0, (depth0 && depth0.seedUri), options) : helperMissing.call(depth0, "type", (depth0 && depth0.seedUri), options)));
  return buffer;
  }

function program3(depth0,data) {
  
  
  return "no-image-url";
  }

function program5(depth0,data) {
  
  
  return "card-hidden-image";
  }

function program7(depth0,data) {
  
  
  return "data-context";
  }

function program9(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n    <div\n      class=\"card-image-wrapper\"\n      data-contextmenu-spy\n      data-ta-id=\"card-image-wrapper\"\n    >\n      <div class=\"card-image-hit-area\">\n        <a\n          href=\"";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.targetUri), {hash:{},inverse:self.program(12, program12, data),fn:self.program(10, program10, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\"\n          data-log-click=\"media-image\"\n          data-drag-text=\"";
  if (helper = helpers.dragText) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.dragText); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n          draggable=\"true\"\n          class=\"card-image-link ";
  stack1 = helpers.unless.call(depth0, (depth0 && depth0.imageUrl), {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\"\n        >\n          <div class=\"card-hit-area-counter-scale\"></div>\n          ";
  stack1 = self.invokePartial(partials['./internal/image.hbs'], './internal/image.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        </a>\n        ";
  stack1 = helpers.unless.call(depth0, (depth0 && depth0.noPlayButton), {hash:{},inverse:self.noop,fn:self.program(14, program14, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      </div>\n    </div>\n    ";
  return buffer;
  }
function program10(depth0,data) {
  
  var stack1, helper;
  if (helper = helpers.targetUri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.targetUri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  return escapeExpression(stack1);
  }

function program12(depth0,data) {
  
  var stack1, helper;
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  return escapeExpression(stack1);
  }

function program14(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n          <div class=\"card-overlay\"></div>\n          ";
  stack1 = self.invokePartial(partials['./internal/controls-play-button.hbs'], './internal/controls-play-button.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        ";
  return buffer;
  }

function program16(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n              ";
  if (helper = helpers.titleHTML) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.titleHTML); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n            ";
  return buffer;
  }

function program18(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n              ";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n            ";
  return buffer;
  }

function program20(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n          <div class=\"card-info-subtitle-links\">\n          ";
  stack1 = helpers.each.call(depth0, (depth0 && depth0.subtitleLinks), {hash:{},inverse:self.noop,fn:self.program(21, program21, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n          </div>\n          ";
  return buffer;
  }
function program21(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n            <span>";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</span>";
  stack1 = helpers.unless.call(depth0, (data == null || data === false ? data : data.last), {hash:{},inverse:self.noop,fn:self.program(22, program22, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n          ";
  return buffer;
  }
function program22(depth0,data) {
  
  
  return ", ";
  }

function program24(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n            ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.description), {hash:{},inverse:self.noop,fn:self.program(25, program25, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n          ";
  return buffer;
  }
function program25(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n            <div class=\"card-info-subtitle-description\" data-ta-id=\"card-description\">\n              ";
  if (helper = helpers.description) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.description); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n            </div>\n            ";
  return buffer;
  }

function program27(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n          <div class=\"card-info-subtitle-links\">\n            ";
  if (helper = helpers.subtitleHTML) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.subtitleHTML); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n          </div>\n          ";
  return buffer;
  }

function program29(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n          <div class=\"card-info-subtitle-metadata\">\n            ";
  if (helper = helpers.metadata) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.metadata); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n          </div>\n          ";
  return buffer;
  }

  buffer += "<div\n  class=\"\n    card\n    card-horizontal\n    card-type-"
    + escapeExpression((helper = helpers.type || (depth0 && depth0.type),options={hash:{},data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), options)))
    + "\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.seedUri), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  stack1 = helpers.unless.call(depth0, (depth0 && depth0.imageUrl), {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.noImage), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  \"\n  data-log-context=\"media-object\"\n  data-log-data='{ \"name\": \"";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\", \"target_uri\": \"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" }'\n  data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n  data-contextmenu\n  ";
  options={hash:{},inverse:self.program(7, program7, data),fn:self.noop,data:data}
  if (helper = helpers.noContext) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.noContext); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.noContext) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.program(7, program7, data),fn:self.noop,data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  data-contextmenu-spy\n  data-card-pressed-container\n  data-card-trigger-pressed-state\n  data-ta-id=\"card\"\n>\n  <div class=\"card-horizontal-interior-wrapper\">\n    ";
  stack1 = helpers.unless.call(depth0, (depth0 && depth0.noImage), {hash:{},inverse:self.noop,fn:self.program(9, program9, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n    <div class=\"card-info-wrapper\">\n      <a\n        href=\"";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.targetUri), {hash:{},inverse:self.program(12, program12, data),fn:self.program(10, program10, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\"\n        data-log-click=\"media-title\"\n        data-drag-text=\"";
  if (helper = helpers.dragText) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.dragText); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n        draggable=\"true\"\n      >\n        <div class=\"card-hit-area-counter-scale\"></div>\n        <div class=\"card-info-content-wrapper\">\n          <div class=\"card-info-title\">\n            ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.titleHTML), {hash:{},inverse:self.program(18, program18, data),fn:self.program(16, program16, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n          </div>\n\n          ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.subtitleLinks), {hash:{},inverse:self.program(24, program24, data),fn:self.program(20, program20, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n          ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.subtitleHTML), {hash:{},inverse:self.noop,fn:self.program(27, program27, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n          ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.metadata), {hash:{},inverse:self.noop,fn:self.program(29, program29, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        </div>\n      </a>\n    </div>\n  </div>\n</div>\n";
  return buffer;
  });

},{"./internal/controls-play-button.hbs":157,"./internal/image.hbs":160,"hbsfy/runtime":615}],155:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./internal/image-with-overlay.hbs');
HandlebarsCompiler.registerPartial('./internal/image-with-overlay.hbs', partial$0);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this, functionType="function";

function program1(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "card-type-station-"
    + escapeExpression((helper = helpers.type || (depth0 && depth0.type),options={hash:{},data:data},helper ? helper.call(depth0, (depth0 && depth0.seedUri), options) : helperMissing.call(depth0, "type", (depth0 && depth0.seedUri), options)));
  return buffer;
  }

function program3(depth0,data) {
  
  
  return "no-image-url";
  }

  buffer += "<div\n  class=\"\n    card\n    card-type-"
    + escapeExpression((helper = helpers.type || (depth0 && depth0.type),options={hash:{},data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), options)))
    + "\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.seedUri), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  stack1 = helpers.unless.call(depth0, (depth0 && depth0.imageUrl), {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  \"\n  data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n  data-contextmenu\n  data-drag-text=\"";
  if (helper = helpers.dragText) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.dragText); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n  draggable=\"true\"\n  data-ta-id=\"card\"\n>\n  <div class=\"card-image-wrapper\" data-contextmenu-spy data-ta-id=\"card-image-wrapper\">\n    ";
  stack1 = self.invokePartial(partials['./internal/image-with-overlay.hbs'], './internal/image-with-overlay.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n</div>\n";
  return buffer;
  });

},{"./internal/image-with-overlay.hbs":159,"hbsfy/runtime":615}],156:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./internal/image-with-overlay.hbs');
HandlebarsCompiler.registerPartial('./internal/image-with-overlay.hbs', partial$0);
var partial$1 = require('./internal/controls.hbs');
HandlebarsCompiler.registerPartial('./internal/controls.hbs', partial$1);
var partial$2 = require('./internal/linked-image.hbs');
HandlebarsCompiler.registerPartial('./internal/linked-image.hbs', partial$2);
var partial$3 = require('./internal/controls.hbs');
HandlebarsCompiler.registerPartial('./internal/controls.hbs', partial$3);
var partial$4 = require('./internal/linked-image.hbs');
HandlebarsCompiler.registerPartial('./internal/linked-image.hbs', partial$4);
var partial$5 = require('./internal/controls.hbs');
HandlebarsCompiler.registerPartial('./internal/controls.hbs', partial$5);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this, functionType="function", blockHelperMissing=helpers.blockHelperMissing;

function program1(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "card-type-station-"
    + escapeExpression((helper = helpers.type || (depth0 && depth0.type),options={hash:{},data:data},helper ? helper.call(depth0, (depth0 && depth0.seedUri), options) : helperMissing.call(depth0, "type", (depth0 && depth0.seedUri), options)));
  return buffer;
  }

function program3(depth0,data) {
  
  
  return "no-image-url";
  }

function program5(depth0,data) {
  
  
  return "data-context";
  }

function program7(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n      <div class=\"card-image-hit-area\" data-log-click=\"media-image\">\n        ";
  stack1 = self.invokePartial(partials['./internal/image-with-overlay.hbs'], './internal/image-with-overlay.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n        ";
  stack1 = helpers.unless.call(depth0, (depth0 && depth0.noPlayButton), {hash:{},inverse:self.noop,fn:self.program(8, program8, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      </div>\n    ";
  return buffer;
  }
function program8(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n          ";
  stack1 = self.invokePartial(partials['./internal/controls.hbs'], './internal/controls.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        ";
  return buffer;
  }

function program10(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n      <div class=\"card-image-hit-area\" data-card-trigger-pressed-state>\n        ";
  stack1 = self.invokePartial(partials['./internal/linked-image.hbs'], './internal/linked-image.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n        ";
  stack1 = helpers.unless.call(depth0, (depth0 && depth0.noPlayButton), {hash:{},inverse:self.noop,fn:self.program(8, program8, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      </div>\n    ";
  return buffer;
  }

function program12(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n  <div\n    class=\"\n      card-info-wrapper\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.subtitleLinks), {hash:{},inverse:self.program(15, program15, data),fn:self.program(13, program13, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.metadata), {hash:{},inverse:self.noop,fn:self.program(18, program18, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    \"\n  >\n    <div class=\"card-info-title\">\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.noLink), {hash:{},inverse:self.program(22, program22, data),fn:self.program(20, program20, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    </div>\n\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.subtitleLinks), {hash:{},inverse:self.program(35, program35, data),fn:self.program(27, program27, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.metadata), {hash:{},inverse:self.noop,fn:self.program(38, program38, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n";
  return buffer;
  }
function program13(depth0,data) {
  
  
  return "\n        card-info-with-subtitle-links\n      ";
  }

function program15(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n        ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.description), {hash:{},inverse:self.noop,fn:self.program(16, program16, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  return buffer;
  }
function program16(depth0,data) {
  
  
  return "\n          card-info-with-description\n        ";
  }

function program18(depth0,data) {
  
  
  return "\n        card-info-with-metadata\n      ";
  }

function program20(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <span data-log-click=\"media-title\">\n          ";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n        </span>\n      ";
  return buffer;
  }

function program22(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      <a\n        href=\"";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.targetUri), {hash:{},inverse:self.program(25, program25, data),fn:self.program(23, program23, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\"\n        data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n        data-log-click=\"media-title\"\n        data-ta-id=\"card-title-link\"\n        title=\"";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n      >\n        ";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n      </a>\n      ";
  return buffer;
  }
function program23(depth0,data) {
  
  var stack1, helper;
  if (helper = helpers.targetUri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.targetUri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  return escapeExpression(stack1);
  }

function program25(depth0,data) {
  
  var stack1, helper;
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  return escapeExpression(stack1);
  }

function program27(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n    <div class=\"card-info-subtitle-links\">\n    ";
  stack1 = helpers.each.call(depth0, (depth0 && depth0.subtitleLinks), {hash:{},inverse:self.noop,fn:self.programWithDepth(28, program28, data, depth0),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    </div>\n    ";
  return buffer;
  }
function program28(depth0,data,depth1) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n      <a\n        title=\"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n        href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n        data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n        ";
  stack1 = (helper = helpers.type || (depth1 && depth1.type),options={hash:{},data:data},helper ? helper.call(depth0, (depth1 && depth1.uri), options) : helperMissing.call(depth0, "type", (depth1 && depth1.uri), options));
  stack1 = (helper = helpers.compare || (depth1 && depth1.compare),options={hash:{
    'operator': ("==")
  },inverse:self.noop,fn:self.program(29, program29, data),data:data},helper ? helper.call(depth0, stack1, "album", options) : helperMissing.call(depth0, "compare", stack1, "album", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        ";
  stack1 = (helper = helpers.type || (depth1 && depth1.type),options={hash:{},data:data},helper ? helper.call(depth0, (depth1 && depth1.uri), options) : helperMissing.call(depth0, "type", (depth1 && depth1.uri), options));
  stack1 = (helper = helpers.compare || (depth1 && depth1.compare),options={hash:{
    'operator': ("==")
  },inverse:self.noop,fn:self.program(31, program31, data),data:data},helper ? helper.call(depth0, stack1, "playlist", options) : helperMissing.call(depth0, "compare", stack1, "playlist", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      >";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</a>";
  stack1 = helpers.unless.call(depth0, (data == null || data === false ? data : data.last), {hash:{},inverse:self.noop,fn:self.program(33, program33, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  return buffer;
  }
function program29(depth0,data) {
  
  
  return "\n          data-log-click=\"artist-name\"\n        ";
  }

function program31(depth0,data) {
  
  
  return "\n          data-log-click=\"owner-name\"\n        ";
  }

function program33(depth0,data) {
  
  
  return ", ";
  }

function program35(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.description), {hash:{},inverse:self.noop,fn:self.program(36, program36, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  return buffer;
  }
function program36(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      <div class=\"card-info-subtitle-description\" data-ta-id=\"card-description\">\n        ";
  if (helper = helpers.description) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.description); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n      </div>\n      ";
  return buffer;
  }

function program38(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n    <div class=\"card-info-subtitle-metadata\" data-ta-id=\"card-metadata\">\n      ";
  if (helper = helpers.metadata) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.metadata); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n    </div>\n    ";
  return buffer;
  }

  buffer += "<div\n  class=\"\n    card\n    card-type-"
    + escapeExpression((helper = helpers.type || (depth0 && depth0.type),options={hash:{},data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), options)))
    + "\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.seedUri), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  stack1 = helpers.unless.call(depth0, (depth0 && depth0.imageUrl), {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  \"\n  data-log-context=\"media-object\"\n  data-log-data='{ \"name\": \"";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\", \"target_uri\": \"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" }'\n  data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n  data-contextmenu\n  ";
  options={hash:{},inverse:self.program(5, program5, data),fn:self.noop,data:data}
  if (helper = helpers.noContext) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.noContext); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.noContext) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.program(5, program5, data),fn:self.noop,data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  data-card-pressed-container\n  data-ta-id=\"card\"\n>\n  <div class=\"card-image-wrapper\" data-contextmenu-spy data-ta-id=\"card-image-wrapper\">\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.noLink), {hash:{},inverse:self.program(10, program10, data),fn:self.program(7, program7, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n\n";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.title), {hash:{},inverse:self.noop,fn:self.program(12, program12, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n</div>\n";
  return buffer;
  });

},{"./internal/controls.hbs":158,"./internal/image-with-overlay.hbs":159,"./internal/linked-image.hbs":161,"hbsfy/runtime":615}],157:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, self=this, blockHelperMissing=helpers.blockHelperMissing, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n  <button\n    type=\"button\"\n    class=\"button button-play button-icon-with-stroke card-button-play\"\n    data-log-click=\"play-button\"\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.range), {hash:{},inverse:self.program(5, program5, data),fn:self.program(2, program2, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  >\n  </button>\n";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n      data-button=\"play\"\n      ";
  options={hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data}
  if (helper = helpers.range) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.range); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.range) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  return buffer;
  }
function program3(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "data-range=\"";
  if (helper = helpers.start) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.start); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + ",";
  if (helper = helpers.end) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.end); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"";
  return buffer;
  }

function program5(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.contextPage), {hash:{},inverse:self.program(9, program9, data),fn:self.program(6, program6, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  return buffer;
  }
function program6(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n        data-button=\"play\"\n        ";
  options={hash:{},inverse:self.noop,fn:self.program(7, program7, data),data:data}
  if (helper = helpers.contextPage) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.contextPage); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.contextPage) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(7, program7, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  return buffer;
  }
function program7(depth0,data) {
  
  var buffer = "";
  buffer += "data-context-page=\""
    + escapeExpression((typeof depth0 === functionType ? depth0.apply(depth0) : depth0))
    + "\"";
  return buffer;
  }

function program9(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n        ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.trackUri), {hash:{},inverse:self.program(13, program13, data),fn:self.program(10, program10, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  return buffer;
  }
function program10(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n          ";
  options={hash:{},inverse:self.noop,fn:self.program(11, program11, data),data:data}
  if (helper = helpers.trackUri) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.trackUri); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.trackUri) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(11, program11, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n          data-button=\"play\"\n        ";
  return buffer;
  }
function program11(depth0,data) {
  
  var buffer = "";
  buffer += "data-track-uri=\""
    + escapeExpression((typeof depth0 === functionType ? depth0.apply(depth0) : depth0))
    + "\"";
  return buffer;
  }

function program13(depth0,data) {
  
  
  return "\n          data-button=\"play-context\"\n        ";
  }

  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "playlist", "track", "album", "station", "artist", "episode", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "playlist", "track", "album", "station", "artist", "episode", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"hbsfy/runtime":615}],158:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./controls-play-button.hbs');
HandlebarsCompiler.registerPartial('./controls-play-button.hbs', partial$0);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this, functionType="function", blockHelperMissing=helpers.blockHelperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n  ";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "playlist", "track", "album", "station", "artist", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "playlist", "track", "album", "station", "artist", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n    ";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "track", "album", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "track", "album", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "playlist", "station", "artist", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "playlist", "station", "artist", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }
function program3(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "\n      <button\n        type=\"button\"\n        data-button=\"add\"\n        class=\"button button-add card-button-add\"\n        data-tooltip=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Save", options) : helperMissing.call(depth0, "loc", "Save", options)))
    + "\"\n        data-tooltip-add=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Save", options) : helperMissing.call(depth0, "loc", "Save", options)))
    + "\"\n        data-tooltip-remove=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Remove", options) : helperMissing.call(depth0, "loc", "Remove", options)))
    + "\"\n        data-log-click=\"add-button\"></button>\n    ";
  return buffer;
  }

function program5(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n      ";
  options={hash:{},inverse:self.program(6, program6, data),fn:self.noop,data:data}
  if (helper = helpers.currentUserPlaylist) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.currentUserPlaylist); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.currentUserPlaylist) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.program(6, program6, data),fn:self.noop,data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  return buffer;
  }
function program6(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "\n      <button\n        type=\"button\"\n        data-button=\"add\"\n        class=\"button button-add card-button-add\"\n        data-tooltip=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Follow", options) : helperMissing.call(depth0, "loc", "Follow", options)))
    + "\"\n        data-tooltip-add=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Follow", options) : helperMissing.call(depth0, "loc", "Follow", options)))
    + "\"\n        data-tooltip-remove=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Unfollow", options) : helperMissing.call(depth0, "loc", "Unfollow", options)))
    + "\"\n        data-log-click=\"follow-button\"></button>\n      ";
  return buffer;
  }

function program8(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n  ";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(9, program9, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "playlist", "track", "album", "artist", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "playlist", "track", "album", "artist", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  }
function program9(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "\n    <button\n      type=\"button\"\n      data-button=\"contextmenu\"\n      class=\"button button-more button-no-border card-button-more\"\n      data-tooltip=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "More", options) : helperMissing.call(depth0, "loc", "More", options)))
    + "\"\n      data-log-click=\"context-menu-button\"></button>\n  ";
  return buffer;
  }

  stack1 = helpers.unless.call(depth0, (depth0 && depth0.playButtonOnly), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n";
  stack1 = self.invokePartial(partials['./controls-play-button.hbs'], './controls-play-button.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n";
  stack1 = helpers.unless.call(depth0, (depth0 && depth0.playButtonOnly), {hash:{},inverse:self.noop,fn:self.program(8, program8, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"./controls-play-button.hbs":157,"hbsfy/runtime":615}],159:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./image.hbs');
HandlebarsCompiler.registerPartial('./image.hbs', partial$0);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, self=this;

function program1(depth0,data) {
  
  
  return "\n  <div class=\"card-overlay\"></div>\n";
  }

  stack1 = self.invokePartial(partials['./image.hbs'], './image.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n";
  stack1 = helpers.unless.call(depth0, (depth0 && depth0.noPlayButton), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"./image.hbs":160,"hbsfy/runtime":615}],160:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./placeholder.hbs');
HandlebarsCompiler.registerPartial('./placeholder.hbs', partial$0);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "style=\"background-image: url('";
  if (helper = helpers.imageUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.imageUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "')\"";
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      data-image-url=\"";
  if (helper = helpers.imageUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.imageUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n    ";
  return buffer;
  }

function program5(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n    ";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},data:data},helper ? helper.call(depth0, (depth0 && depth0.seedUri), options) : helperMissing.call(depth0, "type", (depth0 && depth0.seedUri), options));
  stack1 = (helper = helpers.compare || (depth0 && depth0.compare),options={hash:{
    'operator': ("!=")
  },inverse:self.noop,fn:self.program(6, program6, data),data:data},helper ? helper.call(depth0, stack1, "cluster", options) : helperMissing.call(depth0, "compare", stack1, "cluster", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }
function program6(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.dominantColor), {hash:{},inverse:self.noop,fn:self.program(7, program7, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      <div class=\"card-station-layer card-station-mask\"></div>\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.imageUrl), {hash:{},inverse:self.noop,fn:self.program(9, program9, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  return buffer;
  }
function program7(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <div class=\"card-station-layer card-station-highlight\" style=\"background-color:";
  if (helper = helpers.dominantColor) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.dominantColor); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"></div>\n      ";
  return buffer;
  }

function program9(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <div class=\"card-station-overlay\" style=\"background-image: url(";
  if (helper = helpers.imageUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.imageUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + ")\"></div>\n      ";
  return buffer;
  }

  stack1 = self.invokePartial(partials['./placeholder.hbs'], './placeholder.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n<div class=\"card-image-content-wrapper\">\n  <div\n    class=\"card-image\"\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.imageUrl), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    data-ta-id=\"card-image\"\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.imageUrl), {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  >\n  </div>\n\n  ";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "station", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "station", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n";
  return buffer;
  });

},{"./placeholder.hbs":162,"hbsfy/runtime":615}],161:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./image-with-overlay.hbs');
HandlebarsCompiler.registerPartial('./image-with-overlay.hbs', partial$0);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  
  return "no-image-url";
  }

  buffer += "<a\n  href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n  data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n  data-log-click=\"media-image\"\n  data-drag-text=\"";
  if (helper = helpers.dragText) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.dragText); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n  draggable=\"true\"\n  class=\"card-image-link ";
  stack1 = helpers.unless.call(depth0, (depth0 && depth0.imageUrl), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\"\n>\n  <div class=\"card-hit-area-counter-scale\"></div>\n  ";
  stack1 = self.invokePartial(partials['./image-with-overlay.hbs'], './image-with-overlay.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</a>\n";
  return buffer;
  });

},{"./image-with-overlay.hbs":159,"hbsfy/runtime":615}],162:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  


  return "<div class=\"card-placeholder-wrapper\">\n  <svg class=\"card-placeholder\" viewBox=\"0 0 10 10\" preserveAspectRatio=\"xMidYMid meet\">\n    <text class=\"playlist-placeholder\" x=\"5\" y=\"9.8\">&#xf135;</text>\n    <text class=\"playlist-folder-placeholder\" x=\"5\" y=\"9.8\">&#xf137;</text>\n    <text class=\"album-placeholder\" x=\"5\" y=\"9.8\">&#xf101;</text>\n    <text class=\"artist-placeholder\" x=\"5\" y=\"9.8\">&#xf103;</text>\n    <text class=\"user-placeholder\" x=\"5\" y=\"9.8\">&#xf15d;</text>\n    <text class=\"genre-placeholder\" x=\"5\" y=\"9.8\">&#xf109;</text>\n    <text class=\"collection-placeholder\" x=\"5\" y=\"9.8\">&#xf157;</text>\n    <text class=\"local-files-placeholder\" x=\"5\" y=\"9.8\">&#xf1fb;</text>\n  </svg>\n</div>\n";
  });

},{"hbsfy/runtime":615}],163:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./internal/image.hbs');
HandlebarsCompiler.registerPartial('./internal/image.hbs', partial$0);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <div\n          class=\"card-puff__image\"\n          style=\"background-image: url(";
  if (helper = helpers.imageUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.imageUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + ");\"\n        ></div>\n      ";
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n      <div class=\"card-puff__images\">\n        ";
  stack1 = helpers.each.call(depth0, (depth0 && depth0.images), {hash:{},inverse:self.noop,fn:self.program(4, program4, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      </div>\n\n        ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.title), {hash:{},inverse:self.noop,fn:self.program(7, program7, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  return buffer;
  }
function program4(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n          <div class=\"\n            card-puff__card-image\n            card\n            card-type-"
    + escapeExpression((helper = helpers.type || (depth0 && depth0.type),options={hash:{},data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), options)))
    + "\n            ";
  stack1 = helpers.unless.call(depth0, (depth0 && depth0.imageUrl), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n          \">\n            ";
  stack1 = self.invokePartial(partials['./internal/image.hbs'], './internal/image.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n          </div>\n        ";
  return buffer;
  }
function program5(depth0,data) {
  
  
  return "no-image-url";
  }

function program7(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <div class=\"card-puff__title-container\" data-ta-id=\"card-title-link\">\n          <div class=\"card-puff__title\">";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n        </div>\n        ";
  return buffer;
  }

function program9(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n    <div class=\"card-puff__subtitle\">\n      ";
  if (helper = helpers.subtitle) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.subtitle); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n    </div>\n    ";
  return buffer;
  }

  buffer += "<div\n  class=\"card card-puff\"\n  data-card-pressed-container\n>\n  <div class=\"card-puff__image-wrapper\">\n    <a\n      href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n      class=\"card-puff__link\"\n      data-log-click=\"puff\"\n      draggable=\"false\"\n      data-card-trigger-pressed-state\n      aria-label=";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n    >\n      <div class=\"card-hit-area-counter-scale\"></div>\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.imageUrl), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.images), {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    </a>\n  </div>\n\n  <div class=\"card-puff__info-container\">\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.subtitle), {hash:{},inverse:self.noop,fn:self.program(9, program9, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n</div>\n";
  return buffer;
  });

},{"./internal/image.hbs":160,"hbsfy/runtime":615}],164:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, functionType="function", self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n        <h1 class=\"hdr-l\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "ErrorTitle", options) : helperMissing.call(depth0, "loc", "ErrorTitle", options)))
    + "</h1>\n        <div class=\"message\">";
  stack1 = (helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "ErrorMessage", options) : helperMissing.call(depth0, "loc", "ErrorMessage", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "</div>\n      ";
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <h1 class=\"hdr-l\">";
  if (helper = helpers.errorTitle) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.errorTitle); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</h1>\n        <div class=\"message\">";
  if (helper = helpers.errorMessage) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.errorMessage); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "</div>\n      ";
  return buffer;
  }

function program5(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <a class=\"button button-white\" href=\"";
  if (helper = helpers.errorEscapeUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.errorEscapeUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"error-escape\">";
  if (helper = helpers.errorEscapeMessage) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.errorEscapeMessage); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</a>\n      ";
  return buffer;
  }

function program7(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n        <h1 class=\"hdr-l\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "OfflineTitle", options) : helperMissing.call(depth0, "loc", "OfflineTitle", options)))
    + "</h1>\n        <div class=\"message\">";
  stack1 = (helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "OfflineMessage", options) : helperMissing.call(depth0, "loc", "OfflineMessage", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "</div>\n      ";
  return buffer;
  }

function program9(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <h1 class=\"hdr-l\">";
  if (helper = helpers.offlineTitle) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.offlineTitle); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</h1>\n        <div class=\"message\">";
  if (helper = helpers.offlineMessage) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.offlineMessage); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "</div>\n      ";
  return buffer;
  }

function program11(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <a class=\"button button-white\" href=\"";
  if (helper = helpers.offlineEscapeUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.offlineEscapeUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"offline-escape\">";
  if (helper = helpers.offlineEscapeMessage) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.offlineEscapeMessage); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</a>\n      ";
  return buffer;
  }

function program13(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n  <div class=\"error-version text-muted\">";
  if (helper = helpers.errorVersion) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.errorVersion); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n  ";
  return buffer;
  }

  buffer += "<div class=\"error-and-offline\" data-log-context=\"error-and-offline\">\n  <div class=\"container\">\n    <div class=\"error-content\">\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.useDefaultError), {hash:{},inverse:self.program(3, program3, data),fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.errorEscapeMessage), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    </div>\n    <div class=\"offline-content\">\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.useDefaultOffline), {hash:{},inverse:self.program(9, program9, data),fn:self.program(7, program7, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.offlineEscapeMessage), {hash:{},inverse:self.noop,fn:self.program(11, program11, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    </div>\n  </div>\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.errorVersion), {hash:{},inverse:self.noop,fn:self.program(13, program13, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n";
  return buffer;
  });

},{"hbsfy/runtime":615}],165:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./media/image.hbs');
HandlebarsCompiler.registerPartial('./media/image.hbs', partial$0);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing, self=this, blockHelperMissing=helpers.blockHelperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n  <div class=\"facepile\" data-tooltip title=\"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-tooltip-instant>\n    <div class=\"media-object media-object-image media-object-link media-object-simple media-object-"
    + escapeExpression((helper = helpers.type || (depth0 && depth0.type),options={hash:{},data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), options)))
    + " ";
  options={hash:{},inverse:self.program(2, program2, data),fn:self.noop,data:data}
  if (helper = helpers.imageUrl) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.imageUrl); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.imageUrl) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.program(2, program2, data),fn:self.noop,data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\"\n      data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n      data-log-context=\"media-object\"\n      data-contextmenu>\n      <div class=\"mo-wrapper\">\n        <div class=\"mo-image-wrapper\">\n          <a href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"media-image\">\n            ";
  stack1 = self.invokePartial(partials['./media/image.hbs'], './media/image.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n          </a>\n        </div>\n      </div>\n    </div>\n  </div>\n";
  return buffer;
  }
function program2(depth0,data) {
  
  
  return "show-placeholder";
  }

function program4(depth0,data,depth1) {
  
  var buffer = "", stack1, helper;
  buffer += "\n  <button\n    type=\"button\"\n    class=\"button facepile-badge\"\n    title=\"";
  if (helper = helpers.badgeTooltip) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.badgeTooltip); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n    data-tooltip\n    data-tooltip-instant\n    data-modal=\"spotify:modal:socialproof:"
    + escapeExpression(((stack1 = (depth1 && depth1.uri)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\"\n  >\n    +";
  if (helper = helpers.badgeCount) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.badgeCount); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n  </button>\n";
  return buffer;
  }

  stack1 = (helper = helpers.facepile || (depth0 && depth0.facepile),options={hash:{},inverse:self.programWithDepth(4, program4, data, depth0),fn:self.program(1, program1, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.users), options) : helperMissing.call(depth0, "facepile", (depth0 && depth0.users), options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"./media/image.hbs":183,"hbsfy/runtime":615}],166:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./facepile-common.hbs');
HandlebarsCompiler.registerPartial('./facepile-common.hbs', partial$0);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, self=this;


  buffer += "<div class=\"facepile-list\">\n	";
  stack1 = self.invokePartial(partials['./facepile-common.hbs'], './facepile-common.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n";
  return buffer;
  });

},{"./facepile-common.hbs":165,"hbsfy/runtime":615}],167:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, self=this, blockHelperMissing=helpers.blockHelperMissing;

function program1(depth0,data) {
  
  
  return "data-card-pressed-container";
  }

function program3(depth0,data) {
  
  
  return "data-card-trigger-pressed-state";
  }

function program5(depth0,data) {
  
  var buffer = "";
  buffer += "gc-image-cols-"
    + escapeExpression((typeof depth0 === functionType ? depth0.apply(depth0) : depth0));
  return buffer;
  }

  buffer += "<div\n  class=\"card genre-card\"\n  ";
  options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data}
  if (helper = helpers.useNewCard) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.useNewCard); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.useNewCard) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n>\n  <a\n    href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n    draggable=\"false\"\n    data-log-click=\"genre-card\"\n    ";
  options={hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data}
  if (helper = helpers.useNewCard) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.useNewCard); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.useNewCard) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  >\n    <div class=\"card-hit-area-counter-scale\"></div>\n    <div class=\"gc-image-container\">\n      <div class=\"gc-image ";
  stack1 = helpers['with'].call(depth0, (depth0 && depth0.cols), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" style=\"background-image: url('";
  if (helper = helpers.imageUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.imageUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "')\"></div>\n      <div class=\"gc-label-container\">\n        <div class=\"gc-label-text-wrapper\">\n          <span class=\"gc-label-text\">";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</span>\n        </div>\n      </div>\n    </div>\n  </a>\n</div>\n";
  return buffer;
  });

},{"hbsfy/runtime":615}],168:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('../../../buttons/add-interior.hbs');
HandlebarsCompiler.registerPartial('../../../buttons/add-interior.hbs', partial$0);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, helper, self=this, functionType="function", escapeExpression=this.escapeExpression;

function program1(depth0,data) {
  
  
  return "added";
  }

  buffer += "<button\n  class=\"button button-with-stroke button-add ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.isAdded), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\"\n  data-button=\"add\"\n  data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n  data-log-click=\"add-button\"\n  data-ta-id=\"page-header-button-add\"\n>\n  ";
  stack1 = self.invokePartial(partials['../../../buttons/add-interior.hbs'], '../../../buttons/add-interior.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</button>";
  return buffer;
  });

},{"../../../buttons/add-interior.hbs":152,"hbsfy/runtime":615}],169:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;


  buffer += "<button\n  class=\"button button-icon-with-stroke spoticon-more-16\"\n  data-button=\"contextmenu\"\n  data-tooltip=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "More", options) : helperMissing.call(depth0, "loc", "More", options)))
    + "\"\n  data-log-click=\"contextmenu-button\"\n  data-ta-id=\"page-header-button-more\"\n  aria-label=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "More", options) : helperMissing.call(depth0, "loc", "More", options)))
    + "\"\n>\n</button>\n";
  return buffer;
  });

},{"hbsfy/runtime":615}],170:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('../../../buttons/play-interior.hbs');
HandlebarsCompiler.registerPartial('../../../buttons/play-interior.hbs', partial$0);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n    data-uri=\"";
  if (helper = helpers.playContextUri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.playContextUri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n    data-context\n  ";
  return buffer;
  }

  buffer += "<button\n  class=\"button button-green button-play\"\n  data-button=\"play-context\"\n  data-log-click=\"play-button\"\n  data-ta-id=\"page-header-button-play\"\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.playContextUri), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n>\n  ";
  stack1 = self.invokePartial(partials['../../../buttons/play-interior.hbs'], '../../../buttons/play-interior.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</button>";
  return buffer;
  });

},{"../../../buttons/play-interior.hbs":153,"hbsfy/runtime":615}],171:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n    <div\n      class=\"\n        glue-page-header__background-image-loader\n        ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.isLoaded), {hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      \"\n      data-glue-page-header-background-image-loader\n    >\n      <div\n        class=\"glue-page-header__background-image\"\n        ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.background)),stack1 == null || stack1 === false ? stack1 : stack1.imageUrl), {hash:{},inverse:self.noop,fn:self.program(4, program4, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        data-glue-page-header-background-image\n        data-glue-page-header-background-image-url=\""
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.background)),stack1 == null || stack1 === false ? stack1 : stack1.imageUrl)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\"\n        data-ta-id=\"page-header-background-image\"\n      >\n      </div>\n    </div>\n    <div class=\"glue-page-header__background-overlay\">\n    </div>\n    <div class=\"glue-page-header__background-image-overlay-gradient\">\n    </div>\n    <div\n      class=\"glue-page-header__background-scroll-overlay-ellipse-backdrop\"\n      data-glue-page-header-background-scroll-overlay-ellipse-backdrop\n    >\n    </div>\n    <div\n      class=\"glue-page-header__background-scroll-overlay-ellipse\"\n      data-glue-page-header-background-scroll-overlay-ellipse\n    >\n    </div>\n  ";
  return buffer;
  }
function program2(depth0,data) {
  
  
  return "\n          glue-page-header__background-image--is-loaded\n        ";
  }

function program4(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n          style=\"background-image: url("
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.background)),stack1 == null || stack1 === false ? stack1 : stack1.imageUrl)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + ")\"\n        ";
  return buffer;
  }

function program6(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n    <div\n      class=\"glue-page-header__background-color\"\n      ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.background)),stack1 == null || stack1 === false ? stack1 : stack1.color), {hash:{},inverse:self.noop,fn:self.program(7, program7, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    >\n    </div>\n    <div class=\"glue-page-header__background-overlay\">\n    </div>\n    <div\n      class=\"glue-page-header__background-scroll-overlay\"\n      data-glue-page-header-background-scroll-overlay\n    >\n    </div>\n  ";
  return buffer;
  }
function program7(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n        style=\"background-color: "
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.background)),stack1 == null || stack1 === false ? stack1 : stack1.color)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\"\n      ";
  return buffer;
  }

  buffer += "<div\n  class=\"glue-page-header__background\"\n  data-glue-page-header-background\n>\n  ";
  stack1 = (helper = helpers.compare || (depth0 && depth0.compare),options={hash:{},inverse:self.program(6, program6, data),fn:self.program(1, program1, data),data:data},helper ? helper.call(depth0, ((stack1 = (depth0 && depth0.background)),stack1 == null || stack1 === false ? stack1 : stack1.type), "image", options) : helperMissing.call(depth0, "compare", ((stack1 = (depth0 && depth0.background)),stack1 == null || stack1 === false ? stack1 : stack1.type), "image", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n";
  return buffer;
  });

},{"hbsfy/runtime":615}],172:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('../generic/button-play.hbs');
HandlebarsCompiler.registerPartial('../generic/button-play.hbs', partial$0);
var partial$1 = require('../generic/button-add.hbs');
HandlebarsCompiler.registerPartial('../generic/button-add.hbs', partial$1);
var partial$2 = require('../generic/button-more.hbs');
HandlebarsCompiler.registerPartial('../generic/button-more.hbs', partial$2);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, self=this, functionType="function";

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n    <div class=\"glue-page-header__button\">\n      ";
  stack1 = self.invokePartial(partials['../generic/button-play.hbs'], '../generic/button-play.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    </div>\n  ";
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n    <div class=\"glue-page-header__button\">\n      ";
  stack1 = self.invokePartial(partials['../generic/button-add.hbs'], '../generic/button-add.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    </div>\n  ";
  return buffer;
  }

function program5(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n    <div class=\"glue-page-header__button\">\n      ";
  stack1 = self.invokePartial(partials['../generic/button-more.hbs'], '../generic/button-more.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    </div>\n  ";
  return buffer;
  }

function program7(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n    ";
  stack1 = helpers.each.call(depth0, ((stack1 = (depth0 && depth0.buttons)),stack1 == null || stack1 === false ? stack1 : stack1.customButtons), {hash:{},inverse:self.noop,fn:self.program(8, program8, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }
function program8(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n      <div class=\"glue-page-header__button\">\n        ";
  stack1 = (typeof depth0 === functionType ? depth0.apply(depth0) : depth0);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      </div>\n    ";
  return buffer;
  }

  buffer += "<div class=\"glue-page-header__buttons\">\n  ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.buttons)),stack1 == null || stack1 === false ? stack1 : stack1.playButton), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n  ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.buttons)),stack1 == null || stack1 === false ? stack1 : stack1.addButton), {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n  ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.buttons)),stack1 == null || stack1 === false ? stack1 : stack1.moreButton), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n  ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.buttons)),stack1 == null || stack1 === false ? stack1 : stack1.customButtons), {hash:{},inverse:self.noop,fn:self.program(7, program7, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>";
  return buffer;
  });

},{"../generic/button-add.hbs":168,"../generic/button-more.hbs":169,"../generic/button-play.hbs":170,"hbsfy/runtime":615}],173:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('../../../facepile.hbs');
HandlebarsCompiler.registerPartial('../../../facepile.hbs', partial$0);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n  <div class=\"glue-page-header__count-label\">\n    ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.countLabel)),stack1 == null || stack1 === false ? stack1 : stack1.link), {hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      <div class=\"glue-page-header__count-label-text\">\n        "
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.countLabel)),stack1 == null || stack1 === false ? stack1 : stack1.label)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\n      </div>\n      <div class=\"glue-page-header__count-label-number\">\n        "
    + escapeExpression((helper = helpers.numeral || (depth0 && depth0.numeral),options={hash:{},data:data},helper ? helper.call(depth0, ((stack1 = (depth0 && depth0.countLabel)),stack1 == null || stack1 === false ? stack1 : stack1.number), options) : helperMissing.call(depth0, "numeral", ((stack1 = (depth0 && depth0.countLabel)),stack1 == null || stack1 === false ? stack1 : stack1.number), options)))
    + "\n      </div>\n    ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.countLabel)),stack1 == null || stack1 === false ? stack1 : stack1.link), {hash:{},inverse:self.noop,fn:self.program(4, program4, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n    ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.countLabel)),stack1 == null || stack1 === false ? stack1 : stack1.facePile), {hash:{},inverse:self.noop,fn:self.program(6, program6, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n    <a\n      href=\""
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.countLabel)),stack1 == null || stack1 === false ? stack1 : stack1.link)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\"\n      class=\"glue-page-header__count-label-link\"\n      data-glue-page-header-count-label-link\n    >\n    ";
  return buffer;
  }

function program4(depth0,data) {
  
  
  return "\n    </a>\n    ";
  }

function program6(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n      <div class=\"glue-page-header__count-label-facepile\">\n        ";
  stack1 = self.invokePartial(partials['../../../facepile.hbs'], '../../../facepile.hbs', ((stack1 = (depth0 && depth0.countLabel)),stack1 == null || stack1 === false ? stack1 : stack1.facePile), helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      </div>\n    ";
  return buffer;
  }

  stack1 = helpers['if'].call(depth0, (depth0 && depth0.countLabel), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"../../../facepile.hbs":166,"hbsfy/runtime":615}],174:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n  <div\n    class=\"glue-page-header__description\"\n    data-ta-id=\"page-header-description\"\n  >\n    ";
  if (helper = helpers.descriptionHTML) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.descriptionHTML); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n";
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.description), {hash:{},inverse:self.noop,fn:self.program(4, program4, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  }
function program4(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n    <div\n      class=\"glue-page-header__description\"\n      data-ta-id=\"page-header-description\"\n    >\n      ";
  if (helper = helpers.description) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.description); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n    </div>\n  ";
  return buffer;
  }

  stack1 = helpers['if'].call(depth0, (depth0 && depth0.descriptionHTML), {hash:{},inverse:self.program(3, program3, data),fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"hbsfy/runtime":615}],175:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('../../../cards/card-without-link.hbs');
HandlebarsCompiler.registerPartial('../../../cards/card-without-link.hbs', partial$0);
var partial$1 = require('../../../cards/card-without-link.hbs');
HandlebarsCompiler.registerPartial('../../../cards/card-without-link.hbs', partial$1);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, functionType="function", self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n  <div class=\"glue-page-header__image\">\n    <div class=\"glue-page-header__image-inner\">\n      ";
  if (helper = helpers.imageHTML) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.imageHTML); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    </div>\n  </div>\n";
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.image), {hash:{},inverse:self.noop,fn:self.program(4, program4, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  }
function program4(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n    <div class=\"glue-page-header__image\">\n      <div class=\"glue-page-header__image-inner\">\n        ";
  stack1 = self.invokePartial(partials['../../../cards/card-without-link.hbs'], '../../../cards/card-without-link.hbs', (depth0 && depth0.image), helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      </div>\n    </div>\n  ";
  return buffer;
  }

  stack1 = helpers['if'].call(depth0, (depth0 && depth0.imageHTML), {hash:{},inverse:self.program(3, program3, data),fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"../../../cards/card-without-link.hbs":155,"hbsfy/runtime":615}],176:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n  <span class=\"glue-page-header__label\">";
  if (helper = helpers.labelHTML) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.labelHTML); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "</span>\n";
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.label), {hash:{},inverse:self.noop,fn:self.program(4, program4, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  }
function program4(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n    <span class=\"glue-page-header__label\">";
  if (helper = helpers.label) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.label); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</span>\n  ";
  return buffer;
  }

  stack1 = helpers['if'].call(depth0, (depth0 && depth0.labelHTML), {hash:{},inverse:self.program(3, program3, data),fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { return stack1; }
  else { return ''; }
  });

},{"hbsfy/runtime":615}],177:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var stack1, functionType="function", self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n  <div\n    class=\"glue-page-header__meta-info\"\n    data-ta-id=\"page-header-meta-info\"\n  >\n    ";
  if (helper = helpers.metaInfoHTML) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.metaInfoHTML); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n";
  return buffer;
  }

  stack1 = helpers['if'].call(depth0, (depth0 && depth0.metaInfoHTML), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { return stack1; }
  else { return ''; }
  });

},{"hbsfy/runtime":615}],178:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('../../../navbar.hbs');
HandlebarsCompiler.registerPartial('../../../navbar.hbs', partial$0);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var stack1, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n  <div class=\"glue-page-header__navbar-wrapper\">\n    ";
  stack1 = self.invokePartial(partials['../../../navbar.hbs'], '../../../navbar.hbs', (depth0 && depth0.navBar), helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n";
  return buffer;
  }

  stack1 = helpers['if'].call(depth0, (depth0 && depth0.navBar), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { return stack1; }
  else { return ''; }
  });

},{"../../../navbar.hbs":186,"hbsfy/runtime":615}],179:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  
  return "data-contextmenu";
  }

function program3(depth0,data) {
  
  
  return "draggable=\"true\"";
  }

function program5(depth0,data) {
  
  
  return "\n    data-glue-page-header-use-large-title\n  ";
  }

function program7(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n    ";
  if (helper = helpers.titleHTML) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.titleHTML); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }

function program9(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n    ";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n  ";
  return buffer;
  }

  buffer += "<h1\n  class=\"glue-page-header__title\"\n  data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n  data-ta-id=\"page-header-title\"\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.enableContextMenu), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.enableDragging), {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  data-glue-page-header-title\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.useLargeTitle), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n>\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.titleHTML), {hash:{},inverse:self.program(9, program9, data),fn:self.program(7, program7, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</h1>";
  return buffer;
  });

},{"hbsfy/runtime":615}],180:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./internal/page-header/background.hbs');
HandlebarsCompiler.registerPartial('./internal/page-header/background.hbs', partial$0);
var partial$1 = require('./internal/page-header/image.hbs');
HandlebarsCompiler.registerPartial('./internal/page-header/image.hbs', partial$1);
var partial$2 = require('./internal/page-header/label.hbs');
HandlebarsCompiler.registerPartial('./internal/page-header/label.hbs', partial$2);
var partial$3 = require('./internal/page-header/title.hbs');
HandlebarsCompiler.registerPartial('./internal/page-header/title.hbs', partial$3);
var partial$4 = require('./internal/page-header/description.hbs');
HandlebarsCompiler.registerPartial('./internal/page-header/description.hbs', partial$4);
var partial$5 = require('./internal/page-header/meta-info.hbs');
HandlebarsCompiler.registerPartial('./internal/page-header/meta-info.hbs', partial$5);
var partial$6 = require('./internal/page-header/buttons.hbs');
HandlebarsCompiler.registerPartial('./internal/page-header/buttons.hbs', partial$6);
var partial$7 = require('./internal/page-header/count-label.hbs');
HandlebarsCompiler.registerPartial('./internal/page-header/count-label.hbs', partial$7);
var partial$8 = require('./internal/page-header/buttons.hbs');
HandlebarsCompiler.registerPartial('./internal/page-header/buttons.hbs', partial$8);
var partial$9 = require('./internal/page-header/image.hbs');
HandlebarsCompiler.registerPartial('./internal/page-header/image.hbs', partial$9);
var partial$10 = require('./internal/page-header/title.hbs');
HandlebarsCompiler.registerPartial('./internal/page-header/title.hbs', partial$10);
var partial$11 = require('./internal/page-header/buttons.hbs');
HandlebarsCompiler.registerPartial('./internal/page-header/buttons.hbs', partial$11);
var partial$12 = require('./internal/page-header/navbar.hbs');
HandlebarsCompiler.registerPartial('./internal/page-header/navbar.hbs', partial$12);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, helper, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, functionType="function", self=this;

function program1(depth0,data) {
  
  
  return "\n      glue-page-header--with-navbar\n    ";
  }

function program3(depth0,data) {
  
  
  return "\n      glue-page-header--with-count-label\n    ";
  }

function program5(depth0,data) {
  
  
  return "\n      glue-page-header--with-responsive-height-small\n    ";
  }

function program7(depth0,data) {
  
  
  return "\n      glue-page-header--with-responsive-height-large\n    ";
  }

function program9(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "\n      glue-page-header--"
    + escapeExpression((helper = helpers.type || (depth0 && depth0.type),options={hash:{},data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), options)))
    + "\n    ";
  return buffer;
  }

function program11(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n    data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n  ";
  return buffer;
  }

function program13(depth0,data) {
  
  
  return "\n    data-context\n  ";
  }

function program15(depth0,data) {
  
  
  return "\n    data-glue-page-header-sticky-height=\"160\"\n  ";
  }

function program17(depth0,data) {
  
  
  return "\n    data-glue-page-header-sticky-height=\"116\"\n  ";
  }

function program19(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n    <div class=\"row\">\n      <div class=\"";
  if (helper = helpers.gridClasses) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.gridClasses); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n    ";
  return buffer;
  }

function program21(depth0,data) {
  
  
  return "\n          glue-page-header__content--with-custom-image-size\n        ";
  }

function program23(depth0,data) {
  
  
  return "\n          glue-page-header__content--with-button-placement-left\n        ";
  }

function program25(depth0,data) {
  
  
  return "\n            glue-page-header__spacer--large\n          ";
  }

function program27(depth0,data) {
  
  
  return "\n      </div>\n    </div>\n    ";
  }

function program29(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <div class=\"row\">\n          <div class=\"";
  if (helper = helpers.gridClasses) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.gridClasses); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n        ";
  return buffer;
  }

function program31(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n            ";
  stack1 = self.invokePartial(partials['./internal/page-header/image.hbs'], './internal/page-header/image.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n          ";
  return buffer;
  }

function program33(depth0,data) {
  
  
  return "\n          </div>\n        </div>\n        ";
  }

  buffer += "<header\n  class=\"\n    glue-page-header\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.navBar), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.countLabel), {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.useResponsiveHeightSmall), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.useResponsiveHeightLarge), {hash:{},inverse:self.noop,fn:self.program(7, program7, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.uri), {hash:{},inverse:self.noop,fn:self.program(9, program9, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n    ";
  if (helper = helpers.modifiers) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.modifiers); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n  \"\n  data-glue-page-header\n  data-ta-id=\"page-header\"\n\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.uri), {hash:{},inverse:self.noop,fn:self.program(11, program11, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n  ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.buttons)),stack1 == null || stack1 === false ? stack1 : stack1.playButton), {hash:{},inverse:self.noop,fn:self.program(13, program13, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.navBar), {hash:{},inverse:self.program(17, program17, data),fn:self.program(15, program15, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n>\n  ";
  stack1 = self.invokePartial(partials['./internal/page-header/background.hbs'], './internal/page-header/background.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n  <div\n    class=\"\n      glue-page-header__content-wrapper\n      container\n    \"\n    data-glue-page-header-content\n  >\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.gridClasses), {hash:{},inverse:self.noop,fn:self.program(19, program19, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n    <div\n      class=\"\n        glue-page-header__content\n        ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.useCustomImageSize), {hash:{},inverse:self.noop,fn:self.program(21, program21, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.buttons)),stack1 == null || stack1 === false ? stack1 : stack1.buttonPlacementLeft), {hash:{},inverse:self.noop,fn:self.program(23, program23, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      \"\n    >\n      <div class=\"glue-page-header__content-inner\">\n        ";
  stack1 = self.invokePartial(partials['./internal/page-header/image.hbs'], './internal/page-header/image.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n        <div class=\"glue-page-header__data\">\n          ";
  stack1 = self.invokePartial(partials['./internal/page-header/label.hbs'], './internal/page-header/label.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n          ";
  stack1 = self.invokePartial(partials['./internal/page-header/title.hbs'], './internal/page-header/title.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n          ";
  stack1 = self.invokePartial(partials['./internal/page-header/description.hbs'], './internal/page-header/description.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n          ";
  stack1 = self.invokePartial(partials['./internal/page-header/meta-info.hbs'], './internal/page-header/meta-info.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n          ";
  stack1 = self.invokePartial(partials['./internal/page-header/buttons.hbs'], './internal/page-header/buttons.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n          ";
  stack1 = self.invokePartial(partials['./internal/page-header/count-label.hbs'], './internal/page-header/count-label.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        </div>\n\n        <div class=\"\n          glue-page-header__spacer\n          ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.useLargeSpacer), {hash:{},inverse:self.noop,fn:self.program(25, program25, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        \">\n        </div>\n      </div>\n\n      ";
  stack1 = self.invokePartial(partials['./internal/page-header/buttons.hbs'], './internal/page-header/buttons.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    </div>\n\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.gridClasses), {hash:{},inverse:self.noop,fn:self.program(27, program27, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n\n  <div\n    class=\"glue-page-header__sticky-wrapper\"\n    data-sticky-fixed-wrapper\n    aria-hidden=\"true\"\n  >\n    <div class=\"glue-page-header__sticky\" data-sticky>\n      <div class=\"container\">\n        ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.gridClasses), {hash:{},inverse:self.noop,fn:self.program(29, program29, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n        <div class=\"glue-page-header__sticky-inner\">\n          ";
  stack1 = helpers.unless.call(depth0, (depth0 && depth0.hideImageInStickyHeader), {hash:{},inverse:self.noop,fn:self.program(31, program31, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n          ";
  stack1 = self.invokePartial(partials['./internal/page-header/title.hbs'], './internal/page-header/title.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n          ";
  stack1 = self.invokePartial(partials['./internal/page-header/buttons.hbs'], './internal/page-header/buttons.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        </div>\n\n        ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.gridClasses), {hash:{},inverse:self.noop,fn:self.program(33, program33, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      </div>\n    </div>\n  </div>\n\n  ";
  stack1 = self.invokePartial(partials['./internal/page-header/navbar.hbs'], './internal/page-header/navbar.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</header>\n";
  return buffer;
  });

},{"./internal/page-header/background.hbs":171,"./internal/page-header/buttons.hbs":172,"./internal/page-header/count-label.hbs":173,"./internal/page-header/description.hbs":174,"./internal/page-header/image.hbs":175,"./internal/page-header/label.hbs":176,"./internal/page-header/meta-info.hbs":177,"./internal/page-header/navbar.hbs":178,"./internal/page-header/title.hbs":179,"hbsfy/runtime":615}],181:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./media/image.hbs');
HandlebarsCompiler.registerPartial('./media/image.hbs', partial$0);
var partial$1 = require('./media/controllers.hbs');
HandlebarsCompiler.registerPartial('./media/controllers.hbs', partial$1);
var partial$2 = require('./media/info.hbs');
HandlebarsCompiler.registerPartial('./media/info.hbs', partial$2);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing, self=this, blockHelperMissing=helpers.blockHelperMissing;

function program1(depth0,data) {
  
  
  return "data-context";
  }

function program3(depth0,data) {
  
  
  return " mo-wide-image-wrapper";
  }

function program5(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <div data-drag-text=\"";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"media-image\" draggable=\"true\">\n      ";
  return buffer;
  }

function program7(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <a data-drag-text=\"";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"media-image\">\n      ";
  return buffer;
  }

function program9(depth0,data) {
  
  
  return "\n        </div>\n      ";
  }

function program11(depth0,data) {
  
  
  return "\n        </a>\n      ";
  }

  buffer += "<div\n  class=\"media-object media-object-"
    + escapeExpression((helper = helpers.type || (depth0 && depth0.type),options={hash:{},data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), options)))
    + " ";
  if (helper = helpers.modifiers) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.modifiers); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n  ";
  options={hash:{},inverse:self.program(1, program1, data),fn:self.noop,data:data}
  if (helper = helpers.noContext) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.noContext); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.noContext) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.program(1, program1, data),fn:self.noop,data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n  data-log-context=\"media-object\"\n  data-log-data='{ \"name\": \"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\", \"target_uri\": \"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" }'\n  data-contextmenu\n  data-ta-id=\"card\"\n>\n  <div class=\"mo-wrapper\">\n    <div\n      class=\"mo-image-wrapper";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.wideImage), {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\"\n      data-contextmenu-spy\n      data-ta-id=\"card-image-wrapper\"\n    >\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.noLink), {hash:{},inverse:self.program(7, program7, data),fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n      ";
  stack1 = self.invokePartial(partials['./media/image.hbs'], './media/image.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      <div class=\"mo-overlay\"></div>\n\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.noLink), {hash:{},inverse:self.program(11, program11, data),fn:self.program(9, program9, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n      ";
  stack1 = self.invokePartial(partials['./media/controllers.hbs'], './media/controllers.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    </div>\n    ";
  stack1 = self.invokePartial(partials['./media/info.hbs'], './media/info.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n</div>\n";
  return buffer;
  });

},{"./media/controllers.hbs":182,"./media/image.hbs":183,"./media/info.hbs":184,"hbsfy/runtime":615}],182:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this, functionType="function", blockHelperMissing=helpers.blockHelperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n  ";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "track", "album", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "track", "album", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(4, program4, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "playlist", "station", "artist", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "playlist", "station", "artist", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "\n    <button type=\"button\" data-button=\"add\" class=\"button button-icon-only button-add mo-add\" data-tooltip=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Save", options) : helperMissing.call(depth0, "loc", "Save", options)))
    + "\" data-tooltip-add=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Save", options) : helperMissing.call(depth0, "loc", "Save", options)))
    + "\" data-tooltip-remove=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Remove", options) : helperMissing.call(depth0, "loc", "Remove", options)))
    + "\" data-log-click=\"add-button\"></button>\n  ";
  return buffer;
  }

function program4(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n    ";
  options={hash:{},inverse:self.program(5, program5, data),fn:self.noop,data:data}
  if (helper = helpers.currentUserPlaylist) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.currentUserPlaylist); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.currentUserPlaylist) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.program(5, program5, data),fn:self.noop,data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }
function program5(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "\n    <button type=\"button\" data-button=\"add\" class=\"button button-icon-only button-add mo-add\" data-tooltip=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Follow", options) : helperMissing.call(depth0, "loc", "Follow", options)))
    + "\" data-tooltip-add=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Follow", options) : helperMissing.call(depth0, "loc", "Follow", options)))
    + "\" data-tooltip-remove=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Unfollow", options) : helperMissing.call(depth0, "loc", "Unfollow", options)))
    + "\" data-log-click=\"follow-button\"></button>\n    ";
  return buffer;
  }

function program7(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n    data-button=\"play\"\n    ";
  options={hash:{},inverse:self.noop,fn:self.program(8, program8, data),data:data}
  if (helper = helpers.range) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.range); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.range) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(8, program8, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }
function program8(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "data-range=\"";
  if (helper = helpers.start) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.start); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + ",";
  if (helper = helpers.end) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.end); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"";
  return buffer;
  }

function program10(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.contextPage), {hash:{},inverse:self.program(14, program14, data),fn:self.program(11, program11, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }
function program11(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n      data-button=\"play\"\n      ";
  options={hash:{},inverse:self.noop,fn:self.program(12, program12, data),data:data}
  if (helper = helpers.contextPage) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.contextPage); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.contextPage) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(12, program12, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  return buffer;
  }
function program12(depth0,data) {
  
  var buffer = "";
  buffer += "data-context-page=\""
    + escapeExpression((typeof depth0 === functionType ? depth0.apply(depth0) : depth0))
    + "\"";
  return buffer;
  }

function program14(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.trackUri), {hash:{},inverse:self.program(18, program18, data),fn:self.program(15, program15, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  return buffer;
  }
function program15(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n        ";
  options={hash:{},inverse:self.noop,fn:self.program(16, program16, data),data:data}
  if (helper = helpers.trackUri) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.trackUri); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.trackUri) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(16, program16, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        data-button=\"play\"\n      ";
  return buffer;
  }
function program16(depth0,data) {
  
  var buffer = "";
  buffer += "data-track-uri=\""
    + escapeExpression((typeof depth0 === functionType ? depth0.apply(depth0) : depth0))
    + "\"";
  return buffer;
  }

function program18(depth0,data) {
  
  
  return "\n        data-button=\"play-context\"\n      ";
  }

function program20(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "data-tooltip=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "HoldToPreview", options) : helperMissing.call(depth0, "loc", "HoldToPreview", options)))
    + "\"";
  return buffer;
  }

function program22(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "\n  <button type=\"button\" data-button=\"contextmenu\" class=\"button button-icon-only button-more mo-more\" data-tooltip=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "More", options) : helperMissing.call(depth0, "loc", "More", options)))
    + "\" data-log-click=\"context-menu-button\"></button>\n";
  return buffer;
  }

function program24(depth0,data) {
  
  
  return "\n<button type=\"button\" class=\"button button-icon-only mo-delete\" data-log-click=\"delete-button\"></button>\n";
  }

  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "playlist", "track", "album", "station", "artist", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "playlist", "track", "album", "station", "artist", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n<button type=\"button\" class=\"button button-play mo-play\" data-log-click=\"play-button\"\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.range), {hash:{},inverse:self.program(10, program10, data),fn:self.program(7, program7, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n  ";
  options={hash:{},inverse:self.noop,fn:self.program(20, program20, data),data:data}
  if (helper = helpers.preview) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.preview); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.preview) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(20, program20, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">\n</button>\n\n";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(22, program22, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "playlist", "track", "album", "artist", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "playlist", "track", "album", "artist", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n";
  options={hash:{},inverse:self.noop,fn:self.program(24, program24, data),data:data}
  if (helper = helpers.canDelete) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.canDelete); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.canDelete) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(24, program24, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"hbsfy/runtime":615}],183:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n  <div class=\"mo-image-background-color\">\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.imageUrl), {hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      <div class=\"mo-image-background\" style=\"background-image: url('";
  if (helper = helpers.imageUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.imageUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "')\"></div>\n    ";
  return buffer;
  }

function program4(depth0,data) {
  
  
  return " mo-wide-image";
  }

function program6(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "style=\"background-image: url('";
  if (helper = helpers.imageUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.imageUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "')\"";
  return buffer;
  }

  buffer += "<svg class=\"mo-placeholder\" viewBox=\"0 0 10 10\" preserveAspectRatio=\"xMidYMid meet\">\n  <text class=\"playlist-placeholder\" x=\"5\" y=\"9.8\">&#xf135;</text>\n  <text class=\"playlist-folder-placeholder\" x=\"5\" y=\"9.8\">&#xf137;</text>\n  <text class=\"album-placeholder\" x=\"5\" y=\"9.8\">&#xf101;</text>\n  <text class=\"artist-placeholder\" x=\"5\" y=\"9.8\">&#xf103;</text>\n  <text class=\"user-placeholder\" x=\"5\" y=\"9.8\">&#xf15d;</text>\n  <text class=\"genre-placeholder\" x=\"5\" y=\"9.8\">&#xf109;</text>\n  <text class=\"collection-placeholder\" x=\"5\" y=\"9.8\">&#xf157;</text>\n  <text class=\"local-files-placeholder\" x=\"5\" y=\"9.8\">&#xf1fb;</text>\n</svg>\n\n";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "user", "artist", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "user", "artist", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n<div\n  class=\"mo-image";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.wideImage), {hash:{},inverse:self.noop,fn:self.program(4, program4, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\"\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.imageUrl), {hash:{},inverse:self.noop,fn:self.program(6, program6, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  data-ta-id=\"card-image\"\n></div>\n<span class=\"mo-verified\">\n  <span class=\"spoticon-check-16\"></span>\n</span>\n";
  return buffer;
  });

},{"hbsfy/runtime":615}],184:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./../facepile-common.hbs');
HandlebarsCompiler.registerPartial('./../facepile-common.hbs', partial$0);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, self=this, blockHelperMissing=helpers.blockHelperMissing;

function program1(depth0,data) {
  
  
  return "meta";
  }

function program3(depth0,data) {
  
  
  return "description";
  }

function program5(depth0,data) {
  
  
  return "socialproof";
  }

function program7(depth0,data) {
  
  
  return "subtitle";
  }

function program9(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      <div class=\"mo-title\" title=\"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"media-title\" draggable=\"true\">\n    ";
  return buffer;
  }

function program11(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      <a class=\"mo-title\" title=\"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"media-title\"\n        data-ta-id=\"card-title-link\">\n    ";
  return buffer;
  }

function program13(depth0,data) {
  
  
  return "\n      </div>\n    ";
  }

function program15(depth0,data) {
  
  
  return "\n      </a>\n    ";
  }

function program17(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n      <div class=\"mo-subtitle text-muted one-line\">\n        ";
  options={hash:{},inverse:self.noop,fn:self.program(18, program18, data),data:data}
  if (helper = helpers.artists) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.artists); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.artists) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(18, program18, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        ";
  options={hash:{},inverse:self.noop,fn:self.program(20, program20, data),data:data}
  if (helper = helpers.owner) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.owner); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.owner) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(20, program20, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      </div>\n    ";
  return buffer;
  }
function program18(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n          <a title=\"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"artist-name\">";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</a>\n        ";
  return buffer;
  }

function program20(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n          <a title=\"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"owner-name\">";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</a>\n        ";
  return buffer;
  }

function program22(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      <div class=\"mo-description\" data-ta-id=\"card-description\">";
  if (helper = helpers.description) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.description); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n    ";
  return buffer;
  }

function program24(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.totalListeners), {hash:{},inverse:self.noop,fn:self.program(25, program25, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  return buffer;
  }
function program25(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n        ";
  stack1 = self.invokePartial(partials['./../facepile-common.hbs'], './../facepile-common.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  return buffer;
  }

function program27(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      <div class=\"mo-meta\" data-ta-id=\"card-metadata\">";
  if (helper = helpers.meta) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.meta); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n    ";
  return buffer;
  }

  buffer += "<div class=\"mo-info ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.meta), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.description), {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.socialproof), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  options={hash:{},inverse:self.program(7, program7, data),fn:self.noop,data:data}
  if (helper = helpers.hideSubtitle) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.hideSubtitle); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.hideSubtitle) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.program(7, program7, data),fn:self.noop,data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" data-log-context=\"media-info\">\n  <div class=\"mo-info-wrapper\">\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.noLink), {hash:{},inverse:self.program(11, program11, data),fn:self.program(9, program9, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        <span class=\"mo-title-border\">\n          ";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n          <span class=\"ellipsis\">&nbsp;</span>\n        </span>\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.noLink), {hash:{},inverse:self.program(15, program15, data),fn:self.program(13, program13, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n    ";
  options={hash:{},inverse:self.program(17, program17, data),fn:self.noop,data:data}
  if (helper = helpers.hideSubtitle) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.hideSubtitle); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.hideSubtitle) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.program(17, program17, data),fn:self.noop,data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.description), {hash:{},inverse:self.noop,fn:self.program(22, program22, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n    ";
  options={hash:{},inverse:self.noop,fn:self.program(24, program24, data),data:data}
  if (helper = helpers.socialproof) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.socialproof); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.socialproof) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(24, program24, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.meta), {hash:{},inverse:self.noop,fn:self.program(27, program27, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    <div class=\"media-link-hider\"></div>\n    ";
  if (helper = helpers.customContent) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.customContent); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n</div>\n";
  return buffer;
  });

},{"./../facepile-common.hbs":165,"hbsfy/runtime":615}],185:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += " data-navbar-item-matcher=\"";
  if (helper = helpers.matcher) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.matcher); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"";
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n  <a href=\"";
  if (helper = helpers.url) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.url); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"";
  if (helper = helpers.id) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.id); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" draggable=\"false\">";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</a>\n  ";
  return buffer;
  }

function program5(depth0,data) {
  
  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.id), {hash:{},inverse:self.program(8, program8, data),fn:self.program(6, program6, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program6(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n  <a data-log-click=\"";
  if (helper = helpers.id) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.id); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" draggable=\"false\">";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</a>\n  ";
  return buffer;
  }

function program8(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n  <p class=\"navbar-text\">";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</p>\n  ";
  return buffer;
  }

  buffer += "<li class=\"";
  if (helper = helpers.className) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.className); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-navbar-item-id=\"";
  if (helper = helpers.id) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.id); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.matcher), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.url), {hash:{},inverse:self.program(5, program5, data),fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</li>\n";
  return buffer;
  });

},{"hbsfy/runtime":615}],186:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./navbar-item.hbs');
HandlebarsCompiler.registerPartial('./navbar-item.hbs', partial$0);
var partial$1 = require('./facepile.hbs');
HandlebarsCompiler.registerPartial('./facepile.hbs', partial$1);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, helper, options, self=this, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, functionType="function", blockHelperMissing=helpers.blockHelperMissing;

function program1(depth0,data) {
  
  
  return "no-overflow-menu";
  }

function program3(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n          ";
  stack1 = self.invokePartial(partials['./navbar-item.hbs'], './navbar-item.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        ";
  return buffer;
  }

function program5(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "\n          <li class=\"overflow-menu-button\" data-navbar-item-id=\"navbar-overflow-menu\">\n            <a>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "More", options) : helperMissing.call(depth0, "loc", "More", options)))
    + "</a>\n          </li>\n        ";
  return buffer;
  }

function program7(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n          ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.facePile)),stack1 == null || stack1 === false ? stack1 : stack1.users), {hash:{},inverse:self.noop,fn:self.program(8, program8, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        ";
  return buffer;
  }
function program8(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n            <div class=\"navbar-right facepile-list-container\">\n              ";
  stack1 = self.invokePartial(partials['./facepile.hbs'], './facepile.hbs', (depth0 && depth0.facePile), helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n            </div>\n          ";
  return buffer;
  }

  buffer += "<div class=\"navbar-fixed-wrapper\" data-sticky-fixed-wrapper>\n  <div class=\"navbar\" data-sticky=\"true\">\n    <div class=\"container\">\n      <ul class=\"nav navbar-nav ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.noOverflowMenu), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\"\n        data-navbar=\"navbar\"\n        data-navbar-history-position=\"";
  if (helper = helpers.historyPosition) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.historyPosition); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n        data-navbar-active-id=\"";
  if (helper = helpers.activeTab) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.activeTab); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n        data-log-context=\"navbar\">\n        ";
  options={hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data}
  if (helper = helpers['nav-items']) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0['nav-items']); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers['nav-items']) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        ";
  stack1 = helpers.unless.call(depth0, (depth0 && depth0.noOverflowMenu), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.facePile), {hash:{},inverse:self.noop,fn:self.program(7, program7, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      </ul>\n    </div>\n  </div>\n</div>\n";
  return buffer;
  });

},{"./facepile.hbs":166,"./navbar-item.hbs":185,"hbsfy/runtime":615}],187:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./media/image.hbs');
HandlebarsCompiler.registerPartial('./media/image.hbs', partial$0);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n  <div class=\"pf-bg\" style=\"background-image:url(";
  if (helper = helpers.imageBackgroundUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.imageBackgroundUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + ")\"></div>\n  ";
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n    <div class=\"pf-media-object media-object media-object-image media-object-"
    + escapeExpression((helper = helpers.type || (depth0 && depth0.type),options={hash:{},data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), options)))
    + " media-object-link ";
  if (helper = helpers.modifiers) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.modifiers); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n      data-ta-id=\"card\">\n      <div class=\"mo-wrapper\">\n        <div class=\"mo-image-wrapper\" data-ta-id=\"card-image-wrapper\">\n          ";
  stack1 = self.invokePartial(partials['./media/image.hbs'], './media/image.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        </div>\n      </div>\n    </div>\n    ";
  return buffer;
  }

function program5(depth0,data) {
  
  
  return " pf-title-with-subtitle";
  }

function program7(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n    <span class=\"pf-subtitle text-muted one-line\">";
  if (helper = helpers.subtitle) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.subtitle); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</span>\n    ";
  return buffer;
  }

  buffer += "<a href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" class=\"puff\" draggable=\"false\" data-log-click=\"puff\">\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.imageBackgroundUrl), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n  <div class=\"pf-images\">\n    ";
  stack1 = helpers.each.call(depth0, (depth0 && depth0.images), {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n\n  <div class=\"pf-info-container\">\n    <span class=\"pf-title one-line ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.subtitle), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" data-ta-id=\"card-title-link\">\n      ";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n    </span>\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.subtitle), {hash:{},inverse:self.noop,fn:self.program(7, program7, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n</a>\n";
  return buffer;
  });

},{"./media/image.hbs":183,"hbsfy/runtime":615}],188:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  
  return "true";
  }

function program3(depth0,data) {
  
  
  return "false";
  }

function program5(depth0,data) {
  
  
  return " enabled";
  }

function program7(depth0,data) {
  
  
  return " disabled";
  }

function program9(depth0,data) {
  
  
  return "aria-disabled=\"true\"";
  }

function program11(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "data-slider=\"";
  if (helper = helpers.id) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.id); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"";
  return buffer;
  }

function program13(depth0,data) {
  
  
  return "data-slider";
  }

function program15(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "aria-labelledby=\"";
  if (helper = helpers.labelId) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.labelId); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"";
  return buffer;
  }

function program17(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"";
  return buffer;
  }

function program19(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "data-slider-property=\"";
  if (helper = helpers.property) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.property); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"";
  return buffer;
  }

function program21(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "data-slider-allowed-property=\"";
  if (helper = helpers.allowedProperty) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.allowedProperty); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"";
  return buffer;
  }

  buffer += "<div\n  tabindex=\"0\"\n  role=\"checkbox\"\n  aria-checked=\"";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.enabled), {hash:{},inverse:self.program(3, program3, data),fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\"\n  class=\"slider";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.enabled), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  stack1 = (helper = helpers.compare || (depth0 && depth0.compare),options={hash:{},inverse:self.noop,fn:self.program(7, program7, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.allowed), false, options) : helperMissing.call(depth0, "compare", (depth0 && depth0.allowed), false, options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\"\n  ";
  stack1 = (helper = helpers.compare || (depth0 && depth0.compare),options={hash:{},inverse:self.noop,fn:self.program(9, program9, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.allowed), false, options) : helperMissing.call(depth0, "compare", (depth0 && depth0.allowed), false, options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.id), {hash:{},inverse:self.program(13, program13, data),fn:self.program(11, program11, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.labelId), {hash:{},inverse:self.noop,fn:self.program(15, program15, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.uri), {hash:{},inverse:self.noop,fn:self.program(17, program17, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.property), {hash:{},inverse:self.noop,fn:self.program(19, program19, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.allowedProperty), {hash:{},inverse:self.noop,fn:self.program(21, program21, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">\n  <div></div>\n</div>\n";
  return buffer;
  });

},{"hbsfy/runtime":615}],189:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./tracklist/row-start.hbs');
HandlebarsCompiler.registerPartial('./tracklist/row-start.hbs', partial$0);
var partial$1 = require('./tracklist/play.hbs');
HandlebarsCompiler.registerPartial('./tracklist/play.hbs', partial$1);
var partial$2 = require('./tracklist/save.hbs');
HandlebarsCompiler.registerPartial('./tracklist/save.hbs', partial$2);
var partial$3 = require('./tracklist/name.hbs');
HandlebarsCompiler.registerPartial('./tracklist/name.hbs', partial$3);
var partial$4 = require('./tracklist/artists.hbs');
HandlebarsCompiler.registerPartial('./tracklist/artists.hbs', partial$4);
var partial$5 = require('./tracklist/album.hbs');
HandlebarsCompiler.registerPartial('./tracklist/album.hbs', partial$5);
var partial$6 = require('./tracklist/local.hbs');
HandlebarsCompiler.registerPartial('./tracklist/local.hbs', partial$6);
var partial$7 = require('./tracklist/more.hbs');
HandlebarsCompiler.registerPartial('./tracklist/more.hbs', partial$7);
var partial$8 = require('./tracklist/time.hbs');
HandlebarsCompiler.registerPartial('./tracklist/time.hbs', partial$8);
var partial$9 = require('./tracklist/popularity.hbs');
HandlebarsCompiler.registerPartial('./tracklist/popularity.hbs', partial$9);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, self=this;


  stack1 = self.invokePartial(partials['./tracklist/row-start.hbs'], './tracklist/row-start.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = self.invokePartial(partials['./tracklist/play.hbs'], './tracklist/play.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = self.invokePartial(partials['./tracklist/save.hbs'], './tracklist/save.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = self.invokePartial(partials['./tracklist/name.hbs'], './tracklist/name.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = self.invokePartial(partials['./tracklist/artists.hbs'], './tracklist/artists.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = self.invokePartial(partials['./tracklist/album.hbs'], './tracklist/album.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = self.invokePartial(partials['./tracklist/local.hbs'], './tracklist/local.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = self.invokePartial(partials['./tracklist/more.hbs'], './tracklist/more.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = self.invokePartial(partials['./tracklist/time.hbs'], './tracklist/time.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = self.invokePartial(partials['./tracklist/popularity.hbs'], './tracklist/popularity.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</tr>\n";
  return buffer;
  });

},{"./tracklist/album.hbs":191,"./tracklist/artists.hbs":192,"./tracklist/local.hbs":204,"./tracklist/more.hbs":205,"./tracklist/name.hbs":206,"./tracklist/play.hbs":207,"./tracklist/popularity.hbs":208,"./tracklist/row-start.hbs":209,"./tracklist/save.hbs":210,"./tracklist/time.hbs":213,"hbsfy/runtime":615}],190:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./tracklist/table-attributes.hbs');
HandlebarsCompiler.registerPartial('./tracklist/table-attributes.hbs', partial$0);
var partial$1 = require('./tracklist/header/play.hbs');
HandlebarsCompiler.registerPartial('./tracklist/header/play.hbs', partial$1);
var partial$2 = require('./tracklist/header/save.hbs');
HandlebarsCompiler.registerPartial('./tracklist/header/save.hbs', partial$2);
var partial$3 = require('./tracklist/header/name.hbs');
HandlebarsCompiler.registerPartial('./tracklist/header/name.hbs', partial$3);
var partial$4 = require('./tracklist/header/premium.hbs');
HandlebarsCompiler.registerPartial('./tracklist/header/premium.hbs', partial$4);
var partial$5 = require('./tracklist/header/explicit.hbs');
HandlebarsCompiler.registerPartial('./tracklist/header/explicit.hbs', partial$5);
var partial$6 = require('./tracklist/header/artists.hbs');
HandlebarsCompiler.registerPartial('./tracklist/header/artists.hbs', partial$6);
var partial$7 = require('./tracklist/header/album.hbs');
HandlebarsCompiler.registerPartial('./tracklist/header/album.hbs', partial$7);
var partial$8 = require('./tracklist/header/local.hbs');
HandlebarsCompiler.registerPartial('./tracklist/header/local.hbs', partial$8);
var partial$9 = require('./tracklist/header/more.hbs');
HandlebarsCompiler.registerPartial('./tracklist/header/more.hbs', partial$9);
var partial$10 = require('./tracklist/header/time.hbs');
HandlebarsCompiler.registerPartial('./tracklist/header/time.hbs', partial$10);
var partial$11 = require('./tracklist/header/popularity.hbs');
HandlebarsCompiler.registerPartial('./tracklist/header/popularity.hbs', partial$11);
var partial$12 = require('./tracklist/table-body-attributes.hbs');
HandlebarsCompiler.registerPartial('./tracklist/table-body-attributes.hbs', partial$12);
var partial$13 = require('./tracklist-search-row.hbs');
HandlebarsCompiler.registerPartial('./tracklist-search-row.hbs', partial$13);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, helper, options, self=this, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n      ";
  stack1 = self.invokePartial(partials['./tracklist-search-row.hbs'], './tracklist-search-row.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  return buffer;
  }

  buffer += "<table class=\"tracklist-search ";
  if (helper = helpers.modifiers) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.modifiers); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" ";
  stack1 = self.invokePartial(partials['./tracklist/table-attributes.hbs'], './tracklist/table-attributes.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">\n  <thead class=\"tl-header\">\n    <tr>\n      ";
  stack1 = self.invokePartial(partials['./tracklist/header/play.hbs'], './tracklist/header/play.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = self.invokePartial(partials['./tracklist/header/save.hbs'], './tracklist/header/save.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = self.invokePartial(partials['./tracklist/header/name.hbs'], './tracklist/header/name.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = self.invokePartial(partials['./tracklist/header/premium.hbs'], './tracklist/header/premium.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = self.invokePartial(partials['./tracklist/header/explicit.hbs'], './tracklist/header/explicit.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = self.invokePartial(partials['./tracklist/header/artists.hbs'], './tracklist/header/artists.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = self.invokePartial(partials['./tracklist/header/album.hbs'], './tracklist/header/album.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = self.invokePartial(partials['./tracklist/header/local.hbs'], './tracklist/header/local.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = self.invokePartial(partials['./tracklist/header/more.hbs'], './tracklist/header/more.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = self.invokePartial(partials['./tracklist/header/time.hbs'], './tracklist/header/time.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = self.invokePartial(partials['./tracklist/header/popularity.hbs'], './tracklist/header/popularity.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    </tr>\n  </thead>\n  <tbody ";
  stack1 = self.invokePartial(partials['./tracklist/table-body-attributes.hbs'], './tracklist/table-body-attributes.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">\n    ";
  stack1 = (helper = helpers.list || (depth0 && depth0.list),options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.rows), options) : helperMissing.call(depth0, "list", (depth0 && depth0.rows), options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </tbody>\n</table>\n";
  return buffer;
  });

},{"./tracklist-search-row.hbs":189,"./tracklist/header/album.hbs":193,"./tracklist/header/artists.hbs":194,"./tracklist/header/explicit.hbs":195,"./tracklist/header/local.hbs":196,"./tracklist/header/more.hbs":197,"./tracklist/header/name.hbs":198,"./tracklist/header/play.hbs":199,"./tracklist/header/popularity.hbs":200,"./tracklist/header/premium.hbs":201,"./tracklist/header/save.hbs":202,"./tracklist/header/time.hbs":203,"./tracklist/table-attributes.hbs":211,"./tracklist/table-body-attributes.hbs":212,"hbsfy/runtime":615}],191:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this, blockHelperMissing=helpers.blockHelperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.local), {hash:{},inverse:self.program(4, program4, data),fn:self.program(2, program2, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      ";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n    ";
  return buffer;
  }

function program4(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.uri), {hash:{},inverse:self.program(7, program7, data),fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  return buffer;
  }
function program5(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <a title=\"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"album-name\">";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</a>\n      ";
  return buffer;
  }

function program7(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        ";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n      ";
  return buffer;
  }

  buffer += "<td class=\"tl-cell tl-albums\" data-log-context=\"album-cell\">\n  ";
  stack1 = ((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.album)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1)),blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data}));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</td>\n";
  return buffer;
  });

},{"hbsfy/runtime":615}],192:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var stack1;
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.local), {hash:{},inverse:self.program(4, program4, data),fn:self.program(2, program2, data),data:data});
  if(stack1 || stack1 === 0) { return stack1; }
  else { return ''; }
  }
function program2(depth0,data) {
  
  var stack1, helper;
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  return escapeExpression(stack1);
  }

function program4(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "<a title=\"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"artist-name\">";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</a>";
  return buffer;
  }

  buffer += "<td class=\"tl-cell tl-artists\" data-log-context=\"artist-cell\">\n  ";
  stack1 = (helper = helpers.slice || (depth0 && depth0.slice),options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data},helper ? helper.call(depth0, ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.artists), ", ", options) : helperMissing.call(depth0, "slice", ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.artists), ", ", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</td>\n";
  return buffer;
  });

},{"hbsfy/runtime":615}],193:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, self=this, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n  tl-sort-\n  ";
  stack1 = (helper = helpers.compare || (depth0 && depth0.compare),options={hash:{},inverse:self.program(4, program4, data),fn:self.program(2, program2, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.sortDirection), "asc", options) : helperMissing.call(depth0, "compare", (depth0 && depth0.sortDirection), "asc", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  }
function program2(depth0,data) {
  
  
  return "\n    asc\n  ";
  }

function program4(depth0,data) {
  
  
  return "\n    desc\n  ";
  }

function program6(depth0,data) {
  
  
  return "data-sort=\"track(album(name),disc,number)\"";
  }

  buffer += "<th class=\"tl-albums\n";
  stack1 = (helper = helpers.compare || (depth0 && depth0.compare),options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data},helper ? helper.call(depth0, "track(album(name),disc,number)", (depth0 && depth0.sortQuery), options) : helperMissing.call(depth0, "compare", "track(album(name),disc,number)", (depth0 && depth0.sortQuery), options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.sortable), {hash:{},inverse:self.noop,fn:self.program(6, program6, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Album", options) : helperMissing.call(depth0, "loc", "Album", options)))
    + "</th>\n";
  return buffer;
  });

},{"hbsfy/runtime":615}],194:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, self=this, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n  tl-sort-\n  ";
  stack1 = (helper = helpers.compare || (depth0 && depth0.compare),options={hash:{},inverse:self.program(4, program4, data),fn:self.program(2, program2, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.sortDirection), "asc", options) : helperMissing.call(depth0, "compare", (depth0 && depth0.sortDirection), "asc", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  }
function program2(depth0,data) {
  
  
  return "\n    asc\n  ";
  }

function program4(depth0,data) {
  
  
  return "\n    desc\n  ";
  }

function program6(depth0,data) {
  
  
  return "data-sort=\"track(artists[0:1](name),album(name),disc,number)\"";
  }

  buffer += "<th class=\"tl-artists\n";
  stack1 = (helper = helpers.compare || (depth0 && depth0.compare),options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data},helper ? helper.call(depth0, "track(artists[0:1](name),album(name),disc,number)", (depth0 && depth0.sortQuery), options) : helperMissing.call(depth0, "compare", "track(artists[0:1](name),album(name),disc,number)", (depth0 && depth0.sortQuery), options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.sortable), {hash:{},inverse:self.noop,fn:self.program(6, program6, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Artist", options) : helperMissing.call(depth0, "loc", "Artist", options)))
    + "</th>\n";
  return buffer;
  });

},{"hbsfy/runtime":615}],195:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, self=this;

function program1(depth0,data) {
  
  
  return "data-sort-previous";
  }

  buffer += "<th class=\"tl-explicit\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.sortable), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "></th>\n";
  return buffer;
  });

},{"hbsfy/runtime":615}],196:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, self=this;

function program1(depth0,data) {
  
  
  return "data-sort-previous";
  }

  buffer += "<th class=\"tl-local\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.sortable), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "></th>";
  return buffer;
  });

},{"hbsfy/runtime":615}],197:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, self=this;

function program1(depth0,data) {
  
  
  return "data-sort-previous";
  }

  buffer += "<th class=\"tl-more\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.sortable), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "></th>\r";
  return buffer;
  });

},{"hbsfy/runtime":615}],198:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, self=this, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n  tl-sort-\n  ";
  stack1 = (helper = helpers.compare || (depth0 && depth0.compare),options={hash:{},inverse:self.program(4, program4, data),fn:self.program(2, program2, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.sortDirection), "asc", options) : helperMissing.call(depth0, "compare", (depth0 && depth0.sortDirection), "asc", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  }
function program2(depth0,data) {
  
  
  return "\n    asc\n  ";
  }

function program4(depth0,data) {
  
  
  return "\n    desc\n  ";
  }

function program6(depth0,data) {
  
  
  return "data-sort=\"track(name)\"";
  }

  buffer += "<th class=\"tl-name\n";
  stack1 = (helper = helpers.compare || (depth0 && depth0.compare),options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data},helper ? helper.call(depth0, "track(name)", (depth0 && depth0.sortQuery), options) : helperMissing.call(depth0, "compare", "track(name)", (depth0 && depth0.sortQuery), options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.sortable), {hash:{},inverse:self.noop,fn:self.program(6, program6, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Song", options) : helperMissing.call(depth0, "loc", "Song", options)))
    + "</th>\n";
  return buffer;
  });

},{"hbsfy/runtime":615}],199:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  


  return "<th class=\"tl-play\"></th>\n";
  });

},{"hbsfy/runtime":615}],200:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  


  return "<th class=\"tl-popularity\"></th>\n";
  });

},{"hbsfy/runtime":615}],201:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, self=this;

function program1(depth0,data) {
  
  
  return "data-sort-previous";
  }

  buffer += "<th class=\"tl-premium\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.sortable), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "></th>\n";
  return buffer;
  });

},{"hbsfy/runtime":615}],202:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  


  return "<th class=\"tl-save\"></th>\n";
  });

},{"hbsfy/runtime":615}],203:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n  tl-sort-\n  ";
  stack1 = (helper = helpers.compare || (depth0 && depth0.compare),options={hash:{},inverse:self.program(4, program4, data),fn:self.program(2, program2, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.sortDirection), "asc", options) : helperMissing.call(depth0, "compare", (depth0 && depth0.sortDirection), "asc", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  }
function program2(depth0,data) {
  
  
  return "\n    asc\n  ";
  }

function program4(depth0,data) {
  
  
  return "\n    desc\n  ";
  }

function program6(depth0,data) {
  
  
  return "data-sort=\"track(duration)\"";
  }

  buffer += "<th class=\"tl-time\n";
  stack1 = (helper = helpers.compare || (depth0 && depth0.compare),options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data},helper ? helper.call(depth0, "track(duration)", (depth0 && depth0.sortQuery), options) : helperMissing.call(depth0, "compare", "track(duration)", (depth0 && depth0.sortQuery), options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.sortable), {hash:{},inverse:self.noop,fn:self.program(6, program6, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "></th>\n";
  return buffer;
  });

},{"hbsfy/runtime":615}],204:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "\n  <span class=\"tl-item-local spoticon-localfile-16\" data-tooltip=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "LocalFile", options) : helperMissing.call(depth0, "loc", "LocalFile", options)))
    + "\"></span>\n  ";
  return buffer;
  }

  buffer += "<td class=\"tl-cell tl-local\">\n  ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.local), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</td>\n";
  return buffer;
  });

},{"hbsfy/runtime":615}],205:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, functionType="function";


  buffer += "<td class=\"tl-cell tl-more\">\n  <button\n    type=\"button\"\n    data-button=\"contextmenu\"\n    class=\"button button-icon-only button-more\"\n    data-tooltip=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "More", options) : helperMissing.call(depth0, "loc", "More", options)))
    + "\"\n    data-log-click=\"more-button\"\n    data-log-data='{ \"index\": "
    + escapeExpression(((stack1 = (data == null || data === false ? data : data.index)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + ", \"target_uri\": \"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" }'></button>\n</td>\n";
  return buffer;
  });

},{"hbsfy/runtime":615}],206:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, self=this, functionType="function", blockHelperMissing=helpers.blockHelperMissing, escapeExpression=this.escapeExpression;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n  ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.premium), {hash:{},inverse:self.program(4, program4, data),fn:self.program(2, program2, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  }
function program2(depth0,data) {
  
  
  return "\n    <td class=\"tl-cell tl-name\" colspan=\"1\" data-log-context=\"name-cell\">\n  ";
  }

function program4(depth0,data) {
  
  
  return "\n    <td class=\"tl-cell tl-name\" colspan=\"2\" data-log-context=\"name-cell\">\n  ";
  }

function program6(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n  ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.premium), {hash:{},inverse:self.program(7, program7, data),fn:self.program(4, program4, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  }
function program7(depth0,data) {
  
  
  return "\n    <td class=\"tl-cell tl-name\" colspan=\"3\" data-log-context=\"name-cell\">\n  ";
  }

function program9(depth0,data) {
  
  
  return "tl-item-new";
  }

function program11(depth0,data) {
  
  
  return "</td><td class=\"tl-cell tl-premium\"><span class=\"label\" data-log-click=\"premium\">PREMIUM</span>";
  }

function program13(depth0,data) {
  
  
  return "</td><td class=\"tl-cell tl-explicit\"><span class=\"label\" data-log-click=\"explicit\">EXPLICIT</span>";
  }

  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.explicit), {hash:{},inverse:self.program(6, program6, data),fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n<div class=\"tl-highlight ";
  options={hash:{},inverse:self.noop,fn:self.program(9, program9, data),data:data}
  if (helper = helpers['new']) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0['new']); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers['new']) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(9, program9, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" data-log-click=\"name\">\n  "
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.name)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\n</div>\n";
  stack1 = ((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.premium)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1)),blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(11, program11, data),data:data}));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  stack1 = ((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.explicit)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1)),blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(13, program13, data),data:data}));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</td>\n";
  return buffer;
  });

},{"hbsfy/runtime":615}],207:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  


  return "<td class=\"tl-cell tl-play\">\n  <button\n    type=\"button\"\n    data-button=\"play\"\n    class=\"button button-icon-with-stroke button-play\"\n    data-log-click=\"play-button\"></button>\n</td>\n";
  });

},{"hbsfy/runtime":615}],208:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this, functionType="function";

function program1(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += " data-tooltip=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "ListenCount", ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.listenCount), options) : helperMissing.call(depth0, "loc", "ListenCount", ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.listenCount), options)))
    + "\" data-tooltip-instant";
  return buffer;
  }

  buffer += "<td class=\"tl-cell tl-popularity\"";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.listenCount), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">\n  <div class=\"pop-meter\">\n    <div class=\"pop-meter-background\"></div>\n    <div class=\"pop-meter-overlay\" style=\"width: "
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.popularity)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "%\"></div>\n  </div>\n</td>\n";
  return buffer;
  });

},{"hbsfy/runtime":615}],209:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var stack1, helper;
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  return escapeExpression(stack1);
  }

function program3(depth0,data) {
  
  var stack1, helper;
  if (helper = helpers.index) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.index); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  return escapeExpression(stack1);
  }

function program5(depth0,data) {
  
  var stack1;
  return escapeExpression(((stack1 = (data == null || data === false ? data : data.index)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1));
  }

function program7(depth0,data) {
  
  var stack1, helper;
  if (helper = helpers.contextIndex) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.contextIndex); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  return escapeExpression(stack1);
  }

function program9(depth0,data) {
  
  var stack1;
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.index), {hash:{},inverse:self.program(5, program5, data),fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { return stack1; }
  else { return ''; }
  }

function program11(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "data-uid=\"";
  if (helper = helpers.uid) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uid); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"";
  return buffer;
  }

function program13(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n        ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.offlineProgress), {hash:{},inverse:self.program(19, program19, data),fn:self.program(14, program14, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  return buffer;
  }
function program14(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n          ";
  stack1 = (helper = helpers.compare || (depth0 && depth0.compare),options={hash:{},inverse:self.program(17, program17, data),fn:self.program(15, program15, data),data:data},helper ? helper.call(depth0, ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.offlineProgress), 1, options) : helperMissing.call(depth0, "compare", ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.offlineProgress), 1, options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        ";
  return buffer;
  }
function program15(depth0,data) {
  
  
  return "\n            offline-downloaded\n          ";
  }

function program17(depth0,data) {
  
  
  return "\n            offline-downloading\n          ";
  }

function program19(depth0,data) {
  
  
  return "\n          offline-waiting\n        ";
  }

function program21(depth0,data) {
  
  
  return "playing";
  }

function program23(depth0,data) {
  
  
  return "selected";
  }

function program25(depth0,data) {
  
  
  return "added";
  }

function program27(depth0,data) {
  
  
  return "unavailable";
  }

function program29(depth0,data) {
  
  
  return "local";
  }

function program31(depth0,data) {
  
  
  return "local-file-available";
  }

function program33(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "thumbs-";
  if (helper = helpers.thumb) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.thumb); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1);
  return buffer;
  }

function program35(depth0,data) {
  
  
  return "thumbs-none";
  }

function program37(depth0,data) {
  
  
  return "tl-row--episode";
  }

  buffer += "<tr tabindex=\"0\"\n    aria-label=\""
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.name)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " "
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "By", options) : helperMissing.call(depth0, "loc", "By", options)))
    + " ";
  stack1 = (helper = helpers.slice || (depth0 && depth0.slice),options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data},helper ? helper.call(depth0, ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.artists), ", ", options) : helperMissing.call(depth0, "slice", ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.artists), ", ", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ". "
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "PressEnterToPlay", options) : helperMissing.call(depth0, "loc", "PressEnterToPlay", options)))
    + ".\"\n    data-list-item=\"true\" data-uri=\""
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.uri)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\"\n    data-index=\"";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.index), {hash:{},inverse:self.program(5, program5, data),fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\"\n    data-context-index=\"";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.contextIndex), {hash:{},inverse:self.program(9, program9, data),fn:self.program(7, program7, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\"\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.uid), {hash:{},inverse:self.noop,fn:self.program(11, program11, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    data-scroll-page-item=\"";
  if (helper = helpers.scrollPageItem) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.scrollPageItem); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" draggable=\"true\"\n    data-log-data='{\n      \"index\": ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.index), {hash:{},inverse:self.program(5, program5, data),fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ",\n      \"target_uri\": \""
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.uri)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\",\n      \"name\": \""
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.name)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\"\n    }'\n    data-contextmenu-spy\n    class=\"tl-row\n      ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.shouldBeOffline), {hash:{},inverse:self.noop,fn:self.program(13, program13, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.playing), {hash:{},inverse:self.noop,fn:self.program(21, program21, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.selected), {hash:{},inverse:self.noop,fn:self.program(23, program23, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.added), {hash:{},inverse:self.noop,fn:self.program(25, program25, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.unavailable), {hash:{},inverse:self.noop,fn:self.program(27, program27, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.local), {hash:{},inverse:self.noop,fn:self.program(29, program29, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.localFileAvailable), {hash:{},inverse:self.noop,fn:self.program(31, program31, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.thumb), {hash:{},inverse:self.program(35, program35, data),fn:self.program(33, program33, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.isEpisode), {hash:{},inverse:self.noop,fn:self.program(37, program37, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    \"\n    data-contextmenu>\n";
  return buffer;
  });

},{"hbsfy/runtime":615}],210:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;


  buffer += "<td class=\"tl-cell tl-save\">\n  <button type=\"button\" data-button=\"add\"\n    class=\"button button-icon-only button-add\"\n    data-tooltip=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "SaveYourMusic", options) : helperMissing.call(depth0, "loc", "SaveYourMusic", options)))
    + "\"\n    data-tooltip-add=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "SaveYourMusic", options) : helperMissing.call(depth0, "loc", "SaveYourMusic", options)))
    + "\"\n    data-tooltip-remove=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "RemoveYourMusic", options) : helperMissing.call(depth0, "loc", "RemoveYourMusic", options)))
    + "\"\n    data-log-click=\"save-button\"></button>\n</td>\n";
  return buffer;
  });

},{"hbsfy/runtime":615}],211:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, self=this, blockHelperMissing=helpers.blockHelperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\ndata-insert=\"";
  if (helper = helpers.insertTracks) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.insertTracks); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\ndata-remove=\"";
  if (helper = helpers.removeTracks) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.removeTracks); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n";
  return buffer;
  }

function program3(depth0,data) {
  
  
  return "\ndata-context=\"true\"\n";
  }

function program5(depth0,data) {
  
  
  return "\ndata-list-quick-jump=\"true\"\n";
  }

  buffer += "data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\ndata-list=\"true\"\n";
  options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data}
  if (helper = helpers.allows) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.allows); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.allows) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  options={hash:{},inverse:self.program(3, program3, data),fn:self.noop,data:data}
  if (helper = helpers.noContext) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.noContext); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.noContext) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.program(3, program3, data),fn:self.noop,data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.quickJump), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"hbsfy/runtime":615}],212:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  


  return "data-list-items=\"true\"\ndata-scroll-container\n";
  });

},{"hbsfy/runtime":615}],213:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;


  buffer += "<td class=\"tl-cell tl-time\" data-log-context=\"time-cell\">\n  <span data-log-click=\"duration\">"
    + escapeExpression((helper = helpers.duration || (depth0 && depth0.duration),options={hash:{},data:data},helper ? helper.call(depth0, ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.duration), options) : helperMissing.call(depth0, "duration", ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.duration), options)))
    + "</span>\n</td>\n";
  return buffer;
  });

},{"hbsfy/runtime":615}],214:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.messageProxy = messageProxy;

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

var _uris = require('./uris.json');

var _uris2 = _interopRequireDefault(_uris);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * This module is to be included in zlink
 */

var METHODS = ['POST', 'SUB', 'GET', 'REPLY'];
var BASE_URI = 'message-proxy';
var debug = (0, _debug2.default)('message-proxy');

function messageProxy(requestObj, callback) {
  if (typeof window === 'undefined' || !window.top || !window.top.postMessage) {
    return false;
  }

  var uri = requestObj.uri;

  // Validate Request
  if (!requestObj) throw new Error('Need a request object.');
  if (METHODS.indexOf(requestObj.method) === -1) {
    throw new Error('Need a valid method:', METHODS);
  }
  if (!callback && !requestObj.method === 'POST') {
    throw new Error('Callback needed');
  }
  if (!_uris2.default.hasOwnProperty(uri)) {
    throw new Error('Uri need to be one of these: ', Object.keys(_uris2.default));
  }

  var data = {};
  var requiredKeys = _uris2.default[uri][requestObj.method] || [];

  // GET
  if (requestObj.method === 'GET') {
    var _ret = function () {
      requiredKeys.forEach(function (requiredKey) {
        if (!requestObj.body.hasOwnProperty(requiredKey)) {
          throw new Error('Uri \'GET\' request body missing\n                        a required key: ' + requiredKey);
        }
        data[requiredKey] = requestObj.body[requiredKey];
      });

      var getListener = function getListener(event) {
        if (!isEventValid(event, BASE_URI + '-' + uri + '-reply')) {
          return;
        }
        debug('getListener', uri, event.data);
        if (event.data.error) {
          callback(event.data.error);
        } else {
          delete event.data.uri;
          callback(null, event.data);
        }
        window.removeEventListener('message', getListener);
      };
      window.addEventListener('message', getListener);

      data.uri = BASE_URI + '-' + uri + '-get';
      debug('get', uri, data);
      var messagePosted = postMessageToFrame(requestObj.target, data);
      if (!messagePosted) {
        window.removeEventListener('message', getListener);
        callback('No frame found to post to.');
      }
      return {
        v: true
      };
    }();

    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
  }

  // REPLY
  if (requestObj.method === 'REPLY') {
    var _ret2 = function () {
      var replyListener = function replyListener(event) {
        if (!isEventValid(event, BASE_URI + '-' + uri + '-get')) {
          return;
        }
        debug('reply listener', uri, event.data);
        delete event.data.uri;
        callback(event.data, function reply(replyErr, rawData) {
          var replyData = {};
          if (replyErr) {
            replyData.error = replyErr;
          } else {
            requiredKeys.forEach(function (requiredKey) {
              if (!rawData.hasOwnProperty(requiredKey)) {
                throw new Error('Reply data missing\n                              a required key: ' + requiredKey);
              }
              replyData[requiredKey] = rawData[requiredKey];
            });
          }
          replyData.uri = BASE_URI + '-' + uri + '-reply';
          debug('reply post', uri, replyData);
          event.source.postMessage(replyData, event.origin);
        });
      };
      window.addEventListener('message', replyListener, false);

      return {
        v: function v() {
          window.removeEventListener('message', replyListener);
        }
      };
    }();

    if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === "object") return _ret2.v;
  }

  // POST
  if (requestObj.method === 'POST') {
    requiredKeys.forEach(function (requiredKey) {
      if (!requestObj.body.hasOwnProperty(requiredKey)) {
        throw new Error('Uri \'POST\' request body missing\n                        a required key: ' + requiredKey);
      }
      data[requiredKey] = requestObj.body[requiredKey];
    });

    data.uri = BASE_URI + '-' + uri;
    debug('post', uri, data);
    var _messagePosted = postMessageToFrame(requestObj.target, data);
    if (callback) {
      if (!_messagePosted) {
        callback('No frame found to post to.');
      } else {
        callback(null);
      }
    }
    return true;
  }
  // Subscription
  var sub = function sub(event) {
    if (!isEventValid(event, BASE_URI + '-' + uri)) {
      return;
    }
    debug('subscription event', uri, event.data);
    delete event.data.uri;
    callback(event.data);
  };

  debug('subscription', uri);
  window.addEventListener('message', sub, false);
  return function () {
    window.removeEventListener('message', sub);
  };
}

var originRegex = new RegExp('^https?:\/\/[a-zA-Z-]*.app.spotify.com');

function isEventValid(event, uri) {
  if (!originRegex.test(event.origin)) {
    return false;
  }
  if (event.data.uri !== uri) {
    return false;
  }
  return true;
}

function postMessageToFrame(target, data) {
  if (target === 'top' || !target) {
    debug('postMessageToFrame target=top data=%o', data);
    window.top.postMessage(data, '*');
    // no need to continue
    if (target === 'top') {
      return true;
    }
  }
  var frames = void 0;
  var frameFound = void 0;
  if (window === window.top) {
    frames = window.top.frames;
  } else {
    var topFrames = Array.prototype.slice.call(window.top.frames, 0, window.top.frames.length);
    var thisFrames = Array.prototype.slice.call(window.frames, 0, window.frames.length);
    frames = topFrames.concat(thisFrames);
  }

  var len = frames.length;
  for (var i = 0; i < len; i++) {
    if (target && target !== frames[i].frameElement.src) {
      continue;
    }
    debug('postMessageToFrame target=%o data=%o', frames[i].frameElement.target, data);
    frames[i].postMessage(data, '*');
    frameFound = true;
  }

  debug('postMessageToFrame framesLength=%o frameFound=%o', len, frameFound);
  return frameFound;
}

},{"./uris.json":215,"debug":582}],215:[function(require,module,exports){
module.exports={
  "unit-test": {
    "GET": ["key1"],
    "POST": ["key2"],
    "REPLY": ["key3"]
  },
  "history": {
    "GET": ["count"],
    "REPLY": ["history"]
  },
  "hpto": {
    "REPLY": ["ad"],
    "GET": []
  },
  "hpto-refresh": {
    "SUB": [],
    "POST": []
  },
  "station": {
    "GET": ["stationUri", "metadata", "trackCount"],
    "REPLY": ["stationUri", "station"]
  },
  "station-add": {
    "POST": ["stationUri", "add"]
  },
  "station-autoplay": {
    "POST": ["contextUri", "playerPlaybackId", "prevTracks", "stationUri"],
    "SUB": []
  },
  "station-create": {
    "POST": ["stationUri"],
    "SUB": []
  },
  "station-error": {
    "POST": ["stationUri", "message"],
    "SUB": []
  },
  "station-metadata": {
    "POST": ["stationUri", "metadata"]
  },
  "station-last-played": {
    "POST": ["stationUri"]
  },
  "station-thumb": {
    "POST": ["stationUri", "trackUri", "thumb"]
  },
  "station-heart": {
    "POST": ["stationUri", "trackUri"]
  },
  "stations-all": {
    "GET": [],
    "REPLY": ["user_stations", "genre_stations", "recommended_stations"]
  },
  "stations-saved": {
    "GET": [],
    "REPLY": ["saved_stations"]
  }
}

},{}],216:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.subscribeToMetadata = exports.fetchPlaylistMetadata = exports.offlineSyncPlaylist = exports.logAddToPlaylist = exports.setPlaylistPublished = exports.createNewPlaylist = exports.addTracksToPlaylist = exports.OfflineStatus = undefined;
exports.addAlbumToPlaylist = addAlbumToPlaylist;
exports.addStationToPlaylist = addStationToPlaylist;
exports.addStuffToPlaylist = addStuffToPlaylist;
exports.createRefreshedPlaylist = createRefreshedPlaylist;
exports.setPlaylistCollaborative = setPlaylistCollaborative;
exports.shouldPlaylistBeOffline = shouldPlaylistBeOffline;
exports.getPlaylist2ShowsCell = getPlaylist2ShowsCell;

var _playlistActions = require('./playlist-actions');

var _playlistData = require('./playlist-data');

var _offlineStatus = require('./offline-status');

var OfflineStatus = _interopRequireWildcard(_offlineStatus);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var URI = require('spotify-liburi');

var bridge = require('../../libs/spotify-bridge-request');
var live = require('../../libs/spotify-live');

exports.OfflineStatus = OfflineStatus;
exports.addTracksToPlaylist = _playlistActions.addTracksToPlaylist;
exports.createNewPlaylist = _playlistActions.createNewPlaylist;
exports.setPlaylistPublished = _playlistActions.setPlaylistPublished;
exports.logAddToPlaylist = _playlistActions.logAddToPlaylist;
exports.offlineSyncPlaylist = _playlistActions.offlineSyncPlaylist;
exports.fetchPlaylistMetadata = _playlistData.fetchPlaylistMetadata;
exports.subscribeToMetadata = _playlistData.subscribeToMetadata;
// Work around transpiler non-sense

exports.getCollaborativeStatus = _playlistData.getCollaborativeStatus;

function addAlbumToPlaylist(playlistUri, albumUri, cb) {
  var args = [albumUri.toString(), 0, -1];

  return bridge.request('album_tracks_snapshot', args, function (err, resp) {
    if (err) {
      cb(err);
      return;
    }
    (0, _playlistActions.addTracksToPlaylist)(playlistUri, resp.array, cb);
  });
}

function addStationToPlaylist(playlistUri, stationURI, cb) {
  live(stationURI.toString()).query('rows(track(uri))', function (err, data) {
    if (err) {
      cb(err);
      return;
    }
    var trackURIs = data.rows.map(function (radioTrack) {
      return radioTrack.track.uri;
    });
    (0, _playlistActions.addTracksToPlaylist)(playlistUri, trackURIs, cb);
  });
}

function addStuffToPlaylist(playlistUri, uris, cb) {
  if (uris[0].type === URI.Type.ALBUM) {
    addAlbumToPlaylist(playlistUri, uris[0], cb);
    if (uris.length > 1) {
      console.warn('Passed more than a single album to addStuffToPlaylist(). Adding only one.');
    }
  } else if (uris[0].type === URI.Type.STATION) {
    addStationToPlaylist(playlistUri, uris[0], cb);
  } else {
    var urisStr = uris.map(function (uri) {
      return uri.toString();
    });
    (0, _playlistActions.addTracksToPlaylist)(playlistUri, urisStr, cb);
  }
}

function fetchPlaylistName(playlistUri, cb) {
  var policy = {
    name: true
  };
  (0, _playlistData.fetchPlaylistMetadata)(playlistUri, policy, function (error, data) {
    if (data && data.name) {
      cb(error, data.name);
      return;
    }
    cb(error);
  });
}

function createRefreshedPlaylist(playlistUri, cb) {
  fetchPlaylistName(playlistUri, function (nameError, oldName) {
    if (nameError) {
      cb(nameError);
      return;
    }
    var name = (0, _playlistActions.refreshedPlaylistName)(oldName);

    bridge.cosmosJSON({
      method: 'POST',
      uri: 'hm://playlistfreshener/freshen',
      body: {
        playlistURI: playlistUri.toString(),
        type: 'W2V_freshener'
      }
    }, function (error, body) {
      if (error) {
        cb(error);
        return;
      }

      var trackUris = body.recommendedTracks.map(function (r) {
        return 'spotify:track:' + r.id;
      });

      (0, _playlistActions.createNewPlaylist)(name, function (createNewPlaylistError, newPlaylistUri) {
        if (createNewPlaylistError) {
          cb(createNewPlaylistError);
          return;
        }

        var trackStrs = trackUris.map(function (trackUri) {
          return trackUri.toString();
        });
        (0, _playlistActions.addTracksToPlaylist)(newPlaylistUri, trackStrs, function (addTracksToPlaylistError) {
          cb(addTracksToPlaylistError, newPlaylistUri);
        });
      });
    });
  });
}

function setPlaylistCollaborative(uri, collaborative, cb) {
  bridge.request('playlist_set_collaborative', [uri.toString(), collaborative], function (err) {
    if (err) {
      cb(err);
      return;
    }
    if (collaborative) {
      // when we set a playlist as collaborative, check if
      // it's public and make it private
      (0, _playlistData.getCollaborativeStatus)(uri, function (error, data) {
        if (error || data.published === null) {
          cb(error || new Error('`published` property unexpectedly missing'));
          return;
        }

        if (data.published) {
          (0, _playlistActions.setPlaylistPublished)(uri, false, cb);
          return;
        }
        cb();
      });
    } else {
      cb();
    }
  });
}

function shouldPlaylistBeOffline(uri, cb) {
  var policy = {
    offline: true
  };
  (0, _playlistData.fetchPlaylistMetadata)(uri, policy, function (error, data) {
    if (data && data.offline) {
      var shouldBeOffline = OfflineStatus.shouldBeOffline(data.offline);
      cb(error, shouldBeOffline);
      return;
    }
    cb(error, data);
  });
}

// A synchronous way to "fetch" the playlist2shows ABBA flag.
function getPlaylist2ShowsCell() {
  // initialState.playlist2ShowsCell is initialized on
  // apps/script/zlink/pre-init.js.
  var initialState = window.initialState || window.top.initialState || {};
  return initialState.playlist2ShowsCell || null;
}

},{"../../libs/spotify-bridge-request":225,"../../libs/spotify-live":512,"./offline-status":217,"./playlist-actions":218,"./playlist-data":219,"spotify-liburi":899}],217:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.YES = exports.DOWNLOADING = exports.WAITING_SYNC_NOT_ALLOWED = exports.WAITING_NO_CONNECTION = exports.WAITING_OFFLINE_MODE = exports.WAITING = exports.NO = undefined;
exports.isDownloading = isDownloading;
exports.shouldBeOffline = shouldBeOffline;
exports.progressFromStatus = progressFromStatus;
exports.getLabelForStatus = getLabelForStatus;
exports.sendUserMessageForStatus = sendUserMessageForStatus;

var _spotifyBridgeRequest = require('../../libs/spotify-bridge-request');

var _spotifyBridgeRequest2 = _interopRequireDefault(_spotifyBridgeRequest);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var NO = exports.NO = 'no';
var WAITING = exports.WAITING = 'waiting';
var WAITING_OFFLINE_MODE = exports.WAITING_OFFLINE_MODE = 'waitingOfflineMode';
var WAITING_NO_CONNECTION = exports.WAITING_NO_CONNECTION = 'waitingNoConnection';
var WAITING_SYNC_NOT_ALLOWED = exports.WAITING_SYNC_NOT_ALLOWED = 'waitingSyncNotAllowed';
var DOWNLOADING = exports.DOWNLOADING = 'downloading';
var YES = exports.YES = 'yes';

function isDownloading(offlineStatus) {
  return offlineStatus === DOWNLOADING;
}

function shouldBeOffline(offlineStatus) {
  switch (offlineStatus) {
    case WAITING:
    case WAITING_OFFLINE_MODE:
    case WAITING_NO_CONNECTION:
    case DOWNLOADING:
    case WAITING_SYNC_NOT_ALLOWED:
    case YES:
      return true;
    case NO:
    default:
      return false;
  }
}

// Returns 0 or 1 if able to derive
// progress from the offlineStatus,
// otherwise will return undefined.
function progressFromStatus(offlineStatus) {
  switch (offlineStatus) {
    case WAITING:
    case WAITING_OFFLINE_MODE:
    case WAITING_NO_CONNECTION:
    case WAITING_SYNC_NOT_ALLOWED:
    case NO:
      return 0;
    case YES:
      return 1;
    case DOWNLOADING:
    default:
      return undefined;
  }
}

function getLabelForStatus(offlineStatus) {
  switch (offlineStatus) {
    case DOWNLOADING:
      return 'Downloading';
    case WAITING_OFFLINE_MODE:
    case WAITING_NO_CONNECTION:
    case WAITING_SYNC_NOT_ALLOWED:
      return 'WaitingForConnection';
    case WAITING:
      return 'WaitingForDownload';
    case YES:
      return 'Downloaded';
    case NO:
    default:
      return 'Download';
  }
}

function sendUserMessageForStatus(offlineStatus) {
  switch (offlineStatus) {
    case WAITING_OFFLINE_MODE:
      // Tell the user to turn off offline mode
      _spotifyBridgeRequest2.default.cosmosJSON({
        method: 'POST',
        uri: 'sp://messages/v1/container/user-message',
        body: {
          id: 'cant-offline-sync-playlist-in-offline-mode'
        }
      });
      return true;
    default:
      return false;
  }
}

},{"../../libs/spotify-bridge-request":225}],218:[function(require,module,exports){
(function (global){
// Playlist Actions: functions that mutate playlists in some way
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addTracksToPlaylist = addTracksToPlaylist;
exports.setPlaylistPublished = setPlaylistPublished;
exports.createNewPlaylist = createNewPlaylist;
exports.logAddToPlaylist = logAddToPlaylist;
exports.refreshedPlaylistName = refreshedPlaylistName;
exports.offlineSyncPlaylist = offlineSyncPlaylist;
var cosmos = require('spotify-cosmos-api');

var AddToPlaylist3 = require('../../libs/spotify-logger/messages/AddToPlaylist3');
var live = require('../../libs/spotify-live');
var bridge = require('../../libs/spotify-bridge-request');

var DUPLICATE_ACTIONS = exports.DUPLICATE_ACTIONS = {
  ADD_ALL: 'add_all',
  ADD_UNIQUE: 'add_unique',
  CANCEL: 'cancel'
};

function getDuplicates(playlistURI, trackURIs, callback) {
  cosmos.resolver.post({
    url: 'sp://core-playlist/v1/playlist/' + encodeURIComponent(playlistURI) + '/contains',
    body: {
      items: trackURIs
    }
  }, function (error, response) {
    if (error) {
      callback([]);
      return;
    }

    var body = response.getJSONBody();
    var foundByIndex = body.found;

    var duplicates = [];
    var uniques = [];

    trackURIs.forEach(function (uri, index) {
      if (foundByIndex[index]) {
        duplicates.push(trackURIs[index]);
      } else {
        uniques.push(trackURIs[index]);
      }
    });

    callback(duplicates, uniques);
  });
}

function maybeFilterDuplicates(playlistURI, trackURIs, callback) {
  getDuplicates(playlistURI, trackURIs, function (duplicates, uniques) {
    if (!duplicates.length) {
      callback(trackURIs);
      return;
    }

    cosmos.resolver.post({
      url: 'sp://messages/v1/avoidduplicates',
      body: {
        action: 'confirm',
        source: global.__spotify.app_uri,
        playlistUri: playlistURI,
        numItems: trackURIs.length,
        numDuplicates: duplicates.length
      }
    }, function (postError) {
      if (postError) {
        callback(trackURIs);
        return;
      }

      // Subscribe for the dialog response
      var subscription = cosmos.resolver.subscribe({
        url: 'sp://messages/v1/avoidduplicates'
      }, function (error, response) {
        subscription.cancel();
        if (error) {
          callback(trackURIs);
          return;
        }
        switch (response.getJSONBody().action) {
          case DUPLICATE_ACTIONS.ADD_ALL:
            callback(trackURIs);
            break;

          case DUPLICATE_ACTIONS.ADD_UNIQUE:
            callback(uniques);
            break;

          case DUPLICATE_ACTIONS.CANCEL:
            callback([]);
            break;

          default:
            throw new Error('Invalid DUPLICATE_ACTION.');
        }
      });
    });
  });
}

function addTracksToPlaylist(playlistURI, trackURIs, cb) {
  maybeFilterDuplicates(playlistURI, trackURIs, function (filteredTrackURIs) {
    if (!filteredTrackURIs.length) {
      cb();
      return;
    }

    cosmos.resolver.post({
      url: 'sp://core-playlist/v1/playlist/' + encodeURIComponent(playlistURI),
      body: {
        operation: 'add',
        uris: filteredTrackURIs,
        after: 'end'
      }
    }, function (error, response) {
      // TODO(jaco): Move over to status code checking when CORE-1638 is done.
      var trackLimitExceeded = error && response && response.getJSONBody() && /exceed the maximum playlist size/i.test(response.getJSONBody().error);
      if (trackLimitExceeded) {
        cosmos.resolver.post({
          url: 'sp://messages/v1/container/user-message',
          body: { id: 'playlist-limit-exceeded' }
        });
      }

      if (error) {
        cb(error);
        return;
      }
      cb();
    });
  });
}

function setPlaylistPublished(uri, publish, cb) {
  var uriStr = uri.toString();

  bridge.request(publish ? 'library_publish' : 'library_unpublish', ['spotify:user:@', uriStr], function (err, data) {
    if (!err) {
      live(uriStr).update({
        published: publish
      });
    }
    return cb(err, data);
  });
}

function createNewPlaylist(name, cb) {
  bridge.request('playlist_create', [name], function (err, data) {
    if (err) {
      cb(err);
      return;
    }
    cb(null, data.uri);
  });
}

function logAddToPlaylist(data) {
  var intent;
  if (data.isNew) {
    intent = 'create-new-playlist';
  } else if (data.isInFolder) {
    intent = 'add-to-playlist-in-folder';
  } else {
    intent = 'add-to-playlist';
  }

  AddToPlaylist3.log({
    /* eslint-disable */
    intent: intent,
    item_uri: data.uris[0].toURI(),
    number_items: data.uris.length.toString(),
    section: 'all-playlists',
    source: data.appUri,
    source_action: 'add-to-playlist',
    playlist_index: data.playlistIndex,
    playlist_uri: data.playlistUri,
    total_number_playlists: data.numberOfVisibleItems,
    time: Math.round(Date.now() / 1000)
  });
}

function refreshedPlaylistName(oldName) {
  if (!oldName) {
    // TODO(jaco): Should be localised, but since the name is still very much up
    // in the air and this will only go out to employees, we don't want to send
    // it off for translation yet since it will likely change a couple of times
    // before we're happy with it.
    return 'Similar Playlist';
  }

  var nextInt = function nextInt(intStr) {
    return parseInt(intStr, 10) + 1;
  };

  // Parenthesized number suffix: "Playlist (2)"
  var matches = oldName.match(new RegExp('(.*)\\((\\d+)\\)$'));
  if (matches) {
    return matches[1].trim() + ' (' + nextInt(matches[2]) + ')';
  }

  return oldName + ' (2)';
}

function offlineSyncPlaylist(uri, shouldBeOffline, cb) {
  bridge.cosmos({
    method: shouldBeOffline ? 'POST' : 'DELETE',
    uri: 'sp://offline/v1/resources?uri=' + uri
  }, cb);
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../libs/spotify-bridge-request":225,"../../libs/spotify-live":512,"../../libs/spotify-logger/messages/AddToPlaylist3":526,"spotify-cosmos-api":890}],219:[function(require,module,exports){
(function (global){
// Playlist Data: playlist data fetching and data subscription.
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fetchPlaylistMetadata = fetchPlaylistMetadata;
exports.subscribeToMetadata = subscribeToMetadata;
exports.getCollaborativeStatus = getCollaborativeStatus;
exports.playlistFiltersToReturn = playlistFiltersToReturn;
exports.replaceFiltersToReturn = replaceFiltersToReturn;
exports.getCorePlaylistUrl = getCorePlaylistUrl;
var liburi = require('spotify-liburi');

var bridge = require('../../libs/spotify-bridge-request');
var wrappedUriUtils = require('../../libs/spotify-live-wrapped-uri');
var coreSortParams = require('../../libs/spotify-core-sort-params');

/**
 * Possible policy fields (may not be an exhaustive list):
 *
 * {
 *   link: true,
 *   loaded: true,
 *   published: true,
 *   browsableOffline: true,
 *   totalLength: true,
 *   name: true,
 *   picture: true,
 *   pictureFromAnnotate: true,
 *   canReportAnnotationAbuse: true,
 *   description: true,
 *   descriptionFromAnnotate: true,
 *   collaborative: true,
 *   formatListAttributes: true,
 *   length: true,
 *   duration: true,
 *   lastModification: true,
 *   allows: {
 *     insert: true,
 *     remove: true
 *   },
 *   followed: true,
 *   offline: true,
 *   followers: true,
 *   owner: {
 *     link: true,
 *     username: true,
 *     name: true
 *   },
 *   ownedBySelf: true
 * }
 */
function fetchPlaylistMetadata(playlistUri, policy, cb) {
  bridge.cosmosJSON({
    method: 'GET',
    uri: 'sp://core-playlist/v1/playlist/' + encodeURIComponent(playlistUri) + '/metadata',
    body: {
      policy: policy
    }
  }, function (error, data) {
    return cb(error, data && data.metadata);
  });
}

function subscribeToMetadata(playlistUri, policy, cb) {
  return bridge.cosmosJSON({
    method: 'SUB',
    uri: 'sp://core-playlist/v1/playlist/' + encodeURIComponent(playlistUri) + '/metadata',
    body: { policy: policy }
  }, function (subError, body) {
    return cb(subError, body && body.metadata);
  });
}

function getCollaborativeStatus(uri, cb) {
  var policy = {
    collaborative: true,
    published: true
  };
  fetchPlaylistMetadata(uri.toString(), policy, cb);
}

function playlistFiltersToReturn(returnUnplayableTracks, returnPremiumOnlyTracks) {
  if (returnUnplayableTracks) {
    if (returnPremiumOnlyTracks) {
      // Return all the tracks. No filters. No restrictions!
      return [];
    }
    // Return unplayable tracks without the premium-only tracks.
    // Equivalent to: return all the tracks, except premium-only tracks.
    // Equivalent to: don't return premium-only tracks.
    return ['isPremiumOnly eq false'];
  }

  // returnUnplayableTracks=false

  if (returnPremiumOnlyTracks) {
    // Don't return "regular unplayable" tracks, but return premium-only tracks.
    // A track can be returned if it used to be defined as playable or if it's
    // premium-only.
    var availabilityFlags = 'available|cappingReached|' + // regular (pre-premiere) definition of playable
    'inPremium'; // available (playable) only in Premium

    // Availability flags are based on the ResourceAvailabilityType enum defined
    // in core (spotify/metadata/cpp/include/spotify/metadata/resource_availability.h).
    return ['availability in ' + availabilityFlags];
  }
  // Don't return regular unplayable tracks and don't return premium-only
  // tracks.
  // Equivalent to: don't return any non-playable track.
  return ['playable eq true'];
}

function replaceFiltersToReturn(filters, returnUnplayableTracks, returnPremiumOnlyTracks) {
  var newFilters = filters.filter(function (filter) {
    return !filter.startsWith('playable') && !filter.startsWith('isPremiumOnly') && !filter.startsWith('availability');
  });
  var filtersToAdd = playlistFiltersToReturn(returnUnplayableTracks, returnPremiumOnlyTracks);
  return newFilters.concat(filtersToAdd);
}

function isLocalFilesUri(uri) {
  return (/:internal:local-files.*/.test(uri)
  );
}

function getCorePlaylistUrl(uri, options, windowedPlaylistShowTracklistCell) {
  var parsed = wrappedUriUtils.parse(uri);
  if (!parsed) {
    parsed = {
      originUri: uri,
      sort: null,
      filter: null
    };
  }
  var originUri = parsed.originUri;

  var url;
  if (isLocalFilesUri(uri)) {
    url = 'sp://local-files/v2';
    if (options.type === 'rows') {
      options.type = 'tracks';
    }
  } else {
    var version = options.version || 'v1';
    url = 'sp://core-playlist/' + version + '/playlist/' + encodeURIComponent(originUri);
  }

  var filters = parsed.filter ? parsed.filter.query.split(',') : [];
  if (!isLocalFilesUri(uri)) {
    var playlistOwnerUsername = liburi.from(originUri).username;
    var isOwnPlaylist = playlistOwnerUsername === global.__spotify.username;
    // Project Premiere "redefined" what is considered 'playable' in the context
    // of the "Show Unavailable(Unplayable) Tracks in Playlists" setting.
    // We do the proper translation to core URIs here assuming this filter ended
    // up here due to the user setting.
    var returnUnplayableTracks = !filters.includes('playable eq true');

    var returnPremiumOnlyTracks;
    if (isOwnPlaylist) {
      returnPremiumOnlyTracks = true;
    } else if (windowedPlaylistShowTracklistCell === 'Enabled') {
      returnPremiumOnlyTracks = returnUnplayableTracks;
    } else {
      returnPremiumOnlyTracks = false;
    }

    filters = replaceFiltersToReturn(filters, returnUnplayableTracks, returnPremiumOnlyTracks);
  }

  var query = [];
  if (parsed.sort && options.type !== 'metadata') {
    var direction = parsed.sort.direction === 'desc' ? 'DESC' : 'ASC';
    query.push('sort=' + encodeURIComponent(coreSortParams(parsed.sort.query, direction)));
  }
  if (typeof options.start === 'number') {
    query.push('start=' + options.start);
  }
  if (typeof options.length === 'number') {
    query.push('length=' + options.length);
  }
  if (options.includeEpisodes === true) {
    query.push('includeEpisodes=true');
  }

  if (options.type) {
    url += '/' + options.type;
  }
  if (filters.length) {
    query.push('filter=' + filters.map(encodeURIComponent).join(','));
  }
  if (options.type === 'play') {
    // Include a context URI that is then reflected as the context in the player state
    query.push('uri=' + encodeURIComponent(uri));
  }
  if (query.length) {
    // TODO(felipec): remove the extra & and fix tests
    url += '?' + query.join('&');
  }
  return url;
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../libs/spotify-bridge-request":225,"../../libs/spotify-core-sort-params":226,"../../libs/spotify-live-wrapped-uri":511,"spotify-liburi":899}],220:[function(require,module,exports){
(function (process,global){
/*
defer
*/'use strict';

var kindOf = require('mout/lang/kindOf'),
    now = require('mout/time/now'),
    forEach = require('mout/array/forEach'),
    indexOf = require('mout/array/indexOf');

var callbacks = {
    timeout: {},
    frame: [],
    immediate: []
};

var push = function push(collection, callback, context, defer) {
    var iterator = function iterator() {
        iterate(collection);
    };

    if (!collection.length) defer(iterator);

    var entry = {
        callback: callback,
        context: context
    };

    collection.push(entry);

    return function () {
        var io = indexOf(collection, entry);
        if (io > -1) collection.splice(io, 1);
    };
};

var iterate = function iterate(collection) {
    var time = now();

    forEach(collection.splice(0), function (entry) {
        entry.callback.call(entry.context, time);
    });
};

var defer = {};

if (global.process && process.nextTick) {
    defer.immediate = function (callback, context) {
        return push(callbacks.immediate, callback, context, process.nextTick);
    };
} else if (global.setImmediate) {
    defer.immediate = function (callback, context) {
        return push(callbacks.immediate, callback, context, setImmediate);
    };
} else if (global.postMessage && global.addEventListener) {
    addEventListener('message', function (event) {
        if (event.source === global && event.data === '@deferred') {
            event.stopPropagation();
            iterate(callbacks.immediate);
        }
    }, true);

    defer.immediate = function (callback, context) {
        return push(callbacks.immediate, callback, context, function () {
            postMessage('@deferred', '*');
        });
    };
} else {
    defer.immediate = function (callback, context) {
        return push(callbacks.immediate, callback, context, function (iterator) {
            setTimeout(iterator, 0);
        });
    };
}

var clear;

defer.timeout = function (callback, ms, context) {
    var ct = callbacks.timeout;

    if (!clear) clear = defer.immediate(function () {
        clear = null;
        callbacks.timeout = {};
    });

    return push(ct[ms] || (ct[ms] = []), callback, context, function (iterator) {
        setTimeout(iterator, ms);
    });
};

module.exports = defer;

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":702,"mout/array/forEach":659,"mout/array/indexOf":660,"mout/lang/kindOf":681,"mout/time/now":699}],221:[function(require,module,exports){
/*
Emitter
*/'use strict';

var indexOf = require('mout/array/indexOf'),
    forEach = require('mout/array/forEach');

var prime = require('./index'),
    defer = require('./defer');

var slice = Array.prototype.slice;

var Emitter = prime({
    constructor: function constructor(stoppable) {
        this._stoppable = stoppable;
    },

    on: function on(event, fn) {
        var listeners = this._listeners || (this._listeners = {}),
            events = listeners[event] || (listeners[event] = []);

        if (indexOf(events, fn) === -1) {
            events.push(fn);
        }

        return this;
    },

    off: function off(event, fn) {
        var listeners = this._listeners,
            events;
        if (listeners && (events = listeners[event])) {
            var io = indexOf(events, fn);
            if (io > -1) events.splice(io, 1);
            if (!events.length) delete listeners[event];
            for (var l in listeners) {
                return this;
            }delete this._listeners;
        }
        return this;
    },

    emit: function emit(event) {
        var self = this,
            args = slice.call(arguments, 1);

        var emit = function emit() {
            var listeners = self._listeners,
                events;
            if (listeners && (events = listeners[event])) {
                forEach(events.slice(0), function (event) {
                    var result = event.apply(self, args);
                    if (self._stoppable) return result;
                });
            }
        };

        if (args[args.length - 1] === Emitter.EMIT_SYNC) {
            args.pop();
            emit();
        } else {
            defer.immediate(emit);
        }

        return this;
    }
});

Emitter.EMIT_SYNC = {};

module.exports = Emitter;

},{"./defer":220,"./index":222,"mout/array/forEach":659,"mout/array/indexOf":660}],222:[function(require,module,exports){
/*
prime
 - prototypal inheritance
*/'use strict';

var hasOwn = require('mout/object/hasOwn'),
    mixIn = require('mout/object/mixIn'),
    create = require('mout/lang/createObject'),
    kindOf = require('mout/lang/kindOf');

var hasDescriptors = true;

try {
    Object.defineProperty({}, '~', {});
    Object.getOwnPropertyDescriptor({}, '~');
} catch (e) {
    hasDescriptors = false;
}

// we only need to be able to implement "toString" and "valueOf" in IE < 9
var hasEnumBug = !{ valueOf: 0 }.propertyIsEnumerable('valueOf'),
    buggy = ['toString', 'valueOf'];

var verbs = /^constructor|inherits|mixin$/;

var implement = function implement(proto) {
    var prototype = this.prototype;

    for (var key in proto) {
        if (key.match(verbs)) continue;
        if (hasDescriptors) {
            var descriptor = Object.getOwnPropertyDescriptor(proto, key);
            if (descriptor) {
                Object.defineProperty(prototype, key, descriptor);
                continue;
            }
        }
        prototype[key] = proto[key];
    }

    if (hasEnumBug) {
        for (var i = 0; key = buggy[i]; i++) {
            var value = proto[key];
            if (value !== Object.prototype[key]) prototype[key] = value;
        }
    }

    return this;
};

var prime = function prime(proto) {
    if (kindOf(proto) === 'Function') {
        proto = { constructor: proto };
    }

    var superprime = proto.inherits;

    // if our nice proto object has no own constructor property
    // then we proceed using a ghosting constructor that all it does is
    // call the parent's constructor if it has a superprime, else an empty constructor
    // proto.constructor becomes the effective constructor
    var constructor = hasOwn(proto, 'constructor') ? proto.constructor : superprime ? function () {
        return superprime.apply(this, arguments);
    } : function () {};

    if (superprime) {
        mixIn(constructor, superprime);

        var superproto = superprime.prototype;
        // inherit from superprime
        var cproto = constructor.prototype = create(superproto);

        // setting constructor.parent to superprime.prototype
        // because it's the shortest possible absolute reference
        constructor.parent = superproto;
        cproto.constructor = constructor;
    }

    if (!constructor.implement) constructor.implement = implement;

    var mixins = proto.mixin;
    if (mixins) {
        if (kindOf(mixins) !== 'Array') mixins = [mixins];
        for (var i = 0; i < mixins.length; i++) {
            constructor.implement(create(mixins[i].prototype));
        }
    }

    // implement proto and return constructor
    return constructor.implement(proto);
};

module.exports = prime;

},{"mout/lang/createObject":671,"mout/lang/kindOf":681,"mout/object/hasOwn":690,"mout/object/mixIn":692}],223:[function(require,module,exports){
/*
Map
*/'use strict';

var _indexOf = require('mout/array/indexOf');

var prime = require('./index');

var Map = prime({
    constructor: function Map() {
        this.length = 0;
        this._values = [];
        this._keys = [];
    },

    set: function set(key, value) {
        var index = _indexOf(this._keys, key);

        if (index === -1) {
            this._keys.push(key);
            this._values.push(value);
            this.length++;
        } else {
            this._values[index] = value;
        }

        return this;
    },

    get: function get(key) {
        var index = _indexOf(this._keys, key);
        return index === -1 ? null : this._values[index];
    },

    count: function count() {
        return this.length;
    },

    forEach: function forEach(method, context) {
        for (var i = 0, l = this.length; i < l; i++) {
            if (method.call(context, this._values[i], this._keys[i], this) === false) {
                break;
            }
        }
        return this;
    },

    map: function map(method, context) {
        var results = new Map();
        this.forEach(function (value, key) {
            results.set(key, method.call(context, value, key, this));
        }, this);
        return results;
    },

    filter: function filter(method, context) {
        var results = new Map();
        this.forEach(function (value, key) {
            if (method.call(context, value, key, this)) results.set(key, value);
        }, this);
        return results;
    },

    every: function every(method, context) {
        var every = true;
        this.forEach(function (value, key) {
            if (!method.call(context, value, key, this)) return every = false;
        }, this);
        return every;
    },

    some: function some(method, context) {
        var some = false;
        this.forEach(function (value, key) {
            if (method.call(context, value, key, this)) return !(some = true);
        }, this);
        return some;
    },

    indexOf: function indexOf(value) {
        var index = _indexOf(this._values, value);
        return index > -1 ? this._keys[index] : null;
    },

    remove: function remove(value) {
        var index = _indexOf(this._values, value);

        if (index !== -1) {
            this._values.splice(index, 1);
            this.length--;
            return this._keys.splice(index, 1)[0];
        }

        return null;
    },

    unset: function unset(key) {
        var index = _indexOf(this._keys, key);

        if (index !== -1) {
            this._keys.splice(index, 1);
            this.length--;
            return this._values.splice(index, 1)[0];
        }

        return null;
    },

    keys: function keys() {
        return this._keys.slice();
    },

    values: function values() {
        return this._values.slice();
    }
});

var map = function map() {
    return new Map();
};

map.prototype = Map.prototype;

module.exports = map;

},{"./index":222,"mout/array/indexOf":660}],224:[function(require,module,exports){
'use strict';

// Base function that doesn't have any dependencies on it's own. Expects to get
// state (a plain, empty object) injected in addition to a bridge request
// function.
function cosmosRequest(state, bridge, opts, callback) {

  if (opts.url) throw new Error(ERROR_PREFIX + '"url" is not a valid option, did you mean "uri"?');

  if (typeof opts.uri !== 'string') throw new Error(ERROR_PREFIX + 'Expected uri to be string.');

  if (COSMOS_VERBS.indexOf(opts.method) === -1) throw new Error(ERROR_PREFIX + 'Method must match valid verb in uppercase (GET, POST etc)');

  if (opts.body && typeof opts.body !== 'string') throw new Error(ERROR_PREFIX + 'If body is provided it should be a string.');

  if (opts.headers && Object.prototype.toString.call(opts.headers) !== '[object Object]') throw new Error(ERROR_PREFIX + 'Expected headers be a plain object.');

  var cosmosOptions = {
    action: opts.method,
    uri: opts.uri
  };
  if (opts.body) cosmosOptions.body = opts.body;
  if (opts.headers) cosmosOptions.headers = opts.headers;

  /* Cosmos requires each request to have a unique ID. Ideally, this would be
  uuids, but unfortunately, it is integers. This means that in apps that for
  some reason need to use spotify-cosmos-api, there would between the two
  counters if cosmosRequest started from 0. To make it safe for the two
  implemenations to co-exist if needed, we begin counting at
  significantly higher number: */
  state.requestIDCounter = state.requestIDCounter || TEN_PER_SECOND_FOR_A_YEAR;
  state.requestIDCounter++;

  var requestArguments = [state.requestIDCounter, cosmosOptions];

  var isCanceled = false;
  var stateRequestIDCounter = state.requestIDCounter;

  function cancelFunction() {
    isCanceled = true;
    bridge('cosmos_request_cancel', [stateRequestIDCounter]);
  }

  // run is a recursive function that does a bridge request and then keeps
  // pulling values after every response in the case of a subscription. In
  // case we are not subscribing, or the cancelFunction has been called,
  // run sends cosmos_request_cancel and terminates.
  function run(isFirst, requestIDCounter) {
    var messageName = isFirst ? 'cosmos_request_create' : 'cosmos_request_pull';
    bridge(messageName, requestArguments, function (error, responseString) {
      // The request to cancel may not have gotten to the bridge
      // before the original request got resolved,
      // so make sure not to continue if we detect it's been canceled.
      if (isCanceled) {
        return;
      }
      try {
        if (callback) {
          if (error) {
            callback(error);
          } else {
            callback(null, responseString);
          }
        }
      } finally {
        if (opts.method !== 'SUB') {
          // If the request was a non-SUB, tell core to clean up the request.
          // NOTE: Not sure if this is strictly necessary,
          // have not been to investigate in C++-land, so for now
          // we are just mimicing the behavior of spotify-cosmos-api.
          bridge('cosmos_request_cancel', [requestIDCounter]);
        } else if (!isCanceled) {
          // maybe canceled in above callback
          run(false, requestIDCounter);
        }
      }
    });
  }

  run(true, stateRequestIDCounter);

  return cancelFunction;
}

var TEN_PER_SECOND_FOR_A_YEAR = 10 * 60 * 60 * 24 * 365;

var COSMOS_VERBS = ['GET', 'HEAD', 'POST', 'PUT', 'SUB', 'PATCH', 'DELETE'];

var ERROR_PREFIX = 'bridge.cosmosRequest: ';

module.exports = cosmosRequest;

},{}],225:[function(require,module,exports){
(function (global){
'use strict';

var debug = require('debug')('spotify-bridge-request');
var defer = require('spotify-deferred');

var cosmosBaseFunction = require('./cosmos');

// NOTE: Implicit global state.
var scheduledCoreFlush = false;
var cosmosState = null;

exports.cosmos = cosmos;
exports.cosmosJSON = cosmosJSON;
exports.request = request;
exports._request = _request;

function cosmos() {
  if (!cosmosState) cosmosState = {};

  var baseArguments = [cosmosState, request];
  var cancelFunction = cosmosBaseFunction.apply(null, baseArguments.concat(Array.prototype.slice.call(arguments)));
  return cancelFunction;
}

function _createCallbackWrapper(callback) {
  return function callbackWrapper(err, response) {
    if (!err) {
      var parsedResponse;
      try {
        parsedResponse = JSON.parse(response.body);
      } catch (e) {
        e.message = 'Failed to parse cosmos response: ' + e.message;
        callback(e);
        return;
      }
      callback(null, parsedResponse);
    } else {
      callback(err, response);
    }
  };
}

function cosmosJSON(opts, callback) {
  if (opts.body) {
    opts.body = JSON.stringify(opts.body);
  }
  var callbackWrapper = callback ? _createCallbackWrapper(callback) : null;
  var cancelFunction = cosmos(opts, callbackWrapper);
  return cancelFunction;
}

function request(name, opt_args, opt_callback) {
  var args = opt_args || [];
  var callback = getCallback(name, args, opt_callback);

  debug('req:' + name, args);

  exports._request(name, args, callback);

  if (name !== 'core_flush' && !scheduledCoreFlush) {
    scheduledCoreFlush = true;
    defer(flushCore);
  }

  return exports;
}

function _request(name, args, callback) {
  if (global && typeof global._getSpotifyModule === 'function') {
    global._getSpotifyModule('bridge').executeRequest(JSON.stringify({
      name: name,
      args: args
    }), {
      onSuccess: getSuccessHandler(callback),
      onFailure: getFailureHandler(callback, name, args)
    });
  }
}

function getCallback(name, args, opt_userCallback) {
  var userCallback = opt_userCallback || function () {};

  return function (error, data) {
    if (error) {
      if (error.name === 'timeout') {
        // Set the delay between 300ms and 400ms
        var delay = 300 + Math.floor(Math.random() * 100);

        debug('timeout', error.message);

        // Retry the request
        setTimeout(function () {
          request(name, args, userCallback);
        }, delay);
        return;
      }
    }

    debug('res:' + name, args, data);

    userCallback(error, data);
  };
}

function getSuccessHandler(requestCallback) {
  return function (data) {
    var parsed;

    debug('success', data);

    try {
      parsed = JSON.parse(data);
    } catch (error) {
      requestCallback(error);
    }

    if (parsed) {
      requestCallback(null, parsed);
    }
  };
}

function getFailureHandler(requestCallback, name, args) {
  return function (data) {
    var parsed;

    debug('failure', data);

    try {
      parsed = JSON.parse(data);
    } catch (error) {
      requestCallback(error);
    }

    if (parsed) {
      requestCallback(createError(name, args, parsed));
    }
  };
}

function createError(name, args, response) {
  var argsString = JSON.stringify(args);
  var debug = ' (bridge message: \'' + name + '\', args: ' + argsString + ')';
  var msg = response.message + debug;
  var error = new Error(msg);
  error.name = response.error;

  return error;
}

function flushCore() {
  scheduledCoreFlush = false;
  request('core_flush');
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./cosmos":224,"debug":582,"spotify-deferred":894}],226:[function(require,module,exports){
'use strict';

var parser = require('../spotify-live/util/parser');

var sortMap = {
  track: {
    _replace: '',
    artists: {
      _replace: 'artist'
    },
    disc: {
      _replace: 'discNumber'
    },
    number: {
      _replace: 'trackNumber'
    },
    duration: {
      _replace: 'length'
    }
  },
  timeSinceAdded: {
    _reverse: true,
    _replace: 'addTime'
  },
  addedBy: {
    _replace: '',
    name: {
      _replace: 'addedByDisplayName'
    }
  }
};

function reverse(direction) {
  return direction === 'ASC' ? 'DESC' : 'ASC';
}

function walk(query, mapping, opt_direction, incomingCollector) {
  var results = [];
  var collector = incomingCollector && incomingCollector.slice() || [];

  for (var item, i = 0; item = query.mask[i]; i++) {
    var itemCollector = collector.slice();

    if (item.key) {
      var hasReplace = mapping && mapping[item.key] && mapping[item.key]._replace != null;

      var value = hasReplace ? mapping[item.key]._replace : item.key;
      if (value !== '') {

        // Only add the direction if there's not another sub object
        if (!item.mask) {
          var doReverse = !!(mapping && mapping[item.key] && mapping[item.key]._reverse);
          if (opt_direction) {
            opt_direction = opt_direction.toUpperCase();
            var direction = doReverse ? reverse(opt_direction) : opt_direction;
            value += ' ' + direction;
          }
        }
        itemCollector.push(value);
      }
    }

    if (item.mask) {
      var subLookUp = walk(item, mapping[item.key], opt_direction, itemCollector);
      if (subLookUp.length) {
        results.push(subLookUp);
      }
    } else {
      if (itemCollector.length) {
        results.push(itemCollector.join('.'));
      }
    }
  }
  return results;
}

function getParams(query, opt_direction, opt_map) {
  var parsed = parser(query);
  if (!query) return null;

  var map = opt_map || sortMap;
  var result = walk(parsed, map, opt_direction);

  return result.join(',');
}

module.exports = getParams;

},{"../spotify-live/util/parser":515}],227:[function(require,module,exports){
/*
attributes
*/"use strict";

var $ = require("./base");

var trim = require("mout/string/trim"),
    forEach = require("mout/array/forEach"),
    filter = require("mout/array/filter"),
    indexOf = require("mout/array/indexOf");

// attributes

$.implement({

    setAttribute: function setAttribute(name, value) {
        return this.forEach(function (node) {
            node.setAttribute(name, value);
        });
    },

    getAttribute: function getAttribute(name) {
        var attr = this[0].getAttributeNode(name);
        return attr && attr.specified ? attr.value : null;
    },

    hasAttribute: function hasAttribute(name) {
        var node = this[0];
        if (node.hasAttribute) return node.hasAttribute(name);
        var attr = node.getAttributeNode(name);
        return !!(attr && attr.specified);
    },

    removeAttribute: function removeAttribute(name) {
        return this.forEach(function (node) {
            var attr = node.getAttributeNode(name);
            if (attr) node.removeAttributeNode(attr);
        });
    }

});

var accessors = {};

forEach(["type", "value", "name", "href", "title", "id"], function (name) {

    accessors[name] = function (value) {
        return value !== undefined ? this.forEach(function (node) {
            node[name] = value;
        }) : this[0][name];
    };
});

// booleans

forEach(["checked", "disabled", "selected"], function (name) {

    accessors[name] = function (value) {
        return value !== undefined ? this.forEach(function (node) {
            node[name] = !!value;
        }) : !!this[0][name];
    };
});

// className

var classes = function classes(className) {
    var classNames = trim(className).replace(/\s+/g, " ").split(" "),
        uniques = {};

    return filter(classNames, function (className) {
        if (className !== "" && !uniques[className]) return uniques[className] = className;
    }).sort();
};

accessors.className = function (className) {
    return className !== undefined ? this.forEach(function (node) {
        node.className = classes(className).join(" ");
    }) : classes(this[0].className).join(" ");
};

// attribute

$.implement({

    attribute: function attribute(name, value) {
        var accessor = accessors[name];
        if (accessor) return accessor.call(this, value);
        if (value != null) return this.setAttribute(name, value);
        if (value === null) return this.removeAttribute(name);
        if (value === undefined) return this.getAttribute(name);
    }

});

$.implement(accessors);

// shortcuts

$.implement({

    check: function check() {
        return this.checked(true);
    },

    uncheck: function uncheck() {
        return this.checked(false);
    },

    disable: function disable() {
        return this.disabled(true);
    },

    enable: function enable() {
        return this.disabled(false);
    },

    select: function select() {
        return this.selected(true);
    },

    deselect: function deselect() {
        return this.selected(false);
    }

});

// classNames, has / add / remove Class

$.implement({

    classNames: function classNames() {
        return classes(this[0].className);
    },

    hasClass: function hasClass(className) {
        return indexOf(this.classNames(), className) > -1;
    },

    addClass: function addClass(className) {
        return this.forEach(function (node) {
            var nodeClassName = node.className;
            var classNames = classes(nodeClassName + " " + className).join(" ");
            if (nodeClassName !== classNames) node.className = classNames;
        });
    },

    removeClass: function removeClass(className) {
        return this.forEach(function (node) {
            var classNames = classes(node.className);
            forEach(classes(className), function (className) {
                var index = indexOf(classNames, className);
                if (index > -1) classNames.splice(index, 1);
            });
            node.className = classNames.join(" ");
        });
    },

    toggleClass: function toggleClass(className, force) {
        var add = force !== undefined ? force : !this.hasClass(className);
        if (add) this.addClass(className);else this.removeClass(className);
        return !!add;
    }

});

// toString

$.prototype.toString = function () {
    var tag = this.tag(),
        id = this.id(),
        classes = this.classNames();

    var str = tag;
    if (id) str += '#' + id;
    if (classes.length) str += '.' + classes.join(".");
    return str;
};

var textProperty = document.createElement('div').textContent == null ? 'innerText' : 'textContent';

// tag, html, text, data

$.implement({

    tag: function tag() {
        return this[0].tagName.toLowerCase();
    },

    html: function html(_html) {
        return _html !== undefined ? this.forEach(function (node) {
            node.innerHTML = _html;
        }) : this[0].innerHTML;
    },

    text: function text(_text) {
        return _text !== undefined ? this.forEach(function (node) {
            node[textProperty] = _text;
        }) : this[0][textProperty];
    },

    data: function data(key, value) {
        switch (value) {
            case undefined:
                return this.getAttribute("data-" + key);
            case null:
                return this.removeAttribute("data-" + key);
            default:
                return this.setAttribute("data-" + key, value);
        }
    }

});

module.exports = $;

},{"./base":228,"mout/array/filter":656,"mout/array/forEach":659,"mout/array/indexOf":660,"mout/string/trim":698}],228:[function(require,module,exports){
/*
elements
*/"use strict";

var prime = require("../../libs/prime");

var _forEach = require("mout/array/forEach"),
    _map = require("mout/array/map"),
    _filter = require("mout/array/filter"),
    _every = require("mout/array/every"),
    _some = require("mout/array/some");

// uniqueID

var index = 0,
    __dc = document.__counter,
    counter = document.__counter = (__dc ? parseInt(__dc, 36) + 1 : 0).toString(36),
    key = "uid:" + counter;

var uniqueID = function uniqueID(n) {
    if (n === window) return "window";
    if (n === document) return "document";
    if (n === document.documentElement) return "html";
    return n[key] || (n[key] = (index++).toString(36));
};

var instances = new WeakMap();

// elements prime

var $ = prime({ constructor: function $(n, context) {

        if (n == null) return this && this.constructor === $ ? new Elements() : null;

        var self, uid, instance;

        if (n.constructor !== Elements) {

            self = new Elements();

            if (typeof n === "string") {
                if (!self.search) return null;
                self[self.length++] = context || document;
                return self.search(n);
            }

            if (n.nodeType || n === window) {

                self[self.length++] = n;
            } else if (n.length) {

                // this could be an array, or any object with a length attribute,
                // including another instance of elements from another interface.

                var uniques = {};

                for (var i = 0, l = n.length; i < l; i++) {
                    // perform elements flattening
                    var nodes = $(n[i], context);
                    if (nodes && nodes.length) for (var j = 0, k = nodes.length; j < k; j++) {
                        var node = nodes[j];
                        uid = uniqueID(node);
                        if (!uniques[uid]) {
                            self[self.length++] = node;
                            uniques[uid] = true;
                        }
                    }
                }
            }
        } else {
            self = n;
        }

        if (!self.length) return null;

        // when length is 1 always use the same elements instance

        if (self.length === 1) {
            if (instance = instances.get(self[0])) {
                return instance;
            } else {
                instances.set(self[0], self);
            }
        }

        return self;
    } });

var Elements = prime({

    inherits: $,

    constructor: function Elements() {
        this.length = 0;
    },

    unlink: function unlink() {
        return this.map(function (node) {
            instances.delete(node);
            return node;
        });
    },

    // methods

    forEach: function forEach(method, context) {
        _forEach(this, method, context);
        return this;
    },

    map: function map(method, context) {
        return _map(this, method, context);
    },

    filter: function filter(method, context) {
        return _filter(this, method, context);
    },

    every: function every(method, context) {
        return _every(this, method, context);
    },

    some: function some(method, context) {
        return _some(this, method, context);
    }

});

module.exports = $;

},{"../../libs/prime":222,"mout/array/every":655,"mout/array/filter":656,"mout/array/forEach":659,"mout/array/map":662,"mout/array/some":665}],229:[function(require,module,exports){
/*
delegation
*/"use strict";

var Map = require("../../libs/prime/map");

var $ = require("./events");
require('./traversal');

$.implement({

    delegate: function delegate(event, selector, handle) {

        return this.forEach(function (node) {

            var self = $(node);

            var delegation = self._delegation || (self._delegation = {}),
                events = delegation[event] || (delegation[event] = {}),
                map = events[selector] || (events[selector] = new Map());

            if (map.get(handle)) return;

            var action = function action(e) {
                var target = $(e.target || e.srcElement),
                    match = target.matches(selector) ? target : target.parent(selector);

                var res;

                if (match) res = handle.call(self, e, match);

                return res;
            };

            map.set(handle, action);

            self.on(event, action);
        });
    },

    undelegate: function undelegate(event, selector, handle) {

        return this.forEach(function (node) {

            var self = $(node),
                delegation,
                events,
                map;

            if (!(delegation = self._delegation) || !(events = delegation[event]) || !(map = events[selector])) return;

            var action = map.get(handle);

            if (action) {
                self.off(event, action);
                map.remove(action);

                // if there are no more handles in a given selector, delete it
                if (!map.count()) delete events[selector];
                // var evc = evd = 0, x
                var e1 = true,
                    e2 = true,
                    x;
                for (x in events) {
                    e1 = false;
                    break;
                }
                // if no more selectors in a given event type, delete it
                if (e1) delete delegation[event];
                for (x in delegation) {
                    e2 = false;
                    break;
                }
                // if there are no more delegation events in the element, delete the _delegation object
                if (e2) delete self._delegation;
            }
        });
    }

});

module.exports = $;

},{"../../libs/prime/map":223,"./events":230,"./traversal":233}],230:[function(require,module,exports){
/*
events
*/"use strict";

var Emitter = require("../../libs/prime/emitter");

var $ = require("./base");

$.implement({

    on: function on(event, handle, useCapture) {

        return this.forEach(function (node) {
            var self = $(node);

            var internalEvent = event + (useCapture ? ":capture" : "");

            Emitter.prototype.on.call(self, internalEvent, handle);

            var domListeners = self._domListeners || (self._domListeners = {});
            if (!domListeners[internalEvent]) {
                var listener = function listener(e) {
                    Emitter.prototype.emit.call(self, internalEvent, e || window.event, Emitter.EMIT_SYNC);
                };
                node.addEventListener(event, listener, useCapture || false);
                domListeners[internalEvent] = listener;
            }
        });
    },

    off: function off(event, handle, useCapture) {

        return this.forEach(function (node) {

            var self = $(node);

            var internalEvent = event + (useCapture ? ":capture" : "");

            var domListeners = self._domListeners,
                domEvent,
                listeners = self._listeners,
                events;

            if (domListeners && (domEvent = domListeners[internalEvent]) && listeners && (events = listeners[internalEvent])) {

                Emitter.prototype.off.call(self, internalEvent, handle);

                if (!self._listeners || !self._listeners[event]) {
                    node.removeEventListener(event, domEvent, false);
                    delete domListeners[event];

                    for (var l in domListeners) {
                        return;
                    }delete self._domListeners;
                }
            }
        });
    },

    emit: function emit() {
        var args = arguments;
        return this.forEach(function (node) {
            Emitter.prototype.emit.apply($(node), args);
        });
    }

});

module.exports = $;

},{"../../libs/prime/emitter":221,"./base":228}],231:[function(require,module,exports){
/*
elements
*/"use strict";

var $ = require("./base");
require("./attributes");
require("./events");
require("./insertion");
require("./traversal");
require("./delegation");

module.exports = $;

},{"./attributes":227,"./base":228,"./delegation":229,"./events":230,"./insertion":232,"./traversal":233}],232:[function(require,module,exports){
/*
insertion
*/"use strict";

var $ = require("./base");

// base insertion

$.implement({

    appendChild: function appendChild(child) {
        this[0].appendChild($(child)[0]);
        return this;
    },

    insertBefore: function insertBefore(child, ref) {
        this[0].insertBefore($(child)[0], $(ref)[0]);
        return this;
    },

    removeChild: function removeChild(child) {
        this[0].removeChild($(child)[0]);
        return this;
    },

    replaceChild: function replaceChild(child, ref) {
        this[0].replaceChild($(child)[0], $(ref)[0]);
        return this;
    }

});

// before, after, bottom, top

$.implement({

    before: function before(element) {
        element = $(element)[0];
        var parent = element.parentNode;
        if (parent) this.forEach(function (node) {
            parent.insertBefore(node, element);
        });
        return this;
    },

    after: function after(element) {
        element = $(element)[0];
        var parent = element.parentNode;
        if (parent) this.forEach(function (node) {
            parent.insertBefore(node, element.nextSibling);
        });
        return this;
    },

    bottom: function bottom(element) {
        element = $(element)[0];
        return this.forEach(function (node) {
            element.appendChild(node);
        });
    },

    top: function top(element) {
        element = $(element)[0];
        return this.forEach(function (node) {
            element.insertBefore(node, element.firstChild);
        });
    }

});

// insert, replace

$.implement({

    insert: $.prototype.bottom,

    remove: function remove() {
        return this.forEach(function (node) {
            var parent = node.parentNode;
            if (parent) parent.removeChild(node);
        });
    },

    replace: function replace(element) {
        element = $(element)[0];
        element.parentNode.replaceChild(this[0], element);
        return this;
    }

});

module.exports = $;

},{"./base":228}],233:[function(require,module,exports){
/*
traversal
*/"use strict";

var map = require("mout/array/map");

var slick = require("slick");

var $ = require("./base");

var gen = function gen(combinator, expression) {
    return map(slick.parse(expression || "*"), function (part) {
        return combinator + " " + part;
    }).join(", ");
};

var push_ = Array.prototype.push;

$.implement({

    search: function search(expression) {
        if (this.length === 1) return $(slick.search(expression, this[0], new $()));

        var buffer = [];
        for (var i = 0, node; node = this[i]; i++) {
            push_.apply(buffer, slick.search(expression, node));
        }buffer = $(buffer);
        return buffer && buffer.sort();
    },

    find: function find(expression) {
        if (this.length === 1) return $(slick.find(expression, this[0]));

        for (var i = 0, node; node = this[i]; i++) {
            var found = slick.find(expression, node);
            if (found) return $(found);
        }

        return null;
    },

    sort: function sort() {
        return slick.sort(this);
    },

    matches: function matches(expression) {
        return slick.matches(this[0], expression);
    },

    contains: function contains(node) {
        return slick.contains(this[0], node);
    },

    nextSiblings: function nextSiblings(expression) {
        return this.search(gen('~', expression));
    },

    nextSibling: function nextSibling(expression) {
        return this.find(gen('+', expression));
    },

    previousSiblings: function previousSiblings(expression) {
        return this.search(gen('!~', expression));
    },

    previousSibling: function previousSibling(expression) {
        return this.find(gen('!+', expression));
    },

    children: function children(expression) {
        return this.search(gen('>', expression));
    },

    firstChild: function firstChild(expression) {
        return this.find(gen('^', expression));
    },

    lastChild: function lastChild(expression) {
        return this.find(gen('!^', expression));
    },

    parent: function parent(expression) {
        var buffer = [];
        loop: for (var i = 0, node; node = this[i]; i++) {
            while ((node = node.parentNode) && node !== document) {
                if (!expression || slick.matches(node, expression)) {
                    buffer.push(node);
                    break loop;
                    break;
                }
            }
        }return $(buffer);
    },

    parents: function parents(expression) {
        var buffer = [];
        for (var i = 0, node; node = this[i]; i++) {
            while ((node = node.parentNode) && node !== document) {
                if (!expression || slick.matches(node, expression)) buffer.push(node);
            }
        }return $(buffer);
    }

});

module.exports = $;

},{"./base":228,"mout/array/map":662,"slick":882}],234:[function(require,module,exports){
'use strict';

function EventDispatcher() {
  // In order to not have prototype nor constructor
  this._listeners = Object.create(null);
}

/**
 * Add an event listener.
 *
 * @param {String} type What type of event to listen to.
 * @param {Function} callback Callback function to execute when triggered.
 * @param {Number?} priority The priority(?).
 */
EventDispatcher.prototype.addEventListener = function (type, callback, priority) {
  if (!type || !callback) {
    throw new Error('Both event type and callback need to be defined');
  }

  priority = priority || 0;

  if (!this._listeners[type]) {
    this._listeners[type] = [];
  }

  var handlers = this._listeners[type];
  // Check if this callback is already registered
  if (handlers.every(function (h) {
    return h.callback !== callback;
  })) {
    var newHandler = {
      callback: callback,
      priority: priority
    };

    // Insert the handler in the right position
    var pos = 0;
    while (pos < handlers.length && handlers[pos].priority > newHandler.priority) {
      pos++;
    }
    handlers.splice(pos, 0, newHandler);
  }
};

/**
 * Remove an event listener.
 *
 * @param {String} type What type of event to stop listening to.
 * @param {Function} listener The listener to remove.
 */
EventDispatcher.prototype.removeEventListener = function (type, listener) {
  var handlers = this._listeners[type] || [];
  for (var i = 0; i < handlers.length; i++) {
    if (handlers[i].callback === listener) {
      handlers.splice(i, 1);
      return;
    }
  }
};

/**
 * Dispatch an event
 *
 * @param {Object} event The event to dispatch.
 */
EventDispatcher.prototype.dispatchEvent = function (event) {
  // Iterate on a copy of the array since an event callback might
  // unbind its listener, which would mutate the listeners array and make
  // the for loop act up.
  var handlers = this._listeners[event.type] ? this._listeners[event.type].slice() : [];
  for (var i = 0, len = handlers.length; i < len; i++) {
    var evt = handlers[i];
    evt.callback(event);
  }
};

EventDispatcher.prototype.reset = function () {
  this._listeners = Object.create(null);
};

module.exports = new EventDispatcher();

},{}],235:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
var live = require('../spotify-live');
var surroundMessages = require('../surround-messages');

var center = require('./center');

var IS_ADDED_PROPERTY = 'added';
var FOLLOWERSCOUNT_PROPERTY = 'followersCount';
var FOLLOWINGCOUNT_PROPERTY = 'followingCount';
var BUTTON_SELECTOR = '[data-button=add]';
var JUSTCHANGED_CLASSNAME = 'just-changed';
var ADDED_CLASSNAME = 'added';

var dataPropertiesForAdd = [IS_ADDED_PROPERTY, FOLLOWERSCOUNT_PROPERTY, FOLLOWINGCOUNT_PROPERTY];

var changeHandlers = {};

function getAddedClass(node) {
  var addedClassNode = node[0].closest('data-class-added');
  return addedClassNode ? addedClassNode.getAttribute('data-class-added') : ADDED_CLASSNAME;
}

function getURIFromNode(node) {
  var stateNode = node[0].closest('[data-uri]');
  if (!stateNode) {
    return null;
  }
  return stateNode.getAttribute('data-uri');
}

var eventHandlers = {

  click: function click(event, node) {
    var stateNode = $(node[0].closest('[data-uri]'));
    if (!stateNode) return;

    var uri = stateNode.data('uri');
    if (!uri) return;

    var addedClass = getAddedClass(node);
    var shouldBeAdded = !stateNode.hasClass(addedClass);
    var data = {
      added: shouldBeAdded
    };

    node.addClass(JUSTCHANGED_CLASSNAME);

    // using capture=true to handle buttons with inner divs (used for changing button text)
    node.on('mouseout', function mouseoutHandler(event) {
      if (event.target !== node[0]) return;
      node.off('mouseout', mouseoutHandler);
      node.removeClass(JUSTCHANGED_CLASSNAME);
    }, true);

    // Publish will trigger the update event, which will then update the UI
    live(uri).publish(data);

    // Inform Surround (for More-Like-This)
    surroundMessages.dispatchUriAdded(uri, data);
  },

  changeHandler: function changeHandler(key, value, uri) {
    if (key === IS_ADDED_PROPERTY) {
      var numAffectedButtons = actions.setStateForURI(uri, value);
      if (numAffectedButtons === 0) {
        live(uri).off('update', changeHandlers[uri]);
        delete changeHandlers[uri];
      }
    }

    if (dataPropertiesForAdd.indexOf(key) > -1) {
      center.emit('add-data-change', { uri: uri, model: live(uri), key: key, value: value });
    }
  }

};

var actions = {

  setStateForURI: function setStateForURI(uri, isAdded) {
    var numAffectedButtons = 0;

    var nodes = $(document).search(BUTTON_SELECTOR);
    if (!nodes) return numAffectedButtons;

    for (var i = 0, l = nodes.length; i < l; i++) {
      var node = $(nodes[i]);
      var buttonURI = getURIFromNode(node);
      if (uri === buttonURI) {
        numAffectedButtons++;
        actions.setStateForButtonNode(node, isAdded);
      }
    }

    return numAffectedButtons;
  },

  setStateForButtonNode: function setStateForButtonNode(node, isAdded) {
    var stateNode = $(node[0].closest('[data-uri]'));
    if (!stateNode) return;

    var addedClass = getAddedClass(node);
    actions.setVisualState(isAdded, stateNode, node, addedClass);
  },

  setVisualState: function setVisualState(isAdded, node, button, className) {
    if (isAdded) {
      if (!node.hasClass(className)) node.addClass(className);
      var tooltipRemove = button.data('tooltip-remove');
      if (tooltipRemove) {
        button.setAttribute('data-tooltip', tooltipRemove);
        button.setAttribute('aria-label', tooltipRemove);
      }
      button.setAttribute('data-log-click', 'remove-button');
    } else {
      if (node.hasClass(className)) node.removeClass(className);
      var tooltipAdd = button.data('tooltip-add');
      if (tooltipAdd) {
        button.setAttribute('data-tooltip', tooltipAdd);
        button.setAttribute('aria-label', tooltipAdd);
      }
      button.setAttribute('data-log-click', 'add-button');
    }
  },

  addListenerForNode: function addListenerForNode(node) {
    var uri = getURIFromNode(node);

    // If we have already added a change handler for this URI,
    // we don't want to add another one, so we cancel early.
    // Before cancelling though, we should update button states
    // with the current state from the live model, since there
    // might be new buttons in the DOM.
    if (changeHandlers[uri]) {
      live(uri).get('added', function (error, isAdded) {
        if (error) throw error;
        actions.setStateForButtonNode(node, isAdded);
      }, live.ASAP);
      return;
    }

    changeHandlers[uri] = function (properties) {
      for (var key in properties) {
        var value = properties[key];
        eventHandlers.changeHandler(key, value, uri);
      }
    };

    var model = live(uri);

    // Get the initial state and update the button
    model.get('added', function (error, isAdded) {
      if (error) throw error;
      actions.setStateForButtonNode(node, isAdded);

      // When the initial state is known, we listen for updates
      // so we can update all buttons for this URI later.
      model.on('update', changeHandlers[uri]);
    }, live.ASAP);
  }

};

var handleScrollShow = function handleScrollShow(data) {
  update(data.pageNode, data.nodes);
};

// Export for testing
exports._classNames = {
  ADDED: ADDED_CLASSNAME,
  JUSTCHANGED: JUSTCHANGED_CLASSNAME
};

var isAttached = false;

exports.attach = function attach() {
  if (isAttached) return;
  isAttached = true;

  $(document).delegate('click', BUTTON_SELECTOR, eventHandlers.click);

  center.on('scroll-show-before', handleScrollShow);
};

exports.detach = function detach() {
  if (!isAttached) return;
  isAttached = false;

  $(document).undelegate('click', BUTTON_SELECTOR, eventHandlers.click);
  center.off('scroll-show-before', handleScrollShow);
};

var update = exports.update = function update(node, nodes) {
  if (!isAttached) return;

  // If the node passed in is a button node, just add listeners for that
  if (node && $(node).matches(BUTTON_SELECTOR)) {
    actions.addListenerForNode($(node));

    // Otherwise search all the children of the node (or the document
    // if node is not provided) for buttons.
  } else {

    var nodes = ($(nodes) || $(node) || $(document)).search(BUTTON_SELECTOR);
    if (!nodes) return;

    for (var i = 0, l = nodes.length; i < l; i++) {
      actions.addListenerForNode($(nodes[i]));
    }
  }
};

},{"../spotify-elements":231,"../spotify-live":512,"../surround-messages":559,"./center":242}],236:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
var Navigator = require('../spotify-navigation/navigator');

var SELECTOR = 'a';

var nav = new Navigator();

var handleAnchorClick = function handleAnchorClick(event, node) {
  var anchor = node[0];
  var href = anchor.getAttribute('href');
  if (!href || href[0] === '#') {
    return;
  }
  event.preventDefault();
  nav.openURI(href);
};

var isAttached = false;

exports.attach = function attach() {
  if (isAttached) {
    return;
  }
  isAttached = true;
  $(document).delegate('click', SELECTOR, handleAnchorClick);
};

exports.detach = function detach() {
  if (!isAttached) {
    return;
  }
  isAttached = false;
  $(document).undelegate('click', SELECTOR, handleAnchorClick);
};

exports.update = function () {};

},{"../spotify-elements":231,"../spotify-navigation/navigator":546}],237:[function(require,module,exports){
'use strict';

var modules = [require('./touch'), require('./pressed'), require('./loading')];

exports.attach = function () {
  modules.forEach(function (module) {
    module.attach();
  });
};

exports.detach = function () {
  modules.forEach(function (module) {
    module.detach();
  });
};

exports.update = function () {
  modules.forEach(function (module) {
    module.update();
  });
};

},{"./loading":238,"./pressed":239,"./touch":240}],238:[function(require,module,exports){
'use strict';

var CARD = '.card';
var IMAGE_LOADING_TRANSITION = 1000;

var currentCards = [];

function addCardImage(card) {
  var imageUri;
  var element = card.querySelector('[data-image-url]');
  if (element) {
    imageUri = element.getAttribute('data-image-url');
  }

  if (imageUri) {
    var image;
    var timeout;

    var onImageLoad = function onImageLoad() {
      card.classList.add('image-loaded');
      clearTimeout(timeout);
    };

    var onImageError = function onImageError() {
      card.classList.add('image-error');
    };

    timeout = setTimeout(function () {
      card.classList.add('image-delayed');
    }, IMAGE_LOADING_TRANSITION);

    image = new Image();
    image.addEventListener('load', onImageLoad);
    image.addEventListener('error', onImageError);
    image.src = imageUri;
  }
}

var isAttached = false;

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  currentCards = [];
};

exports.update = function () {
  if (!isAttached) return;

  // Forget orphaned cards
  currentCards = currentCards.filter(function (card) {
    return card.closest('body');
  });

  var cards = document.querySelectorAll(CARD);
  for (var i = 0, card; card = cards[i]; i++) {
    var known = currentCards.indexOf(card) !== -1;
    if (known) {
      return;
    }
    currentCards.push(card);
    addCardImage(card);
  }
};

exports._reset = function () {
  currentCards = [];
};

},{}],239:[function(require,module,exports){
'use strict';

var $ = require('../../spotify-elements');
var CARD = '[data-card-pressed-container]';
var TRIGGER = '[data-card-trigger-pressed-state]';

var doc = $(document);
var pressedElement;

function handleMouseDown(event, element) {
  // The card shouldn't animate when pressing buttons inside of it.
  if (event.target.nodeName.toLowerCase() === 'button') {
    return;
  }
  // The card shouldn't animate when right clicking it
  if (event.button === 2) {
    return;
  }
  element[0].closest(CARD).classList.add('pressed');
  pressedElement = element[0];
}

function handleMouseUp(event, element) {
  element[0].closest(CARD).classList.remove('pressed');

  if (pressedElement === element[0]) {
    pressedElement = null;
  }
}

function handleDragEnd(event, element) {
  element[0].closest(CARD).classList.remove('pressed');

  if (pressedElement === element[0]) {
    pressedElement = null;
  }
}

function handleDocumentMouseUp() {
  if (pressedElement) {
    pressedElement.closest(CARD).classList.remove('pressed');
    pressedElement = null;
  }
}

var isAttached = false;

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  doc.delegate('mousedown', TRIGGER, handleMouseDown);
  doc.delegate('mouseup', TRIGGER, handleMouseUp);
  doc.delegate('dragend', TRIGGER, handleDragEnd);
  doc.on('mouseup', handleDocumentMouseUp);
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  doc.undelegate('mousedown', TRIGGER, handleMouseDown);
  doc.undelegate('mouseup', TRIGGER, handleMouseUp);
  doc.undelegate('dragend', TRIGGER, handleDragEnd);
  doc.off('mouseup', handleDocumentMouseUp);
};

exports.update = function () {};

},{"../../spotify-elements":231}],240:[function(require,module,exports){
'use strict';

var $ = require('../../spotify-elements');
var CARD = '.card';
var IMAGE_HIT_AREA = '.card-image-hit-area';

var doc = $(document);
var hoverActive = false;

var touchArray = [];
var addEvent = function addEvent(touchEvent) {
  touchArray.push(touchEvent);
};

function getCards() {
  return doc.search(CARD);
}

function isCard(element) {
  return !!element.closest(CARD);
}

function handleEvent(e) {
  var target = e.target;
  if (isCard(target)) {
    switch (e.type) {
      case 'touchstart':
        addEvent(e);
        if (hoverActive) {
          disableHover();
        }
        break;

      case 'touchmove':
        addEvent(e);
        break;

      case 'touchend':
        if (target && touchArray.length === 1 && touchArray[0].type === 'touchstart') {
          e.preventDefault();
          target.click();
        }
        touchArray = [];
        break;

      case 'contextmenu':
        addEvent(e);
        break;

      case 'mousemove':
        if (!hoverActive) {
          enableHover();
        }
        break;
    }
  }
}

function disableHover() {
  var cards = getCards();
  if (cards) {
    cards.forEach(function (card) {
      var hitArea = $(card).find(IMAGE_HIT_AREA);
      if (hitArea) {
        hitArea.addClass('no-hover');
      }
    });
    hoverActive = false;
  }
}

function enableHover() {
  var cards = getCards();
  if (cards) {
    cards.forEach(function (card) {
      var hitArea = $(card).find(IMAGE_HIT_AREA);
      if (hitArea) {
        hitArea.removeClass('no-hover');
      }
    });
    hoverActive = true;
  }
}

var isAttached = false;

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  doc.on('touchstart', handleEvent);
  doc.on('touchmove', handleEvent);
  doc.on('touchend', handleEvent);
  doc.on('mousemove', handleEvent);
  doc.on('contextmenu', handleEvent);
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  doc.off('touchstart', handleEvent);
  doc.off('touchmove', handleEvent);
  doc.off('touchend', handleEvent);
  doc.off('mousemove', handleEvent);
  doc.off('contextmenu', handleEvent);
};

exports.update = function () {};

exports._reset = function () {
  hoverActive = true;
};

},{"../../spotify-elements":231}],241:[function(require,module,exports){
(function (global){
'use strict';

var $ = require('../spotify-elements');
var doc = $(document);
var win = $(window);

// Decides how many pixels allowed between two touchmoves to determine if it is a swipe
var SWIPE_SENSITIVITY = 1;
// Constant that sets the amount of pixels allowed to move without locking the horizontal scroll
var SCROLL_LOCK_LIMIT = 10;
// The divider used to calculate the swipe speed. A larger number will make a slower swipe
var SWIPE_LAG = 14;

var handleClickLeft = function handleClickLeft(event, node) {
  handleButtonClick(node, true);
};

var handleClickRight = function handleClickRight(event, node) {
  handleButtonClick(node, false);
};

var getCarouselInner = function getCarouselInner(node) {
  return node.search('[data-carousel-inner]');
};

var getCarouselObjectsWidth = function getCarouselObjectsWidth(carouselInner) {
  var items = carouselInner.children;
  if (!items) {
    return null;
  }
  var itemWidth = parseFloat(global.getComputedStyle(items[0]).width);
  var carouselInnerWidth = parseFloat(global.getComputedStyle(carouselInner).width);
  var carouselTotalWidth = carouselInner.scrollWidth;

  return {
    itemWidth: itemWidth,
    carouselInnerWidth: carouselInnerWidth,
    carouselTotalWidth: carouselTotalWidth
  };
};

var calculateMinLeftPixels = function calculateMinLeftPixels(carouselInner) {
  var minLeft = 0;
  // Determine number of pages based on numbers per page and total number of objects
  var carouselObjectsWidth = getCarouselObjectsWidth(carouselInner);
  if (!carouselObjectsWidth) {
    return minLeft;
  }

  var objectsPerPage = Math.round(carouselObjectsWidth.carouselInnerWidth / carouselObjectsWidth.itemWidth);
  var totalNrOfObjects = Math.round(carouselObjectsWidth.carouselTotalWidth / carouselObjectsWidth.itemWidth);
  var nrOfPages = Math.ceil(totalNrOfObjects / objectsPerPage);
  minLeft = -(carouselObjectsWidth.carouselInnerWidth * (nrOfPages - 1));
  return minLeft;
};

var handleTouchStart = function handleTouchStart(event, node) {
  // Disable swiping the carousel if scrolling down/up the page
  var scrollBlocked = false;
  doc.on('scroll', handleScroll);

  function handleScroll(event) {
    if (!scrollBlocked) {
      doc.undelegate('touchmove', '[data-carousel]', handleTouchMove);
      doc.undelegate('touchend', '[data-carousel]', handleTouchEnd);
    } else {
      event.preventDefault();
    }
  }

  // Get carousel element
  var carouselInner = getCarouselInner(node);
  if (!carouselInner) {
    return;
  }
  carouselInner = carouselInner[0];
  var startX;
  var previousX;
  var deltaX;
  // minLeft is always a negative number or 0. This is the minimum LEFT position of the carousel.
  var minLeft = calculateMinLeftPixels(carouselInner);
  if (minLeft === 0) {
    return;
  }
  doc.delegate('touchmove', '[data-carousel]', handleTouchMove);
  doc.delegate('touchend', '[data-carousel]', handleTouchEnd);

  // Get start coordinates
  if (event.touches) {
    startX = event.touches[0].pageX;
    previousX = startX;
  }

  function handleTouchMove(event) {
    if (!carouselInner) {
      return;
    }
    addDragTransition();

    if (event.touches) {
      var x = event.touches[0].pageX;
      deltaX = previousX - x;
      // Get position of carousel
      var positionLeft = carouselPosition(carouselInner);
      positionLeft = getPositionInPixels(positionLeft, carouselInner);
      // Set adjusted position
      var adjust = positionLeft - deltaX;
      // Check that carousel position doesn't exceed limits
      adjust = checkLimitsPixels(adjust, minLeft);
      carouselInner.style.left = adjust + 'px';
      previousX = x;

      if (deltaX > SCROLL_LOCK_LIMIT) {
        scrollBlocked = true;
      }
      if (scrollBlocked) {
        event.preventDefault();
      }
    }
  }

  function handleTouchEnd() {
    doc.undelegate('touchmove', '[data-carousel]', handleTouchMove);
    doc.undelegate('touchend', '[data-carousel]', handleTouchEnd);
    doc.off('scroll', handleScroll);
    if (!carouselInner) {
      return;
    }
    // If considered as a swipe, swipe
    if (Math.abs(deltaX) > SWIPE_SENSITIVITY) {
      swipe(deltaX);
    }
    updateButtonsOnTouch(node);
  }

  /* Touch swipe functions */

  var swipe = function swipe(deltaX) {
    addSwipeTransition();
    // Get position of carousel
    var leftValue = carouselPosition(carouselInner);
    leftValue = getPositionInPixels(leftValue, carouselInner);

    var carouselObjectsWidth = getCarouselObjectsWidth(carouselInner);
    // Get width of one mediaobject to us as an interval in the calculation for setting the swipe speed
    var itemWidth = carouselObjectsWidth ? parseInt(carouselObjectsWidth.itemWidth, 10) : null;
    if (!itemWidth) {
      return;
    }
    // Calculate position to swipe to based on value of deltaX (e.g. swipe acceleration) and SWIPE_LAG
    // SWIPE_LAG can be changed to a lower/higher value to increase/decrease speed.
    var adjust = leftValue + itemWidth * (-deltaX / SWIPE_LAG);
    // Check that carousel position doesn't exceed limits
    adjust = checkLimitsPixels(adjust, minLeft);
    carouselInner.style.left = adjust + 'px';
  };

  var updateButtonsOnTouch = function updateButtonsOnTouch(node) {
    var carouselId = node.data('carousel');
    var positionLeft = carouselPosition(carouselInner);
    positionLeft = getPositionInPixels(positionLeft, carouselInner);
    var carouselRight = $('[data-carousel=' + carouselId + '][data-button=carousel-right]');
    var carouselLeft = $('[data-carousel=' + carouselId + '][data-button=carousel-left]');

    if (Math.round(positionLeft) <= Math.round(minLeft)) {
      carouselRight.setAttribute('disabled', 'disabled');
    } else {
      carouselRight.removeAttribute('disabled');
    }

    if (positionLeft >= 0) {
      carouselLeft.setAttribute('disabled', 'disabled');
    } else {
      carouselLeft.removeAttribute('disabled');
    }
  };

  var addSwipeTransition = function addSwipeTransition() {
    if (!carouselInner) {
      return;
    }
    // Add swipe transition and remove drag + click transition
    $(carouselInner).addClass('crsl-inner-swipe').removeClass('crsl-inner-drag');
  };

  var addDragTransition = function addDragTransition() {
    if (!carouselInner) {
      return;
    }
    // Add drag transition and remove swipe + click transition
    $(carouselInner).addClass('crsl-inner-drag').removeClass('crsl-inner-swipe');
  };
};

var resetTransitions = function resetTransitions(carouselInner) {
  if (!carouselInner) {
    return;
  }
  // Add click transition and remove drag + swipe transition
  $(carouselInner).removeClass('crsl-inner-drag').removeClass('crsl-inner-swipe');
};

var checkLimitsPixels = function checkLimitsPixels(adjust, minLeft) {
  adjust = Math.min(adjust, 0);
  adjust = Math.max(adjust, minLeft);
  return adjust;
};

var carouselPosition = function carouselPosition(carouselInner) {
  return carouselInner.style.left || '0';
};

var getPositionInPixels = function getPositionInPixels(positionLeft, carouselInner) {
  var isInPx = positionLeft.endsWith('px');
  positionLeft = parseFloat(positionLeft);
  // If current unit isn't px, change to px
  if (!isInPx) {
    var currentPage = Math.abs(positionLeft / 100);
    var carouselObjectsWidth = getCarouselObjectsWidth(carouselInner);

    if (carouselObjectsWidth) {
      positionLeft = -carouselObjectsWidth.carouselInnerWidth * currentPage;
    }
  }
  return positionLeft;
};

var getNextPageInPercent = function getNextPageInPercent(positionLeft, carouselInner, isLeft) {
  var carouselInnerWidth = carouselInner.clientWidth;
  var minLeft = calculateMinLeftPixels(carouselInner);
  var isInPercent = positionLeft.endsWith('%');
  positionLeft = parseInt(positionLeft, 10);
  // If current unit isn't %, change to %
  var nextPage;
  if (!isInPercent) {
    nextPage = Math.abs(positionLeft / carouselInnerWidth);
    if (positionLeft === 0 && !isLeft) {
      // If position is to the end left and button is right
      nextPage = -100;
    } else if (positionLeft === minLeft && isLeft) {
      // If position is to the end right and button is left
      nextPage = (nextPage - 1) * -100;
    } else {
      nextPage = isLeft ? Math.floor(nextPage) : Math.ceil(nextPage);
      nextPage = nextPage * -100;
    }
  } else {
    // If current unit already is in percent
    nextPage = isLeft ? positionLeft + 100 : positionLeft - 100;
  }
  return nextPage;
};

var handleButtonClick = function handleButtonClick(buttonNode, isLeft) {
  if (buttonNode.hasAttribute('disabled')) {
    return;
  }
  var carouselId = buttonNode.data('carousel');
  var carouselInner = $('[data-carousel=' + carouselId + '][data-carousel-main] [data-carousel-inner]')[0];
  var positionLeft = carouselPosition(carouselInner);

  var adjust;
  if (positionLeft) {
    // Get next page in %
    var nextPage = getNextPageInPercent(positionLeft, carouselInner, isLeft);
    adjust = nextPage;
  } else {
    adjust = isLeft ? 0 : -100;
  }
  // Reset transitions
  resetTransitions(carouselInner);
  updateButtonStates(carouselId, adjust);
  carouselInner.style.left = adjust + '%';
};

var updateButtonStates = function updateButtonStates(carouselId, optAdjust) {
  var carouselRight = $('[data-carousel=' + carouselId + '][data-button=carousel-right]');
  var carouselLeft = $('[data-carousel=' + carouselId + '][data-button=carousel-left]');
  var carousel = $('[data-carousel=' + carouselId + '][data-carousel-main]');
  var carouselInner = $(carousel).search('[data-carousel-inner]')[0];
  var leftAdjust;

  if (typeof optAdjust === 'number') {
    leftAdjust = optAdjust;
  } else {
    leftAdjust = carouselInner.style.left ? parseInt(carouselInner.style.left, 10) : 0;
  }

  var shouldRightButtonBeDisabled = carouselInner.clientWidth - leftAdjust / 100 * carouselInner.clientWidth + 10 > carouselInner.scrollWidth;

  if (leftAdjust >= 0) {
    carouselLeft.setAttribute('disabled', 'disabled');
  } else {
    carouselLeft.removeAttribute('disabled');
  }

  if (shouldRightButtonBeDisabled) {
    carouselRight.setAttribute('disabled', 'disabled');
  } else {
    carouselRight.removeAttribute('disabled');
  }
};

var updateAllButtons = function updateAllButtons(node) {
  if (node && node.ownerDocument && !node.ownerDocument.body.contains(node)) return;
  node = $(node) || doc;
  var carousels = node.search('[data-carousel-main]');
  if (carousels) {
    carousels.forEach(function (carousel) {
      updateButtonStates($(carousel).data('carousel'));
    });
  }
};

var isAttached = false;

exports.update = function update(node) {
  if (!isAttached) return;

  updateAllButtons(node);
};

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  doc.delegate('click', '[data-button=carousel-right]', handleClickRight);
  doc.delegate('click', '[data-button=carousel-left]', handleClickLeft);
  doc.delegate('touchstart', '[data-carousel][data-carousel-main]', handleTouchStart);

  win.on('resize', updateAllButtons);
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  doc.undelegate('click', '[data-button=carousel-right]', handleClickRight);
  doc.undelegate('click', '[data-button=carousel-left]', handleClickLeft);
  doc.undelegate('touchstart', '[data-carousel][data-carousel-main]', handleTouchStart);

  win.off('resize', updateAllButtons);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-elements":231}],242:[function(require,module,exports){
/*
Event Center
*/'use strict';

var Emitter = require('../../libs/prime/emitter');

module.exports = new Emitter();

},{"../../libs/prime/emitter":221}],243:[function(require,module,exports){
(function (global){
'use strict';

var $ = require('../spotify-elements');
var live = require('../spotify-live');
var selection = require('./selection');
var wrappedUriUtils = require('../spotify-live-wrapped-uri');
var cosmos = require('spotify-cosmos-api');

var CONTEXTMENU = ['a[data-uri]', '[data-contextmenu]'].join(',');

var makeContextMenuData = function makeContextMenuData(selectionContexts, primaryIndex, uris, x, y) {
  var contexts = [];
  for (var i = 0, selectionContext; selectionContext = selectionContexts[i]; i++) {
    var keys = selectionContext.keys || [];
    var indices = selectionContext.indices || [];
    primaryIndex = primaryIndex || indices[0];
    primaryIndex = primaryIndex === undefined ? null : primaryIndex;

    var contextUri = selectionContext.uri;

    var contextData = {
      uri: contextUri,
      keys: keys,
      indices: indices,
      primaryIndex: primaryIndex
    };

    var origin = selectionContext.origin;
    if (origin) {
      if (primaryIndex !== null) {
        var wrappedList = live(contextUri).get('rows');
        var originList = live(origin.uri).get('rows');
        if (wrappedList && originList) {
          var key = wrappedList.keys[primaryIndex];
          origin.primaryIndex = originList.indexOf(key);
        }
      }
      contextData.origin = origin;
    }
    contexts.push(contextData);
  }
  return {
    contexts: contexts,
    x: x,
    y: y,
    uris: uris
  };
};

var handleContextMenuEvent = function handleContextMenuEvent(event, node) {
  event.preventDefault();
  event.stopPropagation();

  var x = event.clientX,
      y = event.clientY;
  handleContextMenuActiveClass(node);

  if (node[0].tagName.toLowerCase() === 'a') {
    var uri = node.data('uri');
    if (uri) {
      showContextMenu({
        uris: [uri],
        x: x,
        y: y
      });
    }
  } else {
    var contextNode = node.parent('[data-list]');

    var index = +node.data('index');

    var isSelected = false;
    var indices = selection.getIndicesPerList();

    if (contextNode) {
      isSelected = selection.isNodeSelected(node);
    }
    var uris = isSelected ? selection.getUris() : [node.data('uri')];
    showContextMenu(makeContextMenuData(indices, index, uris, x, y));
  }
};

var handleContextMenuButton = function handleContextMenuButton(event, node) {
  var parent;
  var uri = node.data('uri') || (parent = node.parent('[data-uri]')) && parent.data('uri');
  if (!uri) return;

  // The context menu can't know what to offer for a custom list.
  // In case of a sorted and/or filtered list, pass the origin list.
  uri = wrappedUriUtils.getOriginUri(uri) || uri;

  var contextURI = (parent = node.parent('[data-list][data-uri]')) && parent.data('uri');
  var contextIndex = (parent = node.parent('[data-index]')) && +parent.data('index');

  var contextMenuNode = $(node[0].closest('[data-button="contextmenu"]'));
  var relativeTo = contextMenuNode || parent || node;

  var rect = relativeTo[0].getBoundingClientRect();
  var x = rect.left + rect.width / 2;
  var y = rect.top + rect.height;

  // The coordinate must be within the app viewport
  if (y > window.innerHeight) y = window.innerHeight - 1;
  if (x > window.innerWidth) x = window.innerWidth - 1;

  var indices = contextIndex === null || contextIndex === undefined ? null : [contextIndex];

  var context;
  if (contextURI) {
    context = {
      uri: contextURI
    };

    if (indices) {
      context.indices = indices;

      var liveList = live(contextURI).get('rows');
      context.keys = liveList ? indices.map(function (selectedIndex) {
        return liveList.keys[selectedIndex];
      }) : [];
    }

    // Add originList
    var origin = wrappedUriUtils.getOriginUri(contextURI);
    if (origin) {
      context.origin = {
        uri: origin
      };

      if (indices) {
        var wrappedList = live(contextURI).get('rows');
        var originList = live(origin).get('rows');
        if (wrappedList && originList) {
          var originIndices = indices.map(function (index) {
            var key = wrappedList.keys[index];
            return originList.indexOf(key);
          });
          var originKeys = indices.map(function (index) {
            return wrappedList.keys[index];
          });
          context.origin.indices = originIndices;
          context.origin.keys = originKeys;
        }
      }
    }
  }
  showContextMenu(makeContextMenuData([context], contextIndex, [uri], x, y));
  handleContextMenuActiveClass(contextMenuNode);
};

var handleContextMenuActiveClass = function handleContextMenuActiveClass(node) {
  var subscribedParentNodes = node.parents('[data-contextmenu-spy]');
  var collection = $([node, subscribedParentNodes]);
  collection.addClass('contextmenu-active');

  var sub = cosmos.resolver.subscribe({
    url: 'sp://messages/v1/context_menu_state'
  }, function (error, response) {
    if (!error && response.getJSONBody().state === 'hide') {
      collection.removeClass('contextmenu-active');
      sub.cancel();
    }
  });
};

var showContextMenu = function showContextMenu(data) {
  data.appURI = global.__spotify.app_uri;
  var client = live('spotify:client');
  client.emit('show-context-menu', data);
};

var isAttached = false;

exports.attach = function attach() {
  if (isAttached) return;
  isAttached = true;

  $(document).delegate('contextmenu', CONTEXTMENU, handleContextMenuEvent);
  $(document).delegate('click', '[data-button=contextmenu]', handleContextMenuButton);
};

exports.detach = function detach() {
  if (!isAttached) return;
  isAttached = false;

  $(document).undelegate('contextmenu', CONTEXTMENU, handleContextMenuEvent);
  $(document).undelegate('click', '[data-button=contextmenu]', handleContextMenuButton);
};

exports.update = function () {};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-elements":231,"../spotify-live":512,"../spotify-live-wrapped-uri":511,"./selection":297,"spotify-cosmos-api":890}],244:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
var live = require('../spotify-live');
var dom = require('./util/dom');

var SELECTOR_HEART_BUTTON = '[data-button=heart]';

/**
 * Handle the click on a Daily Mix feedback button.
 *
 * @param {MouseEvent} event An event object for a click event.
 * @param {HTMLElement} button A button DOM node.
 *
 * @private
 */
function handleFeedbackButtonClick(event, button) {
  var type = dom.getAttributeFromNodeOrParent(button[0], 'data-button');
  var trackUri = dom.getAttributeFromNodeOrParent(button[0], 'data-uri');
  var contextUri = dom.getContextFromNodeOrParent(button[0]);

  // Must use track uri
  if (!trackUri || !contextUri) return;

  // Emit heart event on context
  if (type === 'heart') {
    live(contextUri).emit('heart', trackUri);
  }
}

var isAttached = false;

/**
 * Attach the event listeners for the module.
 * Part of the spotify-events interface.
 */
exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  var doc = $(document);
  doc.delegate('click', SELECTOR_HEART_BUTTON, handleFeedbackButtonClick);
};

/**
 * Detach the event listeners for the module.
 * Part of the spotify-events interface.
 */
exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  var doc = $(document);
  doc.undelegate('click', SELECTOR_HEART_BUTTON, handleFeedbackButtonClick);
};

exports.update = function () {};

},{"../spotify-elements":231,"../spotify-live":512,"./util/dom":311}],245:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop/custom/queue
 * @private
 */
'use strict';

var hooks = require('../util/hooks');
var QUEUE_URI = 'spotify:internal:queue:future';

/**
 * Hook handler for validating a list target.
 *
 * @param {Object} result Result object. Setting the `valid` property will
 *     affect whether the drop is allowed.
 * @param {HTMLElement} list A DOM node marked up as a list.
 */
function onListDropValidation(result, event, list, location, index) {

  var contextUri = list.getAttribute('data-uri');
  if (!contextUri || contextUri !== QUEUE_URI) return;

  // The "current" track in the queue is marked up as index -1. Disallow
  // dragging anything to that spot.
  if (index === -1) {
    result.valid = false;
    return;
  }
}

/**
 * Attach the module.
 */
function attach() {
  hooks.add('list-drop-validation', onListDropValidation);
}

/**
 * Detach the module.
 */
function detach() {
  hooks.remove('list-drop-validation', onListDropValidation);
}

exports.attach = attach;
exports.detach = detach;

},{"../util/hooks":254}],246:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop/custom/rootlist
 * @private
 */
'use strict';

var $ = require('../../../spotify-elements');

var liburi = require('spotify-liburi');
var live = require('../../../spotify-live');
var intersection = require('mout/array/intersection');

var hooks = require('../util/hooks');
var eventModel = require('../util/eventmodel');
var selection = require('../../selection');

var SELECTOR_LIST = '[data-list]';
var SELECTOR_LIST_ITEM = '[data-list-item]';
var SELECTOR_DRAGGABLE = 'a, [draggable]';
var ATTR_TARGET = 'data-drop-target';

var dragFolderElement = null;

/**
 * Handler for the dragstart event.
 */
function onDragStart() {
  dragFolderElement = null;

  var uris = selection.getUris();
  if (uris.length > 1) return;

  var uri = uris[0];
  var uriObject = uri && liburi.fromString(uri);
  if (!uriObject) return;

  // If dragging a folder, we need to temporarily save the folder DOM node,
  // so that while dragging over items we can check whether to show the drop
  // indicator. Dropping a folder inside itself should not be allowed.
  if (uriObject.type === liburi.Type.FOLDER) {
    var selectedNodes = selection.getNodes();
    for (var i = 0, l = selectedNodes.length; i < l; i++) {
      var node = selectedNodes[i];
      if (node.getAttribute('data-uri') === uri) {
        dragFolderElement = node;
        break;
      }
    }
  }
}

/**
 * Handler for ending a drag.
 */
function onDragEnd() {
  dragFolderElement = null;
}

/**
 * Hook handler for setting drag data.
 *
 * @param {MouseEvent} event Event object for a dragstart event.
 * @param {Array.<string>} uris Array of URIs being dragged.
 * @param {string=} opt_context Optional context URI.
 */
function onSetDragData(event, uris, opt_context) {
  if (opt_context !== 'spotify:rootlist') {
    var followedPlaylistCount = 0;
    for (var i = 0, l = uris.length; i < l; i++) {
      var uriObject = liburi.from(uris[i]);
      var type = uriObject && uriObject.type;
      if (type === liburi.Type.PLAYLIST) {
        var isFollowing = live(uris[i]).get('added');
        if (isFollowing) followedPlaylistCount++;
      } else {
        // If the item is not a playlist, it means we are dragging either only
        // items of another type, or playlists as well as other types.
        break;
      }
    }

    // Dropping only playlists that you are following in the rootlist should
    // not be allowed. If multiple playlists are dragged and some of them are
    // not being followed, dropping is allowed (and the receiver should handle
    // only inserting the new ones). To allow telling these cases apart while
    // not having access to drag data, we set a special MIME type that can be
    // checked later.
    if (followedPlaylistCount === uris.length) {
      event.dataTransfer.setData('text/x-spotify-only-followed-playlists', '');
    }
  }
}

/**
 * Hook handler for validating a list drop.
 *
 * @param {Object} result Result object. Setting the `valid` property will
 *     affect whether the drop is allowed.
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} list A DOM node marked up as a list.
 * @param {string} location The location of the cursor in relation to the list.
 *     This can be either 'inside' or 'below'. The value 'below' means that the
 *     cursor was below the last list found in the DOM.
 */
function onListDropValidation(result, event, list, location) {
  var contextUri = list.getAttribute('data-uri');
  if (contextUri === 'spotify:rootlist') {

    // Dropping only already followed playlists into the rootlist should not
    // be allowed, since you can only have playlists once in the rootlist.
    if (hasOnlyFollowedPlaylists(event)) {
      result.valid = false;
      return;
    }

    // Dropping a folder inside or right below itself should not be allowed
    if (isInsideDraggedFolder(event, location)) {
      result.valid = false;
      return;
    }

    // Dropping on the bottom half of a folder should not be allowed as a list
    // target, but will be a regular target for the folder instead. However, if
    // the dragged items match the list target, dropping should be handled by
    // list code instead of target code (dragover should still not validate as
    // we want the active drop target style and not the list indicator).
    if (isInFolderBottomHalf(event)) {
      if (event.type !== 'drop' || !isMatchingTarget(event, list)) {
        result.valid = false;
        return;
      }
    }
  }
}

/**
 * Hook handler for validating a target.
 *
 * @param {Object} result Result object. Setting the `valid` property will
 *     affect whether the drop is allowed.
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} target DOM node for target that matches MIME types.
 */
function onTargetValidation(result, event, target) {
  var list = target.closest(SELECTOR_LIST);
  if (list) {
    var contextUri = list.getAttribute('data-uri');
    if (contextUri === 'spotify:rootlist') {

      // Dropping only already followed playlists into the rootlist should not
      // be allowed, since you can only have playlists once in the rootlist.
      if (hasOnlyFollowedPlaylists(event)) {
        result.valid = false;
        return;
      }

      // Dropping valid rootlist items on the top half of a folder should not
      // be allowed as a regular target, but will be a list drop target instead.
      // For leave events, we need to validate the whole row as valid, so that
      // the target styling is removed correctly.
      if (event.type !== 'dragleave' && isMatchingTarget(event, list)) {
        var folderNode = getFolderNode(event);
        if (folderNode) {
          if (isBelowMiddleOfNode(event.clientY, folderNode)) {
            result.valid = true;
          } else {
            result.valid = false;
          }
          return;
        }
      }
    }
  }
}

/**
 * Hook handler for getting the indices being moved.
 *
 * @param {string} contextUri The context URI.
 * @param {LiveList} liveList Live list to be changed.
 * @param {Array.<number>} indices Array of indices in the list.
 */
function onGetMoveIndices(contextUri, liveList, indices) {
  if (contextUri === 'spotify:rootlist') {
    var firstIndex = indices[0];
    var firstRow = liveList.get(firstIndex);
    var firstItem = firstRow && firstRow.get('playlist');
    var firstUri = firstItem && firstItem.uri;
    var firstUriType = firstUri && liburi.fromString(firstUri).type;
    var isFolder = firstUriType === liburi.Type.FOLDER;

    if (isFolder) {

      // Add all indices for the folder contents and the end marker
      if (indices.length === 1) {
        var length = getFolderLength(liveList, firstUri, firstIndex);
        for (var i = 1; i <= length; i++) {
          indices.push(firstIndex + i);
        }
      }

      // Abort the move operation if it only contains moving a folder start
      // marker, since moving folders should always move the entire folder.
      // Aborting by returning zero indices.
      if (indices.length === 1) {
        indices.length = 0;
        return;
      }

      var lastRow = liveList.get(indices[indices.length - 1]);
      var lastItem = lastRow && lastRow.get('playlist');
      var lastUri = lastItem && lastItem.uri;

      // Abort the move operation if moving a folder and the last item to move
      // is not the end marker for the folder. Aborting by returning zero
      // indices.
      if (lastUri !== firstUri + ':end') {
        indices.length = 0;
        return;
      }
    }
  }
}

/**
 * Check if only dragging playlists that are being followed already.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {boolean} True if only followed playlists are being dragged.
 */
function hasOnlyFollowedPlaylists(event) {
  var types = event.dataTransfer.types;
  if (types.indexOf('text/x-spotify-only-followed-playlists') > -1) {
    return true;
  }

  return false;
}

/**
 * Check if dragging a folder into (or below) itself.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {string} location The location of the cursor in relation to the list.
 *     This can be either 'inside' or 'below'. The value 'below' means that the
 *     cursor was below the last list found in the DOM.
 *
 * @return {boolean} True if dragging into the same folder being dragged.
 */
function isInsideDraggedFolder(event, location) {
  if (dragFolderElement) {
    var rowNode = location === 'below' ? getLastRowNode() : getRowNode(event);
    if (rowNode) {
      var targetIndex = +rowNode.getAttribute('data-index');
      if (location === 'inside') {
        if (!isBelowMiddleOfNode(event.clientY, rowNode)) {
          targetIndex--;
        }
      }
      if (isIndexInsideDraggedFolder(targetIndex)) {
        return true;
      }
    }
  }

  return false;
}

/**
 * Check if dragging onto the bottom half of a folder.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {boolean} True if dragging onto the bottom half.
 */
function isInFolderBottomHalf(event) {
  var folderNode = getFolderNode(event);
  if (folderNode) {
    return isBelowMiddleOfNode(event.clientY, folderNode);
  }
  return false;
}

/**
 * Check if the position is below the middle of the node.
 *
 * @param {number} y The Y position relative to the viewport.
 * @param {HTMLElement} node DOM node to check against.
 *
 * @return {boolean} True if the position is below.
 */
function isBelowMiddleOfNode(y, node) {
  var rect = node.getBoundingClientRect();
  return y >= rect.top + rect.height / 2;
}

/**
 * Check if the index is inside (or right below) the folder being dragged.
 *
 * @param {number} index Current target index.
 *
 * @return {boolean} True if the target index is inside the folder.
 */
function isIndexInsideDraggedFolder(index) {
  if (!dragFolderElement) return false;

  var liveList = live('spotify:rootlist').get('rows');
  if (!liveList) return false;

  var folderUri = dragFolderElement.getAttribute('data-uri');
  if (!folderUri) return false;

  var start = +dragFolderElement.getAttribute('data-index');
  var end = start + getFolderLength(liveList, folderUri, start);

  if (start > -1 && end > start && index >= start && index <= end) {
    return true;
  }

  return false;
}

/**
 * Check if the MIME types in the drag event matches the MIME types for the
 * specified drop target.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} node A DOM node.
 *
 * @return {boolean} True if the element matches the event.
 */
function isMatchingTarget(event, node) {
  var eventTypes = event.dataTransfer.types;
  var nodeTypes = node.getAttribute(ATTR_TARGET);

  if (nodeTypes) {
    var matching = intersection(nodeTypes.split('|'), eventTypes);
    if (matching.length > 0) return true;
  }

  return false;
}

/**
 * Get the folder row node from the event.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {HTMLElement?} DOM node for the folder, or null if not found.
 */
function getFolderNode(event) {
  var rowNode = getRowNode(event);
  if (rowNode) {
    var uri = rowNode.getAttribute('data-uri');
    var uriObject = liburi.from(uri);
    if (uriObject && uriObject.type === liburi.Type.FOLDER) {
      return rowNode;
    }
  }

  return null;
}

/**
 * Get the list row element from the event target.
 * If the event target itself isn't a list row, it will step out in the parent
 * tree until it finds a row.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {HTMLElement?} The list row element, or null if not found.
 */
function getRowNode(event) {
  return event.target.closest(SELECTOR_LIST_ITEM);
}

/**
 * Get the last list row from the last list in the DOM.
 *
 * @return {HTMLElement?} The list row element, or null if not found.
 */
function getLastRowNode() {
  var lists = $(SELECTOR_LIST);
  var lastList = lists && lists[lists.length - 1];
  if (lastList) {
    var listItems = $(lastList).search(SELECTOR_LIST_ITEM);
    var lastItem = listItems && listItems[listItems.length - 1];
    if (lastItem) return lastItem;
  }

  return null;
}

/**
 * Get the length of a folder, including the contents and end marker, but not
 * the start marker.
 *
 * @param {LiveList} liveList Live list for the rootlist.
 * @param {string} folderUri The folder URI.
 * @param {number} index The index where the folder start marker is.
 *
 * @return {number} The length of the folder.
 */
function getFolderLength(liveList, folderUri, index) {
  var rowAtIndex = liveList.get(index);
  var itemAtIndex = rowAtIndex && rowAtIndex.get('playlist');
  var uriAtIndex = itemAtIndex && itemAtIndex.uri;
  if (uriAtIndex !== folderUri) return 0;

  var folderEndUri = folderUri + ':end';
  var amount = 0;

  for (var i = index + 1, l = liveList.length; i < l; i++) {
    amount++;

    rowAtIndex = liveList.get(i);
    itemAtIndex = rowAtIndex && rowAtIndex.get('playlist');
    uriAtIndex = itemAtIndex && itemAtIndex.uri;
    if (uriAtIndex === folderEndUri) break;
  }

  return amount;
}

/**
 * Attach the module.
 */
function attach() {
  eventModel.delegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.delegate('dragend', 'body', onDragEnd);

  hooks.add('set-drag-data', onSetDragData);
  hooks.add('list-drop-validation', onListDropValidation);
  hooks.add('target-validation', onTargetValidation);
  hooks.add('get-move-indices', onGetMoveIndices);
}

/**
 * Detach the module.
 */
function detach() {
  eventModel.undelegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.undelegate('dragend', 'body', onDragEnd);

  hooks.remove('set-drag-data', onSetDragData);
  hooks.remove('list-drop-validation', onListDropValidation);
  hooks.remove('target-validation', onTargetValidation);
  hooks.remove('get-move-indices', onGetMoveIndices);
}

exports.attach = attach;
exports.detach = detach;

},{"../../../spotify-elements":231,"../../../spotify-live":512,"../../selection":297,"../util/eventmodel":253,"../util/hooks":254,"mout/array/intersection":661,"spotify-liburi":899}],247:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop/custom/sortlist
 * @private
 */
'use strict';

var liburi = require('spotify-liburi');
var sortUriUtils = require('../../../spotify-live-sort-uri');

var hooks = require('../util/hooks');
var eventModel = require('../util/eventmodel');
var selection = require('../../selection');

var SELECTOR_DRAGGABLE = 'a, [draggable]';

var dragSelectionState = null;

/**
 * Handler for the dragstart event.
 */
function onDragStart() {
  dragSelectionState = selection.getIndicesPerList();
}

/**
 * Handler for ending a drag.
 */
function onDragEnd() {
  dragSelectionState = null;
}

/**
 * Hook handler for validating a list drop.
 *
 * @param {Object} result Result object. Setting the `valid` property will
 *     affect whether the drop is allowed.
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} list A DOM node marked up as a list.
 */
function onListDropValidation(result, event, list) {
  var contextUri = list.getAttribute('data-uri');
  if (!contextUri) return;

  // Dropping in sorted lists should not allow specific drop positions,
  if (sortUriUtils.isValid(contextUri) && event.type !== 'drop') {
    result.valid = false;
  }
}

/**
 * Hook handler for validating a list target.
 *
 * @param {Object} result Result object. Setting the `valid` property will
 *     affect whether the drop is allowed.
 * @param {HTMLElement} list A DOM node marked up as a list.
 */
function onListTargetValidation(result, list) {
  var contextUri = list.getAttribute('data-uri');
  if (!contextUri) return;

  // Bail on all invalid uris
  if (!sortUriUtils.isValid(contextUri)) return;

  // We should support incoming drag and drops as well, like from the
  // now playing view for example
  if (!dragSelectionState) {
    result.valid = true;
    return;
  }

  // Dropping in sorted lists should be allowed as a regular target
  if (dragSelectionState.length === 1) {
    if (dragSelectionState[0].uri !== contextUri) {
      result.valid = true;
    }
  }
}

/**
 * Hook handler for checking if a list is a track list.
 *
 * @param {Object} result Result object. Setting the `valid` property will
 *     affect the result.
 * @param {LiveList} liveList The live list.
 * @param {string} contextUri The context URI.
 */
function onIsListOfTracks(result, liveList, contextUri) {
  if (sortUriUtils.isValid(contextUri)) {
    var originUri = sortUriUtils.getOriginUri(contextUri);
    if (originUri) {
      var uriObject = liburi.from(originUri);
      var type = uriObject && uriObject.type;
      if (type === liburi.Type.PLAYLIST) {
        result.valid = true;
      }
    }
  }
}

/**
 * Attach the module.
 */
function attach() {
  eventModel.delegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.delegate('dragend', 'body', onDragEnd);

  hooks.add('list-drop-validation', onListDropValidation);
  hooks.add('list-target-validation', onListTargetValidation);
  hooks.add('is-list-of-tracks', onIsListOfTracks);
}

/**
 * Detach the module.
 */
function detach() {
  eventModel.undelegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.undelegate('dragend', 'body', onDragEnd);

  hooks.remove('list-drop-validation', onListDropValidation);
  hooks.remove('list-target-validation', onListTargetValidation);
  hooks.remove('is-list-of-tracks', onIsListOfTracks);
}

exports.attach = attach;
exports.detach = detach;

},{"../../../spotify-live-sort-uri":510,"../../selection":297,"../util/eventmodel":253,"../util/hooks":254,"spotify-liburi":899}],248:[function(require,module,exports){
(function (global){
/**
 * @module spotify-events/dragndrop/dragdata
 * @private
 */
'use strict';

var liburi = require('spotify-liburi');

var selection = require('../selection');
var hooks = require('./util/hooks');
var eventModel = require('./util/eventmodel');
var itemText = require('./util/itemtext');
var getLogContext = require('../util/get-log-context');

var SELECTOR_DRAGGABLE = 'a, [draggable]';

/**
 * Handler for the dragstart event.
 *
 * @param {MouseEvent} event Event object for a dragstart event.
 * @param {HTMLElement} target The target element.
 */
function onDragStart(event, target) {
  var isSelected = selection.isNodeSelected(target);

  if (isSelected) {
    var uris = selection.getUris();
    if (uris.length > 0) {
      var state = selection.getIndicesPerList();
      var singleContext = state.length === 1;
      var context = singleContext ? state[0] && state[0].uri : null;
      if (context) {
        setEventData(event, uris, null, context, getLogContext(target));
      } else {
        setEventData(event, uris, null, null, getLogContext(target));
      }
    }
  } else {
    var uri = target.getAttribute('data-uri');
    if (!uri) {
      var uriObject = liburi.from(target.getAttribute('href'));
      uri = uriObject ? uriObject.toURI() : '';
    }
    var dragText = itemText.getForElement(target);

    if (uri) {
      setEventData(event, [uri], [dragText], null, getLogContext(target));
    }
  }
}

/**
 * Set drag data on the event.
 * This includes regular MIME types such as plain text and html, but also custom
 * Spotify MIME types that can be used to detect the dragged content while
 * dragging (you can't access data while dragging, so there is no other way
 * to detect what kind of items are being dragged).
 *
 * @param {MouseEvent} event Event object for a dragstart event.
 * @param {Array.<string>} uris Array of Spotify URIs.
 * @param {Array.<string>=} opt_dragTexts Optional drag texts for each URI.
 * @param {string=} opt_context Optional context URI.
 * @param {string=} opt_logContext Optional log context.
 */
function setEventData(event, uris, opt_dragTexts, opt_context, opt_logContext) {
  var urlsPerMimeType = getUrlsPerMimeType(uris);
  var urls = getUrlsForUris(uris);
  var urlList = urls.join('\n');
  var html = getLinkHTML(uris, urls, opt_dragTexts);

  // We set this before others because safari overrides any data that was set
  // before this particular mimetype was set.
  event.dataTransfer.setData('text/uri-list', urlList);

  for (var type in urlsPerMimeType) {
    var urlsForType = urlsPerMimeType[type];
    event.dataTransfer.setData(type, urlsForType.join('\n'));
  }

  event.dataTransfer.setData('text/plain', urlList);
  event.dataTransfer.setData('text/html', html);

  if (opt_context) {

    // Provide the context as drag data. This can be used in the drop event to
    // know where it came from.
    event.dataTransfer.setData('text/x-spotify-data-context', opt_context);
  }

  if (opt_logContext) {
    event.dataTransfer.setData('text/x-spotify-data-log-context', opt_logContext);
  }

  event.dataTransfer.setData('text/x-spotify-data-app-uri', global.__spotify && global.__spotify.app_uri || null);

  hooks.run('set-drag-data', event, uris, opt_context);
}

/**
 * Get URLs for the URIs organized by MIME type.
 *
 * @param  {Array.<string>} uris Array of Spotify URIs.
 *
 * @return {Object.<string, Array.<string>>} Object of arrays of URLs.
 */
function getUrlsPerMimeType(uris) {
  var urlsPerMimeType = {};
  for (var i = 0, l = uris.length; i < l; i++) {
    var uri = uris[i];
    var type = getMimeType(uri);
    var urlsForType = urlsPerMimeType[type] || (urlsPerMimeType[type] = []);
    urlsForType.push(getShareLink(uri));
  }
  return urlsPerMimeType;
}

/**
 * Get URLs for the URIs.
 *
 * @param {Array.<string>} uris Array of Spotify URIs.
 *
 * @return {Array.<string>} Array of share URLs.
 */
function getUrlsForUris(uris) {
  var urls = new Array(uris.length);
  for (var i = 0, l = uris.length; i < l; i++) {
    urls[i] = getShareLink(uris[i]);
  }
  return urls;
}

/**
 * Get a share URL from a Spotify URI.
 *
 * @param {string} uri A Spotify URI.
 *
 * @return {string} The share URL.
 */
function getShareLink(uri) {
  var uriObject = liburi.from(uri);
  return uriObject ? uriObject.toOpenURL() : uri;
}

/**
 * Get the custom Spotify MIME type for a URI.
 *
 * @param {string} uri A Spotify URI.
 *
 * @return {string} The MIME type.
 */
function getMimeType(uri) {
  var type = 'text/x-spotify-';

  var uriObject = liburi.from(uri);
  if (uriObject) {
    var uriType = uriObject.type;

    if (uriType === liburi.Type.TRACK || uriType === liburi.Type.LOCAL) {
      return type + 'tracks';
    }
    if (uriType === liburi.Type.ALBUM || uriType === liburi.Type.LOCAL_ALBUM) {
      return type + 'albums';
    }
    if (uriType === liburi.Type.ARTIST || uriType === liburi.Type.LOCAL_ARTIST) {
      return type + 'artists';
    }
    if (uriType === liburi.Type.USER || uriType === liburi.Type.PROFILE) {
      return type + 'users';
    }
    if (uriType === liburi.Type.PLAYLIST) {
      return type + 'playlists';
    }
    if (uriType === liburi.Type.FOLDER) {
      return type + 'folders';
    }
    if (uriType === liburi.Type.STATION) {
      return type + 'stations';
    }
  }

  return type + 'unknown';
}

/**
 * Get the HTML for links to the given URLs.
 *
 * @param {Array.<string>} uris Array of Spotify URIs.
 * @param {Array.<string>} urls Array of Spotify URLs used for sharing.
 * @param {Array.<string>=} opt_dragTexts Optional drag texts for each URI.
 *
 * @return {string} String of HTML.
 */
function getLinkHTML(uris, urls, opt_dragTexts) {
  var html = '';

  for (var i = 0, l = uris.length; i < l; i++) {
    var textFromArgs = opt_dragTexts && opt_dragTexts[i];
    var text = textFromArgs || itemText.getForUri(uris[i]);

    html += '<a href="' + urls[i] + '">' + text + '</a>';

    if (i < uris.length - 1) {
      html += '<br>';
    }
  }

  return html;
}

/**
 * Attach the module.
 */
function attach() {
  eventModel.delegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
}

/**
 * Detach the module.
 */
function detach() {
  eventModel.undelegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
}

exports.attach = attach;
exports.detach = detach;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../selection":297,"../util/get-log-context":312,"./util/eventmodel":253,"./util/hooks":254,"./util/itemtext":255,"spotify-liburi":899}],249:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop/dragimage
 * @private
 */
'use strict';

var liburi = require('spotify-liburi');
var defer = require('../../../libs/prime/defer');

var selection = require('../selection');
var eventModel = require('./util/eventmodel');
var itemText = require('./util/itemtext');

var i18n = require('../i18n/index');

var SELECTOR_DRAGGABLE = 'a, [draggable]';
var DRAGIMAGE_POS_X = -10;
var DRAGIMAGE_POS_Y = -5;

var dragImageElement = null;
var dragImageShelter = null;

/**
 * Handler for the dragstart event.
 *
 * @param {MouseEvent} event Event object for a dragstart event.
 * @param {HTMLElement} target The target element.
 */
function onDragStart(event, target) {
  var isSelected = selection.isNodeSelected(target);

  var text = '';

  if (isSelected) {
    var uris = selection.getUris();
    if (uris.length === 1) {
      text = itemText.getForUri(uris[0]);
    } else {
      text = getLocalizedTypeFromUris(uris);
    }
  } else {
    text = itemText.getForElement(target);
  }

  var dragImage = getDragImage(text);

  event.dataTransfer.setDragImage(dragImage, DRAGIMAGE_POS_X, DRAGIMAGE_POS_Y);

  removeDragImage();
}

/**
 * Get the drag image element with the specified text set.
 *
 * @param {string} text The text to set.
 *
 * @return {HTMLElement} The drag image element.
 */
function getDragImage(text) {
  if (!dragImageElement) {
    dragImageElement = document.createElement('div');
    dragImageElement.className = 'dnd-image';
  }
  if (!dragImageShelter) {
    dragImageShelter = document.createElement('div');
    dragImageShelter.className = 'dnd-image-shelter';
  }

  dragImageElement.textContent = text;

  document.body.appendChild(dragImageElement);
  document.body.appendChild(dragImageShelter);

  return dragImageElement;
}

/**
 * Remove the drag image element and the shelter it hides behind.
 * This must be delayed a tick to let the native drag and drop handling
 * get the time to read the image.
 */
function removeDragImage() {
  defer.immediate(function () {
    if (dragImageElement && dragImageElement.parentNode) {
      dragImageElement.parentNode.removeChild(dragImageElement);
    }
    if (dragImageShelter && dragImageShelter.parentNode) {
      dragImageShelter.parentNode.removeChild(dragImageShelter);
    }
  });
}

/**
 * Get a localized type for a list of URIs.
 * This could be for example 'tracks', 'playlists' etc. Falls back to 'items'
 * if the URIs are of different type. As this is only called when we drag
 * multiple items, we don't need the singular form.
 *
 * @param {Array.<string>} uris Array of URIs.
 *
 * @return {string} The localized type.
 */
function getLocalizedTypeFromUris(uris) {
  var type = 'item';

  var uriObjectForFirst = liburi.from(uris[0]);
  var typeForFirst = uriObjectForFirst && uriObjectForFirst.type;

  if (typeForFirst) {
    type = typeForFirst;

    for (var i = 0, l = uris.length; i < l; i++) {
      var uriObject = liburi.from(uris[i]);
      if (!uriObject || uriObject.type !== typeForFirst) {
        type = 'item';
        break;
      }
    }
  }

  // User URIs are parsed with type 'profile' in liburi, but we want 'user'
  if (type === 'profile') {
    type = 'user';
  }

  var pluralType = type + 's';

  // Get the localized version of the plural type
  var localized = i18n.get('drag_tooltip_many_' + pluralType, uris.length);

  // If the type was not the generic 'items' type and no localization was found,
  // localize the generic type.
  if (localized === 'drag_tooltip_many_' + pluralType && pluralType !== 'items') {
    localized = i18n.get('drag_tooltip_many_items', uris.length);
  }

  // Return the localized type, or if nothing is found, fall back to the type
  return localized || pluralType;
}

/**
 * Attach the module.
 */
function attach() {
  eventModel.delegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
}

/**
 * Detach the module.
 */
function detach() {
  eventModel.undelegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
}

exports.attach = attach;
exports.detach = detach;

},{"../../../libs/prime/defer":220,"../i18n/index":258,"../selection":297,"./util/eventmodel":253,"./util/itemtext":255,"spotify-liburi":899}],250:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop
 */
'use strict';

var dragDataModule = require('./dragdata');
var dragImageModule = require('./dragimage');
var targetModule = require('./target');
var listModule = require('./list');

// Custom behaviors
var sortlistModule = require('./custom/sortlist');
var rootlistModule = require('./custom/rootlist');
var queueModule = require('./custom/queue');

/**
 * Attach the module.
 */
function attach() {
  dragDataModule.attach();
  dragImageModule.attach();
  targetModule.attach();
  listModule.attach();
  queueModule.attach();

  sortlistModule.attach();
  rootlistModule.attach();
}

/**
 * Detach the module.
 */
function detach() {
  dragDataModule.detach();
  dragImageModule.detach();
  targetModule.detach();
  listModule.detach();
  queueModule.detach();

  sortlistModule.detach();
  rootlistModule.detach();
}

exports.attach = attach;
exports.detach = detach;
exports.update = function () {};

},{"./custom/queue":245,"./custom/rootlist":246,"./custom/sortlist":247,"./dragdata":248,"./dragimage":249,"./list":251,"./target":252}],251:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop/list
 * @private
 */
'use strict';

var $ = require('../../spotify-elements');
var intersection = require('mout/array/intersection');
var Range = require('../../spotify-range2');
var live = require('../../spotify-live');
var liburi = require('spotify-liburi');
var listOperations = require('../../../libs/spotify-live-list-operations');

var hooks = require('./util/hooks');
var eventModel = require('./util/eventmodel');
var selection = require('../selection');

var SELECTOR_DROP_TARGET = '[data-drop-target]';
var SELECTOR_LIST = '[data-list]';
var SELECTOR_LIST_ITEM = '[data-list-item]';
var SELECTOR_LIST_TARGET = SELECTOR_DROP_TARGET + ', body';
var SELECTOR_DRAGGABLE = 'a, [draggable]';
var ATTR_TARGET = 'data-drop-target';

var dropIndicator = null;
var draggedLinkContext = null;
var disabledLists = {};

/**
 * Handler for the dragstart event.
 *
 * @param {MouseEvent} event Event object for a dragstart event.
 * @param {HTMLElement} target The target element.
 */
function onDragStart(event, target) {
  draggedLinkContext = null;

  // clear the selectionState cache
  cachedSelectionState.clear();

  var matchingTarget = getMatchingTarget(event);
  if (matchingTarget) {
    var isInList = $(matchingTarget).matches(SELECTOR_LIST);
    if (isInList) {
      var uri = matchingTarget.getAttribute('data-uri');

      // Dragging a link from inside a list needs to store the list context,
      // since it is not allowed to drop a dragged link inside the same list.
      if (target.tagName.toLowerCase() === 'a') {
        draggedLinkContext = uri;
      }

      // Dragging is disallowed for lists where we're waiting for a list move
      // to finish. This is to prevent multiple moves to be called before the
      // response from the first comes back.
      if (disabledLists[uri]) {
        event.preventDefault();
        return;
      }

      var rowNode = getRowNode(event);
      if (rowNode) {
        var index = getTargetIndex(event.clientY, rowNode);
        if (index !== -1) {
          event.dataTransfer.setData('text/x-spotify-data-log-source-index', index);
        }
      }
    }
  }
}

/**
 * Handler for dragging over a drop target.
 *
 * @param {MouseEvent} event A dragover event object.
 * @param {HTMLElement} target DOM element for the drop target. This can be the
 *     body element even if it's not a drop target.
 */
function onDragOver(event, target) {
  var positionedListDrop = false;
  var rowNode = null;

  var isBody = target === document.body;
  var list = null;
  if (isBody) list = getListTargetFromBody(event);else list = getMatchingListTarget(event);

  // If we found a list from the event, we must validate if it's allowed to drop
  // in the list.
  if (list) {
    var location = isBody ? 'below' : 'inside';

    var index = -1;
    rowNode = location === 'below' ? getLastRowFromLastList() : getRowNode(event);
    if (rowNode) {
      index = getTargetIndex(event.clientY, rowNode);
    }

    if (validateListDrop(event, list, location, index)) {
      if (isBody) {
        positionedListDrop = true;
      } else {
        if (rowNode) {
          positionedListDrop = true;
        }
      }
    }
  }

  if (positionedListDrop) {
    event.preventDefault();

    if (isBody) showDropIndicatorBelowList(list);else if (rowNode) showDropIndicatorForRow(rowNode, event.clientY);
  } else {
    hideDropIndicator();

    var listHookResult = { valid: false };
    if (list) {
      hooks.run('list-target-validation', listHookResult, list);
    }

    // The list might be accepted as a drop target even if dropping in a
    // specific position was not accepted. In that case we need to prevent the
    // default action to tell the browser that we accept drops here.
    if (listHookResult.valid) {
      event.preventDefault();
    } else if (!isBody && list) {
      var targetHookResult = { valid: false };
      hooks.run('target-validation', targetHookResult, event, target);

      // If we know that dropping is not allowed here at all, we need to remove
      // the drop effect from the cursor. This is mainly since the handler in
      // targets.js has already handled the event and accepted it, which sets
      // the drop effect.
      if (!targetHookResult.valid) {
        event.dataTransfer.dropEffect = 'none';
      }
    }
  }
}

/**
 * Handler for dragging out from a drop target.
 */
function onDragLeave() {
  hideDropIndicator();
}

/**
 * Handler for ending a drag.
 */
function onDragEnd() {
  hideDropIndicator();
  draggedLinkContext = null;
}

/**
 * Handler for dropping onto a drop target.
 *
 * @param {MouseEvent} event A drop event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDrop(event, target) {
  hideDropIndicator();

  var isBody = target === document.body;
  var list = null;
  if (isBody) list = getListTargetFromBody(event);else list = getMatchingListTarget(event);

  if (list) {
    var location = isBody ? 'below' : 'inside';

    var index = -1;
    var rowNode = location === 'below' ? getLastRowFromLastList() : getRowNode(event);
    if (rowNode) {
      index = getTargetIndex(event.clientY, rowNode);
    }

    if (validateListDrop(event, list, location, index)) {
      var contextUri = list.getAttribute('data-uri');
      if (contextUri) {
        performListChangesForEvent(event, list, contextUri, location);
        event.handled = true;
      }
    }
  }
}

/**
 * Show the drop indicator below the provided list element.
 *
 * @param {HTMLElement} list A list element.
 */
function showDropIndicatorBelowList(list) {
  var listRect = list.getBoundingClientRect();
  showDropIndicator(listRect.left, listRect.bottom, listRect.width);
}

/**
 * Show the drop indicator above or below a list row.
 *
 * @param {HTMLElement} rowNode A list row element.
 * @param {number} cursorY The cursor Y position, relative to the viewport.
 */
function showDropIndicatorForRow(rowNode, cursorY) {
  var belowMiddle = isBelowMiddleOfNode(cursorY, rowNode);
  var rowRect = rowNode.getBoundingClientRect();
  var x = rowRect.left;
  var y = rowRect.top + (belowMiddle ? rowRect.height : 0);
  showDropIndicator(x, y, rowRect.width);
}

/**
 * Show the drop indicator line for the specified row and cursor position.
 * If the cursor position is below the middle of the row, the indicator will be
 * placed below the row, otherwise above the row.
 *
 * @param {number} x The X position relative to the viewport.
 * @param {number} y The Y position relative to the viewport.
 * @param {number} width The width of the indicator.
 */
function showDropIndicator(x, y, width) {

  // Don't use window.scroll X/Y because cross browser issues.
  // https://developer.mozilla.org/en-US/docs/Web/API/Window.scrollY
  var indicatorAbsX = window.pageXOffset + x;
  var indicatorAbsY = window.pageYOffset + y;
  var indicatorWidth = width;

  if (!dropIndicator) {
    dropIndicator = document.createElement('div');
    dropIndicator.className = 'tr-drag-indicator';
  }

  dropIndicator.style.left = indicatorAbsX + 'px';
  dropIndicator.style.width = indicatorWidth + 'px';
  dropIndicator.style.top = indicatorAbsY + 'px';

  if (!dropIndicator.parentNode) {
    document.body.appendChild(dropIndicator);
  }
}

/**
 * Hide the drop indicator.
 */
function hideDropIndicator() {
  if (dropIndicator && dropIndicator.parentNode) {
    dropIndicator.parentNode.removeChild(dropIndicator);
  }
}

/**
 * Perform the list changes that are needed from the drop event.
 *
 * @param {MouseEvent} event A drop event.
 * @param {HTMLElement} list The list DOM node.
 * @param {string} contextUri The context URI for the list.
 * @param {string} location The location of the cursor in relation to the list.
 *     This can be either 'inside' or 'below'. The value 'below' means that the
 *     cursor was below the last list found in the DOM.
 */
function performListChangesForEvent(event, list, contextUri, location) {
  var liveList = live(contextUri).get('rows');
  if (!liveList) return;

  var targetIndex = 0;

  if (location === 'below') {
    var lastRowNode = getLastRowFromLastList();

    // Dropping below a list without rows will use target index 0
    if (lastRowNode) {
      targetIndex = getTargetIndex(event.clientY, lastRowNode);
    }
  } else {
    var rowNode = getRowNode(event);
    if (!rowNode) return;
    targetIndex = getTargetIndex(event.clientY, rowNode);
  }

  var sourceContext = event.dataTransfer.getData('text/x-spotify-data-context');
  var isSameContext = sourceContext && sourceContext === contextUri;

  if (isSameContext) {
    performMoveChanges(contextUri, liveList, targetIndex);
  } else {
    performInsertChanges(event, list, contextUri, liveList, targetIndex);
  }
  event.data = {
    targetIndex: targetIndex
  };
}

/**
 * Move the selected items to a target index in the list.
 *
 * @param {string} contextUri The context URI of the list.
 * @param {LiveList} liveList The live list for the context.
 * @param {number} targetIndex The target index in the list.
 */
function performMoveChanges(contextUri, liveList, targetIndex) {
  var indices = getMoveIndices(contextUri, liveList);

  // Selection can be nothing. This can happen if you select a row, drag it
  // and before dropping, the row is removed by something else (on another
  // device perhaps). Dropping should in that case not perform any action.
  // Similarly, if dragging multiple rows and some of the rows are removed
  // while dragging, only the rows that are still in the list will be moved.
  if (indices.length === 0) return;

  var operations = listOperations.getMoveOperations(indices, targetIndex);

  // If the list changed while dragging, it might happen that we end up
  // dropping at the same index as we're dragging from, which would give
  // us no operations to perform.
  if (operations.length === 0) return;

  liveList.publish(operations);

  temporarilyDisableList(contextUri, liveList);
}

/**
 * Insert items from the event into the list at the target index.
 *
 * @param {MouseEvent} event A drop event.
 * @param {HTMLElement} list The list DOM node.
 * @param {string} contextUri The context URI for the list.
 * @param {LiveList} liveList The live list for the context.
 * @param {number} targetIndex The target index in the list.
 */
function performInsertChanges(event, list, contextUri, liveList, targetIndex) {
  getInsertValues(event, list, liveList, contextUri, function (error, values) {
    if (error) return;
    if (values.length === 0) return;

    var operations = [{ type: 'insert', index: targetIndex, values: values }];

    liveList.publish(operations);

    temporarilyDisableList(contextUri, liveList);
  });
}

/**
 * Check if dropping at the current position in a list is allowed.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} list A DOM node marked up as a list.
 * @param {string} location The location of the cursor in relation to the list.
 *     This can be either 'inside' or 'below'. The value 'below' means that the
 *     cursor was below the last list found in the DOM.
 *
 * @return {boolean} True if it's a valid drop position.
 */
function validateListDrop(event, list, location, index) {

  // All positions are valid if we're not dragging from a context in the first
  // place. If we do have a context though, we need to validate the position.
  var types = event.dataTransfer.types;
  var isDraggingFromContext = types.indexOf('text/x-spotify-data-context') > -1;
  if (isDraggingFromContext) {
    if (!validatePotentialOperations(event, list, location)) {
      return false;
    }
  }

  var uri = list.getAttribute('data-uri');
  if (uri && draggedLinkContext === uri) {
    return false;
  }

  var result = { valid: true };
  hooks.run('list-drop-validation', result, event, list, location, index);

  return !!result.valid;
}

/**
 * Simple wrapper to cache calls to selection.getIndicesPerList()
 *
 * @return {Object} The result of selection.getIndicesPerList()
 */
var cachedSelectionState = function () {
  var cache = {
    lastTime: 0,
    lastValue: null
  };
  var CACHE_TIMEOUT = 500;

  return {
    get: function get() {
      var now = Date.now();

      if (now - cache.lastTime > CACHE_TIMEOUT) {
        cache = {
          lastValue: selection.getIndicesPerList(),
          lastTime: now
        };
      }

      return cache.lastValue;
    },
    clear: function clear() {
      cache.lastTime = 0;
    }
  };
}();

/**
 * Check if dropping at the current event position would actually result in
 * operations that would change the list.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} list A DOM node marked up as a list.
 * @param {string} location The location of the cursor in relation to the list.
 *     This can be either 'inside' or 'below'. The value 'below' means that the
 *     cursor was below the last list found in the DOM.
 *
 * @return {boolean} True if it would result in a change.
 */
function validatePotentialOperations(event, list, location) {
  // get a cached version of the selectionState
  var selectionState = cachedSelectionState.get();

  // Dropping inside the only selected range inside the only container that
  // has a selection is not allowed, as that would result in no change.
  if (selectionState.length === 1) {

    // Dropping inside a different context is always fine
    var contextUri = list.getAttribute('data-uri');
    if (contextUri !== selectionState[0].uri) {
      return true;
    }

    var selectedRanges = Range.fromIndices(selectionState[0].indicesWithHidden);

    if (selectedRanges.length === 1) {
      var selectedRange = selectedRanges[0];

      // Include the next row in the selected range to handle holding on the
      // top part of the next row, which would be a no-op. The bottom part of
      // the previous row will be taken care of by the code below.
      selectedRange.update(selectedRange.start, selectedRange.end + 1);

      var rowNode = location === 'below' ? getLastRowFromLastList() : getRowNode(event);
      if (rowNode) {
        var targetIndex = getTargetIndex(event.clientY, rowNode);
        if (targetIndex > -1) {
          var targetRange = new Range(targetIndex, targetIndex + 1);

          // If the target index is inside the selected range, it's not allowed
          // to drop, as that would be a no-op.
          if (targetRange.contained(selectedRange)) {
            return false;
          }
        }
      }
    }
  }

  return true;
}

/**
 * Get the drop target element that is matching the event target and the drag
 * MIME types of the event. This will start with the event target and step
 * outwards in the DOM tree to find the first matching element.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {HTMLElement?} The element or null if not found.
 */
function getMatchingTarget(event) {
  var currentNode = event.target;

  while (currentNode) {
    if (isMatchingTarget(event, currentNode)) {
      return currentNode;
    }
    currentNode = currentNode.parentElement;
  }

  return null;
}

/**
 * Get the list element that is matching the event target and the drag MIME
 * types of the event. This will start with the event target and step outwards
 * in the DOM tree to find the first matching element.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {HTMLElement?} The list element or null if not found.
 */
function getMatchingListTarget(event) {
  var currentNode = event.target;

  while (currentNode) {
    var isList = $(currentNode).matches(SELECTOR_LIST);
    if (isList && isMatchingTarget(event, currentNode)) {
      return currentNode;
    }
    currentNode = currentNode.parentElement;
  }

  return null;
}

/**
 * Get a valid list target from the end of body.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {HTMLElement?} The list element or null if not found.
 */
function getListTargetFromBody(event) {
  var lastList = getLastListNode();
  if (lastList) {
    var sameParent = event.target.contains(lastList);
    if (sameParent && isMatchingTarget(event, lastList)) {
      if (isBelowNode(event.clientX, event.clientY, lastList)) {
        return lastList;
      }
    }
  }

  return null;
}

/**
 * Get the list row element from the event target.
 * If the event target itself isn't a list row, it will step out in the parent
 * tree until it finds a row.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {HTMLElement?} The list row element, or null if not found.
 */
function getRowNode(event) {
  return event.target.closest(SELECTOR_LIST_ITEM);
}

/**
 * Get the last list row from the last list in the DOM.
 *
 * @return {HTMLElement?} The list row element, or null if not found.
 */
function getLastRowFromLastList() {
  var lastList = getLastListNode();
  if (lastList) {
    var listItems = $(lastList).search(SELECTOR_LIST_ITEM);
    var lastItem = listItems && listItems[listItems.length - 1];
    if (lastItem) return lastItem;
  }

  return null;
}

/**
 * Get the last list in the DOM.
 *
 * @return {HTMLElement?} The list element, or null if not found.
 */
function getLastListNode() {
  var lists = $(SELECTOR_LIST);
  var lastList = lists && lists[lists.length - 1];
  return lastList || null;
}

/**
 * Get the target index based on a cursor position and the row that the cursor
 * is on.
 *
 * @param {number} y The Y position relative to the viewport.
 * @param {HTMLElement} rowNode The DOM node for the row.
 *
 * @return {number} The target index or -1 if not found.
 */
function getTargetIndex(y, rowNode) {
  var index = rowNode.getAttribute('data-index');

  if (index === null) {
    index = -1;
  } else {
    index = parseInt(index, 10);

    if (isNaN(index)) {
      index = -1;
    } else {
      // If cursor is in the bottom part of the row, dropping will place items
      // after the row, so we need to increment the index.
      if (isBelowMiddleOfNode(y, rowNode)) {
        index++;
      }
    }
  }

  return index;
}

/**
 * Get the indices of the rows to move.
 *
 * @param {string} contextUri The context URI.
 * @param {LiveList} liveList The live list to be changed.
 *
 * @return {Array.<number>} Array of indices.
 */
function getMoveIndices(contextUri, liveList) {
  // As we need the indices, we must use the current selection state,
  // since the list might have changed since the start of the drag.
  // We are only in this function if we are dragging in the same
  // context, so the current selection state will always be valid.
  var selectionState = selection.getIndicesPerList();
  if (selectionState.length !== 1) return [];

  var firstContainer = selectionState[0];
  var selectedIndices = firstContainer.indices;
  var indices = selectedIndices.slice();

  if (indices.length === 0) return [];

  hooks.run('get-move-indices', contextUri, liveList, indices);

  // The indices must be sorted for the utility that creates the list operations
  indices.sort(function (a, b) {
    return a - b;
  });

  return indices;
}

/**
 * Get the values to use for insertion in the list. This will get the event data
 * for the matching MIME types.
 *
 * @param {MouseEvent} event A drop event.
 * @param {HTMLElement} list The list DOM node.
 * @param {LiveList} liveList The live list for the context.
 * @param {string} contextUri The context URI for the list.
 * @param {Function} callback A callback function. The data argument will be an
 *     array of object values.
 */
function getInsertValues(event, list, liveList, contextUri, callback) {
  var eventTypes = event.dataTransfer.types;
  var listTypes = list.getAttribute(ATTR_TARGET);
  if (!listTypes) {
    callback(null, []);
    return;
  }

  var matchingTypes = intersection(listTypes.split('|'), eventTypes);
  if (matchingTypes.length === 0) {
    callback(null, []);
    return;
  }

  var data = getDataFromTypes(event, matchingTypes);

  var isTrackList = isListOfTracks(liveList, contextUri);

  getRowsFromData(data, isTrackList, function (error, rows) {
    if (error) {
      callback(error);
      return;
    }

    callback(null, rows);
  });
}

/**
 * Get the event data associated with the provided MIME types.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {Array.<string>} types Array of MIME types.
 *
 * @return {Object.<string, Array>} Object where key is MIME type and value is
 *     array of values (URIs).
 */
function getDataFromTypes(event, types) {
  var data = {};

  for (var i = 0, l = types.length; i < l; i++) {
    var type = types[i];
    var itemsInData = data[type] = [];

    // A MIME type that starts with text/x-spotify is always containing a list
    // of Open URLs separated by '\n'.
    var hasURIs = type.indexOf('text/x-spotify') === 0;

    var dataForType = event.dataTransfer.getData(type);
    var items = hasURIs ? dataForType.split('\n') : [dataForType];
    for (var n = 0, len = items.length; n < len; n++) {
      var item = items[n];
      if (hasURIs) {
        var uriObject = liburi.from(item);
        if (uriObject) {
          itemsInData.push(uriObject.toURI());
        }
      } else {
        itemsInData.push(item);
      }
    }
  }

  return data;
}

/**
 * Get list row data from the event data. This might expand items if the list
 * is a track list (dropping an album into a track list will expand the album
 * into its tracks and return track rows instead).
 *
 * @param {Object.<string, Array>} data Data from drop event.
 * @param {boolean} isTrackList True if the list is a track list.
 * @param {Function} callback A callback function. The data argument will be an
 *     array of object values.
 */
function getRowsFromData(data, isTrackList, callback) {
  var promised = [];

  if (data['text/x-spotify-tracks']) {
    promised.push(getRowObjects('track', data['text/x-spotify-tracks']));
  }

  if (data['text/x-spotify-albums']) {
    var albums = data['text/x-spotify-albums'];
    if (isTrackList) {
      promised.push(fetchListTrackRows(albums));
    } else {
      promised.push(getRowObjects('album', albums));
    }
  }

  if (data['text/x-spotify-playlists']) {
    var playlists = data['text/x-spotify-playlists'];
    if (isTrackList) {
      promised.push(fetchListTrackRows(playlists));
    } else {
      promised.push(getRowObjects('playlist', playlists));
    }
  }

  if (data['text/x-spotify-artists']) {
    promised.push(getRowObjects('artist', data['text/x-spotify-artists']));
  }

  if (data['text/x-spotify-users']) {
    promised.push(getRowObjects('user', data['text/x-spotify-users']));
  }

  Promise.all(promised).then(function (arrays) {
    var rows = [];
    rows = rows.concat.apply(rows, arrays);
    callback(null, rows);
  }, function (error) {
    callback(error);
  });
}

/**
 * Fetch the track rows from a set of list URIs. This is for the expansion of
 * for example an album into the tracks of the album.
 *
 * @param {Array.<string>} listUris Array of list URIs.
 */
function fetchListTrackRows(listUris) {
  var promised = listUris.map(function (listUri) {
    return new Promise(function (resolve, reject) {
      live(listUri).query('rows(track(uri))', function (error, data) {
        if (error) {
          reject(error);
          return;
        }
        var rows = data.rows.map(function (row) {
          return live(row);
        });
        resolve(rows);
      }, live.ASAP);
    });
  });

  return Promise.all(promised).then(function (arrays) {
    var rows = [];
    rows = rows.concat.apply(rows, arrays);
    return rows;
  });
}

/**
 * Fetch the live object for the row of an item.
 *
 * @param {string} itemType The type of an item (for example 'track').
 * @param {Array.<string>} uris Array of item URIs.
 *
 * @return {Array.<LiveObject>} Array of row live objects.
 */
function getRowObjects(itemType, uris) {
  return uris.map(function (uri) {
    var row = {};
    row[itemType] = { uri: uri };
    return live(row);
  });
}

/**
 * Check if the list is a track list.
 *
 * @param {LiveList} liveList The live list.
 * @param {string} contextUri The context URI for the list.
 *
 * @return {boolean} True if the list is a track list.
 */
function isListOfTracks(liveList, contextUri) {
  var uriObject = liburi.from(contextUri);
  var type = uriObject && uriObject.type;
  if (type === liburi.Type.PLAYLIST) return true;

  var result = { valid: false };
  hooks.run('is-list-of-tracks', result, liveList, contextUri);

  if (!result.valid) {
    var firstRow = liveList.get(0);
    var firstTrack = firstRow && firstRow.get('track');
    if (firstTrack) return true;
  }

  return !!result.valid;
}

/**
 * Check if the position is below the bottom edge of the node.
 *
 * @param {number} x The X position relative to the viewport.
 * @param {number} y The Y position relative to the viewport.
 * @param {HTMLElement} node DOM node to check against.
 *
 * @return {boolean} True if the position is below.
 */
function isBelowNode(x, y, node) {
  var rect = node.getBoundingClientRect();
  var below = y >= rect.bottom;
  var betweenX = x >= rect.left && x <= rect.right;
  return below && betweenX;
}

/**
 * Check if the position is below the middle of the node.
 *
 * @param {number} y The Y position relative to the viewport.
 * @param {HTMLElement} node DOM node to check against.
 *
 * @return {boolean} True if the position is below.
 */
function isBelowMiddleOfNode(y, node) {
  var rect = node.getBoundingClientRect();
  return y >= rect.top + rect.height / 2;
}

/**
 * Check if the MIME types in the drag event matches the MIME types for the
 * specified drop target.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} node A DOM node.
 *
 * @return {boolean} True if the element matches the event.
 */
function isMatchingTarget(event, node) {
  var eventTypes = event.dataTransfer.types;
  var nodeTypes = node.getAttribute(ATTR_TARGET);

  if (nodeTypes) {
    var matching = intersection(nodeTypes.split('|'), eventTypes);
    if (matching.length > 0) return true;
  }

  return false;
}

/**
 * Temporarily disable drag and dropping inside a list until the move or insert
 * is done. This is to prevent multiple operations to be called before the
 * response from the first comes back. We consider the operation done when we
 * receive the next update event, since it's very tricky to know when this
 * specific move is done. To prevent possible errors with being disabled
 * infinitely, we will enable it again after a certain timeout. This could
 * happen for example if the live list is switched out for a new list, in which
 * case we won't get the update event.
 *
 * @param {string} contextUri The context URI.
 * @param {LiveList} liveList The live list that was changed.
 */
function temporarilyDisableList(contextUri, liveList) {

  disabledLists[contextUri] = true;

  var timer;

  var handler = function handler() {
    clearTimeout(timer);
    liveList.off('update', handler);

    // Wait slighly longer to allow the change to trickle down to DOM
    setTimeout(function () {
      delete disabledLists[contextUri];
    }, 100);
  };

  liveList.on('update', handler);

  timer = setTimeout(handler, 500);
}

/**
 * Attach the module.
 */
function attach() {
  eventModel.delegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.delegate('dragover', SELECTOR_LIST_TARGET, onDragOver);
  eventModel.delegate('dragleave', SELECTOR_LIST_TARGET, onDragLeave);
  eventModel.delegate('dragend', 'body', onDragEnd);
  eventModel.delegate('drop', SELECTOR_LIST_TARGET, onDrop);
}

/**
 * Detach the module.
 */
function detach() {
  eventModel.undelegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.undelegate('dragover', SELECTOR_LIST_TARGET, onDragOver);
  eventModel.undelegate('dragleave', SELECTOR_LIST_TARGET, onDragLeave);
  eventModel.undelegate('dragend', 'body', onDragEnd);
  eventModel.undelegate('drop', SELECTOR_LIST_TARGET, onDrop);
}

exports.attach = attach;
exports.detach = detach;

},{"../../../libs/spotify-live-list-operations":461,"../../spotify-elements":231,"../../spotify-live":512,"../../spotify-range2":551,"../selection":297,"./util/eventmodel":253,"./util/hooks":254,"mout/array/intersection":661,"spotify-liburi":899}],252:[function(require,module,exports){
(function (global){
/**
 * @module spotify-events/dragndrop/target
 * @private
 */
'use strict';

var $ = require('../../spotify-elements');
var liburi = require('spotify-liburi');
var defer = require('../../../libs/prime/defer');

var center = require('../center');
var eventModel = require('./util/eventmodel');
var hooks = require('./util/hooks');
var getLogContext = require('../util/get-log-context');
var UserDragAndDropInteraction1 = require('../../spotify-logger/messages/UserDragAndDropInteraction1');

var SELECTOR_DROP_TARGET = '[data-drop-target]';
var SELECTOR_DRAGGABLE = 'a, [draggable]';
var ATTR_TARGET = 'data-drop-target';
var ATTR_NO_CLASSNAME = 'data-drop-no-classname';
var CLASSNAME_ACTIVE = 'drop-target-active';

var longHoldTimerId = 0;
var longHoldTimerDuration = 1000;
var draggedElement = null;
var lastEnteredElement = null;

/**
 * Handler for starting to drag.
 *
 * @param {MouseEvent} event A dragstart event object.
 * @param {HTMLElement} node The draggable DOM element.
 */
function onDragStart(event, node) {
  draggedElement = node;
  lastEnteredElement = null;
}

/**
 * Handler for ending a drag.
 */
function onDragEnd() {
  draggedElement = null;
  lastEnteredElement = null;

  stopLongHoldTimer();
  removeAnyActiveClass();
}

/**
 * Handler for dragging into a drop target.
 *
 * @param {MouseEvent} event A dragenter event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDragEnter(event, target) {
  if (validateTarget(event, target)) {
    setEnter(event, target);
  }
}

/**
 * Handler for dragging out from a drop target.
 *
 * @param {MouseEvent} event A dragleave event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDragLeave(event, target) {
  if (validateTarget(event, target)) {
    setLeave(event, target);
  }
}

/**
 * Handler for dragging over a drop target.
 *
 * @param {MouseEvent} event A dragover event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDragOver(event, target) {
  if (validateTarget(event, target)) {

    // Tell the event that we are accepting drops on this target
    event.preventDefault();

    // Since other code might have set the dropEffect to something else,
    // we need to override that, since we're now accepting drops
    event.dataTransfer.dropEffect = 'copy';

    setEnter(event, target);

    // If the target is not valid, remove any styling for active drop target
  } else {
    setLeave(event, target);
  }
}

/**
 * Handler for dropping on a drop target.
 *
 * @param {MouseEvent} event A drop event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDrop(event, target) {
  stopLongHoldTimer();

  // Dropping should remove active target class name.
  // Dropping outside of a target doesn't need this, as the target is only
  // active when hovering it.
  removeAnyActiveClass();

  if (validateTarget(event, target)) {
    var types = getMimeTypesForTarget(event, target);
    var dropData = getDropData(event, types);
    var sourceUri = event.dataTransfer.getData('text/x-spotify-data-context') || null;
    var sourceLogContext = event.dataTransfer.getData('text/x-spotify-data-log-context') || null;
    var sourceAppUri = event.dataTransfer.getData('text/x-spotify-data-app-uri') || null;
    var sourceIndex = parseInt(event.dataTransfer.getData('text/x-spotify-data-log-source-index'), 0);
    if (isNaN(sourceIndex)) sourceIndex = null;

    var targetUriNode = target.closest('[data-uri]');
    var targetUri = targetUriNode && targetUriNode.getAttribute('data-uri') || null;
    var targetLogContext = getLogContext(target);
    var targetAppUri = global.__spotify && global.__spotify.app_uri || null;

    // Give any other delegates a chance to handle the drop, and if so pass
    // that info along in the event.
    defer.immediate(function () {
      center.emit('drop', {
        handled: event.handled,
        node: target,
        sourceUri: sourceUri,
        targetUri: targetUri,
        data: dropData
      });

      var firstItem = dropData[Object.keys(dropData)[0]][0];
      var itemType = liburi.from(firstItem).type;
      var numberOfItems = Object.keys(dropData).reduce(function (sum, key) {
        return sum + dropData[key].length;
      }, 0);
      var targetIndex = event.data && event.data.targetIndex || null;

      UserDragAndDropInteraction1.log({
        item_type: itemType,
        item_uri: firstItem,
        number_items: numberOfItems,
        source_view_uri: sourceAppUri,
        source_uri: sourceUri,
        source_index: sourceIndex,
        source_component: sourceLogContext,
        target_view_uri: targetAppUri,
        target_uri: targetUri,
        target_index: targetIndex,
        target_component: targetLogContext
      });
    });
  }

  // Prevent navigation on drop
  event.preventDefault();

  // Reset here since our multi-frame architecture means we're not guaranteed
  // to have gotten a dragstart event in this frame prior to dropping.
  lastEnteredElement = null;
}

/**
 * Set target to be entered, including setting style and sending event.
 *
 * @param {MouseEvent} event A dragenter event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function setEnter(event, target) {
  if (target === lastEnteredElement) {
    return;
  }

  lastEnteredElement = target;

  if (!target.hasAttribute(ATTR_NO_CLASSNAME)) {
    $(target).addClass(CLASSNAME_ACTIVE);
  }

  var types = getMimeTypesForTarget(event, target);
  center.emit('dragenter', { node: target, types: types });

  startLongHoldTimer(target, types);
}

/**
 * Set target to be left, including removing style and sending event.
 *
 * @param {MouseEvent} event A dragleave event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function setLeave(event, target) {
  if (target !== lastEnteredElement) {
    return;
  }

  lastEnteredElement = null;

  if (!target.hasAttribute(ATTR_NO_CLASSNAME)) {
    $(target).removeClass(CLASSNAME_ACTIVE);
  }

  var types = getMimeTypesForTarget(event, target);
  center.emit('dragleave', { node: target, types: types });

  stopLongHoldTimer();
}

/**
 * Check if the drop target matches the MIME types for the event.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} target DOM element for the drop target.
 *
 * @return {boolean} True if the target is valid.
 */
function validateTarget(event, target) {

  // The element being dragged is not accepted as a drop target
  if (target === draggedElement) {
    return false;
  }

  var types = getMimeTypesForTarget(event, target);

  if (types.length) {
    var result = { valid: true };
    hooks.run('target-validation', result, event, target);

    if (result.valid) {
      return true;
    }
  }

  return false;
}

/**
 * Get the data associated with the drop, grouped by MIME type.
 * If the data contained Spotify URLs, they will be converted to Spotify URIs.
 *
 * @param {MouseEvent} event Event object for a drop event.
 * @param {Array.<string>} types Array of MIME types.
 *
 * @return {Object.<string, Array.<string>>} Data object of arrays of item
 *     URIs, grouped by MIME type.
 */
function getDropData(event, types) {
  var data = {};

  for (var i = 0, l = types.length; i < l; i++) {
    var itemsInData = data[types[i]] = [];
    var dataForType = event.dataTransfer.getData(types[i]);
    var hasURIs = types[i].indexOf('text/x-spotify') === 0;
    var items = hasURIs ? dataForType.split('\n') : [dataForType];

    for (var n = 0, len = items.length; n < len; n++) {
      var item = items[n];
      if (hasURIs) {
        var uriObject = liburi.from(item);
        if (uriObject) item = uriObject.toURI();
      }
      if (item) itemsInData.push(item);
    }
  }

  var hasContextData = types.indexOf('text/x-spotify-data-context') > -1;
  if (hasContextData) {
    data['text/x-spotify-data-context'] = [event.dataTransfer.getData('text/x-spotify-data-context')];
  }

  return data;
}

/**
 * Start a timer for emitting an event for long-hold on a target.
 * If one is already started, it will use the previous timer and not restart it.
 *
 * @param {HTMLElement} target A DOM element for the drop target.
 * @param {Array.<string>} types Array of MIME types.
 */
function startLongHoldTimer(target, types) {

  // Don't start a new timer if we already have one running
  if (longHoldTimerId) return;

  longHoldTimerId = setTimeout(function () {
    center.emit('dragover-long', { node: target, types: types });
  }, longHoldTimerDuration);
}

/**
 * Stop any running timer for emitting an event for long-hold on a target.
 */
function stopLongHoldTimer() {
  clearTimeout(longHoldTimerId);

  // Reset the timer ID so we can know that there is no timer running
  longHoldTimerId = 0;
}

/**
 * Remove the active class name from any element that has it.
 */
function removeAnyActiveClass() {
  var active = $('.' + CLASSNAME_ACTIVE);
  if (active) {
    active.removeClass(CLASSNAME_ACTIVE);
  }
}

/**
 * Get the MIME types that are matching both the drag event and the target.
 *
 * @param {MouseEvent} event Any kind of drag and drop event.
 * @param {HTMLElement} target A DOM element.
 *
 * @return {Array.<string>} Array of MIME types.
 */
function getMimeTypesForTarget(event, target) {
  var mimeTypes = [];
  var dataTypes = event.dataTransfer.types;

  var targetTypes = target.getAttribute(ATTR_TARGET);
  if (targetTypes) {
    targetTypes = targetTypes.split('|');

    for (var i = 0, l = dataTypes.length; i < l; i++) {
      var type = dataTypes[i];
      if (targetTypes.indexOf(type) > -1) {
        mimeTypes.push(type);
      }
    }
  }

  return mimeTypes;
}

/**
 * Attach the module.
 */
function attach() {
  eventModel.delegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.delegate('dragenter', SELECTOR_DROP_TARGET, onDragEnter);
  eventModel.delegate('dragleave', SELECTOR_DROP_TARGET, onDragLeave);
  eventModel.delegate('dragover', SELECTOR_DROP_TARGET, onDragOver);
  eventModel.delegate('dragend', 'body', onDragEnd);
  eventModel.delegate('drop', SELECTOR_DROP_TARGET, onDrop);
}

/**
 * Detach the module.
 */
function detach() {
  eventModel.undelegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.undelegate('dragenter', SELECTOR_DROP_TARGET, onDragEnter);
  eventModel.undelegate('dragleave', SELECTOR_DROP_TARGET, onDragLeave);
  eventModel.undelegate('dragover', SELECTOR_DROP_TARGET, onDragOver);
  eventModel.undelegate('dragend', 'body', onDragEnd);
  eventModel.undelegate('drop', SELECTOR_DROP_TARGET, onDrop);
}

exports.attach = attach;
exports.detach = detach;

// Exporting for testing
var originalDuration = longHoldTimerDuration;
exports.setLongHoldDuration = function setLongHoldDuration(duration) {
  longHoldTimerDuration = duration;
};
exports.resetLongHoldDuration = function resetLongHoldDuration() {
  longHoldTimerDuration = originalDuration;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../libs/prime/defer":220,"../../spotify-elements":231,"../../spotify-logger/messages/UserDragAndDropInteraction1":530,"../center":242,"../util/get-log-context":312,"./util/eventmodel":253,"./util/hooks":254,"spotify-liburi":899}],253:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop/util/eventmodel
 * @private
 *
 * This module is made to be an abstraction of the event model for drag and
 * drop. It also exposes a delegation interface which allows you to only
 * listen for events for targets matching a certain selector.
 *
 * The need for this abstraction is to simplify the code listening to drag
 * and drop events.
 *
 * - The raw events we get from the browser are sometimes not that easy to
 *   work with. For example, when moving from one target to another, we get
 *   a dragenter event before the dragleave event, which can cause confusion.
 *   This abstraction flips that around, so that you always get the dragleave
 *   event before the dragenter event.
 *
 * - The raw events also trigger for children. For example, if moving the
 *   cursor from one element to one of its children, we get a dragenter event
 *   for the child element and a dragleave for the outer element. This makes
 *   it difficult to highlight drop targets based on dragenter/dragleave.
 *   This abstraction helps by making sure the handler is not called if moving
 *   to a child element inside an element that matches the selector. There
 *   is an exception though when moving to a child that is also matching a
 *   selector, the outer element is then left and the child is entered.
 *
 * @example
 * function onDragEnter(event, target) {
 *   event instanceof MouseEvent; // true
 *   target instanceof HTMLElement; // true
 *   target.matches('[data-drop-target]'); // true
 * }
 *
 * // Start listening
 * eventmodel.delegate('dragenter', '[data-drop-target]', onDragEnter);
 *
 * // Stop listening
 * eventmodel.undelegate('dragenter', '[data-drop-target]', onDragEnter);
 */
'use strict';

var $ = require('../../../spotify-elements');

var attached = {};
var delegations = {};
var movementHandlerCount = 0;

// State variables
var hasEntered = false;
var lastEnteredElement = null;
var lastEnterTarget = null;
var lastEnterEvent = null;
var wasLastEventEnter = false;

/**
 * Reset the temporary state variables used while dragging.
 */
function resetState() {
  hasEntered = false;
  lastEnteredElement = null;
  lastEnterTarget = null;
  lastEnterEvent = null;
  wasLastEventEnter = false;
}

/**
 * Generic handler for any event.
 * This function will look at the current delegations and run the handler
 * functions for the matching delegations.
 * Some events will be handled by calling a special handler, which in some cases
 * later will check for matching delegations.
 *
 * @param {Event} event Event object.
 */
function onEvent(event) {
  var handler = getPrimaryHandler(event.type);
  if (handler) {
    handler(event);
  } else {
    handleDelegationsForEvent(event);
  }
}

/**
 * Handler for a dragenter event.
 * Depending on state, this might save the event for later and call the
 * handler at a later point, to ensure that the dragenter event is sent
 * after the dragleave.
 *
 * @param {MouseEvent} event Event object for a dragenter event.
 */
function onPrimaryDragEnter(event) {
  wasLastEventEnter = true;

  if (hasEntered) {
    if (lastEnteredElement !== event.target) {
      lastEnterEvent = event;
    }
  } else {
    hasEntered = true;
    lastEnteredElement = event.target;
    handleDelegationsForEvent(event);
  }
}

/**
 * Handler for a dragleave event.
 * Depending on state, this might also trigger the handlers for a dragenter
 * event, if there was a saved event from before.
 *
 * @param {MouseEvent} event Event object for a dragleave event.
 */
function onPrimaryDragLeave(event) {
  wasLastEventEnter = false;
  lastEnteredElement = null;

  handleDelegationsForEvent(event);

  if (hasEntered) {
    if (lastEnterEvent) {
      lastEnteredElement = lastEnterEvent.target;
      handleDelegationsForEvent(lastEnterEvent);
      lastEnterEvent = null;
    } else {
      hasEntered = false;
    }
  }
}

/**
 * Handler for a drop event.
 * This is handled by a special handler only to reset some state.
 *
 * @param {MouseEvent} event Event object for a drop event.
 */
function onPrimaryDrop(event) {
  resetState();
  handleDelegationsForEvent(event);
}

/**
 * Handler for a dragend event.
 * This is handled by a special handler only to reset some state.
 *
 * @param {MouseEvent} event Event object for a drop event.
 */
function onPrimaryDragEnd(event) {
  resetState();
  handleDelegationsForEvent(event);
}

/**
 * Delegation handler for a dragenter event.
 * After matching against stored delegations, we need to do some final checking
 * before calling the user handler.
 *
 * @param {MouseEvent} event Event object for a dragenter event.
 * @param {HTMLElement} target A DOM element.
 * @param {Function} handler The user handler.
 */
function onDragEnter(event, target, handler) {
  if (target !== lastEnterTarget) {
    lastEnterTarget = target;
    callUserHandler(event, target, handler);
  }
}

/**
 * Delegation handler for a dragleave event.
 * After matching against stored delegations, we need to do some final checking
 * before calling the user handler.
 *
 * @param {MouseEvent} event Event object for a dragleave event.
 * @param {HTMLElement} target A DOM element.
 * @param {Function} handler The user handler.
 * @param {string} selector A CSS selector string.
 */
function onDragLeave(event, target, handler, selector) {
  var shouldCallUserHandler = false;

  var lastElement = lastEnterEvent && lastEnterEvent.target;
  if (lastElement) {
    var isSameElement = target === lastElement;
    var isEnteringChild = !isSameElement && target.contains(lastElement);
    var isEnteringMatchingElement = $(lastElement).matches(selector);
    if (!isSameElement && (!isEnteringChild || isEnteringMatchingElement)) {
      shouldCallUserHandler = true;
    }
  }

  // Most often the sequence of events will be dragenter->dragenter->dragleave
  // when moving into one element and then into another element. But if the
  // sequence is just dragenter->dragleave, we should also call the user
  // handler. This would happen if there is no new entered element.
  if (!wasLastEventEnter) {
    shouldCallUserHandler = true;
  }

  if (shouldCallUserHandler) {
    lastEnterTarget = null;
    callUserHandler(event, target, handler);
  }
}

/**
 * Find matching delegations and call the handlers.
 *
 * @param {Event} event Event object.
 */
function handleDelegationsForEvent(event) {
  var type = event.type;
  var delegationData = delegations[type];

  if (delegationData && delegationData.length > 0) {

    delegationData.forEach(function (data) {
      var selector = data.selector;
      var matchingTarget = event.target.closest(selector);

      if (matchingTarget) {
        var handler = getHandler(type) || callUserHandler;
        handler(event, matchingTarget, data.handler, selector);
      }
    });
  }
}

/**
 * Call the user handler for a delegation.
 *
 * @param {Event} event Event object.
 * @param {HTMLElement} target A DOM element.
 * @param {Function} handler The user handler.
 */
function callUserHandler(event, target, handler) {
  handler.call(exports, event, target);
}

/**
 * Get any handler that needs to be called for a raw event before looking
 * for any delegations.
 *
 * @param {string} type Event type.
 *
 * @return {Function?} The handler function or null if no special handler
 *     should be called.
 */
function getPrimaryHandler(type) {
  switch (type) {
    case 'dragenter':
      return onPrimaryDragEnter;
    case 'dragleave':
      return onPrimaryDragLeave;
    case 'dragend':
      return onPrimaryDragEnd;
    case 'drop':
      return onPrimaryDrop;
  }
  return null;
}

/**
 * Get any handler that needs to be called after matching delegations,
 * but before calling the user handler.
 *
 * @param {string} type Event type.
 *
 * @return {Function?} The handler function or null if no special handler
 *     should be called.
 */
function getHandler(type) {
  switch (type) {
    case 'dragenter':
      return onDragEnter;
    case 'dragleave':
      return onDragLeave;
  }
  return null;
}

/**
 * Check if the event type is one of the events that need special handling
 * for movement (enter/leave events).
 *
 * @param {string} type Event type.
 *
 * @return {boolean} True if the type is a movement type, false otherwise.
 */
function isMovementType(type) {
  switch (type) {
    case 'dragenter':
      return true;
    case 'dragleave':
      return true;
    case 'dragend':
      return true;
    case 'drop':
      return true;
  }
  return false;
}

/**
 * Attach a global event listener on document for the specified type.
 *
 * @param {string} type Event type.
 */
function attach(type) {
  if (attached[type]) return;
  attached[type] = true;
  document.addEventListener(type, onEvent, false);
}

/**
 * Detach a global event listener on document for the specified type.
 *
 * @param {string} type Event type.
 */
function detach(type) {
  if (!attached[type]) return;
  attached[type] = false;
  document.removeEventListener(type, onEvent, false);
}

/**
 * Start listening for an event via event delegation for the specified
 * selector.
 *
 * @example
 * var selector = '[data-drop-target]';
 * eventModel.delegate('dragenter', selector, function(event, target) {
 *   event instanceof MouseEvent; // true
 *   target instanceof HTMLElement; // true
 *   target.matches('[data-drop-target]'); // true
 * });
 */
function delegate(type, selector, handler) {
  if (isMovementType(type)) {
    movementHandlerCount++;
    if (movementHandlerCount === 1) {
      attach('dragenter');
      attach('dragleave');
      attach('dragend');
      attach('drop');
    }
  } else if (!attached[type]) {
    attach(type);
  }

  if (!delegations[type]) delegations[type] = [];

  delegations[type].push({ selector: selector, handler: handler });
}

/**
 * Stop listening for an event via event delegation for the specified
 * selector and handler.
 *
 * @example
 * eventModel.undelegate('dragenter', '[data-drop-target]', handler);
 */
function undelegate(type, selector, handler) {
  if (isMovementType(type)) {
    movementHandlerCount = Math.max(0, movementHandlerCount - 1);
    if (movementHandlerCount === 0) {
      detach('dragenter');
      detach('dragleave');
      detach('dragend');
      detach('drop');
    }
  }

  var delegationsForType = delegations[type];
  if (delegationsForType) {
    for (var i = 0, l = delegationsForType.length; i < l; i++) {
      var data = delegationsForType[i];
      if (data.selector === selector && data.handler === handler) {
        delegationsForType.splice(i, 1);
        break;
      }
    }

    if (!isMovementType && delegationsForType.length === 0) {
      detach(type);
    }
  }
}

exports.delegate = delegate;
exports.undelegate = undelegate;

},{"../../../spotify-elements":231}],254:[function(require,module,exports){
/**
 * Hooks
 *
 * Almost like an event emitter. You can add hooks for different ids, and when
 * a hook for an ID is run, the handlers are called.
 *
 * @module spotify-events/dragndrop/util/hooks
 * @private
 */
'use strict';

var hooks = {};

/**
 * Add a hook handler for a specific hook ID.
 *
 * @param {string} id The hook ID.
 * @param {function} handler The handler function. The hook sets the arguments.
 */
function add(id, handler) {
  if (!hooks[id]) hooks[id] = [];
  hooks[id].push(handler);
}

/**
 * Remove a hook handler for a specific hook ID.
 *
 * @param {string} id The hook ID.
 * @param {function} handler The handler function.
 */
function remove(id, handler) {
  if (hooks[id]) {
    var index = hooks[id].indexOf(handler);
    if (index > -1) {
      hooks[id].splice(index, 1);
    }
  }
}

/**
 * Run the hook handlers for a specific hook ID.
 *
 * @param {string} id The hook ID.
 */
function run(id) {
  var handlers = hooks[id];
  if (handlers && handlers.length > 0) {
    var args = Array.prototype.slice.call(arguments, 1);
    for (var i = 0, l = handlers.length; i < l; i++) {
      handlers[i].apply(null, args);
    }
  }
}

exports.add = add;
exports.remove = remove;
exports.run = run;

},{}],255:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop/util/itemtext
 * @private
 */
'use strict';

var live = require('../../../spotify-live');
var liburi = require('spotify-liburi');

/**
 * Get the text for a URI.
 *
 * @param {string} uri Any URI.
 *
 * @return {string} The text.
 */
function getForUri(uri) {
  var uriObject = liburi.from(uri);
  if (!uriObject) return '';

  var type = uriObject.type;

  if (type === liburi.Type.TRACK || type === liburi.Type.LOCAL) {
    return getForTrack(uri);
  } else if (type === liburi.Type.ARTIST || type === liburi.Type.LOCAL_ARTIST) {
    return getForArtist(uri);
  } else if (type === liburi.Type.ALBUM || type === liburi.Type.LOCAL_ALBUM) {
    return getForAlbum(uri);
  } else if (type === liburi.Type.PLAYLIST) {
    return getForPlaylist(uri);
  } else if (type === liburi.Type.USER || type === liburi.Type.PROFILE) {
    return getForUser(uri);
  } else if (type === liburi.Type.FOLDER) {
    return getForFolder(uri);
  } else if (type === liburi.Type.STATION) {
    return getForStation(uri);
  } else if (type === liburi.Type.EPISODE) {
    return getForEpisode(uri);
  }

  return '';
}

/**
 * Get the text for a track URI.
 *
 * Examples:
 * Track Name – First Artist, Second Artist, Third Artist (and so on...)
 * Track Name
 *
 * @param {string} uri Track URI.
 *
 * @return {string} The text.
 */
function getForTrack(uri) {
  var object = live(uri);
  var itemName = object.get('name');
  if (!itemName) return '';

  var artists = object.get('artists');
  if (!artists || artists.length === 0) return itemName;

  var artistNames = artists.get(0, artists.length).map(function (artist) {
    return artist.get('name');
  }).join(', ');
  if (!artistNames) return itemName;

  return separateDragTextItems(itemName, artistNames);
}

/**
 * Get the text for an artist URI.
 *
 * Examples:
 * Artist Name
 *
 * @param {string} uri Artist URI.
 *
 * @return {string} The text.
 */
function getForArtist(uri) {
  return live(uri).get('name') || '';
}

/**
 * Get the text for an album URI.
 *
 * Examples:
 * Artist Name – Album Name
 * Album Name
 *
 * @param {string} uri Album URI.
 *
 * @return {string} The text.
 */
function getForAlbum(uri) {
  var object = live(uri);
  var itemName = object.get('name');
  if (!itemName) return '';

  var artists = object.get('artists');
  if (!artists || artists.length === 0) return itemName;

  var artistName = artists.get(0).get('name');
  if (!artistName) return itemName;

  return separateDragTextItems(artistName, itemName);
}

/**
 * Get the text for a playlist URI.
 *
 * Examples:
 * Playlist Name – Owner Name
 * Playlist Name – owner_username
 * Playlist Name
 *
 * @param {string} uri Playlist URI.
 *
 * @return {string} The text.
 */
function getForPlaylist(uri) {
  var object = live(uri);
  var itemName = object.get('name');
  if (!itemName) return '';

  var owner = object.get('owner');
  var ownerName = owner && (owner.get('name') || owner.get('username'));
  if (!ownerName) return itemName;

  return separateDragTextItems(itemName, ownerName);
}

/**
 * Get the text for a playlist URI.
 *
 * Examples:
 * User Name
 * username
 *
 * @param {string} uri Playlist URI.
 *
 * @return {string} The text.
 */
function getForUser(uri) {
  var object = live(uri);
  var itemName = object.get('name');
  if (itemName) return itemName;

  var uriObject = liburi.fromString(uri);
  var username = uriObject && uriObject.username;
  return username || '';
}

/**
 * Get the text for a folder URI.
 *
 * Examples:
 * Folder Name
 *
 * @param {string} uri Folder URI.
 *
 * @return {string} The text.
 */
function getForFolder(uri) {
  return live(uri).get('name');
}

/**
 * Get the text for a station URI.
 *
 * Examples:
 * Station Name
 *
 * @param {string} uri Station URI.
 *
 * @return {string} The text.
 */
function getForStation(uri) {
  return live(uri).get('name');
}

/**
 * Get the text for a episode URI.
 *
 * Examples:
 * The Making of "Day of the Dead"
 *
 * @param {string} uri Episode URI.
 *
 * @return {string} The text.
 */
function getForEpisode(uri) {
  return live(uri).get('name');
}

/**
 * Separate two strings by the special dash ('en dash', &#8211;) we use.
 *
 * @param {string} item1 First string.
 * @param {string} item2 Second string.
 *
 * @return {string} Final string.
 */
function separateDragTextItems(item1, item2) {
  return item1 + ' – ' + item2;
}

/**
 * Get the text for an element.
 *
 * @param {HTMLElement} target The target element being dragged.
 *
 * @return {string} The drag text.
 */
function getForElement(target) {
  var title = target.getAttribute('data-drag-text');
  if (title) return title;

  var uri = target.getAttribute('data-uri');
  if (!uri) {
    var uriObject = liburi.from(target.getAttribute('href'));
    uri = uriObject ? uriObject.toURI() : '';
  }
  if (uri) {
    title = getForUri(uri);
    if (title) return title;
  }

  title = target.getAttribute('title');
  if (title) return title;

  return target.textContent;
}

exports.getForUri = getForUri;
exports.getForElement = getForElement;

},{"../../../spotify-live":512,"spotify-liburi":899}],256:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
var live = require('../spotify-live');
var center = require('./center');
var stickyEvents = require('./sticky');
var cosmos = require('./util/cosmos');
var merge = require('mout/object/merge');
var deepEquals = require('mout/lang/deepEquals');
var getOriginUri = require('../spotify-live-wrapped-uri').getOriginUri;
var appUtil = require('./util/app');

var SCROLL_PADDING = 8;
var STRING_FILTER_KEY = 'list-filter-string-';
var SESSION_STORAGE = 'spotify:session-storage';

function update(node) {
  if (!isAttached) return;

  node = $(node) || $(document);
  var nodes = node.matches('[data-filter]') ? [node[0]] : node.search('[data-filter]');
  if (!nodes) {
    return;
  }
  nodes.forEach(function (node) {
    var uri = getURI(node);
    if (!uri) {
      return;
    }

    // When no state is initialized for the uri, initialize it and set the string from the DOM.
    // This is the case when the playlist app loaded a URI that globally has a filter string set.
    var hasState = states[uri];
    if (!hasState) {
      var inputElement = $(node).find('input[type=text]')[0];
      var value = inputElement.value;
      if (value) {
        updateState(uri, {
          activated: true,
          enteredString: value
        });
      }
    }

    handleStale(uri);
  });
}

function handleStale(uri) {
  render(uri);
  logUsage(uri);

  var state = getState(uri);
  var stateHasBeenEmitted = deepEquals(state, lastEmittedStates[uri]);
  if (!stateHasBeenEmitted) {
    lastEmittedStates[uri] = state;
    var value = state.activated ? state.enteredString : '';
    emitFilterRequest(uri, value);
    persistFilterOnSessionStorage(uri, value);
  }
}

function render(uri) {
  var $candidateContainers = $(document).search('[data-uri] [data-filter]');
  if (!$candidateContainers) return;

  var $matchingCandidates = $candidateContainers.filter(function (container) {
    return getURI(container) === uri;
  });
  $matchingCandidates.forEach(function (mainElement) {
    var state = getState(uri);
    var inputElement = $(mainElement).find('input[type=text]')[0];
    var wrapperElement = $(mainElement).find('.h-search-wrapper')[0];
    if (state.activated) {
      if (!$(wrapperElement).hasClass('focus')) {
        $(wrapperElement).addClass('focus');

        mainElement.setAttribute('data-sticky', '');
        stickyEvents.update();
      }

      // NOTE: Setting input.value makes the cursor jump
      // which is annoying when changing typos in the
      // search field. Only set value if text ACTUALLY
      // changes:
      if (inputElement.value !== state.enteredString) {
        inputElement.value = state.enteredString;
      }
    } else {
      inputElement.blur();
      if ($(wrapperElement).hasClass('focus')) {
        $(wrapperElement).removeClass('focus');

        mainElement.removeAttribute('data-sticky');
        stickyEvents.update();
      }
      inputElement.value = '';
    }
  });
}

function focusAndSelectInput(inputElement) {

  // Only focus and select the input text if doesn't have focus already.
  if (document.activeElement !== inputElement) {
    inputElement.focus();
    inputElement.select();
  }
}

function scrollIntoView(inputElement) {
  var rect = inputElement.getBoundingClientRect();

  // Only scroll if the input is out of view
  var filterFieldOffset = rect.top - SCROLL_PADDING;
  if (filterFieldOffset < 0 || rect.bottom > window.innerHeight) {
    window.scrollTo(0, window.pageYOffset + filterFieldOffset);
  }
}

function logUsage(uri) {
  var state = getState(uri);
  if (state.enteredString && !getState(uri).usageLogged) {
    updateState(uri, { usageLogged: true });
    // Fields must be in the same order as in logparser
    // AND all fields MUST be present or logging wont happen
    // and will fail silently. https://ghe.spotify.net/datainfra/log-parser/blob/94e6a896efa5d781b0cac54f3dcf92c9c4ee3c73/spotify/log_parser/messages_specs.py#L777

    cosmos.post({
      url: 'sp://logging/v1/log',
      body: {
        'message': 'ClientEvent',
        'version': 3,
        'fields': [window.__spotify.app_uri, // source
        'spotify-events-filter', // context
        'user:typing', // event
        'input-field', // event-version
        '', // test-version
        '', // source-version
        '', // source-vendor
        '' // json-data
        ]
      }
    });
  }
}

function emitFilterRequest(uri, value) {
  center.emit('filter-request', uri, value);
}

function persistFilterOnSessionStorage(uri, value) {
  uri = getOriginUri(uri) || uri;

  var key = STRING_FILTER_KEY + uri;
  var publish = {};
  publish[key] = value;
  live(SESSION_STORAGE).publish(publish);
}

function handleCancelClick(e) {
  clear(getURI(e.target));
}

function handleInputInput(e) {
  updateState(getURI(e.target), { enteredString: e.target.value });
}

function handleInputKeyup(e) {
  var isEscape = e.keyCode === 27;
  if (isEscape) {
    clear(getURI(e.target));
  }
}

function handleInputFocus(e) {
  updateState(getURI(e.target), { activated: true });
}
function handleInputFocusOut(e) {
  var state = getState(getURI(e.target));
  if (state.enteredString === '') {
    updateState(getURI(e.target), { activated: false });
  }
}

function clear(uri) {
  updateState(uri, { activated: false, enteredString: '' });
}

function getState(uri) {
  return states[uri] || {
    activated: false,
    enteredString: ''
  };
}

function updateState(uri, update) {
  states[uri] = merge(getState(uri), update);
  handleStale(uri);
}

function getURI(element) {
  var uri = element.getAttribute('data-uri');
  if (!uri) {
    var parents = $(element).parents('[data-uri]');
    if (parents) {
      uri = parents[0].getAttribute('data-uri');
    }
  }
  uri = getOriginUri(uri) || uri;

  // We use the data-uri as a key for state, but the uri of the
  // container might change to the "sorted" versions of the
  // original uri. From a filter UX state standpoint, these are the
  // same, so we normalize it here.
  return uri || null;
}

var states;
var lastEmittedStates;

var isAttached = false;
var controlMessageSubscription;
var attach = function attach() {
  if (isAttached) {
    return;
  }
  isAttached = true;
  states = {};
  lastEmittedStates = {};
  controlMessageSubscription = cosmos.subscribe({
    url: 'sp://messages/v1/container/control'
  }, function (_, response) {
    if (!appUtil.isActive()) return;

    var isMessageOfTypeFind = response && response.body && response.body.type === 'filter';
    if (!isMessageOfTypeFind) return;
    $('[data-filter]').forEach(function (mainElement, i) {
      updateState(getURI(mainElement), {
        activated: true
      });

      var inputElement = $(mainElement).find('input[type=text]')[0];
      if (inputElement) {

        // Only scroll first filter into view.
        if (i === 0) {
          scrollIntoView(inputElement);
        }

        focusAndSelectInput(inputElement);
      }
    });
  });

  center.on('filter-reset', clear);

  $(document).delegate('click', '[data-filter] .h-search-close', handleCancelClick);
  $(document).delegate('click', '[data-filter-reset]', handleCancelClick);
  $(document).delegate('input', '[data-filter] input', handleInputInput);
  $(document).delegate('keyup', '[data-filter] input', handleInputKeyup);
  $(document).delegate('focusin', '[data-filter] input', handleInputFocus);
  $(document).delegate('focusout', '[data-filter] input', handleInputFocusOut);
};

var detach = function detach() {
  if (!isAttached) return;
  states = null;
  controlMessageSubscription.cancel();

  center.off('filter-reset', clear);

  $(document).undelegate('click', '[data-filter] .h-search-close', handleCancelClick);
  $(document).undelegate('click', '[data-filter-reset]', handleCancelClick);
  $(document).undelegate('input', '[data-filter] input', handleInputInput);
  $(document).undelegate('keyup', '[data-filter] input', handleInputKeyup);
  $(document).undelegate('focusin', '[data-filter] input', handleInputFocus);
  $(document).undelegate('focusout', '[data-filter] input', handleInputFocusOut);
  isAttached = false;
};

// Tells native container that the current app can handle filter
// commands. Enables filter commands in the native menu,
// along with corresponding keyboard shortcuts.
var broadcast = function broadcast(enabled) {
  if (enabled === undefined) {
    throw new Error('broadcast requires enabled argument');
  }
  cosmos.post({
    url: 'sp://messages/v1/container/control',
    body: {
      type: 'update_menu_state',
      enable_filter_item: enabled
    }
  });
};

module.exports = {
  attach: attach,
  detach: detach,
  update: update,
  broadcast: broadcast
};

},{"../spotify-elements":231,"../spotify-live":512,"../spotify-live-wrapped-uri":511,"./center":242,"./sticky":303,"./util/app":309,"./util/cosmos":310,"mout/lang/deepEquals":673,"mout/object/merge":691}],257:[function(require,module,exports){
'use strict';

var _glue = require('../glue');

var _glue2 = _interopRequireDefault(_glue);

var _frameUpdater = require('../frame-updater');

var _cancellationTokenSource = require('../cancellation-token-source');

var _cancellationTokenSource2 = _interopRequireDefault(_cancellationTokenSource);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Export _-prefixed functions for unit tests. This is so that we don't have to
// repeat all the tests for the contents of these functions in all situations
// it's run in and lets us test the functions as units and test that the various
// situations call these functions.

var isAttached = false;
var isFontLoaded = false;
var useNewHeaders = false;
var topBarHeight = 0;
var headerHeight = 0;
var stickyHeight = 0;
var currentScrollY = 0;
var lastScrollY = 0;
var lastScrollYDiffs = [0, 0, 0, 0, 0];
var lastLoadedImageNode = null;
var scrollListenerId = 0;
var needsTitleSizeUpdate = true;
var lastUpdatedTitleNode = null;
var lastUpdatedTitleContent = '';
var fontPromise = null;
var cancellationTokenSource = null;
var frameRequestIds = [];
var lastHeaderNode = null;
var scrollNode = null;

exports._updateHeader = function _updateHeader() {
  var header = document.querySelector('[data-glue-page-header]');

  // Optimize to only run header updates when scrolling within the header area
  // at the top of the page, and also when the current scroll event is below the
  // header but the previous event was within the header.
  if (header !== lastHeaderNode || currentScrollY < headerHeight || lastScrollY < headerHeight) {
    lastHeaderNode = header;

    updateHeaderBackgroundPosition();
    updateHeaderAlphaMask();
    updateHeaderBackgroundScrollOverlay();
    updateHeaderBackgroundScrollOverlayEllipse();
    updateHeaderImageScaling();
  }
};

// This function runs first in each update cycle and sets variables scoped to
// the module. Ideally each function would just read the value it needs, but for
// performance reasons we do this once at the start of each update.
exports._updateHeaderSizes = function _updateHeaderSizes() {
  var header = document.querySelector('[data-glue-page-header]');
  if (header) {
    topBarHeight = parseInt(document.documentElement.getAttribute('data-new-headers-top-bar-height'), 10) || 0;
    headerHeight = header.offsetHeight;
    stickyHeight = parseInt(header.getAttribute('data-glue-page-header-sticky-height'), 10) || 0;
  } else {
    topBarHeight = 0;
    headerHeight = 0;
    stickyHeight = 0;
  }
};

function updateHeaderAlphaMask() {
  var headerContent = document.querySelector('[data-glue-page-header-content]');
  if (headerContent) {
    var maskHeight = 24;
    var offset1 = currentScrollY + topBarHeight;
    var offset2 = offset1 + maskHeight;

    headerContent.style.webkitMaskImage = 'linear-gradient(to bottom, transparent ' + offset1 + 'px, black ' + offset2 + 'px)';
  }
}

function updateHeaderBackgroundPosition() {
  var headerBackground = document.querySelector('[data-glue-page-header-background]');
  if (headerBackground) {
    var isSticky = currentScrollY > headerHeight - stickyHeight;
    headerBackground.style.position = isSticky ? 'fixed' : '';
    headerBackground.style.top = isSticky ? '-' + (headerHeight - stickyHeight) + 'px' : '';
    // JSDom v3 doesn't seem to support the `auto` keyword as a value for bottom
    // so we set it on a different property to be able to test it in unit tests.
    headerBackground.style._bottom = isSticky ? 'auto' : '';
    headerBackground.style.bottom = headerBackground.style._bottom;
    headerBackground.style.height = isSticky ? headerHeight + 'px' : '';
  }

  var headerImage = document.querySelector('[data-glue-page-header-background-image]');
  if (headerImage) {
    var currentTransform = headerImage.style.transform || '';
    headerImage.style.transform = (currentTransform.replace(/translateY\(.*?\)/, '') + (' translateY(' + Math.min(currentScrollY, headerHeight - stickyHeight) + 'px)')).trim();
  }
}

function updateHeaderBackgroundScrollOverlay() {
  var scrollOverlay = document.querySelector('[data-glue-page-header-background-scroll-overlay]');
  if (scrollOverlay) {
    var maxOpacity = 0.4;
    scrollOverlay.style.opacity = Math.round(Math.min(1, currentScrollY / (headerHeight - stickyHeight)) * maxOpacity * 1000) / 1000;
  }
}

function updateHeaderBackgroundScrollOverlayEllipse() {
  var scrollPercentage = Math.min(1, currentScrollY / (headerHeight - stickyHeight));

  var scrollOverlay = document.querySelector('[data-glue-page-header-background-scroll-overlay-ellipse]');
  if (scrollOverlay) {
    scrollOverlay.style.opacity = Math.round(Math.min(1, scrollPercentage * 2) * 1000) / 1000;
  }

  var scrollOverlayBackdrop = document.querySelector('[data-glue-page-header-background-scroll-overlay-ellipse-backdrop]');
  if (scrollOverlayBackdrop) {
    scrollOverlayBackdrop.style.opacity = Math.round(scrollPercentage * 1000) / 1000;
  }
}

function updateHeaderImageScaling() {
  var headerImage = document.querySelector('[data-glue-page-header-background-image]');
  if (headerImage) {
    var loader = document.querySelector('[data-glue-page-header-background-image-loader]');
    var isImageLoaded = loader ? loader.classList.contains('glue-page-header__background-image-loader--is-loaded') : false;
    if (isImageLoaded) {
      var maxScale = 1.07;
      var minScale = 1;
      var scrollPercentage = Math.min(1, currentScrollY / (headerHeight - stickyHeight));
      var scale = Math.round((maxScale - scrollPercentage * (maxScale - minScale)) * 1000) / 1000;
      var currentTransform = headerImage.style.transform || '';
      headerImage.style.transform = (currentTransform.replace(/scale\(.*?\)/, '') + (' scale(' + scale + ')')).trim();
    }
  }
}

exports._updateTitleTypeSize = function _updateTitleTypeSize() {
  var title = document.querySelector('[data-glue-page-header-content] [data-glue-page-header-title]');
  if (title) {
    // Optimize performance by only updating if specifically needed (triggered
    // by resize for example) or if the title node is different or if title
    // content changed.
    var isNewNode = title !== lastUpdatedTitleNode;
    var isNewContent = title.textContent !== lastUpdatedTitleContent;
    if (title && (needsTitleSizeUpdate || isNewNode || isNewContent)) {
      needsTitleSizeUpdate = false;
      lastUpdatedTitleNode = title;
      lastUpdatedTitleContent = title.textContent;

      _glue2.default.responsiveTitleType.setSizeForTitle(title, {
        useLargeTitle: title.hasAttribute('data-glue-page-header-use-large-title')
      });

      // Force an update of sizes since it might have changed due to title size
      exports._updateHeaderSizes();
    }
  }
};

exports._updateScrollClassNames = function _updateScrollClassNames() {
  var header = document.querySelector('[data-glue-page-header]');
  if (header) {
    (function () {
      var hasNewHeaderNode = !header._hasBeenSeen;

      // Disable header animations when the header node changes. This solves the
      // problem where the header content would otherwise animate when switching
      // between playlists.
      if (hasNewHeaderNode) {
        header._hasBeenSeen = true;
        header.classList.add('glue-page-header--with-no-animations');
      } else {
        frameRequestIds.push((0, _frameUpdater.requestFrame)(null, function () {
          header.classList.remove('glue-page-header--with-no-animations');
        }));
      }

      lastScrollYDiffs.push(Math.abs(currentScrollY - lastScrollY));
      lastScrollYDiffs.shift();

      var threshold = 30;
      var isScrollingFast = lastScrollYDiffs.reduce(function (isFast, diff) {
        return isFast || diff > threshold;
      }, false);

      // This allows the header to go into a fast scroll mode where the header
      // animations are tweaked a bit.
      if (isScrollingFast) {
        header.classList.add('glue-page-header--with-fast-scrolling');
      } else {
        header.classList.remove('glue-page-header--with-fast-scrolling');
      }
    })();
  }
};

exports._updateHeaderImageLoading = function _updateHeaderImageLoading() {
  var headerImage = document.querySelector('[data-glue-page-header-background-image]');

  if (headerImage) {
    if (headerImage === lastLoadedImageNode) {
      return;
    }

    var imageUrl = headerImage.getAttribute('data-glue-page-header-background-image-url');

    lastLoadedImageNode = headerImage;

    if (imageUrl) {
      var image = new window.Image();
      image.onload = function () {
        var loader = document.querySelector('[data-glue-page-header-background-image-loader]');

        if (!loader.classList.contains('glue-page-header__background-image-loader--is-loaded')) {
          loader.classList.add('glue-page-header__background-image-loader--is-loaded');
          loader.classList.add('glue-page-header__background-image-loader--with-loading-animation');
          updateHeaderImageScaling();

          loader.addEventListener('transitionend', function handler() {
            loader.removeEventListener('transitionend', handler);
            loader.classList.remove('glue-page-header__background-image-loader--with-loading-animation');
          });
        }
      };
      image.src = imageUrl;
    }
  }
};

exports._updateScrollValue = function _updateScrollValue() {
  lastScrollY = currentScrollY;
  currentScrollY = scrollNode === document ? window.scrollY : scrollNode.scrollTop;
};

function handleResize() {
  needsTitleSizeUpdate = true;

  exports._ensureFontIsLoaded(function (error) {
    if (error) {
      console.error(error);
      return;
    }
    exports._updateTitleTypeSize();
    exports._updateHeaderSizes();
    exports._updateHeader();
  });
}

exports._ensureFontIsLoaded = function _ensureFontIsLoaded(callback) {
  if (isFontLoaded) {
    callback(null);
    return;
  }
  if (!fontPromise) {
    fontPromise = _glue2.default.responsiveTitleType.loadFont();
  }
  var token = cancellationTokenSource.token();
  fontPromise.then(function () {
    if (token.isCanceled()) {
      callback(token.operationCanceledError());
      return;
    }
    isFontLoaded = true;
    callback(null);
  }, function (fontPromiseError) {
    callback(token.errorIfCanceled() || fontPromiseError);
  });
};

exports.attach = function attach() {
  if (!isAttached) {
    isAttached = true;
    cancellationTokenSource = new _cancellationTokenSource2.default();

    if (!scrollNode) {
      scrollNode = document;
    }

    // Try getting the flag from the current window first, then use the flag
    // from the top window (zlink). The current window shouldn't have the state
    // in normal cases, but we need this to be able to show the right thing
    // from the demo in glue-reference (via the glue-header-demo app).
    var initialState = window.initialState || window.top.initialState || {};
    useNewHeaders = initialState.newHeaders;

    if (useNewHeaders) {
      exports._ensureFontIsLoaded(function (error) {
        return error && console.error(error);
      });
      exports._updateHeaderSizes();

      scrollListenerId = (0, _frameUpdater.addDebouncedScrollListener)(scrollNode, function () {
        exports._updateScrollValue();
      }, function () {
        exports._updateScrollClassNames();
        exports._updateHeader();
      });

      window.addEventListener('resize', handleResize);
    }
  }
};

exports.detach = function detach() {
  if (isAttached) {
    cancellationTokenSource.cancel();
    cancellationTokenSource = null;

    frameRequestIds.forEach(function (id) {
      (0, _frameUpdater.cancelFrame)(id);
    });
    frameRequestIds = [];

    isAttached = false;
    isFontLoaded = false;
    fontPromise = null;
    headerHeight = 0;
    stickyHeight = 0;
    currentScrollY = 0;
    lastScrollY = 0;
    lastScrollYDiffs = [0, 0, 0, 0, 0];
    needsTitleSizeUpdate = true;
    lastUpdatedTitleNode = null;
    lastUpdatedTitleContent = '';
    scrollNode = null;

    if (useNewHeaders) {
      (0, _frameUpdater.removeDebouncedScrollListener)(scrollListenerId);
      window.removeEventListener('resize', handleResize);
      useNewHeaders = false;
    }
  }
};

exports.update = function update() {
  if (!isAttached) {
    return;
  }
  if (useNewHeaders) {
    frameRequestIds.push((0, _frameUpdater.requestFrame)(function () {
      exports._updateScrollValue();
    }, function () {
      exports._updateScrollClassNames();
      exports._updateHeaderImageLoading();
    }));

    exports._ensureFontIsLoaded(function (error) {
      if (error) {
        console.error(error);
        return;
      }
      frameRequestIds.push((0, _frameUpdater.requestFrame)(function () {
        exports._updateHeaderSizes();
      }, function () {
        exports._updateTitleTypeSize();
        exports._updateHeader();
      }));
    });
  }
};

// A way to let an app override the node to listen for scroll events on.
// This has to be called before `attach` is called.
exports.setScrollNode = function setScrollNode(node) {
  scrollNode = node;
};

},{"../cancellation-token-source":124,"../frame-updater":126,"../glue":148}],258:[function(require,module,exports){
arguments[4][1][0].apply(exports,arguments)
},{"../../../libs/spotify-i18n":456,"./json/cs.json":259,"./json/de.json":260,"./json/el.json":261,"./json/en.json":262,"./json/es-419.json":263,"./json/es.json":264,"./json/fi.json":265,"./json/fr-CA.json":266,"./json/fr.json":267,"./json/hu.json":268,"./json/id.json":269,"./json/it.json":270,"./json/ja.json":271,"./json/nl.json":272,"./json/pl.json":273,"./json/pt-BR.json":274,"./json/sv.json":275,"./json/tr.json":276,"./json/zh-Hant.json":277,"./json/zsm.json":278,"dup":1}],259:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "{0} položka",
    "few": "{0} položky",
    "other": "{0} položek"
  },
  "drag_tooltip_many_tracks": {
    "one": "{0} skladba",
    "few": "{0} skladby",
    "other": "{0} skladeb"
  },
  "drag_tooltip_many_artists": {
    "one": "{0} umělec",
    "few": "{0} umělci",
    "other": "{0} umělců"
  },
  "drag_tooltip_many_albums": {
    "one": "{0} album",
    "few": "{0} alba",
    "other": "{0} alb"
  },
  "drag_tooltip_many_playlists": {
    "one": "{0} playlist",
    "few": "{0} playlisty",
    "other": "{0} playlistů"
  },
  "drag_tooltip_many_users": {
    "one": "{0} uživatel",
    "few": "{0} uživatelé",
    "other": "{0} uživatelů"
  }
}
},{}],260:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 Element",
    "other": "{0} Elemente"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 Titel",
    "other": "{0} Titel"
  },
  "drag_tooltip_many_artists": {
    "one": "1 Künstler",
    "other": "{0} Künstler"
  },
  "drag_tooltip_many_albums": {
    "one": "1 Album",
    "other": "{0} Alben"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 Playlist",
    "other": "{0} Playlists"
  },
  "drag_tooltip_many_users": {
    "one": "1 User",
    "other": "{0} User"
  }
}
},{}],261:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "{0} στοιχείο",
    "other": "{0} στοιχεία"
  },
  "drag_tooltip_many_tracks": {
    "one": "{0} κομμάτι",
    "other": "{0} κομμάτια"
  },
  "drag_tooltip_many_artists": {
    "one": "{0} καλλιτέχνης",
    "other": "{0} καλλιτέχνες"
  },
  "drag_tooltip_many_albums": {
    "one": "{0} άλμπουμ",
    "other": "{0} άλμπουμ"
  },
  "drag_tooltip_many_playlists": {
    "one": "{0} playlist",
    "other": "{0} playlist"
  },
  "drag_tooltip_many_users": {
    "one": "{0} χρήστης",
    "other": "{0} χρήστες"
  }
}
},{}],262:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 item",
    "other": "{0} items"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 track",
    "other": "{0} tracks"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artist",
    "other": "{0} artists"
  },
  "drag_tooltip_many_albums": {
    "one": "1 album",
    "other": "{0} albums"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 playlist",
    "other": "{0} playlists"
  },
  "drag_tooltip_many_users": {
    "one": "1 user",
    "other": "{0} users"
  }
}
},{}],263:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 elemento",
    "other": "{0} elementos"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 canción",
    "other": "{0} canciones"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artista",
    "other": "{0} artistas"
  },
  "drag_tooltip_many_albums": {
    "one": "1 álbum",
    "other": "{0} álbumes"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 playlist",
    "other": "{0} playlists"
  },
  "drag_tooltip_many_users": {
    "one": "1 usuario",
    "other": "{0} usuarios"
  }
}
},{}],264:[function(require,module,exports){
arguments[4][263][0].apply(exports,arguments)
},{"dup":263}],265:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 tuote",
    "other": "{0} tuotetta"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 kappale",
    "other": "{0} kappaletta"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artisti",
    "other": "{0} artistia"
  },
  "drag_tooltip_many_albums": {
    "one": "1 albumi",
    "other": "{0} albumia"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 soittolista",
    "other": "{0} soittolistaa"
  },
  "drag_tooltip_many_users": {
    "one": "1 käyttäjä",
    "other": "{0} käyttäjää"
  }
}
},{}],266:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 article",
    "other": "{0} articles"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 chanson",
    "other": "{0} chansons"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artiste",
    "other": "{0} artistes"
  },
  "drag_tooltip_many_albums": {
    "one": "1 album",
    "other": "{0} albums"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 liste de lecture",
    "other": "{0} listes de lecture"
  },
  "drag_tooltip_many_users": {
    "one": "1 utilisateur",
    "other": "{0} utilisateurs"
  }
}
},{}],267:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "{0} élément",
    "other": "{0} éléments"
  },
  "drag_tooltip_many_tracks": {
    "one": "{0} titre",
    "other": "{0} titres"
  },
  "drag_tooltip_many_artists": {
    "one": "{0} artiste",
    "other": "{0} artistes"
  },
  "drag_tooltip_many_albums": {
    "one": "{0} album",
    "other": "{0} albums"
  },
  "drag_tooltip_many_playlists": {
    "one": "{0} playlist",
    "other": "{0} playlists"
  },
  "drag_tooltip_many_users": {
    "one": "{0} utilisateur",
    "other": "{0} utilisateurs"
  }
}
},{}],268:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "{0} tétel",
    "other": "{0} tétel"
  },
  "drag_tooltip_many_tracks": {
    "one": " {0} szám",
    "other": " {0} szám"
  },
  "drag_tooltip_many_artists": {
    "one": "{0} előadó",
    "other": "{0} előadó"
  },
  "drag_tooltip_many_albums": {
    "one": "{0} album",
    "other": "{0} album"
  },
  "drag_tooltip_many_playlists": {
    "one": "{0} műsorlista",
    "other": "{0} műsorlista"
  },
  "drag_tooltip_many_users": {
    "one": "{0} felhasználó",
    "other": "{0} felhasználó"
  }
}
},{}],269:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "other": "{0} item"
  },
  "drag_tooltip_many_tracks": {
    "other": "{0} lagu"
  },
  "drag_tooltip_many_artists": {
    "other": "{0} artis"
  },
  "drag_tooltip_many_albums": {
    "other": "{0} album"
  },
  "drag_tooltip_many_playlists": {
    "other": "{0} playlist"
  },
  "drag_tooltip_many_users": {
    "other": "{0} pengguna"
  }
}
},{}],270:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 elemento",
    "other": "{0} elementi"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 brano",
    "other": "{0} brani"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artista",
    "other": "{0} artisti"
  },
  "drag_tooltip_many_albums": {
    "one": "1 album",
    "other": "{0} album"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 playlist",
    "other": "{0} playlist"
  },
  "drag_tooltip_many_users": {
    "one": "1 utente",
    "other": "{0} utenti"
  }
}
},{}],271:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "other": "{0} 個のアイテム"
  },
  "drag_tooltip_many_tracks": {
    "other": "{0} 曲のトラック"
  },
  "drag_tooltip_many_artists": {
    "other": "{0} 人のアーティスト"
  },
  "drag_tooltip_many_albums": {
    "other": "{0} 枚のアルバム"
  },
  "drag_tooltip_many_playlists": {
    "other": "{0}個のプレイリスト"
  },
  "drag_tooltip_many_users": {
    "other": "{0} 人のユーザー"
  }
}
},{}],272:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "{0} item",
    "other": "{0} items"
  },
  "drag_tooltip_many_tracks": {
    "one": "{0} nummer",
    "other": "{0} nummers"
  },
  "drag_tooltip_many_artists": {
    "one": "{0} artiest",
    "other": "{0} artiesten"
  },
  "drag_tooltip_many_albums": {
    "one": "{0} album",
    "other": "{0} albums"
  },
  "drag_tooltip_many_playlists": {
    "one": "{0} afspeellijst",
    "other": "{0} afspeellijsten"
  },
  "drag_tooltip_many_users": {
    "one": "{0} gebruiker",
    "other": "{0} gebruikers"
  }
}
},{}],273:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "{0} element",
    "few": "{0} elementy",
    "many": "{0} elementów",
    "other": "{0} elementu"
  },
  "drag_tooltip_many_tracks": {
    "one": "{0} utwór",
    "few": "{0} utwory",
    "many": "{0} utworów",
    "other": "{0} utworu"
  },
  "drag_tooltip_many_artists": {
    "one": "{0} wykonawca",
    "few": "{0} wykonawców",
    "many": "{0} wykonawców",
    "other": "{0} wykonawcy"
  },
  "drag_tooltip_many_albums": {
    "one": "{0} album",
    "few": "{0} albumy",
    "many": "{0} albumów",
    "other": "{0} albumu"
  },
  "drag_tooltip_many_playlists": {
    "one": "{0} playlista",
    "few": "{0} playlisty",
    "many": "{0} playlist",
    "other": "{0} playlist"
  },
  "drag_tooltip_many_users": {
    "one": "{0} użytkownik",
    "few": "{0} użytkowników",
    "many": "{0} użytkowników",
    "other": "{0} użytkowników"
  }
}
},{}],274:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 item",
    "other": "{0} itens"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 faixa",
    "other": "{0} faixas"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artista",
    "other": "{0} artistas"
  },
  "drag_tooltip_many_albums": {
    "one": "1 álbum",
    "other": "{0} álbuns"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 playlist",
    "other": "{0} playlists"
  },
  "drag_tooltip_many_users": {
    "one": "1 usuário",
    "other": "{0} usuários"
  }
}
},{}],275:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "1 objekt",
    "other": "{0} objekt"
  },
  "drag_tooltip_many_tracks": {
    "one": "1 låt",
    "other": "{0} låtar"
  },
  "drag_tooltip_many_artists": {
    "one": "1 artist",
    "other": "{0} artister"
  },
  "drag_tooltip_many_albums": {
    "one": "1 album",
    "other": "{0} album"
  },
  "drag_tooltip_many_playlists": {
    "one": "1 spellista",
    "other": "{0} spellistor"
  },
  "drag_tooltip_many_users": {
    "one": "1 användare",
    "other": "{0} användare"
  }
}
},{}],276:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "one": "{0} öğe",
    "other": "{0} öğe"
  },
  "drag_tooltip_many_tracks": {
    "one": "{0} parça",
    "other": "{0} parça"
  },
  "drag_tooltip_many_artists": {
    "one": "{0} sanatçı",
    "other": "{0} sanatçı"
  },
  "drag_tooltip_many_albums": {
    "one": "{0} albüm",
    "other": "{0} albüm"
  },
  "drag_tooltip_many_playlists": {
    "one": "{0} çalma listesi",
    "other": "{0} çalma listesi"
  },
  "drag_tooltip_many_users": {
    "one": "{0} kullanıcı",
    "other": "{0} kullanıcı"
  }
}
},{}],277:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "other": "{0} 個項目"
  },
  "drag_tooltip_many_tracks": {
    "other": "{0} 首歌曲"
  },
  "drag_tooltip_many_artists": {
    "other": "{0} 個藝人"
  },
  "drag_tooltip_many_albums": {
    "other": "{0} 張專輯"
  },
  "drag_tooltip_many_playlists": {
    "other": "{0} 份播放清單"
  },
  "drag_tooltip_many_users": {
    "other": "{0} 位使用者"
  }
}
},{}],278:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": {
    "other": "{0} item"
  },
  "drag_tooltip_many_tracks": {
    "other": "{0} lagu"
  },
  "drag_tooltip_many_artists": {
    "other": "{0} artis"
  },
  "drag_tooltip_many_albums": {
    "other": "{0} album"
  },
  "drag_tooltip_many_playlists": {
    "other": "{0} senarai main"
  },
  "drag_tooltip_many_users": {
    "other": "{0} pengguna"
  }
}
},{}],279:[function(require,module,exports){
'use strict';

var modules = [require('./lang'), require('./anchor'), require('./player'), require('./dragndrop'), require('./add'), require('./selection'), require('./contextmenu'), require('./sticky'), require('./navbar'), require('./offline'), require('./filter'), require('./tooltip'), require('./list'), require('./menu'), require('./scroll'), require('./carousel'), require('./scrollbar'), require('./header'), require('./slider'), require('./select'), require('./sort'), require('./thumbs'), require('./dailymix'), require('./touch-mediaobjects'), require('./list-quick-jump'), require('./cards')];

var events = {};

var isAttached = false;

events.update = function update(node) {
  if (!isAttached) return;

  modules.forEach(function (module) {
    module.update(node);
  });
};

events.attach = function attach() {
  if (isAttached) return;
  isAttached = true;

  modules.forEach(function (module) {
    module.attach();
  });
};

events.detach = function detach() {
  if (!isAttached) return;
  isAttached = false;

  modules.forEach(function (module) {
    module.detach();
  });
};

module.exports = events;

},{"./add":235,"./anchor":236,"./cards":237,"./carousel":241,"./contextmenu":243,"./dailymix":244,"./dragndrop":250,"./filter":256,"./header":257,"./lang":280,"./list":282,"./list-quick-jump":281,"./menu":283,"./navbar":284,"./offline":285,"./player":287,"./scroll":292,"./scrollbar":293,"./select":294,"./selection":297,"./slider":301,"./sort":302,"./sticky":303,"./thumbs":304,"./tooltip":305,"./touch-mediaobjects":306}],280:[function(require,module,exports){
'use strict';

var isAttached = false;

exports.update = function () {};

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  var locale = window.__spotify && window.__spotify.locale;
  if (locale) {
    document.documentElement.setAttribute('lang', locale);
  }
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  document.documentElement.removeAttribute('lang');
};

},{}],281:[function(require,module,exports){
(function (global){
'use strict';

var center = require('./center');
var cosmos = require('./util/cosmos');
var ClientEvent3 = require('../spotify-logger/messages/ClientEvent3');

var SPACE_KEYCODE = 32;
var BACKSPACE_KEYCODE = 8;
var DELETE_KEYCODE = 46;

exports.attach = function attach() {
  document.addEventListener('keypress', onKeyPress, false);
  document.addEventListener('keydown', onKeyDown, false);
};

exports.detach = function detach() {
  document.removeEventListener('keypress', onKeyPress, false);
  document.removeEventListener('keydown', onKeyDown, false);
};

exports.update = function () {};

var selector = ':not([data-sticky-active]) > [data-list-quick-jump]';
var SEARCH_STRING_CONCATENATION_TIMEOUT = 1000;

var searchStringsByUri = {};
var searchTimeoutsByUri = {};
var searchTimestampsByUri = {};

// onKeyPress is needed to read characters properly
function onKeyPress(event) {
  if (shouldEventBeIgnored(event)) return;
  processEvent(event);
}

// onKeyDown is needed to read <backspace>
function onKeyDown(event) {
  if (shouldEventBeIgnored(event)) return;

  var isBackspace = event.keyCode === BACKSPACE_KEYCODE;

  if (!isBackspace) return;
  processEvent(event);
}

function processEvent(event) {
  var isBackspace = event.keyCode === BACKSPACE_KEYCODE;

  var letter = event.keyCode === SPACE_KEYCODE ? ' ' : String.fromCharCode(event.keyCode).trim();
  if (!letter && !isBackspace) return;

  var listNode = getListNode(event.target);
  if (!listNode) return;

  var uri = getUri(listNode);
  if (!uri) return;

  // No need to do anything if there is no active search and user presses
  // BACKSPACE, since that would temporarily disable using SPACE for toggling
  // music, even though no quick-jump was actually made (KM-10204)
  if (isBackspace && !searchStringsByUri[uri]) return;

  if (!(uri in searchStringsByUri)) searchStringsByUri[uri] = '';

  if (isBackspace) {
    searchStringsByUri[uri] = searchStringsByUri[uri].slice(0, -1);
  } else if (letter) {
    searchStringsByUri[uri] += letter;
  }

  center.emit('list-quick-jump-request', uri, searchStringsByUri[uri] || null);

  if (searchTimeoutsByUri[uri]) clearTimeout(searchTimeoutsByUri[uri]);

  if (event.keyCode === SPACE_KEYCODE) {
    event.preventDefault(); // Prevent space from scrolling page
  }

  var shortcutsToIgnore = [{ keyCode: SPACE_KEYCODE }, { keyCode: BACKSPACE_KEYCODE }, { keyCode: DELETE_KEYCODE }];

  // Tell container to ignore <space>, <backspace> and <delete> shortcuts
  // until further notice
  cosmos.post({
    url: 'sp://messages/v1/ignoreshortcuts',
    body: {
      action: 'ignore',
      shortcuts: shortcutsToIgnore
    }
  });

  searchTimeoutsByUri[uri] = setTimeout(function () {
    // Tell container to stop ignoring <space>, <backspace> and <delete>
    // shortcuts
    cosmos.post({
      url: 'sp://messages/v1/ignoreshortcuts',
      body: {
        action: 'unignore',
        shortcuts: shortcutsToIgnore
      }
    });

    delete searchStringsByUri[uri];
    delete searchTimeoutsByUri[uri];
    delete searchTimestampsByUri[uri];
    center.emit('list-quick-jump-request', uri, null);
  }, SEARCH_STRING_CONCATENATION_TIMEOUT);

  if (searchStringsByUri[uri].length <= 20) {
    var timeSinceLastLetter = Date.now() - searchTimestampsByUri[uri] || null;
    ClientEvent3.log({
      source: global.__spotify && global.__spotify.app_uri || null,
      context: uri,
      event_version: 'list-quick-jump',
      event: 'user:type',
      json_data: JSON.stringify({
        str: searchStringsByUri[uri],
        letter: letter,
        was_backspace: isBackspace,
        time_since_last_letter: timeSinceLastLetter
      })
    });
  }

  searchTimestampsByUri[uri] = Date.now();
}

function shouldEventBeIgnored(event) {
  return event.metaKey || event.ctrlKey || event.target.matches('input, textarea, [contenteditable]');
}

function getListNode(target) {
  var listNode = target.closest(selector);
  if (!listNode) {
    var listNodes = document.querySelectorAll(selector);
    var hasOnlyOneListNode = listNodes && listNodes.length === 1;

    if (hasOnlyOneListNode) {
      listNode = listNodes[0];
    }
  }
  return listNode;
}

function getUri(listNode) {
  var uriParent = listNode.closest('[data-uri]');
  return uriParent && uriParent.getAttribute('data-uri');
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-logger/messages/ClientEvent3":527,"./center":242,"./util/cosmos":310}],282:[function(require,module,exports){
(function (global){
'use strict';

var $ = require('../spotify-elements');
var live = require('../spotify-live');
var center = require('./center');
var selection = require('./selection');
var cosmos = require('./util/cosmos');
var appUtil = require('./util/app');

var ROW_SELECTOR = '[data-list-item]';
var UNAVAILABLE_CLASS_NAME = 'unavailable';
var OFFLINE_DOWNLOADED_CLASS_NAME = 'offline-downloaded';
var OFFLINE_DOWNLOADING_CLASS_NAME = 'offline-downloading';
var OFFLINE_WAITING_CLASS_NAME = 'offline-waiting';

var storedTrackURIsForUnplayable = {};
var storedTrackURIsForOffline = {};

function updatePlayabilityForRows(uri, playable) {
  var rows = $(document).search(ROW_SELECTOR + '[data-uri="' + uri + '"]');
  if (rows) {
    updatePlayabilityForElements(rows, playable);
  }
}

function updatePlayabilityForElements(elements, playable) {
  if (playable) {
    elements.removeClass(UNAVAILABLE_CLASS_NAME);
  } else {
    elements.addClass(UNAVAILABLE_CLASS_NAME);
  }
}

function updateOfflineForRows(uri, shouldBeOffline, offlineProgress) {
  var rows = $(document).search(ROW_SELECTOR + '[data-uri="' + uri + '"]');
  if (rows) {

    // This will take an elements object as the first argument, so it can contain multiple rows
    updateOfflineForElements(rows, shouldBeOffline, offlineProgress);
  }
}

function updateOfflineForElements(elements, shouldBeOffline, offlineProgress) {

  // The track is either already downloaded or will be soon
  if (shouldBeOffline) {

    // Download done
    if (offlineProgress === 1) {
      elements.addClass(OFFLINE_DOWNLOADED_CLASS_NAME);
      elements.removeClass(OFFLINE_DOWNLOADING_CLASS_NAME);
      elements.removeClass(OFFLINE_WAITING_CLASS_NAME);

      // Waiting to be downloaded
    } else if (offlineProgress === 0) {
      elements.addClass(OFFLINE_WAITING_CLASS_NAME);
      elements.removeClass(OFFLINE_DOWNLOADED_CLASS_NAME);
      elements.removeClass(OFFLINE_DOWNLOADING_CLASS_NAME);

      // Downloading at the moment
    } else {
      elements.addClass(OFFLINE_DOWNLOADING_CLASS_NAME);
      elements.removeClass(OFFLINE_DOWNLOADED_CLASS_NAME);
      elements.removeClass(OFFLINE_WAITING_CLASS_NAME);
    }

    // The track is not supposed to be downloaded offline
  } else {
    elements.removeClass(OFFLINE_DOWNLOADED_CLASS_NAME);
    elements.removeClass(OFFLINE_DOWNLOADING_CLASS_NAME);
    elements.removeClass(OFFLINE_WAITING_CLASS_NAME);
  }
}

function updateUnplayableRows(node, opt_rows) {
  var rows = opt_rows || ($(node) || $(document)).search(ROW_SELECTOR);
  if (rows) {
    rows.forEach(function (row) {
      var uri = $(row).data('uri');

      var model = live(uri);
      var playable = model.get('playable');

      if (playable !== undefined) {
        updatePlayabilityForElements($(row), playable);
      }

      if (uri in storedTrackURIsForUnplayable) return;
      storedTrackURIsForUnplayable[uri] = true;

      model.on('update', function (properties) {
        if ('playable' in properties) {
          updatePlayabilityForRows(uri, properties.playable);
        }
      });
    });
  }
}

function updateOfflineSyncing(node, opt_rows) {
  var rows = opt_rows || ($(node) || $(document)).search(ROW_SELECTOR);
  if (rows) {
    rows.forEach(function (row) {
      var uri = $(row).data('uri');
      var model = live(uri);

      // Try to query the data sync if possible (live.ASAP), to try to set the
      // class names before adding the rows to the DOM (by the scroller), to
      // avoid flickering.
      model.query('shouldBeOffline, offlineProgress', function (error, data) {
        if (error) throw error;
        updateOfflineForElements($(row), data.shouldBeOffline, data.offlineProgress);

        if (uri in storedTrackURIsForOffline) return;
        storedTrackURIsForOffline[uri] = true;

        model.on('update', function (properties) {
          if ('shouldBeOffline' in properties || 'offlineProgress' in properties) {
            updateOfflineForRows(uri, model.get('shouldBeOffline'), model.get('offlineProgress'));
          }
        });
      }, live.ASAP);
    });
  }
}

function handleKeyDown(event) {
  if (!event.target.closest(ROW_SELECTOR) || ignoredShortcuts[JSON.stringify({ keyCode: event.keyCode })]) return;

  var shouldRemove = false;
  var isWindows = /Win/.test(global.window.navigator.userAgent);

  var isBackspace = event.keyCode === 8;
  var isDelete = event.keyCode === 46;

  if (isWindows) {
    shouldRemove = isDelete;
  } else {
    shouldRemove = isBackspace || isDelete;
  }

  if (shouldRemove) {
    removeCurrentlySelectedListItems();
  }
}

function removeCurrentlySelectedListItems() {
  var lists = selection.getIndicesPerList();
  if (lists.length > 0) {
    var firstIndex = null;
    lists.forEach(function (list) {
      // Delete from origin list where applicable
      // TODO: We could just remove from the list directly, without going
      // through the origin list. Removing from a sorted list will pass
      // the change on to the origin list automatically.
      if (list.origin) {
        list = list.origin;
      }
      var model = live(list.uri);

      var indices = list.indices.sort(function (a, b) {
        return a - b;
      });

      model.query('allows(removeTracks)', function (error, data) {
        if (error) throw error;
        if (!data.allows.removeTracks) return;

        model.get('rows', function (error, liveList) {
          if (error) throw error;
          var operations = indices.map(function (index, indexInArray) {
            return { type: 'remove', index: index - indexInArray, length: 1 };
          });
          liveList.publish(operations);

          if (firstIndex === null) {
            firstIndex = indices[0];
          }
        });
      });
    });
  }
}

function handleScrollShow(data) {
  updateUnplayableRows(data.container, data.nodes);
  updateOfflineSyncing(data.container, data.nodes);
}

// Exported for testing
exports._classNames = {
  UNAVAILABLE: UNAVAILABLE_CLASS_NAME,
  OFFLINE_WAITING: OFFLINE_WAITING_CLASS_NAME,
  OFFLINE_DOWNLOADING: OFFLINE_DOWNLOADING_CLASS_NAME,
  OFFLINE_DOWNLOADED: OFFLINE_DOWNLOADED_CLASS_NAME
};

var isAttached = false;

exports.update = function update(node) {
  if (!isAttached) return;

  updateUnplayableRows(node);
  updateOfflineSyncing(node);
};

var doc = $(document);
var deleteSubscription;
var ignoredShortcutsSubscription;
var ignoredShortcuts = {};
exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  doc.on('keydown', handleKeyDown);
  center.on('scroll-show-before', handleScrollShow);

  deleteSubscription = cosmos.subscribe({ url: 'sp://messages/v1/container/control' }, function (error, response) {
    if (error) throw error;
    var data = response.body;
    if (data && data.type === 'delete' && appUtil.isActiveAndFocused()) {
      removeCurrentlySelectedListItems();
    }
  });

  ignoredShortcutsSubscription = cosmos.subscribe({
    url: 'sp://messages/v1/ignoreshortcuts'
  }, function (error, response) {
    if (response.body.action === 'ignore') {
      response.body.shortcuts.forEach(function (shortcut) {
        ignoredShortcuts[JSON.stringify(shortcut)] = 1;
      });
    } else if (response.body.action === 'unignore') {
      response.body.shortcuts.forEach(function (shortcut) {
        delete ignoredShortcuts[JSON.stringify(shortcut)];
      });
    }
  });
};
exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  doc.off('keydown', handleKeyDown);
  center.off('scroll-show-before', handleScrollShow);

  if (deleteSubscription) {
    deleteSubscription.cancel();
    deleteSubscription = null;
  }

  if (ignoredShortcutsSubscription) {
    ignoredShortcutsSubscription.cancel();
    ignoredShortcutsSubscription = null;
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-elements":231,"../spotify-live":512,"./center":242,"./selection":297,"./util/app":309,"./util/cosmos":310}],283:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.attach = attach;
exports.detach = detach;
exports.update = update;

var _throttle = require('./util/throttle');

var _throttle2 = _interopRequireDefault(_throttle);

var _center = require('./center');

var _center2 = _interopRequireDefault(_center);

var _spotifyNavigation = require('../spotify-navigation');

var _spotifyNavigation2 = _interopRequireDefault(_spotifyNavigation);

var _appState = require('../spotify-navigation/app-state');

var _appState2 = _interopRequireDefault(_appState);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SELECTOR_MENU = '[data-menu]';
var SELECTOR_MENU_ITEM = '[data-menu-item]';
var SELECTOR_MENU_ITEM_DISABLED = '[data-menu-item-disabled]';
var SELECTOR_MENU_ITEM_ENABLED = '[data-menu-item]:not([data-menu-item-disabled])';
var ATTRIBUTE_MENU = 'data-menu';
var ATTRIBUTE_MENU_ITEM = 'data-menu-item';
var CLASS_SUBMENU = '.dropdown-submenu';
var CLASS_MENU = '.dropdown-menu';

var navigator = new _spotifyNavigation2.default.Navigator();

var isAttached = false;

// The state will take the following shape (a nested structure that can be any
// number of levels deep):
// {
//   menu: { // null if root menu is not open
//     node: menuNode,
//     selectedNode: menuItemNode, // or null
//     menu: { // null if a sub menu is not open
//       node: subMenuNode,
//       selectedNode: subMenuItemNode, // or null,
//       menu: null, // null if a sub menu is not open
//       parent: <back-reference>, // a reference to the object one level up
//     },
//     parent: null, // always null for the root menu
//   }
// }
var state = {
  menu: null
};

/**
 * Handler for when an element gets focused.
 *
 * @param {FocusEvent} event A focus event.
 */
function onFocus(event) {
  var targetMenu = event.target.closest(SELECTOR_MENU);
  if (targetMenu && !state.menu) {
    state.menu = {
      node: targetMenu,
      selectedNode: null,
      menu: null,
      active: true,
      parent: null
    };

    targetMenu.addEventListener('mousemove', onMouseMoveThrottled);
    targetMenu.addEventListener('mouseleave', onMouseLeave);

    // We need to ensure that before triggering the "touchstart" event in the <LI> element
    // of the node, we emulate the mouse being moved over it. This way, the listeners are
    // attached and they will fire.
    // Note: this "mouseMove" call cannot be throttled, because the "touchstart" that will
    // trigger in the <LI> will happen before the throttler fires the event. Additionally,
    // there's no need to use the throttling logic for the touchstart event.
    targetMenu.addEventListener('touchstart', onMouseMove, true);
  }
}

/**
 * Handler for when an element loses focus.
 *
 * @param {FocusEvent} event A blur event.
 */
function onBlur(event) {
  var target = event.target,
      relatedTarget = event.relatedTarget;


  if (state.menu && target === state.menu.node) {
    // A blur on the menu (target) can mean an element inside of it gains focus.
    // No need to reset then.
    if (!relatedTarget || !target.contains(relatedTarget)) {
      hideMenu();
    }
  }
}

/**
 * Handler for when a key is pressed.
 *
 * @param {KeyboardEvent} event A keyboard event.
 */
function onKeyDown(event) {
  // Only act on events when a menu is open
  if (!state.menu) {
    return;
  }

  var keyCode = event.keyCode;
  var isEnter = keyCode === 13;
  var isEscape = keyCode === 27;
  var isUp = keyCode === 38;
  var isDown = keyCode === 40;
  var isLeft = keyCode === 37;
  var isRight = keyCode === 39;

  if (isEnter) {
    // Look for links to follow inside the current menu item.
    var activeMenuState = getStateForActiveMenu();
    var selectedMenuItem = activeMenuState.selectedNode;
    var link = selectedMenuItem && selectedMenuItem.querySelector('a[href]');
    if (link) {
      navigator.requestOpenState(new _appState2.default(link.getAttribute('href')));
    }
    emitActivateItemEvent(selectedMenuItem);
    return;
  }

  if (isEscape) {
    hideMenu();
    return;
  }

  if (isUp || isDown) {
    var _activeMenuState = getStateForActiveMenu();
    if (_activeMenuState.node) {
      var newActiveMenuItem = isDown ? getMenuItemBelow(_activeMenuState) : getMenuItemAbove(_activeMenuState);

      if (newActiveMenuItem) {
        selectItemInMenu(_activeMenuState, _activeMenuState, newActiveMenuItem);
      }
    }
    return;
  }

  if (isRight) {
    var _activeMenuState2 = getStateForActiveMenu();
    if (_activeMenuState2.selectedNode) {
      if (_activeMenuState2.selectedNode.matches(CLASS_SUBMENU)) {

        // Open the sub menu if not open already (might have been opened by the
        // mouse cursor)
        if (!_activeMenuState2.menu) {
          openSubMenu(_activeMenuState2, _activeMenuState2.selectedNode);
        }

        // Select the first item in the sub menu
        var subMenuNode = _activeMenuState2.menu.node;
        var firstItemInSubMenu =
        // We'd like to get firstElementChild to avoid text nodes, but since
        // JSDom doesn't support that, fall back to firstChild for tests.
        subMenuNode.firstElementChild || subMenuNode.firstChild;
        selectItemInMenu(_activeMenuState2, _activeMenuState2.menu, firstItemInSubMenu);
      }
    }
    return;
  }

  if (isLeft) {
    var _activeMenuState3 = getStateForActiveMenu();
    if (_activeMenuState3.parent) {
      closeSubMenuOf(_activeMenuState3.parent);
    }
    return;
  }
}

/**
 * Handler for when the mouse is moved over a menu.
 * This is only attached for the current menu (if there is a current menu).
 *
 * @param {MouseEvent} event A mouse event.
 */
function onMouseMove(event) {
  var isMenu = event.target.matches(CLASS_MENU);
  if (isMenu) {
    return;
  }

  var targetItem = event.target.closest(SELECTOR_MENU_ITEM);
  if (!targetItem) {
    return;
  }

  var targetMenu = targetItem.closest(CLASS_MENU);
  var targetMenuState = getStateForMenu(targetMenu);
  var activeMenuState = getStateForActiveMenu();

  if (targetItem === activeMenuState.selectedNode) {
    return;
  }

  if (targetItem.matches(SELECTOR_MENU_ITEM_DISABLED)) {
    deselectItemInMenu(activeMenuState);
  } else {
    selectItemInMenu(activeMenuState, targetMenuState, targetItem);
    activeMenuState = getStateForActiveMenu();
  }

  // When hovering over an item that has a sub menu, open the sub menu if not
  // open already.
  if (targetItem.matches(CLASS_SUBMENU)) {
    if (!targetMenuState.menu) {
      openSubMenu(targetMenuState, targetItem);
    }

    // When hovering over a regular item and a sub menu is currently shown, close
    // the sub menu.
  } else if (activeMenuState.menu) {
    closeSubMenuOf(activeMenuState);
  }
}
var onMouseMoveThrottled = (0, _throttle2.default)(onMouseMove);

/**
 * Handler for when the mouse leaves a menu.
 * This is only attached for the current menu (if there is a current menu).
 *
 * @param {MouseEvent} event A mouse event.
 */
function onMouseLeave(event) {
  if (!event.relatedTarget || !event.relatedTarget.closest(SELECTOR_MENU)) {
    var activeMenuState = getStateForActiveMenu();
    deselectItemInMenu(activeMenuState);
    if (activeMenuState.menu) {
      closeSubMenuOf(activeMenuState);
    }
  }
}

/**
 * Handler for when the current menu item is clicked.
 * This is only attached for the current menu item (if there is one).
 *
 * @param {MouseEvent} event A mouse event.
 */
function onItemClick(event) {
  var targetMenu = event.target.closest(CLASS_MENU);
  var targetMenuState = getStateForMenu(targetMenu);
  var itemNode = targetMenuState.selectedNode;

  emitActivateItemEvent(itemNode);
}

/**
 * In order to prevent the simulated click event when using a touchscreen,
 * we prevent default so click won't trigger. That click event would otherwise
 * trigger a click on the layer beneath since the menu is closed after activating an item.
 *
 * @param {TouchEvent} event a Touch event.
 */
function onItemTouchStart(event) {
  event.preventDefault();
  onItemClick(event);
}

/**
 * Emit a center event to activate the current item.
 *
 * @param {HTMLElement} itemNode HTML element for the item.
 */
function emitActivateItemEvent(itemNode) {
  _center2.default.emit('menu-activate-item', {
    menu: {
      id: state.menu.node.getAttribute(ATTRIBUTE_MENU) || '',
      element: state.menu.node
    },
    item: {
      id: itemNode.getAttribute(ATTRIBUTE_MENU_ITEM) || '',
      element: itemNode
    }
  });
}

/**
 * Set the current menu item to a new item.
 *
 * @param {Object} activeMenuState Menu state object for the currently active
 *   menu.
 * @param {Object} targetMenuState Menu state object for the menu where the item
 *   that is to be selected is located.
 * @param {HTMLElement} itemNode An HTML element for the menu item.
 */
function selectItemInMenu(activeMenuState, targetMenuState, itemNode) {
  var isTargetSubMenu = activeMenuState.menu === targetMenuState;
  var isTargetParentMenu = isSecondContainedInFirst(targetMenuState, activeMenuState);

  // If the item is in a sub menu we only want to remove any item event
  // listeners. Removing visual selection should only happen when moving within
  // the same menu.
  if (isTargetSubMenu) {
    removeItemListeners(activeMenuState.selectedNode);
  } else {
    deselectItemInMenu(activeMenuState);
  }

  // Deselect the currently selected item in parent menu, if moving from sub
  // menu to the parent menu.
  if (isTargetParentMenu) {
    deselectItemInMenu(targetMenuState);
  }

  activeMenuState.active = false;

  if (targetMenuState.selectedNode !== itemNode) {
    itemNode.classList.add('selected');
    addItemListeners(itemNode);
    targetMenuState.selectedNode = itemNode;
  }

  targetMenuState.active = true;
}

/**
 * Deselect any selected item in the menu represented by the passed state.
 *
 * @param {Object} menuState The menu state object.
 */
function deselectItemInMenu(menuState) {
  if (menuState.selectedNode) {
    var itemNode = menuState.selectedNode;
    itemNode.classList.remove('selected');
    removeItemListeners(itemNode);
    menuState.selectedNode = null;
  }
}

/**
 * Add the click listeners from an item node.
 *
 * @param {HTMLElement} itemNode An HTML element for the menu item.
 */
function addItemListeners(itemNode) {
  itemNode.addEventListener('click', onItemClick);
  itemNode.addEventListener('touchstart', onItemTouchStart);
}

/**
 * Remove the click listeners from an item node.
 *
 * @param {HTMLElement} itemNode An HTML element for the menu item.
 */
function removeItemListeners(itemNode) {
  itemNode.removeEventListener('click', onItemClick);
  itemNode.removeEventListener('touchstart', onItemTouchStart);
}

/**
 * Open a sub menu for the provided menu state object and item node.
 *
 * @param {Object} menuState The menu state object for the parent menu.
 * @param {HTMLElement} itemNode An HTML element for the menu item.
 */
function openSubMenu(menuState, itemNode) {
  var menuNode = itemNode.querySelector(CLASS_MENU);
  if (menuNode) {
    menuState.menu = {
      parent: menuState,
      node: menuNode,
      selectedNode: null,
      menu: null,
      active: false
    };
    menuNode.classList.add('open');
  }
}

/**
 * Close all sub menus for the provided menu state object.
 *
 * @param {Object} menuState The menu state object for the parent menu.
 */
function closeSubMenuOf(menuState) {
  // Close deeper sub menus first
  if (menuState.menu.menu) {
    closeSubMenuOf(menuState.menu);
  }

  if (menuState.menu.active) {
    menuState.menu.active = false;
    menuState.active = true;
  }

  deselectItemInMenu(menuState.menu);
  menuState.menu.node.classList.remove('open');
  menuState.menu = null;
}

/**
 * Hide the current menu by broadcasting a message via center.
 * A listener can be added via center and the handler will then really hide it.
 *
 * @example
 * center.on('menu-hide', function(event) {
 *   if (event.menu.id === 'profile-menu') {
 *     hideProfileMenu();
 *   }
 * });
 */
function hideMenu() {
  if (state.menu) {
    var menuNode = state.menu.node;

    menuNode.removeEventListener('mousemove', onMouseMoveThrottled);
    menuNode.removeEventListener('mouseleave', onMouseLeave);
    menuNode.removeEventListener('touchstart', onMouseMove, true);

    // Remove any sub menus
    var menuState = state.menu;
    while (menuState) {
      deselectItemInMenu(menuState);
      menuState.node.classList.remove('open');
      menuState = menuState.menu;
    }

    delete state.menu;

    _center2.default.emit('menu-hide', {
      menu: {
        id: menuNode.getAttribute(ATTRIBUTE_MENU) || '',
        element: menuNode
      }
    });
  }
}

/**
 * Test if the second menu state object is contained in the second state object.
 *
 * @param {Object} first Menu state object.
 * @param {Object} second Menu state object.
 *
 * @return {Boolean}        True if it is.
 */
function isSecondContainedInFirst(first, second) {
  var statePart = first.menu;
  while (statePart && statePart !== second) {
    statePart = statePart.menu;
  }

  return !!statePart;
}

/**
 * Get the menu state object for the provided menu node. This assumes the node
 * is part of the state tree.
 *
 * @param {HTMLElement} menuNode The menu element.
 *
 * @return {Object} Menu state object.
 */
function getStateForMenu(menuNode) {
  var statePart = state.menu;
  while (statePart && statePart.node !== menuNode) {
    statePart = statePart.menu;
  }

  return statePart;
}

/**
 * Get the menu state object for the currently active menu.
 *
 * @return {Object} Menu state object.
 */
function getStateForActiveMenu() {
  var statePart = state.menu;
  while (statePart && !statePart.active) {
    statePart = statePart.menu;
  }

  return statePart;
}

/**
 * Find the menu item that is below the current one.
 * This will skip disabled menu items as well as any elements that are not
 * defined as menu items. If there is no menu item below the current one,
 * this will return null.
 *
 * @param {Object} activeMenuState Menu state object for the currently active
 *   menu.
 *
 * @return {HTMLElement?} The HTML element for the menu item, or null.
 */
function getMenuItemBelow(activeMenuState) {
  if (!activeMenuState.selectedNode) {
    return activeMenuState.node.querySelector(SELECTOR_MENU_ITEM_ENABLED);
  }

  var item = activeMenuState.selectedNode.nextElementSibling;
  while (item) {
    var isMenuItem = item.matches(SELECTOR_MENU_ITEM);
    var isDisabled = item.matches(SELECTOR_MENU_ITEM_DISABLED);
    if (isMenuItem && !isDisabled) {
      break;
    }
    item = item.nextElementSibling;
  }

  return item;
}

/**
 * Find the menu item that is above the current one.
 * This will skip disabled menu items as well as any elements that are not
 * defined as menu items. If there is no menu item above the current one,
 * this will return null.
 *
 * @param {Object} activeMenuState Menu state object for the currently active
 *   menu.
 *
 * @return {HTMLElement?} The HTML element for the menu item, or null.
 */
function getMenuItemAbove(activeMenuState) {
  if (!activeMenuState.selectedNode) {
    var results = activeMenuState.node.querySelectorAll(SELECTOR_MENU_ITEM_ENABLED);
    return results[results.length - 1] || null;
  }

  var item = activeMenuState.selectedNode.previousElementSibling;
  while (item) {
    var isMenuItem = item.matches(SELECTOR_MENU_ITEM);
    var isDisabled = item.matches(SELECTOR_MENU_ITEM_DISABLED);
    if (isMenuItem && !isDisabled) {
      break;
    }
    item = item.previousElementSibling;
  }

  return item;
}

/**
 * The spotify-events style attach function. Should be called once when DOM
 * is ready.
 */
function attach() {
  if (isAttached) return;
  isAttached = true;

  document.addEventListener('keydown', onKeyDown);

  // use capture to work around the non-bubbling events
  document.addEventListener('focus', onFocus, true);
  document.addEventListener('blur', onBlur, true);
}

/**
 * The spotify-events style detach function. Should be called when you no
 * longer need the events.
 */
function detach() {
  if (!isAttached) return;
  isAttached = false;

  state.menu = null;

  document.removeEventListener('keydown', onKeyDown);
  document.removeEventListener('focus', onFocus, true);
  document.removeEventListener('blur', onBlur, true);
}

/**
 * The spotify-events style update function. Should be called when DOM
 * changes.
 */
function update() {}

},{"../spotify-navigation":545,"../spotify-navigation/app-state":544,"./center":242,"./util/throttle":313}],284:[function(require,module,exports){
(function (global){
'use strict';

var $ = require('../spotify-elements');

var live = require('../spotify-live');
var center = require('./center');

var NAVBAR_ATTR_NAME = 'data-navbar';
var ITEM_ID_ATTR_NAME = 'data-navbar-item-id';
var ITEM_MATCHER_ATTR_NAME = 'data-navbar-item-matcher';
var VIEW_ID_ATTR_NAME = 'data-navbar-view-id';
var ACTIVE_ID_ATTR_NAME = 'data-navbar-active-id';
var HISTORY_POS_ATTR_NAME = 'data-navbar-history-position';
var CLASSNAME_ACTIVE = 'active';
var OVERFLOW_MENU_ID = 'navbar-overflow-menu';
var STICKY_WRAPPER_ATTR_NAME = 'data-sticky-fixed-wrapper';

var APPLICATION_MODEL_URI = 'spotify:application';

var navbarOverflowItems;
var isShowingNavbarOverflow;
var shouldShowNavbarOverflow;

var getSelector = function getSelector(name, opt_operator, opt_matcher) {
  if (opt_operator && opt_matcher) {
    return '[' + name + opt_operator + '"' + opt_matcher + '"' + ']';
  }
  return '[' + name + ']';
};

var handleClick = function handleClick(event, tab) {
  var id = tab.getAttribute(ITEM_ID_ATTR_NAME);

  if (id === OVERFLOW_MENU_ID) {
    shouldShowNavbarOverflow = true;
    updateOverflowMenu();
    return;
  }

  activateItem(id);
  // Prevent any default click action (like link navigation)
  event.preventDefault();
};

var activateItem = function activateItem(id) {
  updateScrollPosition();

  var view = getView(id);
  var tabs = getTabsForId(id);

  // Set styles for navbar items and show/hide views
  setActive(id, tabs, view);
};

var onMessage = function onMessage(message) {
  if (message.data && message.data.name === 'navbar-overflow-click') {
    activateItem(message.data.itemId);
  }

  if (message.data && message.data.name === 'hide-navbar-overflow') {
    hideOverflow();
  }
};

var updateOverflowMenu = function updateOverflowMenu() {
  var moreMenuItem = document.querySelector('[data-navbar-item-id=navbar-overflow-menu]');
  if (!moreMenuItem) {
    return;
  }

  var canBeOpen = navbarOverflowItems && navbarOverflowItems.length;
  if (!canBeOpen) {
    shouldShowNavbarOverflow = false;
  }

  // There's no check for isShowingNavbarOverflow, the event is intentionally
  // resent on update, to support resizing.
  if (shouldShowNavbarOverflow) {
    isShowingNavbarOverflow = true;
    var descriptors = navbarOverflowItems.map(function (item) {
      var link = item.querySelector('a[href]');

      // The text is in the <a> element inside the item.
      return {
        name: item.firstElementChild && item.firstElementChild.textContent || '',
        id: item.getAttribute(ITEM_ID_ATTR_NAME),
        url: link && link.getAttribute('href'),
        active: item.classList.contains('active')
      };
    });

    var targetRect = moreMenuItem.getBoundingClientRect();
    global.top.postMessage({
      type: 'show-navbar-overflow',
      items: descriptors,
      right: targetRect.right,
      top: targetRect.bottom
    }, '*');
  }

  if (!shouldShowNavbarOverflow && isShowingNavbarOverflow) {
    isShowingNavbarOverflow = false;
    global.top.postMessage({
      type: 'hide-navbar-overflow'
    }, '*');
  }
};

var hideOverflow = function hideOverflow() {
  if (isShowingNavbarOverflow) {
    shouldShowNavbarOverflow = false;
    updateOverflowMenu();
  }
};

var getViews = function getViews() {
  var views = document.querySelectorAll(getSelector(VIEW_ID_ATTR_NAME));
  return Array.prototype.slice.call(views);
};

var getTabs = function getTabs() {
  var tabs = document.querySelectorAll(getSelector(ITEM_ID_ATTR_NAME));
  return Array.prototype.slice.call(tabs);
};

var getTabsForId = function getTabsForId(tabId) {
  if (!tabId) {
    return [];
  }
  // This is intentionally selecting on all of the document
  var tabs = document.querySelectorAll(getSelector(ITEM_ID_ATTR_NAME, '=', tabId));
  return Array.prototype.slice.call(tabs);
};

var getActiveTab = function getActiveTab() {
  var navbar = getNavbar();
  if (!navbar) return null;
  var activeTabId = navbar.getAttribute(ACTIVE_ID_ATTR_NAME);
  var activeTabs = getTabsForId(activeTabId);
  return activeTabs[0];
};

var getView = function getView(id) {
  return document.querySelector(getSelector(VIEW_ID_ATTR_NAME, '=', id));
};

var getFirstTabId = function getFirstTabId() {
  var tab = document.querySelector(getSelector(ITEM_ID_ATTR_NAME));
  if (tab) {
    if (tab.getAttribute(ITEM_ID_ATTR_NAME) === OVERFLOW_MENU_ID) {
      return null;
    }
    return tab.getAttribute(ITEM_ID_ATTR_NAME);
  }
  return null;
};

var setActiveForMatchingId = function setActiveForMatchingId(ids) {
  // Off the list of passed ids, find the first one that matches a tab, then set
  // that one as active.
  var count = 0;
  var tabs;
  var id;
  while (count < ids.length && (!tabs || !tabs.length)) {
    if (ids[count]) {
      id = ids[count];
      tabs = getTabsForId(id);
    }
    count++;
  }
  var useID = id;

  if (!tabs || !tabs.length) {
    return;
  }
  var view = getView(useID);

  setActive(useID, tabs, view);
};

var setActive = function setActive(id, tabs, view) {
  var currentActiveTab = getActiveTab();
  var currentActiveId = currentActiveTab && currentActiveTab.getAttribute(ITEM_ID_ATTR_NAME);

  // Abort if the new tab is already active
  if (currentActiveId === id) return;

  setActiveTabs(id, tabs);
  setActiveView(id, view);

  center.emit('navbar-change', { id: id });
};

var setActiveTabs = function setActiveTabs(id, tabs) {
  var navbar = getNavbar();
  if (!navbar) return;

  navbar.setAttribute(ACTIVE_ID_ATTR_NAME, id);

  tabs.forEach(function (tab) {
    tab.classList.add(CLASSNAME_ACTIVE);
  });

  // Remove the active class name from all tabs except the ones that should be active
  var tabs = getTabs();
  if (tabs.length) {
    tabs.forEach(function (_tab) {
      if (_tab.getAttribute(ITEM_ID_ATTR_NAME) !== id) {
        _tab.classList.remove(CLASSNAME_ACTIVE);
      }
    });
  }
};

var setActiveView = function setActiveView(id, view) {
  if (!view) {
    return;
  }

  var views = getViews();

  // Hide all views except the one that should be active
  for (var i = 0, l = views.length; i < l; i++) {
    if (views[i] !== view[0]) {
      hide(views[i]);
    }
  }

  show(view);
};

var hide = function hide(element) {
  element.style.display = 'none';
};
var show = function show(element) {
  element.style.display = 'block';
};

var updateForNode = function updateForNode(node) {
  var navbar = getNavbar(node);
  if (!navbar) return;

  live(APPLICATION_MODEL_URI).query('appURI, arguments', function (error, data) {
    if (error) throw error;

    var uri = fixAppURI(data.appURI);
    var fullAppURI = uri;
    if (data.arguments) {
      fullAppURI += ':' + data.arguments;
    }
    var id = getIdFromMatchers(fullAppURI);

    if (id) {
      // This is only the case when matchers (ITEM_MATCHER_ATTR_NAME) are used in DOM.
      setActiveForMatchingId([id]);
    } else {
      // For cases where id is only to be matched from one argument, find the id to
      // highlight by looking at the argument at HISTORY_POS_ATTR_NAME.
      var argumentIndex = +navbar.getAttribute(HISTORY_POS_ATTR_NAME) || 0;
      var idAtArgumentIndex = data.arguments.split(':')[argumentIndex];

      // For cases where nothing matches, also pass the first tab ID. This is
      // how the first tab is highlighted by default.
      var firstTabId = getFirstTabId();

      setActiveForMatchingId([fullAppURI, idAtArgumentIndex, firstTabId]);
    }
  });
};

function updateForOverflow(node) {
  var navbar = getNavbar(node);
  if (!navbar) return;

  var itemSelector = '[data-navbar] > [data-navbar-item-id]:not(.overflow-menu-button)';
  var items = node.querySelectorAll(itemSelector);
  if (!items) {
    return;
  }

  items = Array.prototype.slice.call(items);

  var overflowMenuButton = navbar.querySelector('.overflow-menu-button');

  // If we have less than two items, only show the navbar and be done. We need
  // at least two items for messurement and chances are a "more" menu won't be
  // needed.
  if (items.length < 2) {
    navbar.style.visibility = 'visible';
    if (overflowMenuButton) {
      overflowMenuButton.style.display = 'none';
    }
    return;
  }

  var navbarWidth = getWidth(navbar);
  if (!navbarWidth) {
    // The navbar isn't rendered. Bail out.
    return;
  }

  // Reset to the initial rendering state to be able to measure items.
  if (overflowMenuButton) {
    overflowMenuButton.style.display = 'inline';
  }

  items.forEach(function (item) {
    item.style.display = 'block';
    item.classList.remove('last-visible');
  });

  var sizing = measureNavbar(items, overflowMenuButton);

  // If stuff doesn't completely fit, reduce the available space by the "more"
  // menu with, then calculate what needs to go in it.
  var availableSpace = navbarWidth;
  var firstOverflown = getFirstOverflownIndex(availableSpace, sizing.itemWidths);
  var needsMoreMenu = items.length !== firstOverflown;

  if (needsMoreMenu) {
    availableSpace -= sizing.overflowMenuButtonWidth;
    firstOverflown = getFirstOverflownIndex(availableSpace, sizing.itemWidths);
  }

  if (!navbarOverflowItems) {
    navbarOverflowItems = [];
  }
  navbarOverflowItems.length = 0;

  items.forEach(function (item, i) {
    var shouldBeInOverflow = i >= firstOverflown;
    if (shouldBeInOverflow) {
      navbarOverflowItems.push(item);
    }

    // If we don't draw an overflow menu, set the last-visible class on the
    // very last item so its margin-right is removed.
    var isLastInNotOverflown = !needsMoreMenu && i === items.length - 1;

    item.style.display = shouldBeInOverflow ? 'none' : 'block';
    item.classList.toggle('last-visible', isLastInNotOverflown);
  });

  if (overflowMenuButton) {
    overflowMenuButton.style.display = needsMoreMenu ? 'inline' : 'none';
  }

  // Update items and position, possibly close the menu
  updateOverflowMenu();
  navbar.style.visibility = 'visible';
}

function updateScrollPosition() {
  var scrollTop = window.pageYOffset;
  var stickyElements = Array.prototype.slice.call(document.querySelectorAll('[' + STICKY_WRAPPER_ATTR_NAME + ']'));

  if (stickyElements.length === 0) return;

  // Get the `top` value of a sticky element that is
  // in a fixed position (negative value)
  // and the closest to the top (smallest top value).
  var topTarget = stickyElements.reduce(function (res, el) {
    var top = el.getBoundingClientRect().top;
    return top < res ? top : res;
  }, 0);

  var topBarHeight = parseInt(document.documentElement.getAttribute('data-new-headers-top-bar-height'), 10) || 0;

  if (topTarget < 0) {
    // Add 1 px to have the sticky element in fixed position.
    window.scrollTo(0, scrollTop + topTarget + 1 - topBarHeight);
  }
}

function handleResize() {
  updateForOverflow(document.body);
}

function measureNavbar(items, overflowMenuButton) {
  // Find out what the margin per item is my messuring beween the first 2 items.
  var item1 = items[0];
  var item2 = items[1];

  var right1 = Math.floor(item1.getBoundingClientRect().right);
  var left2 = Math.floor(item2.getBoundingClientRect().left);
  var marginPerSide = (left2 - right1) / 2;

  var itemWidths = [];
  if (items) {
    itemWidths = items.map(function (item, i, all) {
      var marginLeft = i === 0 ? 0 : marginPerSide;
      var marginRight = i === all.length - 1 ? 0 : marginPerSide;
      return getWidth(item) + marginLeft + marginRight;
    });
  }

  // When the overflowMenuButton is showns, it's always at the end, so it has
  // no right margin.
  var overflowMenuButtonWidth = 0;
  if (overflowMenuButton) {
    overflowMenuButtonWidth = getWidth(overflowMenuButton) + marginPerSide;
  }

  return {
    itemWidths: itemWidths,
    overflowMenuButtonWidth: overflowMenuButtonWidth
  };
}

function getWidth(element) {
  return element && element.offsetWidth || 0;
}

function getFirstOverflownIndex(space, sizes) {
  var count = 0;
  var used = 0;
  while (sizes[count] !== undefined && used < space) {
    used += sizes[count];
    // This is actually expected to return up to .length of the sizes.
    // That will be the case when everything fits.
    count++;
  }
  if (used < space) {
    return count;
  }
  return count - 1;
}

// Hack to get around bridge bug (reported at WP-471) where WP reports
// the uri with the arguments as well.
var fixAppURI = function fixAppURI(uri) {
  return uri.split(':').slice(0, 3).join(':');
};

// Matchers allow you to tell a tab to be active for a pattern of the app arguments.
// If you define data-navbar-item-matcher="user:.*?:playlist:.*$" you tell the tab
// to be active when the arguments match that regexp.
var storedMatchers = {};
var getMatchers = function getMatchers(node) {
  var matchers = node.querySelectorAll(getSelector(ITEM_MATCHER_ATTR_NAME));
  if (!matchers.length) return;

  matchers = Array.prototype.slice.call(matchers);
  matchers.forEach(function (matcher) {
    var regexp = matcher.getAttribute(ITEM_MATCHER_ATTR_NAME);
    var id = matcher.getAttribute(ITEM_ID_ATTR_NAME);
    storedMatchers[regexp] = id;
  });
};

var getIdFromMatchers = function getIdFromMatchers(uri) {
  for (var regexp in storedMatchers) {
    if (storedMatchers.hasOwnProperty(regexp)) {
      var regexpObj = new RegExp(regexp);
      if (regexpObj.test(uri)) return storedMatchers[regexp];
    }
  }
  return null;
};

var getNavbar = function getNavbar(opt_node) {
  var node = opt_node || document.documentElement;
  var selector = getSelector(NAVBAR_ATTR_NAME);
  return node.matches(selector) ? node : node.querySelector(selector);
};

var onApplicationChange = function onApplicationChange(event) {
  if ('arguments' in event || 'active' in event) {
    updateForNode(document.documentElement);
  }
};

var isAttached = false;

exports.update = function update(node) {
  if (!isAttached) return;

  updateForNode(node || document.documentElement);
  getMatchers(node || document.documentElement);
  updateForOverflow(node || document.documentElement);
};

exports.attach = function attach() {
  if (isAttached) return;
  isAttached = true;

  $(document).delegate('click', getSelector(ITEM_ID_ATTR_NAME), handleClick);
  window.addEventListener('message', onMessage);
  live(APPLICATION_MODEL_URI).on('update', onApplicationChange);
  window.addEventListener('resize', handleResize);
  center.on('navbar-hide', hideOverflow);
};

exports.detach = function detach() {
  if (!isAttached) return;
  isAttached = false;

  navbarOverflowItems = null;
  isShowingNavbarOverflow = false;
  shouldShowNavbarOverflow = false;

  $(document).undelegate('click', getSelector(ITEM_ID_ATTR_NAME), handleClick);
  window.removeEventListener('message', onMessage);
  live(APPLICATION_MODEL_URI).off('update', onApplicationChange);
  window.removeEventListener('resize', handleResize);
  center.off('navbar-hide', hideOverflow);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-elements":231,"../spotify-live":512,"./center":242}],285:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
var live = require('../spotify-live');

var sessionModel;

function onSessionUpdate(properties) {
  if ('online' in properties) {
    if (properties.online) {
      $(document.body).removeClass('offline');
    } else {
      $(document.body).addClass('offline');
    }
  }
}

function updateWithSessionValue() {
  live('spotify:client').query('session(online)', function (error, data) {
    if (error) throw error;
    onSessionUpdate({ online: data.session.online });
  });
}

var isAttached = false;

exports.update = function () {
  if (!isAttached) return;

  updateWithSessionValue();
};

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  if (!sessionModel) {
    live('spotify:client').get('session', function (error, session) {
      if (error) throw error;
      sessionModel = session;
      sessionModel.on('update', onSessionUpdate);
    });
  }
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  if (sessionModel) {
    sessionModel.off('update', onSessionUpdate);
    sessionModel = null;
  }
};

},{"../spotify-elements":231,"../spotify-live":512}],286:[function(require,module,exports){
'use strict';

/**
 * @private
 */

var $ = require('../../spotify-elements');
var utils = require('./utils');

var SELECTOR_LIST_ROW = '[data-context] [data-list-item]';
var SELECTOR_PLAY_BUTTON = '[data-button=play]';
var SELECTOR_PLAY_CONTEXT_BUTTON = '[data-button=play-context]';

// This array will store event types for touch handling
var lastEventTypes = [];

// Methods that need implementation from another module.
// This is to support generic handling of user actions from within this module,
// but allow further checks and actions to be performed by another module. This
// allows multiple different implementations of starting playback for example.
var methods = {
  getPlayerVariantUri: utils.createEmptyMethod('getPlayerVariantUri'),
  handlePlayButton: utils.createEmptyMethod('handlePlayButton'),
  handlePlayFromRow: utils.createEmptyMethod('handlePlayFromRow')
};

/**
 * Handle the click of a play button.
 *
 * @param {MouseEvent} event An event object for a click event.
 * @param {Elements} button An element instance from the `elements` package.
 *
 * @private
 */
function handlePlayButtonClick(event, button) {
  var buttonNode = button[0];
  var buttonContextUri = utils.getUriFromButton(buttonNode);

  // We need an associated context URI for the button
  if (!buttonContextUri) {
    return;
  }

  var playerContextUri = methods.getPlayerVariantUri();
  var isPlayingContext = utils.compareContexts(playerContextUri, buttonContextUri);

  var source = utils.getAttributeValueFromNode(buttonNode, 'data-play-source');

  methods.handlePlayButton(buttonNode, {
    isPlayingContext: isPlayingContext,
    contextUri: buttonContextUri,
    source: source,
    reason: 'playbtn'
  });
}

/**
 * Handle the double click or tap of a list row to start playback.
 *
 * @param {Elements} row An element instance from the `elements` package.
 *
 * @private
 */
function handleListRow(row) {
  var contextNode = row.parent('[data-context]');
  if (contextNode) {
    var rowNode = row[0];
    var source = utils.getAttributeValueFromNode(rowNode, 'data-play-source');
    methods.handlePlayFromRow(rowNode, {
      contextUri: contextNode.data('uri'),
      source: source,
      reason: 'clickrow'
    });
  }
}

/**
 * Handle double clicking on a list row to start playback.
 *
 * @param {MouseEvent} event An event object for a double click.
 * @param {Elements} row An element instance from the `elements` package.
 *
 * @private
 */
function handleRowDoubleClick(event, row) {
  // Only play when not clicking on interactive elements such as buttons
  if (!utils.isInteractiveElement(event.target)) {
    handleListRow(row);
  }
}

/**
 * Handle a key press on a list row.
 * This will take care of starting playback when pressing Enter.
 *
 * @param {KeyboardEvent} event A keyboard event.
 * @param {Elements} row An element instance from the `elements` package.
 *
 * @private
 */
function handleRowKeyDown(event, row) {
  var isEnter = event.keyCode === 13;
  if (isEnter) {
    if (utils.isFormOrLinkElement(event.target)) {
      return;
    }

    event.preventDefault();
    event.stopPropagation();

    handleListRow(row);
  }
}

/**
 * Handle the 'contextmenu' event. This is only for touch handling.
 * This is needed since we use a custom context menu in Spotify, and the handler
 * for that calls `preventDefault` for the 'contextmenu' event, which means the
 * rest of the touch handling will go on as usual. So as we don't get the
 * 'touchcancel' event, we need to catch the 'contextmenu' event here to know
 * that we should not act on the following 'touchend' event.
 *
 * @param {MouseEvent} event A 'contextmenu' event.
 *
 * @private
 */
function handleContextMenu(event) {
  lastEventTypes.push(event.type);
}

/**
 * Handle the start of a touch. Used to detect a tap.
 *
 * @param {TouchEvent} event A touch event.
 *
 * @private
 */
function handleRowTouchStart(event) {
  lastEventTypes.push(event.type);
}

/**
 * Handle the move of a touch. Used to abort detection of a tap.
 *
 * @param {TouchEvent} event A touch event.
 *
 * @private
 */
function handleRowTouchMove(event) {
  lastEventTypes.push(event.type);
}

/**
 * Handle the end of a touch. Used to detect a tap and start playback of a row.
 *
 * @param {TouchEvent} event A touch event.
 * @param {Elements} row An element instance from the `elements` package.
 *
 * @private
 */
function handleRowTouchEnd(event, row) {
  // If this was a tap (only touchstart was triggered before this)
  if (lastEventTypes.length === 1 && lastEventTypes[0] === 'touchstart') {

    // Prevent the simulated mouse events (including click). This is to
    // avoid the simulated click event to click on the play button that
    // appears when selecting a row on touchstart.
    // See: https://jira.spotify.net/browse/KM-7983
    if (!utils.isInteractiveElement(event.target)) {
      event.preventDefault();

      // Tapping on a row should play it
      handleListRow(row);
    }
  }
  lastEventTypes = [];
}

/**
 * Attach the needed event listeners for the module.
 */
exports.attach = function () {
  var doc = $(document);

  doc.delegate('keydown', SELECTOR_LIST_ROW, handleRowKeyDown);
  doc.delegate('click', SELECTOR_PLAY_BUTTON, handlePlayButtonClick);
  doc.delegate('click', SELECTOR_PLAY_CONTEXT_BUTTON, handlePlayButtonClick);
  doc.delegate('dblclick', SELECTOR_LIST_ROW, handleRowDoubleClick);

  /* For touch handling */
  doc.delegate('touchstart', SELECTOR_LIST_ROW, handleRowTouchStart);
  doc.delegate('touchend', SELECTOR_LIST_ROW, handleRowTouchEnd);
  doc.delegate('touchmove', SELECTOR_LIST_ROW, handleRowTouchMove);
  doc.delegate('contextmenu', SELECTOR_LIST_ROW, handleContextMenu);
};

/**
 * Detach the event listeners for the module.
 */
exports.detach = function () {
  var doc = $(document);

  doc.undelegate('keydown', SELECTOR_LIST_ROW, handleRowKeyDown);
  doc.undelegate('click', SELECTOR_PLAY_BUTTON, handlePlayButtonClick);
  doc.undelegate('click', SELECTOR_PLAY_CONTEXT_BUTTON, handlePlayButtonClick);
  doc.undelegate('dblclick', SELECTOR_LIST_ROW, handleRowDoubleClick);

  /* For touch handling */
  doc.undelegate('touchstart', SELECTOR_LIST_ROW, handleRowTouchStart);
  doc.undelegate('touchend', SELECTOR_LIST_ROW, handleRowTouchEnd);
  doc.undelegate('touchmove', SELECTOR_LIST_ROW, handleRowTouchMove);
  doc.undelegate('contextmenu', SELECTOR_LIST_ROW, handleContextMenu);
};

/**
 * Set the external methods for this module to add implementations for starting
 * playback etc.
 *
 * @param {Object} methodDefinitions Object where keys are method names and
 *     values are functions.
 */
exports.setMethods = function (methodDefinitions) {
  for (var name in methodDefinitions) {
    if (methodDefinitions.hasOwnProperty(name)) {
      methods[name] = methodDefinitions[name];
    }
  }
};

},{"../../spotify-elements":231,"./utils":289}],287:[function(require,module,exports){
'use strict';

var playerWithIndices = require('./withIndices');
var playerWithUids = require('./withUids');

var playerModule = playerWithIndices;

exports.setMode = function (type) {
  switch (type) {
    case 'indices':
      playerModule = playerWithIndices;
      break;
    case 'uids':
      playerModule = playerWithUids;
      break;
  }
};

exports.attach = function () {
  playerModule.attach();
};

exports.detach = function () {
  playerModule.detach();
};

exports.update = function (optNode) {
  playerModule.update(optNode);
};

},{"./withIndices":290,"./withUids":291}],288:[function(require,module,exports){
'use strict';

/**
 * @private
 */

var difference = require('mout/array/difference');
var $ = require('../../spotify-elements');
var live = require('../../spotify-live');

var center = require('../center');
var utils = require('./utils');

var CURRENT = 'current';
var PAUSED = 'paused';
var PLAYING = 'playing';

var LOG_PLAY_BUTTON = 'play-button';
var LOG_PAUSE_BUTTON = 'pause-button';

var SELECTOR_PLAY_BUTTON = '[data-button=play]';
var SELECTOR_PLAY_CONTEXT_BUTTON = '[data-button=play-context]';
var SELECTOR_ALL_PLAY_BUTTONS = SELECTOR_PLAY_BUTTON + ',' + SELECTOR_PLAY_CONTEXT_BUTTON;

// Methods that need implementation from another module.
// This is to support generic handling of DOM updates from within this module,
// but allow further checks and actions to be performed by another module. This
// allows multiple different implementations of highlighting playing objects.
var methods = {
  getPlayerVariantUri: utils.createEmptyMethod('getPlayerVariantUri'),
  getPlayerIsPlaying: utils.createEmptyMethod('getPlayerIsPlaying'),
  getPlayingNodes: utils.createEmptyMethod('getPlayingNodes'),

  // This should be a function that takes a function as the first argument. That
  // function argument should be called whenever the player state has changed.
  subscribeToPlayerChange: utils.createEmptyMethod('subscribeToPlayerChange')
};

var playableChangeHandlers = {};
var playerSubscription = null;

/**
 * Update states in the DOM based on current player state.
 *
 * @param {HTMLElement=} node An optional DOM node. If passed, only nodes inside
 *     of that node will be updated.
 */
function updateDOM(optNode) {
  var containerNode = optNode || document;

  updateButtonsBasedOnPlayable(containerNode);

  var playingNodes = getPlayingNodes(containerNode);
  var currentNodes = getCurrentNodes(containerNode);

  if (currentNodes) {
    var nodesForRemoval = currentNodes;
    if (playingNodes) {
      nodesForRemoval = difference(currentNodes, playingNodes);
    }
    nodesForRemoval.forEach(removePlayingStateFromNode);
  }

  if (playingNodes) {
    var nodesForAddition = playingNodes;
    if (currentNodes) {
      nodesForAddition = difference(playingNodes, currentNodes);
    }
    nodesForAddition.forEach(addPlayingStateToNode);

    var nodesForUpdate = difference(playingNodes, nodesForAddition);
    nodesForUpdate.forEach(updatePlayingStateForNode);
  }
}

/**
 * Update the playable status of all play buttons found inside the passed
 * container node.
 *
 * @param {HTMLElement} containerNode A DOM node to search for nodes inside.
 *
 * @private
 */
function updateButtonsBasedOnPlayable(containerNode) {
  // `[data-button=play]` buttons are used to play something specific *in* a
  // context (defining an index as a track number or uid/uri or range).
  // Those are currently not updated themselves, instead their rows are being
  // set to `.unavailable`.
  var buttons = $(containerNode).search('[data-button=play-context]');
  if (buttons) {
    buttons.forEach(updateButtonBasedOnPlayable);
  }
}

/**
 * Update the playable status of the passed button.
 *
 * @param {HTMLElement} button A button DOM node.
 *
 * @private
 */
function updateButtonBasedOnPlayable(button) {

  // Play buttons in list rows should not be handled, as the buttons are
  // hidden by CSS anyway for unplayable rows.
  if ($(button).parent('[data-list-item]')) {
    return;
  }

  var contextURI = utils.getUriFromButton(button);

  // Check if the context has a playable flag specified.
  var playableValue = live(contextURI).get('playable');
  var definesPlayable = playableValue !== undefined;

  // If it does, update the `disabled` attribute based on it
  if (definesPlayable) {
    if (playableValue) {
      button.removeAttribute('disabled');
    } else {
      button.setAttribute('disabled', 'disabled');
    }

    if (!playableChangeHandlers[contextURI]) {
      playableChangeHandlers[contextURI] = function (changed) {
        if (!changed.hasOwnProperty('playable')) {
          return;
        }
        // Update all buttons currently in DOM when `playable` changes on a
        // context. Not worth adding logic to only pick out buttons pointing to
        // a specific URI.
        updateButtonsBasedOnPlayable(document.body);
      };
      live(contextURI).on('update', playableChangeHandlers[contextURI]);
    }
  }
}

/**
 * Get the nodes inside the passed container node that are currently marked as
 * playing.
 *
 * @param {HTMLElement} containerNode A DOM node to search for nodes inside.
 *
 * @return {?Elements} An element instance from the `elements` package, or null.
 *
 * @private
 */
function getCurrentNodes(containerNode) {
  return $(containerNode).search('[data-playback-active=true]');
}

/**
 * Get the nodes inside the passed container node that should be marked as
 * playing based on the current player state.
 *
 * @param {HTMLElement} containerNode A DOM node to search for nodes inside.
 *
 * @return {?Elements} An element instance from the `elements` package, or null.
 *
 * @private
 */
function getPlayingNodes(containerNode) {
  var variantUri = methods.getPlayerVariantUri();
  var selectors = utils.getContextSelectorsWithVariants(variantUri);

  var contextNodes = $(containerNode).search(selectors.join(', '));
  if (contextNodes) {
    contextNodes = Array.prototype.slice.call(contextNodes);
  } else {
    contextNodes = [];
  }

  // Pass it through the outside implementation, which might filter out
  // nodes from `contextNodes` and add more nodes to the match.
  return methods.getPlayingNodes(containerNode, contextNodes);
}

/**
 * Remove the playing state from the passed DOM node, as it's no longer playing.
 *
 * @param {HTMLElement} node The DOM node to remove state from.
 *
 * @private
 */
function removePlayingStateFromNode(node) {
  var className = [CURRENT, PAUSED, PLAYING].join(' ');
  node = $(node);
  node.removeClass(className).removeAttribute('data-playback-active');

  if (node.matches(SELECTOR_ALL_PLAY_BUTTONS)) {
    node.attribute('data-log-click', LOG_PLAY_BUTTON);
  }
}

/**
 * Add the playing state to the passed DOM node, as it's now playing.
 *
 * @param {HTMLElement} node The DOM node to add state to.
 *
 * @private
 */
function addPlayingStateToNode(node) {
  var isPlaying = methods.getPlayerIsPlaying();

  var classNames = [CURRENT, isPlaying ? PLAYING : PAUSED].join(' ');

  node = $(node);
  node.addClass(classNames).data('playback-active', true);

  if (node.matches(SELECTOR_ALL_PLAY_BUTTONS)) {
    node.attribute('data-log-click', isPlaying ? LOG_PAUSE_BUTTON : LOG_PLAY_BUTTON);
  }
}

/**
 * Update the playing state for the passed DOM node, as it's still representing
 * the currently playing context, but the player might switch between
 * playing/paused.
 *
 * @param {HTMLElement} node The DOM node to update state for.
 *
 * @private
 */
function updatePlayingStateForNode(node) {
  var isPlaying = methods.getPlayerIsPlaying();

  var currentClassName = isPlaying ? PAUSED : PLAYING;
  var newClassName = isPlaying ? PLAYING : PAUSED;
  var element = $(node);

  if (element.hasClass(currentClassName)) {
    element.removeClass(currentClassName);
  }

  if (!element.hasClass(newClassName)) {
    element.addClass(newClassName);
  }

  if (element.matches(SELECTOR_ALL_PLAY_BUTTONS)) {
    element.attribute('data-log-click', isPlaying ? LOG_PAUSE_BUTTON : LOG_PLAY_BUTTON);
  }
}

/**
 * Handle updating of DOM nodes when they have been added to the DOM by a scroll
 * agent.
 *
 * @param {Object} event Custom event object sent from the scroll agent. Should
 *     contain a `container` property pointing to the DOM node containing the
 *     rows.
 *
 * @private
 */
function handleScrollShowAfter(event) {
  var container = $(event.container);
  var contextNode = null;
  if (container.matches('[data-context]')) {
    contextNode = container;
  } else {
    contextNode = container.parent('[data-context]');
  }

  // We can't pass the context node itself as root because of how the playing
  // state queries are set up.
  var contextParent = contextNode && contextNode[0].parentElement || document;

  updateDOM(contextParent);
}

/**
 * Attach the needed event listeners for the module.
 */
exports.attach = function () {
  playerSubscription = methods.subscribeToPlayerChange(function () {
    updateDOM();
  });

  center.on('scroll-show-after', handleScrollShowAfter);
};

/**
 * Detach the needed event listeners for the module.
 */
exports.detach = function () {
  if (playerSubscription) {
    playerSubscription.cancel();
    playerSubscription = null;
  }

  for (var contextUri in playableChangeHandlers) {
    if (playableChangeHandlers.hasOwnProperty(contextUri)) {
      live(contextUri).off('update', playableChangeHandlers[contextUri]);
    }
  }
  playableChangeHandlers = {};

  center.off('scroll-show-after', handleScrollShowAfter);
};

/**
 * Update things in the DOM.
 */
exports.update = updateDOM;

/**
 * Set the external methods for this module to add implementations for methods
 * needed for highlighting playing objects.
 *
 * @param {Object} methodDefinitions Object where keys are method names and
 *     values are functions.
 */
exports.setMethods = function (methodDefinitions) {
  for (var name in methodDefinitions) {
    if (methodDefinitions.hasOwnProperty(name)) {
      methods[name] = methodDefinitions[name];
    }
  }
};

},{"../../spotify-elements":231,"../../spotify-live":512,"../center":242,"./utils":289,"mout/array/difference":653}],289:[function(require,module,exports){
(function (global){
'use strict';

/**
 * This module might be used by modules outside of spotify-events.
 * @public
 */

var liburi = require('spotify-liburi');

var getOriginUri = require('../../spotify-live-wrapped-uri').getOriginUri;

/**
 * Get the context URI from a button node or its parents.
 *
 * @param {HTMLElement} button A DOM node for a button.
 *
 * @return {string} The context URI or empty string if not found.
 */
function getUriFromButton(button) {
  var contextNode = button.closest('[data-context]');
  return contextNode && contextNode.getAttribute('data-uri') || '';
}

/**
 * Get the value for the passed attribute name, either from the passed node or
 * from any parent node.
 *
 * @param {HTMLElement} node The node to start searching from.
 * @param {string} attributeName The name of the attribute.
 *
 * @return {string} The value, or empty string if not found.
 */
function getAttributeValueFromNode(node, attributeName) {
  var selector = '[' + attributeName + ']';
  var attributeNode = node.closest(selector);
  return attributeNode && attributeNode.getAttribute(attributeName) || '';
}

/**
 * Check if the passed element is a form or link element.
 *
 * @param {HTMLElement} element A DOM node.
 *
 * @return {boolean} True if it is a form or link element.
 */
function isFormOrLinkElement(element) {
  var tagName = element.tagName.toLowerCase();
  var elements = ['input', 'textarea', 'button', 'select', 'optgroup', 'option', 'a'];
  return elements.indexOf(tagName) > -1;
}

/**
 * Check if the passed element is an interactive element (links, buttons).
 *
 * @param {HTMLElement}  element A DOM node.
 *
 * @return {boolean} True if the element is interactive.
 */
function isInteractiveElement(element) {
  var tagName = element.tagName.toLowerCase();
  return tagName === 'a' || tagName === 'button';
}

/**
 * Get a CSS selector string for a context.
 *
 * @param {string} operator A CSS selector operator ($= or similar).
 * @param {string} uri The context URI.
 *
 * @return {string} The CSS selector string.
 */
function getContextSelector(operator, uri) {
  return '[data-context][data-uri' + operator + uri + ']';
}

/**
 * Get an array of CSS selectors for searching for context nodes inside the DOM.
 *
 * @param {string} uri The context URI to search for. This should be the
 *     currently playing variant URI (for example, when playing a sorted
 *     playlist the sorted URI should be passed).
 *
 * @return {Array.<string>} Array of CSS selector strings.
 */
function getContextSelectors(uri) {
  var SAME = '=';

  var selectors = [getContextSelector(SAME, uri)];

  var normalized = normalizeUri(uri);
  if (uri !== normalized) {
    selectors.push(getContextSelector(SAME, normalized));
  }

  return selectors;
}

/**
 * Get an array of CSS selectors for searching for context nodes inside the DOM.
 * This also includes any variant of the passed context URI. For example, if
 * passing a sorted playlist URI, it will return selectors for matching all
 * variations of that playlist URI, including the regular playlist URI, filtered
 * URI etc.
 *
 * @param {string} uri The context URI to search for. This can be either the
 *     origin URI, or any variant URI. The function will convert it to the
 *     origin URI automatically.
 *
 * @return {Array.<string>} Array of CSS selector strings.
 */
function getContextSelectorsWithVariants(uri) {
  var STARTS_WITH = '^=';
  var ENDS_WITH = '$=';
  var EQUALS = '=';

  var originUri = getOriginUri(uri) || uri;
  var originUriNormalized = normalizeUri(originUri);

  var originUriEnding = originUri.replace(/^spotify:/, ':');
  var originUriEndingNormalized = normalizeUri(originUriEnding);

  var selectors = [getContextSelector(EQUALS, originUri)];

  selectors.push(getContextSelector(STARTS_WITH, 'spotify:internal:filterlist:') + getContextSelector(ENDS_WITH, originUri.replace(/^spotify:/, ':')));

  selectors.push(getContextSelector(STARTS_WITH, 'spotify:internal:sortlist:') + getContextSelector(ENDS_WITH, originUri.replace(/^spotify:/, ':')));

  if (originUri !== originUriNormalized) {
    selectors.push(getContextSelector(EQUALS, originUriNormalized));
    selectors.push(getContextSelector(STARTS_WITH, 'spotify:internal:filterlist:') + getContextSelector(ENDS_WITH, originUriEndingNormalized));
    selectors.push(getContextSelector(STARTS_WITH, 'spotify:internal:sortlist:') + getContextSelector(ENDS_WITH, originUriEndingNormalized));
  }

  return selectors;
}

/**
 * Check if two context URIs are representing the same context. This will take
 * care of normalizing the casing of URL encoding and filtered/sorted contexts.
 *
 * @param {string} context1 The first context.
 * @param {string} context2 The second context.
 *
 * @return {boolean} True if they represent the same context.
 */
function compareContexts(context1, context2) {
  if (!context1 || !context2) return false;

  context1 = normalizeUri(getOriginUri(context1) || context1);
  context2 = normalizeUri(getOriginUri(context2) || context2);

  return context1 === context2;
}

/**
 * A URI might contain URL encoded characters, and per spec the URL encoding can
 * be either in lowercase or uppercase (should be treated as same URL). If the
 * input URL has lowercase encoding, liburi will convert it into uppercase
 * encoding.
 *
 * @param {string} uri The URI to normalize.
 *
 * @return {string} The normalized URI.
 */
function normalizeUri(uri) {
  var uriObj = liburi.from(uri);
  var normalized = uriObj ? uriObj.toString() : uri;

  // Work around incorrect handling of `spotify:internal:...` URIs by liburi,
  // since it does not recognize `internal` URIs, and therefore uses the default
  // `app` type.
  normalized = normalized.replace(/^spotify:app:internal:/, 'spotify:internal:');

  // Work around the bad conversion of spaces in filtered list URIs. The URI
  // spec we use says that spaces should be encoded as `+`, but the `filterlist`
  // URI uses the regular `%20` encoding for spaces. Passing it through liburi
  // converts it to `+`, so we need to convert it back to `%20` again.
  normalized = normalized.replace(/:internal:filterlist:[^:]+/, function (match) {
    return match.replace(/\+/g, '%20');
  });

  return normalized;
}

/**
 * Create an empty method that will only log a warning when called.
 *
 * @param {string} methodName The name of the method to warn about.
 *
 * @return {Function} The function.
 */
function createEmptyMethod(methodName) {
  return function () {
    if (global.console) {
      console.warn('spotify-events/player: `' + methodName + '` is not implemented.');
    }
  };
}

exports.getUriFromButton = getUriFromButton;
exports.getAttributeValueFromNode = getAttributeValueFromNode;
exports.isFormOrLinkElement = isFormOrLinkElement;
exports.isInteractiveElement = isInteractiveElement;
exports.getContextSelector = getContextSelector;
exports.getContextSelectors = getContextSelectors;
exports.getContextSelectorsWithVariants = getContextSelectorsWithVariants;
exports.compareContexts = compareContexts;
exports.normalizeUri = normalizeUri;
exports.createEmptyMethod = createEmptyMethod;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-live-wrapped-uri":511,"spotify-liburi":899}],290:[function(require,module,exports){
'use strict';

/**
 * @private
 */

var live = require('../../spotify-live');
var Range = require('../../spotify-range2');
var $ = require('../../spotify-elements');
var find = require('mout/array/find');

var playerActions = require('./actions');
var playerUpdates = require('./updates');
var utils = require('./utils');

var isAttached = false;

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  playerActions.setMethods({
    getPlayerVariantUri: getPlayerVariantUri,
    handlePlayButton: handlePlayButton,
    handlePlayFromRow: handlePlayFromRow
  });

  playerUpdates.setMethods({
    getPlayerVariantUri: getPlayerVariantUri,
    getPlayerIsPlaying: getPlayerIsPlaying,
    getPlayingNodes: getPlayingNodes,
    subscribeToPlayerChange: subscribeToPlayerChange
  });

  playerActions.attach();
  playerUpdates.attach();
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  playerActions.detach();
  playerUpdates.detach();
};

exports.update = function (optNode) {
  if (!isAttached) return;

  playerUpdates.update(optNode);
};

/**
 * Get the variant URI for the currently playing context. For example, if
 * playing a sorted playlist, this should return the sorted URI.
 *
 * @return {string} The context variant URI, or empty string if nothing is
 *     playing.
 */
function getPlayerVariantUri() {
  var variant = live('spotify:player').get('variant');
  return variant ? variant.uri : '';
}

/**
 * Get the index of the currently playing track within the playing context.
 *
 * @return {number} The index, or -1 if not found.
 */
function getPlayerIndex() {
  var indexObject = live('spotify:player').get('index');
  return indexObject ? indexObject.get('track') : -1;
}

/**
 * Get the URI of the currently playing track.
 *
 * @return {string} The track URI, or empty string if nothing is playing.
 */
function getPlayerTrackUri() {
  var track = live('spotify:player').get('track');
  return track && track.uri || '';
}

/**
 * Get the playing status of the player.
 *
 * @return {boolean} True if the player is currently playing audio.
 */
function getPlayerIsPlaying() {
  var isPlaying = live('spotify:player').get('isPlaying');
  var isPaused = live('spotify:player').get('isPaused');
  return isPlaying && !isPaused;
}

/**
 * Get whether the player is currently shuffling the context.
 *
 * @return {boolean} True if shuffling.
 */
function getPlayerIsShuffling() {
  var options = live('spotify:player').get('options');
  var shufflingContext = options && options.get('shufflingContext');
  return !!shufflingContext;
}

/**
 * Subscribe to player changes.
 *
 * @param {Function} handler A handler function. The data passed to this
 *     function is irrelevent, only the fact that something changed is needed.
 *
 * @return {Object} An object with a `cancel` method to cancel the subscription.
 */
function subscribeToPlayerChange(handler) {
  live('spotify:player').on('update', handler);
  var active = true;
  return {
    cancel: function cancel() {
      if (active) {
        live('spotify:player').off('update', handler);
        active = false;
      }
    }
  };
}

/**
 * Handle the click of a play button.
 * This function should decide what the action should be, and pause/resume
 * playback or start playback of a new context.
 *
 * @param {HTMLElement} buttonNode A button DOM node.
 * @param {Object} data Object of data about the action:
 *     isPlayingContext: (boolean) Whether the button looks to be representing
 *         the currently playing context.
 *     contextUri: (string) The context URI for the button.
 *     source: (string) The 'play source' value, for logging purposes.
 *     reason: (string) The 'play reason' value, for logging purposes.
 */
function handlePlayButton(buttonNode, data) {
  var button = $(buttonNode);
  var playerIndex = getPlayerIndex();
  var range;
  var newIndex;
  var uids;
  var uris;

  var dataRange = button.data('range');
  if (dataRange) {
    range = Range.fromString(dataRange);
    var list = live(data.contextUri).get('rows');
    if (list) {
      var indices = range.toIndices();
      uids = indices.map(function (index) {
        return list.keys[index];
      });
      uris = indices.map(function (index) {
        var track = list.get(index).get('track');
        return track.uri;
      });
    }
    newIndex = null;
  } else {
    var contextIndexNode = null;
    if (button.matches('[data-context-index]')) {
      contextIndexNode = button;
    } else {
      contextIndexNode = button.parent('[data-context-index]');
    }

    if (contextIndexNode) {
      newIndex = parseInt(contextIndexNode.data('context-index'), 10);
      var list = live(data.contextUri).get('rows');
      if (list) {
        uids = [list.keys[newIndex]];
        uris = [list.get(newIndex).get('track').uri];
      }
    } else {
      newIndex = null;
    }
  }

  var shouldPauseResume = false;

  if (data.isPlayingContext) {
    if (range) {
      shouldPauseResume = range.contains(new Range(playerIndex, playerIndex + 1));
    } else if (newIndex !== null) {
      shouldPauseResume = newIndex === playerIndex;
    } else {
      shouldPauseResume = true;
    }
  }

  if (shouldPauseResume) {
    if (getPlayerIsPlaying()) {
      live('spotify:player').emit('pause');
    } else {
      live('spotify:player').emit('resume');
    }
  } else {
    var eventData = {
      context: data.contextUri,
      index: newIndex,
      source: data.source,
      reason: data.reason
    };

    if (range) {
      eventData.range = [range.start, range.end];
    }

    if (uids) {
      eventData.uids = uids;
    }

    if (uris) {
      eventData.uris = uris;
    }

    live('spotify:player').emit('play', eventData);
  }
}

/**
 * Handle playing a list row. This function should start playback of a context
 * starting from a specific row.
 *
 * @param {HTMLElement} rowNode A DOM node for a list row.
 * @param {Object} data Object of data about the action:
 *     contextUri: (string) The context URI for the list.
 *     source: (string) The 'play source' value, for logging purposes.
 *     reason: (string) The 'play reason' value, for logging purposes.
 */
function handlePlayFromRow(rowNode, data) {
  var index = parseInt(rowNode.getAttribute('data-context-index'), 10);
  if (isNaN(index)) {
    index = -1;
  }
  var uid = rowNode.getAttribute('data-uid') || '';
  var uri = rowNode.getAttribute('data-uri') || '';

  var eventData = {
    context: data.contextUri,
    index: index,
    source: data.source,
    reason: data.reason
  };

  if (uid) {
    eventData.uids = [uid];
  }

  if (uri) {
    eventData.uris = [uri];
  }

  live('spotify:player').emit('play', eventData);
}

/**
 * Get the nodes inside the passed container node that should be marked as
 * playing.
 *
 * @param {HTMLElement} containerNode The DOM node to search inside.
 * @param {Array.<HTMLElement>} contextNodes Array of DOM nodes that are already
 *     matched based on context URIs. These can be filtered if needed, but
 *     otherwise they should be included in the return value.
 *
 * @return {Array.<HTMLElement>} An array of DOM nodes.
 */
function getPlayingNodes(containerNode, contextNodes) {
  var playerIndex = getPlayerIndex();
  var playerTrackUri = getPlayerTrackUri();
  var variantUri = getPlayerVariantUri();

  // Remove any matched context nodes that have a range specified and where
  // the current player index does not match.
  var filteredContextNodes = filterRanges(playerIndex, contextNodes);

  var selectors = utils.getContextSelectors(variantUri);
  var selectorsWithVariants = utils.getContextSelectorsWithVariants(variantUri);

  var rowNodes = getContextNodesForRows(containerNode, selectors, playerIndex, playerTrackUri) || [];

  var rangeNodes = getContextNodesForRanges(containerNode, selectorsWithVariants, playerIndex) || [];

  // Only return button nodes whos closest context is one of the nodes in the
  // contextNodes array. Imagine this minimal node tree:
  //
  // [data-context][data-uri="spotify:root-context"]
  //   [data-button=play-context]
  //   [data-context][data-uri="spotify:nested-context"]
  //     [data-button=play-context]
  //
  // The first [data-button=play-context] should play "spotify:root-context".
  // Ths second [data-button=play-context] should play "spotify:nested-context".
  var buttonNodes = [];
  if (contextNodes.length) {
    var candidates = $(contextNodes).search('[data-button=play-context]');
    if (candidates) {
      buttonNodes = candidates.filter(function (candidate) {
        var closestContextNode = candidate.closest('[data-context]');
        return contextNodes.indexOf(closestContextNode) >= 0;
      });
    }
  }

  // Let `elements` remove any duplicate nodes
  var nodes = $([filteredContextNodes, rowNodes, rangeNodes, buttonNodes]);

  return nodes ? Array.prototype.slice.call(nodes) : [];
}

/**
 * Get the nodes inside the passed container node that match what's currently
 * playing and are list rows.
 *
 * @param {HTMLElement} containerNode The DOM node to search inside.
 * @param {Array.<string>} selectors Array of CSS selectors for matching the
 *     currently playing context.
 * @param {number} index The currently playing index.
 * @param {string} trackUri The URI of the currently playing track.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function getContextNodesForRows(containerNode, selectors, index, trackUri) {
  var isShuffling = getPlayerIsShuffling();

  // When playing from this client, we highlight the playing index if the
  // playing variant and the list variant are exactly the same.
  //
  // Removed support for connect as we can no longer detect a connect session: KM-9645.

  var useIndexSelector = !isShuffling;
  var useTrackSelector = !!trackUri;

  var selector = selectors.map(function (selector) {
    if (useIndexSelector || useTrackSelector) selector += ' ';
    if (useIndexSelector) selector += '[data-context-index=' + index + ']';
    if (useTrackSelector) selector += '[data-uri="' + trackUri + '"]';
    return selector;
  }).join(', ');

  var nodes = selector && $(containerNode).search(selector);
  if (nodes) {
    nodes = Array.prototype.slice.call(nodes);

    if (isShuffling) {
      // As the lax matching used in this case might yield duplicate rows in a
      // single list, we must filter out those.
      nodes = nodes.filter(function (row) {
        var listNode = $(row).parent('[data-list]');
        // If this row is not the first row to be highlighted in this list,
        // filter it out.
        return row === find(nodes, function (row) {
          return listNode === $(row).parent('[data-list]');
        });
      });
    }
  } else {
    nodes = [];
  }

  return nodes;
}

/**
 * Get the nodes inside the passed container node that match what's currently
 * playing and have a matching range specified.
 *
 * @param {HTMLElement} containerNode The DOM node to search inside.
 * @param {Array.<string>} selectors Array of CSS selectors for matching the
 *     currently playing context.
 * @param {number} index The currently playing index.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function getContextNodesForRanges(containerNode, selectors, index) {
  var rangeAttribute = '[data-range]';

  // It needs to search for all range elements somewhere inside an element
  // marked up as a context, as well as range elements that themselves are
  // contexts.
  selectors = selectors.map(function (selector) {
    var rangeInContextSelector = selector + ' ' + rangeAttribute;
    var rangedContextSelector = selector + rangeAttribute;
    var rangeSelector = rangeInContextSelector + ', ' + rangedContextSelector;
    return rangeSelector;
  });

  var rangeNodes = $(containerNode).search(selectors.join(', '));
  if (rangeNodes) {
    rangeNodes = Array.prototype.slice.call(rangeNodes);
  } else {
    rangeNodes = [];
  }

  return filterRanges(index, rangeNodes);
}

/**
 * Return a new array of nodes where nodes that specify a range that doesn't
 * match the currently playing index are removed.
 *
 * @param {number} index The currently playing index.
 * @param {Array.<HTMLElement>} nodes Array of DOM nodes.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function filterRanges(index, nodes) {
  var thisRange = new Range(index, index + 1);

  return nodes.filter(function (node) {
    node = $(node);
    var range = node.data('range');

    // Node without a range should always be active
    if (!range) return true;

    // If player has no index, but the node has a range, we can't be sure if
    // it's playing
    if (!thisRange) return false;

    range = Range.fromString(range);
    return range.contains(thisRange);
  });
}

},{"../../spotify-elements":231,"../../spotify-live":512,"../../spotify-range2":551,"./actions":286,"./updates":288,"./utils":289,"mout/array/find":657}],291:[function(require,module,exports){
'use strict';

var live = require('../../spotify-live');
var $ = require('../../spotify-elements');

var playerActions = require('./actions');
var playerUpdates = require('./updates');
var utils = require('./utils');

var isAttached = false;

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  playerActions.setMethods({
    getPlayerVariantUri: getPlayerVariantUri,
    handlePlayButton: handlePlayButton,
    handlePlayFromRow: handlePlayFromRow
  });

  playerUpdates.setMethods({
    getPlayerVariantUri: getPlayerVariantUri,
    getPlayerIsPlaying: getPlayerIsPlaying,
    getPlayingNodes: getPlayingNodes,
    subscribeToPlayerChange: subscribeToPlayerChange
  });

  playerActions.attach();
  playerUpdates.attach();
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  playerActions.detach();
  playerUpdates.detach();
};

exports.update = function (optNode) {
  if (!isAttached) return;

  playerUpdates.update(optNode);
};

/**
 * Get the variant URI for the currently playing context. For example, if
 * playing a sorted playlist, this should return the sorted URI.
 *
 * @return {string} The context variant URI, or empty string if nothing is
 *     playing.
 */
function getPlayerVariantUri() {
  var variant = live('spotify:player').get('variant');
  return variant ? variant.uri : '';
}

/**
 * Get the index of the currently playing page.
 *
 * @return {number} The page index, or -1 if not found.
 */
function getPlayerPageIndex() {
  var indexObject = live('spotify:player').get('index');
  var pageIndex = indexObject && indexObject.get('page');
  var hasPageIndex = typeof pageIndex === 'number';
  return hasPageIndex ? pageIndex : -1;
}

/**
 * Get the UID of the currently playing track.
 *
 * @return {string} The UID, or empty string if not found.
 */
function getPlayerTrackUid() {
  return live('spotify:player').get('uid') || '';
}

/**
 * Get the uri of the currently playing track.
 *
 * @return {string} The uri, or empty string if not found.
 */
function getPlayerTrackUri() {
  var track = live('spotify:player').get('track');
  return track ? track.get('uri') || '' : '';
}

/**
 * Get the URI of the currently playing track.
 *
 * @return {string} The track URI, or empty string if nothing is playing.
 */
function getPlayerTrackUri() {
  var track = live('spotify:player').get('track');
  return track && track.uri || '';
}

/**
 * Get the playing status of the player.
 *
 * @return {boolean} True if the player is currently playing audio.
 */
function getPlayerIsPlaying() {
  var isPlaying = live('spotify:player').get('isPlaying');
  var isPaused = live('spotify:player').get('isPaused');
  return isPlaying && !isPaused;
}

/**
 * Get whether the playback was initiated from open.spotify.com
 *
 * This info is needed to be able to do a best-effort of highlighting rows when
 * playing from open.
 *
 * @return {boolean} True if playing from open.spotify.com.
 */
function getPlayerIsPlayingFromOpen() {
  var playOrigin = live('spotify:player').get('playOrigin');
  var externalReferrer = playOrigin && playOrigin.get('externalReferrer');

  return externalReferrer && externalReferrer.indexOf('https://open.spotify.com/') === 0;
}

/**
 * Subscribe to player changes.
 *
 * @param {Function} handler A handler function. The data passed to this
 *     function is irrelevent, only the fact that something changed is needed.
 *
 * @return {Object} An object with a `cancel` method to cancel the subscription.
 */
function subscribeToPlayerChange(handler) {
  live('spotify:player').on('update', handler);
  var active = true;
  return {
    cancel: function cancel() {
      if (active) {
        live('spotify:player').off('update', handler);
        active = false;
      }
    }
  };
}

/**
 * Handle the click of a play button.
 * This function should decide what the action should be, and pause/resume
 * playback or start playback of a new context.
 *
 * @param {HTMLElement} buttonNode A button DOM node.
 * @param {Object} data Object of data about the action:
 *     isPlayingContext: (boolean) Whether the button looks to be representing
 *         the currently playing context.
 *     contextUri: (string) The context URI for the button.
 *     source: (string) The 'play source' value, for logging purposes.
 *     reason: (string) The 'play reason' value, for logging purposes.
 */
function handlePlayButton(buttonNode, data) {
  var isPlaying = data.isPlayingContext;

  var trackUid = utils.getAttributeValueFromNode(buttonNode, 'data-uid');
  var trackUri = utils.getAttributeValueFromNode(buttonNode, 'data-track-uri');
  var pageIndex = parseInt(utils.getAttributeValueFromNode(buttonNode, 'data-context-page'), 10);

  if (isPlaying) {
    isPlaying = verifyIsPlayingIndex(trackUid, trackUri, pageIndex);
  }

  if (isPlaying) {
    if (getPlayerIsPlaying()) {
      live('spotify:player').emit('pause');
    } else {
      live('spotify:player').emit('resume');
    }
  } else {

    var eventData = {
      context: data.contextUri,
      source: data.source,
      reason: data.reason
    };

    if (trackUid) {
      eventData.uid = trackUid;
    }

    if (trackUri) {
      eventData.trackUri = trackUri;
    }

    if (!isNaN(pageIndex)) {
      eventData.page = pageIndex;
    }

    live('spotify:player').emit('play', eventData);
  }
}

/**
 * Verify that a uid, uri or pageIndex is playing, or that just the context
 * is playing when none of that is set.
 * This is used when we already know that we're playing the context.
 *
 * @param {string} trackUid
 * @param {string} trackUri
 * @param {number} pageIndex
 *
 * @return {boolean} True if it's really playing
 */
function verifyIsPlayingIndex(trackUid, trackUri, pageIndex) {
  if (trackUid) {
    var playerTrackUid = getPlayerTrackUid();
    return playerTrackUid === trackUid;
  }

  if (trackUri) {
    var playerTrackUri = getPlayerTrackUri();
    return playerTrackUri === trackUri;
  }

  if (!isNaN(pageIndex)) {
    var playerPageIndex = getPlayerPageIndex();
    return playerPageIndex === pageIndex;
  }

  // No index given also means it's really playing.
  return true;
}

/**
 * Handle playing a list row. This function should start playback of a context
 * starting from a specific row.
 *
 * @param {HTMLElement} rowNode A DOM node for a list row.
 * @param {Object} data Object of data about the action:
 *     contextUri: (string) The context URI for the list.
 *     source: (string) The 'play source' value, for logging purposes.
 *     reason: (string) The 'play reason' value, for logging purposes.
 */
function handlePlayFromRow(rowNode, data) {
  var eventData = {
    context: data.contextUri,
    source: data.source,
    reason: data.reason
  };

  var uid = rowNode.getAttribute('data-uid');
  if (uid) {
    eventData.uid = uid;
  }

  var pageIndex = parseInt(utils.getAttributeValueFromNode(rowNode, 'data-context-page'), 10);
  if (!isNaN(pageIndex)) {
    eventData.page = pageIndex;
  }

  live('spotify:player').emit('play', eventData);
}

/**
 * Get the nodes inside the passed container node that should be marked as
 * playing.
 *
 * @param {HTMLElement} containerNode The DOM node to search inside.
 * @param {Array.<HTMLElement>} contextNodes Array of DOM nodes that are already
 *     matched based on context URIs. These can be filtered if needed, but
 *     otherwise they should be included in the return value.
 *
 * @return {Array.<HTMLElement>} An array of DOM nodes.
 */
function getPlayingNodes(containerNode, contextNodes) {
  var playerPageIndex = getPlayerPageIndex();
  var playerTrackUid = getPlayerTrackUid();
  var playerTrackUri = getPlayerTrackUri();
  var variantUri = getPlayerVariantUri();

  // Remove any matched context nodes that have a page specified and where
  // the current player page does not match.
  var filteredContextNodes = filterPages(playerPageIndex, contextNodes);

  var selectors = utils.getContextSelectorsWithVariants(variantUri);
  var rowNodes = getContextNodesForRows(containerNode, selectors, playerTrackUid, playerTrackUri) || [];

  var selectorsWithVariants = utils.getContextSelectorsWithVariants(variantUri);
  var pageNodes = getContextNodesForPages(containerNode, selectorsWithVariants, playerPageIndex) || [];

  // Only return button nodes whos closest context is one of the nodes in the
  // contextNodes array. Imagine this minimal node tree:
  //
  // [data-context][data-uri="spotify:root-context"]
  //   [data-button=play-context]
  //   [data-context][data-uri="spotify:nested-context"]
  //     [data-button=play-context]
  //
  // The first [data-button=play-context] should play "spotify:root-context".
  // Ths second [data-button=play-context] should play "spotify:nested-context".
  var buttonNodes = [];
  if (contextNodes.length) {
    var candidates = $(contextNodes).search('[data-button=play-context]');
    if (candidates) {
      buttonNodes = candidates.filter(function (candidate) {
        var closestContextNode = candidate.closest('[data-context]');
        return contextNodes.indexOf(closestContextNode) >= 0;
      });
    }
  }

  // Let `elements` remove any duplicate nodes
  var nodes = $([filteredContextNodes, rowNodes, pageNodes, buttonNodes]);

  return nodes ? Array.prototype.slice.call(nodes) : [];
}

/**
 * Get the nodes inside the passed container node that match what's currently
 * playing and are list rows.
 *
 * @param {HTMLElement} containerNode The DOM node to search inside.
 * @param {Array.<string>} selectors Array of CSS selectors for matching the
 *     currently playing context.
 * @param {string} trackUid The UID of the currently playing track.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function getContextNodesForRows(containerNode, selectors, trackUid, trackUri) {

  // When playing from this client, we highlight the playing UIDs.
  var useTrackSelector = getPlayerIsPlayingFromOpen();

  var selector = selectors.map(function (selector) {
    selector += ' ';
    if (useTrackSelector) selector += '[data-uri=' + trackUri + ']';
    if (!useTrackSelector) selector += '[data-uid=' + trackUid + ']';
    return selector;
  }).join(', ');

  var nodes = $(containerNode).search(selector);
  if (nodes) {
    nodes = Array.prototype.slice.call(nodes);

    if (useTrackSelector) {
      // Gets UID of the first node and find all the nodes
      // with the same UID
      var firstUid = $(nodes[0]).data('uid');
      nodes = nodes.filter(function (row) {
        return firstUid === $(row).data('uid');
      });
    }
  } else {
    nodes = [];
  }

  return nodes;
}

/**
 * Get the nodes inside the passed container node that match what's currently
 * playing and have a matching page specified.
 *
 * @param {HTMLElement} containerNode The DOM node to search inside.
 * @param {Array.<string>} selectors Array of CSS selectors for matching the
 *     currently playing context.
 * @param {number} playerPageIndex The currently playing page index.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function getContextNodesForPages(containerNode, selectors, playerPageIndex) {
  var pageAttribute = '[data-context-page]';

  // It needs to search for all range elements somewhere inside an element
  // marked up as a context, as well as range elements that themselves are
  // contexts.
  selectors = selectors.map(function (selector) {
    var pageInContextSelector = selector + ' ' + pageAttribute;
    var pagedContextSelector = selector + pageAttribute;
    var pageSelector = pageInContextSelector + ', ' + pagedContextSelector;
    return pageSelector;
  });

  var pageNodes = $(containerNode).search(selectors.join(', '));
  if (pageNodes) {
    pageNodes = Array.prototype.slice.call(pageNodes);
  } else {
    pageNodes = [];
  }

  return filterPages(playerPageIndex, pageNodes);
}

/**
 * Return a new array of nodes where nodes that specify a context page that
 * doesn't match the currently playing context page are removed.
 *
 * @param {number} playerPageIndex The currently playing page index.
 * @param {Array.<HTMLElement>} contextNodes Array of already matched nodes.
 *
 * @return {Array.<HTMLElement>} Array of filtered nodes.
 */
function filterPages(playerPageIndex, contextNodes) {
  return contextNodes.filter(function (node) {
    var nodePageIndex = parseInt(node.getAttribute('data-context-page'), 10);

    // Node without a page should always be active
    if (isNaN(nodePageIndex)) return true;

    // If player has no page, but the node has a page, we can't be sure if it's
    // playing.
    if (isNaN(playerPageIndex)) return false;

    // Node that matches the player page should be active
    return playerPageIndex === nodePageIndex;
  });
}

},{"../../spotify-elements":231,"../../spotify-live":512,"./actions":286,"./updates":288,"./utils":289}],292:[function(require,module,exports){
'use strict';

var Range = require('../spotify-range2');

var contains = require('mout/array/contains');

var $ = require('../spotify-elements');

var SYNC = require('../../libs/prime/emitter').EMIT_SYNC;

var throttle = require('./util/throttle');
var ListManager = require('./util/ListManager.js');

var center = require('./center');

var doc = $(document);
var win = $(window);

var scrollContainers = [];
var listManagers = [];
var scrollHandlers = [];
var pendingScrollContainers = [];
var pendingHiddenIndices = [];
var cleanupHandlers = [];

var getBounds = function getBounds(view, container) {
  var dde = document.documentElement;

  if (view === window || view === document.body) view = dde;
  var viewTop = view === dde ? 0 : view.getBoundingClientRect().top;

  var viewHeight = view.clientHeight;
  var containerTop = container.getBoundingClientRect().top;
  var containerHeight = container.offsetHeight;

  var viewBox = {
    top: viewTop,
    height: viewHeight,
    bottom: viewTop + viewHeight
  };

  var containerBox = {
    top: containerTop,
    height: containerHeight,
    bottom: containerTop + containerHeight
  };

  return {
    view: viewBox,
    container: containerBox
  };
};

var getRange = function getRange(view, container, height, hotZone) {
  hotZone = hotZone || 0;
  var bounds = getBounds(view, container);
  var top = -(bounds.container.top - bounds.view.top);
  var startsAt = Math.floor((top - hotZone) / height);
  var endsAt = Math.ceil((top + bounds.view.height + hotZone) / height);
  if (startsAt < 0) startsAt = 0;
  if (endsAt <= startsAt) return false;
  return new Range(startsAt, endsAt);
};

var init = function init(view, container, length, height, tag) {
  var view0 = view[0];
  var container0 = container[0];

  container.addClass('scroll-container-enabled');

  var manager = new ListManager(container0, {
    height: height,
    length: length,
    tag: tag,
    debug: false,
    request: function request(range, callback) {
      center.emit('scroll-request', container0, range, callback, SYNC);
    }
  });
  listManagers.push(manager);

  // Update the manager with previously saved hidden indices.
  // This allows the scroller to take hidden indices into account even for the
  // first render.
  var pendingIndex = pendingScrollContainers.indexOf(container);
  if (pendingIndex > -1) {
    manager.reset(length, pendingHiddenIndices[pendingIndex]);
    pendingScrollContainers.splice(pendingIndex, 1);
    pendingHiddenIndices.splice(pendingIndex, 1);
  }

  manager.on('before-show', function (range, nodes) {
    center.emit('scroll-show-before', {
      pageNode: container,
      container: container,
      range: range,
      nodes: nodes
    }, SYNC);
  });

  manager.on('after-show', function (range, nodes) {
    center.emit('scroll-show-after', {
      pageNode: container,
      container: container,
      range: range,
      nodes: nodes
    }, SYNC);
  });

  manager.on('index-change', function (index) {
    center.emit('scroll-index-change', {
      pageNode: container,
      container: container,
      ranges: index
    }, SYNC);
  });

  var hasRequestedMore = false;

  var scroll = function scroll() {
    var bounds = getBounds(view0, container0);
    var show = getRange(view0, container0, height);

    if (show) {
      var padding = 2;
      show = new Range(show.start - padding, show.end + padding);
      manager.show(new Range(show.start, show.end));
    }

    // If the scroll position is close enough to the end, an event should be
    // emitted to allow for more content to be loaded. Not all lists will use this,
    // but some lists want to lazy load content by loading more when you reach the
    // bottom, and then they can listen for this event.
    if (!hasRequestedMore) {
      if (bounds.container.bottom < 2000) {
        hasRequestedMore = true;

        // Emit the event and also pass a callback to the event.
        // The receiver of this event should pass the new total length of the list
        // as the second argument to the callback.
        center.emit('scroll-request-more', container0, function (error, length) {
          if (error) throw error;
          hasRequestedMore = false;
          scrollReset(container0, length);
        });
      }
    }
  };

  scrollHandlers.push(scroll);

  scroll = container._scrollEvent = throttle(scroll);

  var scrollReset = function scrollReset(c, height, opt_hiddenIndices, opt_fromIndex) {
    if ($(c) === container) {
      var hasFromIndex = typeof opt_fromIndex === 'number';
      if (hasFromIndex && opt_fromIndex > 0) {
        manager.resetFrom(opt_fromIndex, height, opt_hiddenIndices);
      } else {
        manager.reset(height, opt_hiddenIndices);
      }
      scroll();
    }
  };

  center.on('scroll-reset', scrollReset);
  container._scrollResetEvent = scrollReset;

  var scrollToIndex = function scrollToIndex(c, index, opt_offsetScrollPosition) {
    if (view0 !== window) {
      throw new Error('Can\'t scroll to index if view is not `window`');
    }

    if ($(c) === container) {
      var bounds = getBounds(view0, container0);

      // Let's say we scroll the sidebar to show the playlist at 200px from
      // the top or the bottom (depending if it was above or below fold).
      // If the sidebar height is smaller than 400px, we vertically center the
      // playlist:
      var offset = Math.min(opt_offsetScrollPosition || 0, (bounds.view.height - manager.height) / 2);

      var indexTopRelativeToContainer = manager.height * index;
      var position = bounds.container.top + indexTopRelativeToContainer;

      var scrollY = position + window.pageYOffset;
      var stickyOffset = (doc.search('[data-sticky-active]') || []).map(function (sticky) {
        return sticky.offsetHeight;
      }).reduce(function (a, b) {
        return a + b;
      }, 0);

      if (document.querySelector('[data-new-headers-top-bar-height]')) {
        stickyOffset += parseInt(document.querySelector('[data-new-headers-top-bar-height]').getAttribute('data-new-headers-top-bar-height'), 10);
      }

      if (position <= stickyOffset) {
        // item is above viewport
        scrollY -= offset + stickyOffset;
      } else if (position + manager.height > bounds.view.height) {
        // item is below viewport
        scrollY += offset + manager.height - bounds.view.height;
      } else {
        // item is in viewport
        return;
      }

      view0.scrollTo(0, scrollY);
    }
  };

  center.on('scroll-to-index', scrollToIndex);

  view.on('scroll', scroll);
  win.on('resize', scroll);
  scroll();

  cleanupHandlers.push({
    container: container,
    clean: function clean() {
      center.off('scroll-reset', scrollReset);
      center.off('scroll-to-index', scrollToIndex);
      view.off('scroll', scroll);
      win.off('resize', scroll);

      delete container._scrollEvent;
      delete container._scrollResetEvent;

      container.removeClass('scroll-container-enabled');
    }
  });
};

function onScrollSetHidden(data) {
  var hiddenIndices = data.indices;

  var container = $(data.itemContainer);
  var index = scrollContainers.indexOf(container);
  if (index > -1) {
    var manager = listManagers[index];
    if (manager) {
      manager.reset(manager.length, hiddenIndices);
    }
    var scrollHandler = scrollHandlers[index];
    if (scrollHandler) {
      scrollHandler();
    }
  } else {
    pendingScrollContainers.push(container);
    pendingHiddenIndices.push(hiddenIndices);
  }
}

var isAttached = false;

exports.update = function (node) {
  if (!isAttached) return;

  node = $(node) || doc;

  var scrollNodes = doc.search('[data-scroll-container]');

  var handlers = [];
  var managers = [];
  scrollContainers = scrollContainers.filter(function (container, index) {
    if (!contains(scrollNodes, container[0])) {
      for (var i = 0; i < cleanupHandlers.length; i++) {
        if (cleanupHandlers[i].container === container) {
          cleanupHandlers[i].clean();
          cleanupHandlers.splice(i, 1);
          break;
        }
      }
      return false;
    }
    managers.push(listManagers[index]);
    handlers.push(scrollHandlers[index]);
    return true;
  });
  listManagers = managers;
  scrollHandlers = handlers;

  if (node !== doc) scrollNodes = node.search('[data-scroll-container]');

  if (scrollNodes) {
    scrollNodes.forEach(function (node0) {
      var container = $(node0);

      if (container._scrollEvent || node0.children.length) return;

      scrollContainers.push(container);
      var view = container.parent('[data-scroll-view]') || win;

      var callback = function callback(error, children, length) {
        if (error) throw error;

        // Only continue initialization if the container is still in the DOM
        if (contains(doc.search('[data-scroll-container]'), container[0])) {
          children = $(children);
          children.insert(container);

          var second = children[1];
          var height = second.offsetHeight;
          var tag = $(second).tag();
          children.remove();
          init(view, container, length, height, tag);
        }
      };

      center.emit('scroll-request', container[0], new Range(0, 3), callback, SYNC);
    });
  }
};

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  center.on('scroll-set-hidden', onScrollSetHidden);
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  center.off('scroll-set-hidden', onScrollSetHidden);

  scrollContainers = [];
  cleanupHandlers.forEach(function (_ref) {
    var clean = _ref.clean;

    clean();
  });
  cleanupHandlers = [];
};

},{"../../libs/prime/emitter":221,"../spotify-elements":231,"../spotify-range2":551,"./center":242,"./util/ListManager.js":307,"./util/throttle":313,"mout/array/contains":652}],293:[function(require,module,exports){
'use strict';

var _spotifyCosmosApi = require('spotify-cosmos-api');

var _spotifyCosmosApi2 = _interopRequireDefault(_spotifyCosmosApi);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var isAttached = false;
var controlMessageSubscription = void 0;
var currentStyle = 'always-visible';

function refreshStyle() {
  var nav = window.navigator;
  var isMac = nav && nav.userAgent.indexOf('Mac') > -1;
  var os = isMac ? 'mac' : 'windows';

  if (currentStyle === 'always-visible') {
    document.documentElement.classList.add('scrollbar-style-visible-' + os);
    document.documentElement.classList.remove('scrollbar-style-overlay');
  } else {
    document.documentElement.classList.remove('scrollbar-style-visible-' + os);
    document.documentElement.classList.add('scrollbar-style-overlay');
  }
}

exports.update = function () {};

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  var initialValue = window.__spotify && window.__spotify.scroller_style;
  currentStyle = initialValue === 'overlay' ? 'overlay' : 'always-visible';
  refreshStyle();

  controlMessageSubscription = _spotifyCosmosApi2.default.resolver.subscribe({
    url: 'sp://messages/v1/container/control'
  }, function (error, response) {
    if (!error) {
      var data = response.getJSONBody();
      if (data) {
        var styleWasChanged = false;
        switch (data.type) {
          case 'set_scroller_style_always_visible':
            currentStyle = 'always-visible';
            styleWasChanged = true;
            break;
          case 'set_scroller_style_overlay':
            currentStyle = 'overlay';
            styleWasChanged = true;
            break;
        }

        if (styleWasChanged) {
          refreshStyle();
        }

        // Fix a rendering bug in Chromium. When scroller style changes in the
        // system (changing system preference, connecting/disconnecting a mouse
        // etc), Chromium will not always render properly. Sometimes it shows a
        // white area where the scroll bar is supposed to be and sometimes it
        // renders it with native styles even though the CSS styles should be
        // applied. By setting `overflow: hidden` to all elements for a brief
        // moment it will force the scroll bars to re-render.
        //
        // https://jira.spotify.net/browse/KM-8285
        // http://crbug.com/538579
        if (styleWasChanged) {
          var performFix = function performFix() {
            var styleNode = document.createElement('style');
            styleNode.innerHTML = '* {overflow: hidden !important}';
            document.head.appendChild(styleNode);
            // Delay removal one tick so that it has time to render
            setTimeout(function () {
              document.head.removeChild(styleNode);
            }, 0);
          };

          // Perform the fix twice (once with a delay), since it sometimes might
          // be slow and won't apply the fix on the first try.
          performFix();
          setTimeout(performFix, 1000);
        }
      }
    } else {
      controlMessageSubscription.cancel();
    }
  });
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  if (controlMessageSubscription) {
    controlMessageSubscription.cancel();
    controlMessageSubscription = null;
  }
};

},{"spotify-cosmos-api":890}],294:[function(require,module,exports){
/**
 * @module spotify-events/select
 */
'use strict';

var $ = require('../spotify-elements');
var center = require('./center');

var live = require('../spotify-live');

var ATTR_SELECT = 'select';
var ATTR_PROPERTY = 'select-property';
var SELECTOR_SELECT = '[data-' + ATTR_SELECT + ']';

// Stored nodes, used to not add listeners multiple times
var storedNodes = [];

/**
 * Handle a change on a select node.
 *
 * @param {MouseEvent} event Event object.
 * @param {Elements} elem An elements DOM node for the select.
 */
function handleChange(event, elem) {
  var property = elem.data(ATTR_PROPERTY);
  var node = elem[0];
  // If a property is set, update the model. That will later trigger
  // an update of the view and a change event on center will be sent.
  if (property) {
    publish(node, property);
    // If no property is set, just emit a change event on center.
  } else {
    emitUpdate(node, selectedValue(node));
  }
}

/**
 * Return the value attribute of the selected option
 *
 * @param {Elements} elem An elements DOM node for the select
 */
function selectedValue(node) {
  var selected = node.options[node.selectedIndex];
  return selected.value;
}

/**
 * Handle when a select-option event happens on center.
 *
 * @param {Object} event An object with data.
 */
function onSelectSet(event) {
  if (!event.id) return;

  var elem = $('[data-' + ATTR_SELECT + '=' + event.id + ']');
  if (!elem) return;

  var node = elem[0];
  var value = event.selected;

  // updating the node will trigger a DOM event,
  // delegated to handleChange in this module.
  var property = elem.data(ATTR_PROPERTY);

  if (property) {
    publish(node, property, value);
  } else {
    setState(node, value);
  }
}

/**
 * Publish new data to the live model. If no data-uri is found from
 * the passed node, nothing happens.
 *
 * @param {HtmlElement} node A DOM node for the select
 * @param {string} property A property name on the live model
 * @param {string=} opt_value Optional value to set the property to.
 *     If not provided, the selected option's value is fetched from the DOM.
 */
function publish(node, property, opt_value) {
  var uri = getUriFromNode(node);
  if (!uri) return;

  var model = live(uri);

  // If the model doesn't have a current value, we can't safely
  // set a new value without maybe being wrong.
  var value = model.get(property);
  if (value === undefined) return;

  var newValue = opt_value === undefined ? selectedValue(node) : opt_value;

  var data = {};
  data[property] = newValue;

  // Publishing the new value to the model will trigger the update
  // handler added here in this module to send an center event,
  // and update the DOM if needed.
  model.publish(data);
}

/**
 * Update the state of one select node.
 *
 * @param {HTMLElement} node A DOM node for the select.
 */
function updateNode(node) {
  if (storedNodes.indexOf(node) > -1) return;
  storedNodes.push(node);

  var elem = $(node);
  var property = elem.data(ATTR_PROPERTY);
  if (!property) return;

  var uri = getUriFromNode(node);
  if (!uri) return;

  var model = live(uri);

  model.get(property, function (error, value) {
    if (error) throw error;

    setState(node, value);

    model.on('update', function (properties) {
      if (property in properties) {
        setState(node, properties[property]);
      }
    });
  });
}

/**
 * Update a select node based on a value.
 *
 * @param {HTMLElement} node A DOM node for a select.
 * @param {string} value The value attribute of the option to select
 */
function setState(node, value) {
  updateNodeWithValue(node, value);
  emitUpdate(node, value);
}

/**
 * Update a select based on an option's value attribute
 *
 * @param {HTMLElement} node A DOM node for a select.
 * @param {string} value The value attribute of the option to select
 */
function updateNodeWithValue(node, value) {
  var selectElement = $(node);
  var optionElement = selectElement.find('option[value="' + value + '"]');
  if (optionElement && !optionElement.attribute('selected')) {
    optionElement.select();
  }
}

/**
 * Emit a change event on center. It will have the following format:
 * {
 *   element: HTMLElement,
 *   id: 'id from data-select attribute' || null,
 *   selected: the new selected value
 * }
 *
 * @param {HTMLElement} node A DOM node for a select.
 * @param {string} value Attribute of the selected option
 */
function emitUpdate(node, selected) {
  var id = $(node).data(ATTR_SELECT) || null;
  center.emit('select-change', {
    element: node,
    id: id,
    selected: selected
  });
}

/**
 * Get a URI from a node.
 *
 * @param {HTMLElement} node A DOM node.
 *
 * @return {string?} A URI string or null if not found.
 */
function getUriFromNode(node) {
  var stateNode = node.closest('[data-uri]');
  if (!stateNode) return null;
  return stateNode.getAttribute('data-uri');
}

var isAttached = false;

exports.update = function (opt_node) {
  if (!isAttached) return;

  var nodes = $(opt_node || document).search(SELECTOR_SELECT);
  if (!nodes) return;

  nodes.forEach(updateNode);
};

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  var doc = $(document);
  doc.delegate('change', SELECTOR_SELECT, handleChange);

  center.on('select-set', onSelectSet);
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  var doc = $(document);
  doc.undelegate('change', SELECTOR_SELECT, handleChange);

  center.off('select-set', onSelectSet);
};

},{"../spotify-elements":231,"../spotify-live":512,"./center":242}],295:[function(require,module,exports){
/**
 * @module spotify-events/selection/containers
 * @private
 */
'use strict';

var $ = require('../../spotify-elements');
var live = require('../../spotify-live');

/**
 * Container DOM nodes.
 *
 * @type {Array.<HTMLElement>}
 */
var containers = [];

/**
 * Forget the known containers.
 */
function reset() {
  containers.length = 0;
}

/**
 * Update container storage based on the current DOM.
 */
function update() {
  var nodes = $(document).search(':not(.sticky-clone) > [data-list]');
  if (!nodes) return;

  // Don't drop any containers. If they are removed from the DOM we just keep
  // the reference along with the selection state at the same index. Clearing
  // has to be done manually instead.

  nodes.forEach(function (container) {
    if (!containers.includes(container)) {
      containers.push(container);
      containers.sort(function (a, b) {
        var n;
        if (a === b) {
          n = 0;
        } else if (a.compareDocumentPosition(b) & Node.DOCUMENT_POSITION_PRECEDING) {
          n = 1;
        } else {
          n = -1;
        }
        return n;
      });
    }
  });
}

/**
 * Get the number of rows in the container at the specified index.
 *
 * @param {number} index The container index.
 *
 * @return {number} The number of rows.
 */
function getContainerLength(index) {
  var container = $(containers[index]);
  if (!container) return 0;

  var uri = container.data('uri');
  if (!uri) return 0;

  var list = live(uri).get('rows');
  if (!list) return 0;

  return list.length;
}

/**
 * Get the index of a container based on URI.
 *
 * @param {string} uri The URI of the container.
 *
 * @return {number} The index of the container. Returns -1 if not found.
 */
function getContainerIndex(uri) {
  for (var i = 0, l = containers.length; i < l; i++) {
    var containerUri = getUri(i);
    if (containerUri === uri) return i;
  }

  return -1;
}

/**
 * Get the URI for a container.
 *
 * @param {number} index The container index.
 *
 * @return {string?} The URI or null if not found.
 */
function getUri(index) {
  var element = containers[index];
  var uri = element && element.getAttribute('data-uri');
  return uri || null;
}

/**
 * Get the URIs for all containers.
 *
 * @return {Array.<string?>} Array of URIs.
 */
function getUris() {
  var uris = [];
  for (var i = 0, l = containers.length; i < l; i++) {
    uris.push(getUri(i));
  }
  return uris;
}

/**
 * Get the live list for a container.
 *
 * @param {number} index The container index.
 *
 * @return {LiveList?} A live list or null if not found.
 */
function getLiveList(index) {
  var uri = getUri(index);
  var list = live(uri).get('rows');
  return list || null;
}

exports.elements = containers;
exports.reset = reset;
exports.update = update;
exports.getContainerLength = getContainerLength;
exports.getContainerIndex = getContainerIndex;
exports.getUri = getUri;
exports.getUris = getUris;
exports.getLiveList = getLiveList;

},{"../../spotify-elements":231,"../../spotify-live":512}],296:[function(require,module,exports){
(function (global){
/**
 * spotify-events/selection/controller
 * @private
 */
'use strict';

var $ = require('../../spotify-elements');
var intersection = require('mout/array/intersection');
var live = require('../../spotify-live');
var liburi = require('spotify-liburi');

var center = require('../center');
var selection = require('./index');
var model = require('./model');
var rows = require('./rows');
var containers = require('./containers');
var positions = require('./positions');
var Position = require('../util/Position');
var cosmos = require('../util/cosmos');

var focusEventValid = false;

// Listeners per URI (key is URI)
var listListeners = {};
var listListenerUris = [];

var SELECTABLE = '[data-list-item]';
var CLIPBOARD_ENDPOINT = 'sp://desktop/v1/clipboard';

/**
 * Check whether the event occured on the documentElement.
 *
 * @param {Event} event A event object.
 *
 * @return {boolean}
 */
function isOnDocument(event) {
  return event.target === document.documentElement;
}

/**
 * Get the row node from a mouse event.
 *
 * @param {MouseEvent} event A mouse event object.
 *
 * @return {HTMLElement} A DOM node.
 */
function getNodeFromEvent(event) {
  return event.target.closest(SELECTABLE);
}

/**
 * Check if a target is inside a filter component.
 *
 * @param {HTMLElement} target A DOM node.
 *
 * @return {boolean} Whether the target was inside a filter component.
 */
function isFilterTarget(target) {
  return target !== document && !!target.closest('[data-filter]');
}

/**
 * Handle a mousedown event.
 *
 * @param {MouseEvent|TouchEvent} event A mouse or touch event.
 * @param {boolean=} opt_isMouseUp Pass true if this is a simulated mousedown
 *     triggered by a mouseup event.
 */
function handleMouseDown(event, opt_isMouseUp) {
  if (isOnDocument(event)) {
    return;
  }

  focusEventValid = false;
  var node = getNodeFromEvent(event);
  if (node) {
    handleRowMouseDown(event, node, opt_isMouseUp);
  } else {
    handleOutsideMouseDown(event);
  }
}

/**
 * Handle when the mouse is pressed down on a list row.
 *
 * @param {MouseEvent|TouchEvent} event A mouse or touch event.
 * @param {HTMLElemtn} rowNode The DOM node for the clicked row.
 * @param {boolean=} opt_isMouseUp Pass true if this is a simulated mousedown
 *     triggered by a mouseup event.
 */
function handleRowMouseDown(event, rowNode, opt_isMouseUp) {
  var button = getButtonFromEvent(event);
  var isPrimaryButton = button === 1;

  // If we can't find a valid position for the DOM node, we can't handle
  // selection correctly.
  var position = positions.getFromNode(rowNode);
  if (!position) return;

  var isSelected = model.isSelected(position);
  var singleMultiSelect = isMac() ? event.metaKey : event.ctrlKey;
  var multiselect = event.shiftKey || singleMultiSelect;
  var singleClick = !event.shiftKey;

  if (!isMultiSelectEnabled()) {
    singleMultiSelect = multiselect = false;
    singleClick = true;
  }

  // Remove selection if a selected item is clicked with cmd/ctrl
  if (multiselect && singleClick && isSelected && isPrimaryButton) {

    // For multiselect, make sure we do the deselection only on mouseup
    if (!opt_isMouseUp) return;
    handleDeselectOnSingleMultiSelect(position);

    // Select multiple items if clicked with shift key
  } else if (!singleClick) {

    // Optimize by doing this only on mousedown
    if (opt_isMouseUp) return;
    handleShiftMultiSelect(position);

    // Select a single item
  } else {

    // Handle the case when the primary button is pressed down on a selected item.
    // The method will be called once again in that case, on mouse up. This is
    // to allow the drag and drop to abort the selection change.

    // So we do the actual selection on mouseup, where we know it's not a drag n drop thing.
    if (isPrimaryButton && isSelected && !opt_isMouseUp) {
      return;
    }
    // For multiselect, make sure we do the selection only on mouseup
    if (multiselect && !opt_isMouseUp) {
      return;
    }

    handleSingleSelect(position, event, opt_isMouseUp);
  }
  rows.update();
}

/**
 * Handle when the mouse is pressed down outside a list row.
 *
 * @param {MouseEvent} event A mouse event.
 */
function handleOutsideMouseDown(event) {
  var isSort = !!event.target.closest('[data-sort]');
  var isFilter = isFilterTarget(event.target);
  var hasSelection = model.hasSelection();

  // Deselect if clicked outside the list.
  // Clicking sort headers should just sort, not clear selection.
  if (!(isSort || isFilter) && hasSelection) {
    model.clear();
    rows.update();
  }
}

/**
 * Handle a focus event.
 *
 * @param {MouseEvent} event A mouse event.
 */
function handleFocus(event) {
  if (!focusEventValid) return;
  var node = getNodeFromEvent(event);
  if (node) {
    handleRowFocus(event, node);
  } else {
    handleOutsideFocus(event);
  }
  focusEventValid = false;
}

/**
 * Handle when a row receives focus.
 *
 * @param {MouseEvent} event A mouse event.
 * @param {HTMLElement} rowNode The DOM node for the focused row.
 */
function handleRowFocus(event, rowNode) {
  var position = positions.getFromNode(rowNode);

  // Invalid positions and already selected rows don't need to be handled
  if (!position || model.isSelected(position)) {
    return;
  }

  model.clear();
  model.add(position);
  model.setFocus(position);
  model.setOrigin(position);
  rows.update();
}

/**
 * Handle when an element outside the table receives focus.
 *
 * @param {MouseEvent} event A mouse event.
 */
function handleOutsideFocus(event) {
  if (isFilterTarget(event.target)) return;
  model.clear();
  rows.update();
}

/**
 * Handle when the mouse button is released.
 *
 * @param {MouseEvent|TouchEvent} event A mouse or touch event.
 */
function handleMouseUp(event) {
  if (isOnDocument(event)) {
    return;
  }

  handleMouseDown(event, true);
}

/**
 * Handle deselecting a currently selected row in a multi-select situation
 * (cmd/ctrl). This might mean that we need to adjust origin and focus as well.
 *
 * @param {Position} position Position clicked on.
 */
function handleDeselectOnSingleMultiSelect(position) {
  var origin = model.getOrigin();
  var focus = model.getFocus();
  var dir = positions.getDirection(origin, focus);

  // When removing the node that is both origin and focus, there will be no
  // direction in which the origin/focus could be moved. Like here:

  // Click A, CMD click C, CMD click B, CMD click B again.

  // Native desktop will now still have origin on B. MacOS Finder does move
  // origin but it's hard to know how it decides.

  // For a predictable behaviour, default to look downwards, and always reverse
  // the direction when no selected node is found.

  if (!dir) dir = 1;

  var isOrigin = position.isSame(origin);
  var isFocus = position.isSame(focus);
  var above, below;

  if (isOrigin || isFocus) {
    above = getClosestSelected(position, 'up');
    below = getClosestSelected(position, 'down');
  }

  // If direction is down (1), the next after origin is found below
  if (isOrigin) {
    model.setOrigin(dir === 1 ? below || above : above || below);
  }

  // If direction is down (1), the next after focus is found above
  if (position.isSame(focus)) {
    model.setFocus(dir === 1 ? above || below : below || above);
  }

  model.remove(position);
}

/**
 * Handle multi-selecting a range from the current focus to the new position.
 * This also handles deselecting as needed.
 *
 * @param {Position} position Position clicked on.
 */
function handleShiftMultiSelect(position) {
  var origin = model.getOrigin();
  var focus = model.getFocus();

  // Remove selection from origin to old focus.
  // If it's part of the new selection it will be re-added.
  if (origin && focus && !origin.isSame(focus)) {
    model.remove(origin, focus);
  }

  // If there is no origin, we will set the origin to the first selectable row
  if (!origin) {
    origin = new Position(0, 0);
    model.setOrigin(origin);
  }

  // Add selection from the current origin to the clicked position
  model.add(origin, position);
  model.setFocus(position);
}

/**
 * Handle a normal mousedown without any multi-select keys.
 *
 * @param {Position} position Position clicked on.
 * @param {MouseEvent|TouchEvent} event A mouse or touch event.
 */
function handleSingleSelect(position, event) {
  var origin = model.getOrigin();

  var button = getButtonFromEvent(event);
  var isPrimaryButton = button === 1;
  var isSecondaryButton = button === 2;

  var isSelected = model.isSelected(position);
  var singleMultiSelect = isMac() ? event.metaKey : event.ctrlKey;
  var multiselect = event.shiftKey || singleMultiSelect;

  if (!isMultiSelectEnabled()) {
    singleMultiSelect = multiselect = false;
  }

  // Left click without cmd/ctrl/shift clears selection.
  // Also right click on something that wasn't selected clears.
  var isRegularPrimary = !multiselect && isPrimaryButton;
  var isSelectedSecondary = !isSelected && isSecondaryButton;
  if (isRegularPrimary || isSelectedSecondary) {
    model.clear();
  }

  // Add item to selection
  model.add(position);
  model.setFocus(position, { isTouch: isTouchEvent(event) });

  // When adding to an existing selection, leave origin alone.
  var isNextToSelection;
  if (origin && !origin.isSame(position)) {
    var next = positions.getClosest(position, 'down');

    isNextToSelection = next && model.isSelected(next);
    if (!isNextToSelection) {
      var prev = positions.getClosest(position, 'up');
      isNextToSelection = prev && model.isSelected(prev);
    }
  }
  if (!isNextToSelection) {
    model.setOrigin(position);
  }
}

/**
 * Handler for when a key is pressed down in the list. Depending on the key,
 * this will either move the selection (up and down arrows), shrink/grow the
 * selection (shift up and down arrows) or clear the selection (escape key).
 *
 * @param {KeyboardEvent} event The event object.
 */
function handleKeyDown(event) {
  if (isFilterTarget(event.target)) return;

  focusEventValid = true;
  var isUp = event.keyCode === 38;
  var isDown = event.keyCode === 40;

  if (!isKeyboardNavEnabled()) return;

  if (!isUp && !isDown) return;

  var origin = model.getOrigin();
  var focus = model.getFocus();
  var next = focus;

  do {
    next = next && positions.getClosest(next, isDown ? 'down' : 'up');
  } while (next && model.isPositionHidden(next));

  // Only move the selection if the up or down key was pressed.
  // And only do it if the cmd/ctrl key is not also pressed.
  // The cmd/ctrl key will change the volume in the client.
  if ((isUp || isDown) && !event.metaKey && !event.ctrlKey && next) {

    // Multi-select must have a previous selection position
    if (event.shiftKey && isMultiSelectEnabled() && origin && focus) {
      var keyDirection = isDown ? 1 : -1;
      var direction = positions.getDirection(origin, focus);
      var isSingleRange = direction === 0;
      if (isSingleRange || keyDirection === direction) {
        model.add(next);
        scrollIntoView(next);
      } else {
        model.remove(focus);
      }

      // If multi-select can't be performed, just move the current selection
    } else {
      model.clear();
      model.add(next);
      model.setOrigin(next);
      scrollIntoView(next);
      event.preventDefault(); // Prevent normal scrolling
    }

    // Always set the new focus to the row above or below
    model.setFocus(next);
  }

  rows.update();
}

/**
 * Handle when a section of a list is scrolled into view.
 * This needs to update selection state of the row nodes.
 *
 * @param {Object} event Event object.
 */
function handleScrollShowAfter(event) {
  var node = event.pageNode && event.pageNode[0];
  rows.update(node);
}

/**
 * Handle setting which indices are hidden.
 *
 * @param {Object} data Object with properties `hiddenIndices` (array of
 *     indices) and `uri` (URI of the list).
 */
function handleSetHidden(data) {
  model.setHiddenIndices(data.indices, data.uri);
}

/**
 * Add a row to the selection based on a list URI.
 * TODO: Remove logic to handle global lists.
 *
 * @param {string} listUri The list URI.
 * @param {number} index The index within the list.
 * @param {boolean=} opt_doNotScrollIntoView Optionally skip scrolling added index into view
 */
function handleAddByUri(listUri, index, opt_doNotScrollIntoView) {
  var uriNodes = $('[data-uri=' + listUri + ']');
  var matches = intersection(containers.elements, uriNodes);

  if (!matches || matches.length < 1) {
    return;
  }

  var container = $(matches[0]);
  var containerIndex = container && containers.elements.indexOf(container[0]);
  var listIsPlayContext = container && container.matches('[data-context]');

  if (listIsPlayContext) {
    // Selection is not based on the global container that is defined via data-context,
    // so the indices need to be resolved to match the selection containers.
    var localPosition = positions.getPositionFromGlobalIndex(index);
    containerIndex = localPosition.containerIndex;
    index = localPosition.index;
  } else if (containerIndex === -1) {
    console.warn('No container matching this uri was found or selection doesn\'t know ' + 'about the container. Possibly you need to run events.update.');
    return;
  }

  if (!isMultiSelectEnabled()) model.clear();

  var position = new Position(containerIndex, index);
  if (!model.getOrigin()) model.setOrigin(position);
  model.setFocus(position);
  model.add(position);

  rows.update();

  if (opt_doNotScrollIntoView !== true) {
    scrollIntoView(position);
  }
}

/**
 * Handle a select_all event from Cosmos.
 */
function handleSelectAll() {
  if (!isMultiSelectEnabled()) {
    return;
  }

  model.clear();

  var first = new Position(0, 0);
  model.setOrigin(first);

  var last = positions.getLastPositionForSelectAll();
  model.setFocus(last);

  model.add(first, last);
  rows.update();
}

/**
 * Handle a copy event from Cosmos.
 */
function handleCopy() {
  cosmos.put({ url: CLIPBOARD_ENDPOINT, body: getSelectedUrls().join('\n') });
}

/**
 * Handle a cut event from Cosmos.
 */
function handleCut() {
  handleCopy();

  cosmos.post({ url: 'sp://messages/v1/container/control', body: { type: 'delete' } });
}

/**
 * Gets list of uris for selected rows
 *
 * @return {Array.<string>} Array of URIs.
 */
function handleGetUris() {
  var selections = model.selections;
  var uris = [];

  for (var container = 0; container < selections.length; container++) {
    var containerSelection = selections[container];
    if (!containerSelection) continue;

    var entity;

    var list = containers.getLiveList(container);
    if (!list) continue;

    // * Order the keys
    // Since the user can select tracks in any order,
    // the selection is an unordered set until we actually retrieve the
    // uris of the selection. In this case we want to get the uris
    // in the same order as they are shown in the list.
    var orderedSelectedKeys = list.keys.filter(function (key) {
      return !!containerSelection[key];
    });

    for (var i = 0, l = orderedSelectedKeys.length; i < l; i++) {
      var item = list.valueOf(orderedSelectedKeys[i]);
      if (!item) continue;

      entity = item.get('track');
      if (!entity) entity = item.get('playlist');
      if (!entity) entity = item.get('album');
      if (!entity) entity = item.get('artist');
      if (!entity) entity = item.get('user');
      if (!entity) entity = item;

      uris.push(entity.get('uri'));
    }
  }

  return uris;
}

/**
 * Returns the HTTPS urls of the selected rows
 *
 * @return {Array.<string>} Array of URLs.
 */
function getSelectedUrls() {
  var uris = handleGetUris();
  var urls = [];
  for (var i = 0; i < uris.length; i++) {
    var uriObj = liburi.from(uris[i]);
    if (uriObj) {
      urls.push(uriObj.toOpenURL());
    }
  }
  return urls;
}

/**
 * Get the mouse button number identifier from an event object.
 *
 * @param {MouseEvent|TouchEvent} event A mouse event.
 *
 * @return {number} A number representing the pressed button:
 *     0: No button pressed
 *     1: Primary button (usually left)
 *     2: Secondary button (usually right)
 *     3: Middle (usually the wheel)
 */
function getButtonFromEvent(event) {

  // Touches don't have buttons, so treat all touches as a primary button
  if (isTouchEvent(event)) {
    return 1;
  }

  switch (event.button) {
    case 0:
      return 1;
    case 2:
      return 2;
    case 1:
      return 3;
    default:
      return 0;
  }
}

/**
 * Check if the user agent is on a Mac.
 *
 * @return {boolean} True if Mac, false otherwise.
 */
function isMac() {
  if (!global.window) return false;
  if (!global.window.navigator) return false;
  var userAgent = global.window.navigator.userAgent || '';
  return userAgent.indexOf('Mac') > -1;
}

/**
 * Check if multi-select is enabled.
 * We currently disable it for the Web Player, since not much can be done with
 * a multi-selection there.
 *
 * @return {boolean} True if enabled, false otherwise.
 */
function isMultiSelectEnabled() {
  if ($('body').data('multi-select-disabled') !== null) return false;
  if (!global.window) return false;
  return !!global.window._getSpotifyModule;
}

/**
 * Check if keyboard selection is enabled.
 * If it's not enabled it is not possible to move the selection with arrow
 * keys or extend it with shift + arrow keys.
 *
 * @return {boolean} True if enabled, false otherwise.
 */
function isKeyboardNavEnabled() {
  return $('body').data('keyboard-select-disabled') === null;
}

/**
 * Check if the event is a touch event.
 *
 * @param {Event} event Event object.
 *
 * @return {boolean} True if it is a touch event object.
 */
function isTouchEvent(event) {
  return !!event.changedTouches;
}

/**
 * Get the closest selected position in the specified direction.
 *
 * @param {Position} position A position.
 * @param {string} direction The direction to search in: 'up' or 'down'.
 *
 * @return {Position?} A position or null if not found.
 */
function getClosestSelected(position, direction) {
  while (position) {
    position = positions.getClosest(position, direction);
    if (position && model.isSelected(position)) {
      return position;
    }
  }
  return null;
}

/**
 * Scroll the position into view.
 *
 * @param {Position} position A position.
 */
function scrollIntoView(position) {
  var container = containers.elements[position.containerIndex];
  var scrollContainer = container && container.querySelector('[data-scroll-container]');
  if (scrollContainer) {
    center.emit('scroll-to-index', scrollContainer, position.index);
  } else {
    var node = positions.getNodeFromPosition(position);
    if (!node) return;

    var offset = node.getBoundingClientRect().top;
    if (offset < 0 || offset >= window.innerHeight) {
      node.scrollIntoView(offset < 0);
    }
  }
}

/**
 * Update the list listeners for the current containers.
 */
function updateListListeners() {
  var uris = containers.getUris();

  for (var i = 0, l = uris.length; i < l; i++) {
    var uri = uris[i];
    if (uri && listListenerUris.indexOf(uri) === -1) {
      var list = live(uri).get('rows');
      if (list) {
        var listener = createListListener(uri);
        list.on('update', listener);
        listListeners[uri] = listener;
        listListenerUris.push(uri);
      }
    }
  }
}

/**
 * Create an event listener for list updates.
 * When an update happens, the selection model will be updated for the right
 * container.
 *
 * @param {string} uri A URI for a list.
 *
 * @return {function} A listener function.
 */
function createListListener(uri) {
  return function (operations) {
    var uris = containers.getUris();
    var containerIndex = uris.indexOf(uri);
    if (containerIndex > -1) {

      // If something was removed from the list, we must update the selection
      // state, as something that was selected might have been removed.
      // Insert and move operations don't affect the current selection state,
      // as everything is based on row IDs, which don't change.
      for (var i = 0, l = operations.length; i < l; i++) {
        var operation = operations[i];
        if (operation.type === 'remove') {
          model.updateContainer(containerIndex);
          break;
        }
      }

      // Update the rows visually based on the model state
      rows.update();
    }
  };
}

/**
 * Remove all list listeners.
 */
function resetListListeners() {
  for (var i = 0, l = listListenerUris.length; i < l; i++) {
    var uri = listListenerUris[i];
    var listener = listListeners[uri];
    var list = live(uri).get('rows');
    if (list && listener) {
      list.off('update', listener);
      delete listListeners[uri];
      listListenerUris.splice(i, 1);
      i--;l--;
    }
  }
}

function handleListSwap(event) {
  var rowsListBefore = live(event.before).get('rows');
  if (!rowsListBefore) return;

  var selectionBefore = selection.getIndicesPerList().filter(function (indicesPerList) {
    return indicesPerList.uri === event.before;
  })[0];

  var selectedKeysBefore = [];
  if (selectionBefore) {
    selectedKeysBefore = selectionBefore.indices.map(function (index) {
      return rowsListBefore.keys[index];
    });
  }

  center.on('scroll-reset', function onScrollReset() {
    center.off('scroll-reset', onScrollReset);

    live(event.after).get('rows', function (error, rowsListAfter) {
      selectedKeysBefore.forEach(function (selectedKeyBefore) {
        var indexAfter = rowsListAfter.keys.indexOf(selectedKeyBefore);
        if (indexAfter !== -1) {
          handleAddByUri(event.after, indexAfter, true);
        }
      });
    }, live.ASAP);
  });
}

exports.handleMouseDown = handleMouseDown;
exports.handleMouseUp = handleMouseUp;
exports.handleKeyDown = handleKeyDown;
exports.handleFocus = handleFocus;
exports.handleScrollShowAfter = handleScrollShowAfter;
exports.handleSetHidden = handleSetHidden;
exports.handleAddByUri = handleAddByUri;
exports.handleSelectAll = handleSelectAll;
exports.handleCopy = handleCopy;
exports.handleCut = handleCut;
exports.handleGetUris = handleGetUris;
exports.updateListListeners = updateListListeners;
exports.resetListListeners = resetListListeners;
exports.handleListSwap = handleListSwap;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-elements":231,"../../spotify-live":512,"../center":242,"../util/Position":308,"../util/cosmos":310,"./containers":295,"./index":297,"./model":298,"./positions":299,"./rows":300,"mout/array/intersection":661,"spotify-liburi":899}],297:[function(require,module,exports){
/**
 * spotify-events/selection
 */
'use strict';

var $ = require('../../spotify-elements');
var live = require('../../spotify-live');
var getOriginUri = require('../../spotify-live-wrapped-uri').getOriginUri;

var center = require('../center');
var controller = require('./controller');
var containers = require('./containers');
var model = require('./model');
var rows = require('./rows');
var positions = require('./positions');
var Position = require('../util/Position');
var appUtil = require('../util/app');

var cosmos = require('../util/cosmos');

var controlMessageSubscription;

/**
 * Attach event listeners etc.
 */
exports.attach = function () {
  var doc = $(document);
  doc.on('mousedown', controller.handleMouseDown);
  doc.on('touchstart', controller.handleMouseDown);
  doc.on('mouseup', controller.handleMouseUp);
  doc.on('touchend', controller.handleMouseUp);
  doc.on('keydown', controller.handleKeyDown);
  doc.on('focus', controller.handleFocus, true);

  center.on('scroll-show-after', controller.handleScrollShowAfter);
  center.on('selection-set-hidden', controller.handleSetHidden);
  center.on('list-swap', controller.handleListSwap);

  // Creating an "intentional bug".. By switching to use row IDs internally
  // for the selection model, we no longer need to manually update indices
  // as long as the new list has the same IDs (which we require anyway for
  // other reasons). We stopped using this event a long time ago anyway,
  // because it never really worked without odd behaviors. I've done a
  // code search (indexed Nov 23 2014), and there is not a single place
  // where this event is used, except in old versions of spotify-events,
  // which is not a problem. Technically, not responding to this event
  // is a breaking change, but for simplicity's sake let's stop handling it.
  // Fixing code that never gets used just for the sake of it makes no sense.
  // If someone really needs this in the future, we can fix it then.
  // So, this line should be commented for now.
  //
  // center.on('update-indices', controller.handleUpdateIndices);

  controlMessageSubscription = cosmos.subscribe({ url: 'sp://messages/v1/container/control' }, function (error, response) {
    if (error) throw error;
    var data = response.body;
    if (data && appUtil.isActiveAndFocused()) {
      if (data.type === 'select_all') {
        controller.handleSelectAll();
      } else if (data.type === 'copy') {
        controller.handleCopy();
      } else if (data.type === 'cut') {
        controller.handleCut();
      }
    }
  });
};

/**
 * Detach event listeners etc.
 */
exports.detach = function () {
  var doc = $(document);
  doc.off('mousedown', controller.handleMouseDown);
  doc.off('touchstart', controller.handleMouseDown);
  doc.off('mouseup', controller.handleMouseUp);
  doc.off('touchend', controller.handleMouseUp);
  doc.off('keydown', controller.handleKeyDown);
  doc.off('focus', controller.handleFocus, true);

  center.off('scroll-show-after', controller.handleScrollShowAfter);
  center.off('selection-set-hidden', controller.handleSetHidden);
  center.off('list-swap', controller.handleListSwap);

  // See comment in `attach` for the long story why this is commented.
  // center.off('update-indices', controller.handleUpdateIndices);

  if (controlMessageSubscription) {
    controlMessageSubscription.cancel();
    controlMessageSubscription = null;
  }
};

/**
 * Update the module based on the current DOM state.
 */
exports.update = function () {
  containers.update();
  controller.updateListListeners();
};

/**
 * Add a row to the selection based on a list URI.
 *
 * @param {string} listUri The list URI.
 * @param {number} index The index within the list.
 */
exports.add = function (listUri, index) {
  controller.handleAddByUri(listUri, index);
};

/**
 * Check if the selection has any holes (contains many ranges).
 *
 * @return {boolean} True if it has holes, false otherwise.
 */
exports.hasHoles = function () {
  return model.hasHoles();
};

/**
 * Check if the row node is selected.
 *
 * @param {HTMLElement|Elements} node A DOM node for a row.
 *
 * @return {boolean} True if it is selected, false otherwise.
 */
exports.isNodeSelected = function (node) {
  node = 'innerHTML' in node ? node : node[0];
  if (!node) return false;

  var position = positions.getFromNode(node);
  if (!position) return false;

  return model.isSelected(position);
};

/**
 * Reset the selection state and its knowledge of any containers.
 */
exports.reset = function () {
  controller.resetListListeners();
  model.reset();
  rows.update();
  containers.reset();
};

/**
 * Clear the current selection.
 */
exports.clear = function () {
  model.clear();
  rows.update();
};

/**
 * Set the origin to a new position.
 *
 * @param {number} containerIndex The index of the container.
 * @param {number} index The index within the container.
 */
exports.setOrigin = function (containerIndex, index) {
  model.setOrigin(new Position(containerIndex, index));
};

/**
 * Set the focus to a new position.
 *
 * @param {number} containerIndex The index of the container.
 * @param {number} index The index within the container.
 */
exports.setFocus = function (containerIndex, index) {
  model.setFocus(new Position(containerIndex, index));
};

/**
 * Get the current origin position.
 *
 * @return {Object?} An object with numeric properties `containerIndex`
 *     and `index`, or null if no origin is set.
 */
exports.getOrigin = function () {
  var origin = model.getOrigin();
  if (!origin) return null;
  return {
    containerIndex: origin.containerIndex,
    index: origin.index
  };
};

/**
 * Get the current focus position.
 *
 * @return {Object?} An object with numeric properties `containerIndex`
 *     and `index`, or null if no origin is set.
 */
exports.getFocus = function () {
  var focus = model.getFocus();
  if (!focus) return null;
  return {
    containerIndex: focus.containerIndex,
    index: focus.index
  };
};

/**
 * Get all selected indices organized by list.
 *
 * @return {Array.<Object>} Array of objects of this structure:
 *     {
 *       containerIndex: 0,
 *
 *       // This is the list in the UI (could be sorted or unsorted)
 *       uri: 'spotify:internal:sortlist:asc:track(name):list',
 *       keys: ['c', 'd', 'e', 'j', 'o', 't'],
 *       indices: [3, 4, 5, 10, 15, 20], // Ordered indices in the list
 *
 *       // If all items between two selected items are hidden, they will be
 *       // included here to allow nice ranges to be created from this. It will
 *       // also include hidden items right after the last selected item.
 *       keysWithHidden: ['c', 'd', 'e', 'j', 'k', 'l', 'm', 'n', 'o', 't'],
 *       indicesWithHidden: [3, 4, 5, 10, 11, 12, 13, 14, 15, 20],
 *
 *       // Optional object for the unsorted list if the list is a sorted list
 *       origin: {
 *         uri: 'spotify:list',
 *         keys: ['c', 'd', 'e', 'j', 'o', 't'],
 *         indices: [7, 19, 8, 14, 0, 9] // Unordered indices in the original list
 *       }
 *     }
 */
exports.getIndicesPerList = function () {
  var selections = model.selections;
  var indicesPerList = [];

  for (var i = 0; i < selections.length; i++) {
    var containerSelection = selections[i];
    if (containerSelection && Object.keys(containerSelection).length) {

      var uri = containers.getUri(i);
      if (!uri) continue;

      var list = containers.getLiveList(i);
      if (!list) continue;

      var indices = model.getIndicesForContainer(i);
      if (!indices) continue;

      var keys = indices.map(function (selectedIndex) {
        return list.keys[selectedIndex];
      });

      var indicesWithHidden = model.getIndicesWithHiddenForContainer(i);
      var keysWithHidden = indicesWithHidden.map(function (selectedIndex) {
        return list.keys[selectedIndex];
      });

      var context = {
        containerIndex: i,
        uri: uri,
        indices: indices,
        keys: keys,
        indicesWithHidden: indicesWithHidden,
        keysWithHidden: keysWithHidden
      };

      var originUri = getOriginUri(uri);
      if (originUri) {
        var wrappedList = live(uri).get('rows');
        var originList = live(originUri).get('rows');

        var originIndices;
        var originKeys;
        if (wrappedList && originList) {
          var key;
          var originListKeyIndexMap = {};
          originIndices = new Array(indices.length);
          originKeys = new Array(indices.length);

          for (var i = 0, keys = originList.keys; i < keys.length; i++) {
            originListKeyIndexMap[keys[i]] = i;
          }

          for (var j = 0; j < indices.length; j++) {
            key = wrappedList.keys[indices[j]];
            originIndices[j] = originListKeyIndexMap[key];
            originKeys[j] = originList.keys[originIndices[j]];
          }
        }
        context.origin = {
          uri: originUri,
          indices: originIndices || [],
          keys: originKeys || []
        };
      }

      indicesPerList.push(context);
    }
  }

  return indicesPerList;
};

/**
 * Get all selected indices relative to the full page (across all containers).
 *
 * @return {Object?} The value null if no global context is found or if found,
 *     an object of this structure:
 *     {
 *       uri: 'spotify:context:uri',
 *       indices: [0, 3, 56, 120],
 *
 *       // These elements are Elements instances from the 'elements' npm
 *       // package. This should be fixed in a future major version, to be
 *       // normal HTML elements.
 *       containers: [
 *         containerElement1,
 *         containerElement1,
 *         containerElement4,
 *         containerElement5
 *       ]
 *     }
 */
exports.getIndicesGlobal = function () {
  var selections = model.selections;
  var elements = containers.elements;
  var indices = [];
  var selectionContainers = [];

  if (elements.length === 0) {
    return null;
  }
  var contextUriContainer = elements[0].closest('[data-context]');
  var contextUri = contextUriContainer && contextUriContainer.getAttribute('data-uri');

  if (!contextUri) return null;

  for (var container = 0; container < selections.length; container++) {
    var containerSelection = selections[container];
    var list = containers.getLiveList(container);
    if (list && containerSelection) {

      var orderedSelectedKeys = list.keys.filter(function (key) {
        return !!containerSelection[key];
      });

      for (var i = 0, l = orderedSelectedKeys.length; i < l; i++) {
        var j = list.keys.indexOf(orderedSelectedKeys[i]);
        indices.push(positions.getGlobalIndexFromPosition(new Position(container, j)));
        selectionContainers.push($(elements[container]));
      }
    }
  }

  return {
    uri: contextUri,
    indices: indices,
    containers: selectionContainers
  };
};

/**
 * Get the URI of all selected rows.
 *
 * @return {Array.<string>} Array of URIs.
 */
exports.getUris = function () {
  return controller.handleGetUris();
};

/**
 * Get the nodes for all selected rows that can be found.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
exports.getNodes = function () {
  return rows.getSelectedRows();
};

},{"../../spotify-elements":231,"../../spotify-live":512,"../../spotify-live-wrapped-uri":511,"../center":242,"../util/Position":308,"../util/app":309,"../util/cosmos":310,"./containers":295,"./controller":296,"./model":298,"./positions":299,"./rows":300}],298:[function(require,module,exports){
/**
 * @module spotify-events/selection/model
 * @private
 */
'use strict';

var live = require('../../spotify-live');
var Range = require('../../spotify-range2');
var containers = require('./containers');
var positions = require('./positions');
var Position = require('../util/Position');

/**
 * Selections for all known containers.
 * Each container's selection space is represented as an object where keys are
 * row IDs. This allows for quick lookups.
 *
 * @type {Array.<Object.<string, boolean>>}
 */
var selections = [];

/**
 * Hidden items for all known containers.
 * Each container is represented as an object where keys are row IDs. This
 * allows for quick lookups.
 *
 * @type {Object.<number, Object.<string, boolean>>}
 */
var hiddenKeysPerContainer = {};

var originContainerIndex = null;
var originKey = null;
var focusContainerIndex = null;
var focusKey = null;
var focusIsTouch = false;

/**
 * Get the current origin.
 *
 * @return {Position?} The origin position or null if not set.
 */
function getOrigin() {
  if (originContainerIndex === null) return null;
  if (originKey === null) return null;

  var list = containers.getLiveList(originContainerIndex);
  if (list) {
    var index = list.keys.indexOf(originKey);
    if (index === -1) return null;
    var position = new Position(originContainerIndex, index);
    return position;
  }
  return null;
}

/**
 * Get the current focus. This is the position for the keyboard focus.
 *
 * @return {Position?} The focus position or null if not set.
 */
function getFocus() {
  if (focusContainerIndex === null) return null;
  if (focusKey === null) return null;

  var list = containers.getLiveList(focusContainerIndex);
  if (list) {
    var index = list.keys.indexOf(focusKey);
    var position = new Position(focusContainerIndex, index);
    return position;
  }
  return null;
}

/**
 * Set the current origin.
 *
 * @param {Position?} position A position or null if removing the origin.
 */
function setOrigin(position) {
  if (position) {
    var list = containers.getLiveList(position.containerIndex);
    if (list) {
      originContainerIndex = position.containerIndex;
      originKey = list.keys[position.index] || null;
      return;
    }
  }

  originContainerIndex = null;
  originKey = null;
}

/**
 * Set the current focus.
 *
 * @param {Position?} position A position or null if removing the focus.
 */
function setFocus(position, options) {
  focusIsTouch = !!(options && options.isTouch);

  if (position) {
    var list = containers.getLiveList(position.containerIndex);
    if (list) {
      focusContainerIndex = position.containerIndex;
      focusKey = list.keys[position.index];
      return;
    }
  }

  focusContainerIndex = null;
  focusKey = null;
}

/**
 * Check if the current focus was triggered by a touch.
 * This is done since we might want to have different styles for selection focus
 * when triggered by a touch event.
 *
 * @return {boolean} True if triggered by touch.
 */
function wasFocusTriggeredByTouch() {
  return focusIsTouch;
}

/**
 * Handle setting which indices are hidden.
 *
 * @param {Array.<number>} hiddenIndices Array of indices that are hidden.
 * @param {string} containerUri The URI of the container.
 */
function setHiddenIndices(hiddenIndices, containerUri) {
  var list = live(containerUri).get('rows');
  if (list) {
    var keys = list.keys;
    var hiddenKeys = {};
    for (var i = 0, l = hiddenIndices.length; i < l; i++) {
      var key = keys[hiddenIndices[i]];
      if (key) hiddenKeys[key] = true;
    }

    var containerIndex = containers.getContainerIndex(containerUri);

    hiddenKeysPerContainer[containerIndex] = hiddenKeys;

    updateContainer(containerIndex);
  }
}

/**
 * Check if given position is hidden.
 *
 * @param {Position} from The position to check.
 * @return {boolean} True if position is hidden.
 */
function isPositionHidden(pos) {
  var idsPerContainer = getIds(pos, pos);
  var id = idsPerContainer[0][0];
  var hiddenKeys = hiddenKeysPerContainer[pos.containerIndex];
  return hiddenKeys && hiddenKeys[id];
}

/**
 * Add rows to the selection.
 *
 * @param {Position} from The start position to add.
 * @param {Position=} opt_to The end position to add. If not provided, it will
 *     only add a single row to the selection.
 */
function add(from, opt_to) {
  var to = opt_to || from;

  // Flip the positions if the direction is up.
  if (positions.getDirection(from, to) === -1) {
    var temp = from;
    from = to;
    to = temp;
  }

  var idsPerContainer = getIds(from, to);

  for (var i = 0, l = idsPerContainer.length; i < l; i++) {
    var containerIndex = from.containerIndex + i;
    var selected = selections[containerIndex] || (selections[containerIndex] = Object.create(null));
    var ids = idsPerContainer[i];
    var hiddenKeys = hiddenKeysPerContainer[containerIndex];

    // Set all new items as selected, unless they're hidden
    for (var j = 0, id; id = ids[j]; j++) {
      if (!hiddenKeys || !hiddenKeys[id]) {
        selected[id] = true;
      }
    }
  }
}

/**
 * Remove rows from the selection.
 *
 * @param {Position} from The start position to remove.
 * @param {Position=} opt_to The end position to remove. If not provided, it will
 *     only remove a single row from the selection.
 */
function remove(from, opt_to) {
  var to = opt_to || from;

  // Flip the positions if the direction is up.
  if (positions.getDirection(from, to) === -1) {
    var temp = from;
    from = to;
    to = temp;
  }

  var idsPerContainer = getIds(from, to);

  for (var i = 0, l = idsPerContainer.length; i < l; i++) {
    var containerIndex = from.containerIndex + i;
    var selected = selections[containerIndex] || (selections[containerIndex] = Object.create(null));
    var ids = idsPerContainer[i];

    // Loop the row ids that are to be removed and remove them from the selection.
    // That's usually faster than looping the selection since there's no UI for
    // removing a big chunk of selection in one go.
    for (var j = 0, id; id = ids[j]; j++) {
      delete selected[id];
    }
  }
}

/**
 * Clear the current selection.
 */
function clear() {
  selections.length = 0;
  setOrigin(null);
  setFocus(null);
}

/**
 * Reset the current selection state.
 */
function reset() {
  clear();
  hiddenKeysPerContainer = {};
}

/**
 * Update the model state based on the current state of the list.
 * If items were removed from the list, removed items that were selected
 * will be removed from selection state.
 */
function updateContainer(containerIndex) {
  var keys = selections[containerIndex];
  if (!keys) return;

  var list = containers.getLiveList(containerIndex);
  if (!list) return;

  for (var key in keys) {
    var hasKey = list.hasKey(key);
    var shouldDelete = !hasKey;
    if (!shouldDelete) {
      var hiddenKeys = hiddenKeysPerContainer[containerIndex];
      var shouldDelete = hiddenKeys ? hiddenKeys[key] : false;
    }
    if (shouldDelete) {
      delete keys[key];
    }
  }
}

/**
 * Get IDs for the provided global range.
 *
 * @param {Position} from The start position.
 * @param {Position} to The end position. This position must be below the
 *     `from` position.
 *
 * @return {Array.<Array.<string>>} Array of IDs per container.
 */
function getIds(from, to) {
  var idsPerContainer = [];

  var fromContainer = from.containerIndex;
  var toContainer = to.containerIndex;

  for (var i = fromContainer; i <= toContainer; i++) {
    var fromIndex = i === fromContainer ? from.index : 0;
    var toIndex;
    if (i === toContainer) {
      toIndex = to.index;
    } else {
      var containerLength = containers.getContainerLength(i);
      if (containerLength > 0) {
        toIndex = containerLength - 1;
      }
    }

    if (toIndex === undefined) {
      idsPerContainer.push([]);
    } else {
      var ids = [];
      idsPerContainer.push(ids);

      var containerUri = containers.getUri(i);
      var list = live(containerUri).get('rows');
      if (list) {
        var keys = list.keys;

        for (var n = fromIndex; n < toIndex + 1; n++) {
          ids.push(keys[n]);
        }
      }
    }
  }

  return idsPerContainer;
}

/**
 * Check if the position is selected.
 *
 * @param {Position} position A position.
 *
 * @return {boolean} True if it is selected, false otherwise.
 */
function isSelected(position) {

  // Get the ranges of the according container
  var keys = selections[position.containerIndex];
  if (!keys) return false;

  // Check if the row is within the selected ranges for the container
  var list = containers.getLiveList(position.containerIndex);
  if (list) {
    var key = list.keys[position.index];
    return !!keys[key];
  }

  return false;
}

/**
 * Check if the selection has any holes (contains many ranges).
 *
 * @return {boolean} True if it has holes, false otherwise.
 */
function hasHoles() {
  var rangeCount = 0;

  for (var containerIndex = 0; containerIndex < selections.length; containerIndex++) {
    var containerSelection = selections[containerIndex];
    var list = containers.getLiveList(containerIndex);

    var keys = Object.keys(containerSelection);

    // A selection in more than one container means the selection has holes
    if (keys.length > 0) {
      rangeCount++;

      // Also more than one range in only one container means it has holes.
      if (list) {
        var indices = [];
        for (var j = 0, len = keys.length; j < len; j++) {
          indices.push(list.indexOf(keys[j]));
        }
        indices.sort(function (a, b) {
          return a - b;
        });
        var previousIndex;
        for (var i = 0, l = indices.length; i < l; i++) {
          var index = indices[i];
          if (i > 0 && index > previousIndex + 1) {
            rangeCount++;
            break;
          }
          previousIndex = index;
        }
      }
    }
    if (rangeCount > 1) return true;
  }

  return false;
}

/**
 * Check if there is any selection in any container.
 *
 * @return {boolean} True if there is a selection.
 */
function hasSelection() {
  for (var i = 0, l = selections.length; i < l; i++) {
    if (selections[i] && Object.keys(selections[i]).length > 0) {
      return true;
    }
  }

  return false;
}

/**
 * Get the selected indices for a container.
 *
 * @param {number} containerIndex The container index.
 *
 * @return {Array.<number>?} An array of indices or null if nothing is selected.
 */
function getIndicesForContainer(containerIndex) {
  var unorderedKeys = selections[containerIndex];
  if (!unorderedKeys) return null;
  var indices = [];

  var list = containers.getLiveList(containerIndex);

  var orderedKeys = list.keys.filter(function (key) {
    return !!unorderedKeys[key];
  });

  if (list && orderedKeys.length) {
    if (orderedKeys.length > 1) {
      // indexOfMany() is much more perfomant for big selections
      indices = list.indexOfMany(orderedKeys);
    } else {
      // for a single selected item, indexOf() is a little bit more perfomant
      indices = [list.indexOf(orderedKeys[0])];
    }
  }

  return indices.length ? indices : null;
}

/**
 * Get the selected indices for a container, including hidden items that join
 * two ranges. For example, in a list [A, B, C, D, E, F, G, H], everything is
 * selected except C, D, F and G. There are hidden items, C, D, F and G. This
 * method would then return the indices of all items except H,
 * [0, 1, 2, 3, 4, 5, 6]. It does include hidden items right after the last
 * selected one.
 *
 * @param {number} containerIndex The container index.
 *
 * @return {Array.<number>?} An array of indices or null if nothing is selected.
 */
function getIndicesWithHiddenForContainer(containerIndex) {
  var indices = getIndicesForContainer(containerIndex);
  if (!indices) return null;

  var hiddenKeys = hiddenKeysPerContainer[containerIndex];
  if (!hiddenKeys) return indices;

  var ranges = Range.fromIndices(indices);
  if (ranges.length === 1) return indices;

  var list = containers.getLiveList(containerIndex);
  if (!list) return indices;

  var hiddenIds = Object.keys(hiddenKeys);
  var hiddenIndices = [];

  if (hiddenIds.length) {
    if (hiddenIds.length > 1) {
      // indexOfMany() is much more perfomant for big selections
      hiddenIndices = list.indexOfMany(hiddenIds);
    } else {
      // for a single selected item, indexOf() is a little bit more perfomant
      hiddenIndices = [list.indexOf(hiddenIds[0])];
    }
  }

  hiddenIndices = hiddenIndices.filter(function (index) {
    return index > -1;
  });

  var hiddenRanges = Range.fromIndices(hiddenIndices);
  var hiddenStarts = hiddenRanges.map(function (range) {
    return range.start;
  });
  var hiddenEnds = hiddenRanges.map(function (range) {
    return range.end;
  });

  for (var i = 0, l = ranges.length; i < l; i++) {
    var range = ranges[i];
    var nextRange = ranges[i + 1];

    var indexOfRange = hiddenStarts.indexOf(range.end);
    if (indexOfRange > -1) {
      var hiddenEnd = hiddenEnds[indexOfRange];
      if (!nextRange || hiddenEnd === nextRange.start) {
        var hiddenIndicesInRange = hiddenRanges[indexOfRange].toIndices();
        if (hiddenIndicesInRange.length > 0) {
          indices = indices.concat(hiddenIndicesInRange);
        }
      }
    }
  }

  indices.sort(function (a, b) {
    return a - b;
  });

  return indices.length ? indices : null;
}

exports.selections = selections;
exports.getOrigin = getOrigin;
exports.getFocus = getFocus;
exports.setOrigin = setOrigin;
exports.setFocus = setFocus;
exports.wasFocusTriggeredByTouch = wasFocusTriggeredByTouch;
exports.setHiddenIndices = setHiddenIndices;
exports.isPositionHidden = isPositionHidden;
exports.add = add;
exports.remove = remove;
exports.clear = clear;
exports.reset = reset;
exports.updateContainer = updateContainer;
exports.isSelected = isSelected;
exports.hasHoles = hasHoles;
exports.hasSelection = hasSelection;
exports.getIndicesForContainer = getIndicesForContainer;
exports.getIndicesWithHiddenForContainer = getIndicesWithHiddenForContainer;

},{"../../spotify-live":512,"../../spotify-range2":551,"../util/Position":308,"./containers":295,"./positions":299}],299:[function(require,module,exports){
/**
 * @module spotify-events/selection/positions
 * @private
 */
'use strict';

var $ = require('../../spotify-elements');

var containers = require('./containers');
var Position = require('../util/Position');

/**
 * Get the closest position in the specified direction.
 *
 * @param {Position} position A position.
 * @param {string} direction The direction to search in: 'up' or 'down'.
 *
 * @return {Position?} A position or null if not found.
 */
function getClosest(position, direction) {
  var isDown = direction === 'down';
  var containerIndex = position.containerIndex;
  var index = position.index;

  // Find next position within the current container
  var containerLength = containers.getContainerLength(containerIndex);
  var nextIndex = isDown ? index + 1 : index - 1;
  if (nextIndex < containerLength && nextIndex >= 0) {
    return new Position(containerIndex, nextIndex);
  }

  // Out of bounds, traverse containers
  containerIndex = isDown ? containerIndex + 1 : containerIndex - 1;
  containerLength = containers.getContainerLength(containerIndex);
  if (containerLength) {
    nextIndex = isDown ? 0 : containerLength - 1;
    return new Position(containerIndex, nextIndex);
  }

  return null;
}

/**
 * Get a position from a row node.
 *
 * @param {HTMLElement} node A DOM node for a list row.
 *
 * @return {Position?} A position or null if not found.
 */
function getFromNode(node) {

  // We need a parent node, since we will be checking if the row is inside
  // one of the known selection containers.
  if (!node.parentNode) return null;

  // We also need a data-index attribute on the row to get the index for the
  // row within the current selection container.
  if (!node.hasAttribute('data-index')) return null;

  var elements = containers.elements;
  if (elements.length === 0) return null;

  for (var i = 0, l = elements.length; i < l; i++) {
    if (elements[i] && containsNode(elements[i], node)) {
      var row = +node.getAttribute('data-index');
      return new Position(i, row);
    }
  }

  return null;
}

/**
 * Check if an element contains another node.
 *
 * @param {HTMLElement} element The container element.
 * @param {HTMLElement} child The potential child node.
 *
 * @return {boolean} True if element contains the child, false otherwise.
 */
function containsNode(element, child) {
  while (child && child.parentNode !== element) {
    child = child.parentNode;
  }
  return !!child;
}

/**
 * Get the row node that the specified position represents.
 *
 * @param {Position} position A position.
 *
 * @return {HTMLElement?} A DOM node or null if not found.
 */
function getNodeFromPosition(position) {
  var container = containers.elements[position.containerIndex];
  if (!container) return null;
  var node = $(container).find('[data-index=' + position.index + ']');
  return node ? node[0] : null;
}

/**
 * Get the direction from one position to another.
 *
 * @param {Position} from First position.
 * @param {Position} to Second position.
 *
 * @return {number} A number representing the direction.
 *     -1 is up
 *      0 is same
 *      1 is down
 */
function getDirection(from, to) {
  if (!from || !to) return 0;

  // With different containers we can just compare the containers
  if (from.containerIndex !== to.containerIndex) {
    return from.containerIndex < to.containerIndex ? 1 : -1;
  }

  // Within the same container, compare the row indices
  if (from.index === to.index) {
    return 0;
  }
  return from.index < to.index ? 1 : -1;
}

/**
 * Get data about in which container and where inside that the provided
 * global index is.
 *
 * @param {number} globalIndex An index relative to the full page (all
 *     selection containers).
 *
 * @return {Position} A position.
 */
function getPositionFromGlobalIndex(globalIndex) {
  var resolvedIndex = globalIndex;
  var resolvedContainerIndex = 0;
  var containerLength;
  var countIndices = 0;

  // Subtract the amount of tracks in containers until passing globalIndex
  for (var i = 0, l = containers.elements.length; i < l; i++) {

    containerLength = containers.getContainerLength(i);
    countIndices += containerLength;

    if (countIndices > globalIndex) break;

    resolvedContainerIndex = i + 1;
    resolvedIndex -= containerLength;
  }

  return new Position(resolvedContainerIndex, resolvedIndex);
}

/**
 * Get the global index relative to the full page (across all selection
 * containers) from a position object.
 *
 * @param {Position} position A position.
 *
 * @return {number} A global index.
 */
function getGlobalIndexFromPosition(position) {
  var resolvedIndex = position.index;

  // Subtract length of previous lists
  for (var i = position.containerIndex - 1; i >= 0; i--) {
    resolvedIndex += containers.getContainerLength(i);
  }

  return resolvedIndex;
}

/**
 * Get last position on page.
 *
 * @return {Position} A position.
 */
function getLastPosition() {
  var lastContainerIndex = containers.elements.length - 1;
  var lastIndex = containers.getContainerLength(lastContainerIndex) - 1;

  return new Position(lastContainerIndex, lastIndex);
}

/**
 * Get last position for "select all" on page, disregarding containers with
 * [data-select-all="false"].
 *
 * @return {Position} A position.
 */
function getLastPositionForSelectAll() {
  var lastContainerIndex = containers.elements.filter(function (element) {
    return element.getAttribute('data-list-may-select-all') !== 'false';
  }).length - 1;
  var lastIndex = containers.getContainerLength(lastContainerIndex) - 1;

  return new Position(lastContainerIndex, lastIndex);
}

exports.getClosest = getClosest;
exports.getFromNode = getFromNode;
exports.getNodeFromPosition = getNodeFromPosition;
exports.getDirection = getDirection;
exports.getPositionFromGlobalIndex = getPositionFromGlobalIndex;
exports.getGlobalIndexFromPosition = getGlobalIndexFromPosition;
exports.getLastPosition = getLastPosition;
exports.getLastPositionForSelectAll = getLastPositionForSelectAll;

},{"../../spotify-elements":231,"../util/Position":308,"./containers":295}],300:[function(require,module,exports){
/**
 * @module spotify-events/selection/rows
 * @private
 */
'use strict';

var $ = require('../../spotify-elements');
var difference = require('mout/array/difference');

var model = require('./model');
var containers = require('./containers');
var positions = require('./positions');

var SELECTOR_ROW = '[data-list-item]';
var CLASSNAME_SELECTED = 'selected';
var CLASSNAME_FOCUSED = 'selection-focus';
var CLASSNAME_FOCUSED_TOUCH = 'selection-focus-touch';
var focusTimeout;

/**
 * Update the selection state of rows.
 *
 * @param {HTMLElement=} opt_node Optional DOM node. If provided, the update
 *     will only affect rows found inside this node.
 */
function update(opt_node) {
  var currentlySelectedRows = getSelectedRows(opt_node);
  var rowsToBeSelected = getRowsToSelect(opt_node);

  var rowsToDeselect = difference(currentlySelectedRows, rowsToBeSelected);
  var rowsToSelect = difference(rowsToBeSelected, currentlySelectedRows);

  currentlySelectedRows.forEach(function (row) {
    $(row).removeClass(CLASSNAME_FOCUSED);
    $(row).removeClass(CLASSNAME_FOCUSED_TOUCH);
  });

  // Remove styles for selected rows that should now be deselected
  rowsToDeselect.forEach(function (row) {
    $(row).removeClass(CLASSNAME_SELECTED);
  });

  // Add styles for unselected rows that should now be selected
  rowsToSelect.forEach(function (row) {
    $(row).addClass(CLASSNAME_SELECTED);
  });

  // Add styles for the row with the selection focus
  var focus = model.getFocus();
  if (focus) {
    var focusNode = positions.getNodeFromPosition(focus);
    if (focusNode) {
      // If the focusNode is not yet in the viewport and we `focus()` it, the
      // browser will bluntly scroll it into view, which looks bad. (KM-6508)
      clearTimeout(focusTimeout);
      focusTimeout = setTimeout(function () {
        var isInputFocused = document.activeElement && $(document.activeElement).matches('input, textarea');
        var isButtonFocused = document.activeElement && $(document.activeElement).matches('button');
        if (isElementInViewport(focusNode) && !isInputFocused && !isButtonFocused) {
          focusNode.focus();
        }
      }, 0);
      $(focusNode).addClass(CLASSNAME_FOCUSED);

      if (model.wasFocusTriggeredByTouch()) {
        $(focusNode).addClass(CLASSNAME_FOCUSED_TOUCH);
      }
    }
  }
}

/**
 * Get the rows that are currently selected, found inside the known containers.
 *
 * @param {HTMLElement=} opt_node Optional DOM node. If provided, it will only
 *     search inside this node.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function getSelectedRows(opt_node) {
  var elements = opt_node ? [opt_node] : containers.elements;
  var rows = [];

  elements.forEach(function (container) {
    var nodes = $(container).search(SELECTOR_ROW + '.' + CLASSNAME_SELECTED);
    if (nodes) Array.prototype.push.apply(rows, nodes);
  });

  return rows;
}

/**
 * Get the rows that should be selected, found inside the known containers.
 *
 * @param {HTMLElement=} opt_node Optional DOM node. If provided, it will only
 *     search inside this node.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function getRowsToSelect(opt_node) {
  var rows = [];
  var containerElements = containers.elements;

  model.selections.forEach(function (keys, index) {
    if (!keys) return;

    var list = containers.getLiveList(index);
    if (!list) return;

    var container = containerElements[index];
    // If a node was passed, only check the container if it contains the node
    if (opt_node && !containerElements[index].contains(opt_node)) {
      container = null;
    }
    if (!container) {
      return;
    }

    var listNodes = $(container).search(SELECTOR_ROW);
    if (!listNodes) return;

    var nodes = listNodes.filter(function (listNode) {
      var nodeIndex = +listNode.getAttribute('data-index');
      var nodeRowId = list.keys[nodeIndex];
      return !!keys[nodeRowId];
    });

    Array.prototype.push.apply(rows, nodes);
  });
  return rows;
}

function isElementInViewport(el) {
  var rect = el.getBoundingClientRect();
  return rect.top >= 0 && rect.bottom <= document.documentElement.clientHeight;
}

exports.update = update;
exports.getSelectedRows = getSelectedRows;

},{"../../spotify-elements":231,"./containers":295,"./model":298,"./positions":299,"mout/array/difference":653}],301:[function(require,module,exports){
/**
 * @module spotify-events/slider
 */
'use strict';

var $ = require('../spotify-elements');
var center = require('./center');

var live = require('../spotify-live');

var ATTR_SLIDER = 'slider';
var ATTR_PROPERTY = 'slider-property';
var SELECTOR_SLIDER = '[data-' + ATTR_SLIDER + ']';
var CLASSNAME_ENABLED = 'enabled';
var CLASSNAME_DISABLED = 'disabled';
var ATTR_ALLOWED = 'slider-allowed-property';

var SPACE_KEY_CODE = 32;

// Stored nodes, used to not add listeners multiple times
var storedNodes = [];

/**
 * Handle a click on a slider node.
 *
 * @param {MouseEvent} event Event object.
 * @param {Elements} elem An elements DOM node for the slider.
 */
function handleClick(event, elem) {
  var property = elem.data(ATTR_PROPERTY);

  if (elem.data(ATTR_ALLOWED) && !live(elem.data('uri')).get(elem.data(ATTR_ALLOWED))) {
    return;
  }

  if (property) {
    // If a property is set, update the model. That will later trigger
    // an update of the view and a change event on center will be sent.
    toggleModelPropertyAndPublish(elem[0], property);
  } else {
    // If no property is set, emit a change event on center, and let the handler
    // decide what's the state of the slider by emiting a 'slider-set' event.
    emitChangeEvent(elem[0], !elem.hasClass(CLASSNAME_ENABLED));
  }
}

/**
 * Handle a keyboard event on a slider node.
 *
 * @param {KeyboardEvent} event Event object.
 * @param {Elements} elem An elements DOM node for the slider.
 */
function handleKeyUp(event, elem) {
  if (event.keyCode !== SPACE_KEY_CODE) {
    return;
  }

  handleClick(event, elem);
}

/**
 * Handle when a slider-set event happens on center.
 *
 * @param {Object} event An object with data.
 */
function onSliderSet(event) {
  if (!event.id) return;

  var elem = $('[data-' + ATTR_SLIDER + '=' + event.id + ']');
  if (!elem) return;

  var node = elem[0];
  var enabled = !!event.enabled;

  var property = elem.data(ATTR_PROPERTY);

  if (property) {
    toggleModelPropertyAndPublish(node, property, enabled);
  } else {
    setState(node, enabled);
  }
}

/**
 * Update the live model with new data. If no data-uri is found from
 * the passed node, nothing happens.
 *
 * @param {HTMLElement} node A DOM node for the slider.
 * @param {string} property A property name on the model.
 * @param {boolean=} opt_enabled Optional boolean flag. If true, this
 *     sets it to true, if false this sets it to false. If not provided,
 *     this sets it to the opposite of the current value in the model.
 */
function toggleModelPropertyAndPublish(node, property, opt_enabled) {
  var uri = getUriFromNode(node);
  if (!uri) return;

  var model = live(uri);

  // If the model doesn't have a current value, we can't safely
  // set a new value without maybe being wrong.
  var value = model.get(property);
  if (value === undefined) return;

  var newValue = opt_enabled === undefined ? !value : opt_enabled;

  var data = {};
  data[property] = newValue;

  // Publishing the new value to the model will trigger the update
  // handler added here in this module to update the visual state
  // of the button.
  model.publish(data);
}

/**
 * Update the state of one slider node.
 *
 * @param {HTMLElement} node A DOM node for the slider.
 */
function updateNode(node) {
  // Don't handle the same URI and node twice.
  if (storedNodes.indexOf(node) > -1) return;
  storedNodes.push(node);

  var elem = $(node);
  var property = elem.data(ATTR_PROPERTY);
  var allowedProperty = elem.data(ATTR_ALLOWED);

  if (!property) return;

  var uri = getUriFromNode(node);
  if (!uri) return;

  var model = live(uri);

  model.get(property, function (error, value) {
    if (error) throw error;

    setState(node, !!value);
    emitChangeEvent(node, !!value);

    model.on('update', function (properties) {
      if (property in properties) {
        setState(node, !!properties[property]);
        emitChangeEvent(node, !!properties[property]);
      }

      if (allowedProperty && allowedProperty in properties) {
        disableNode(node, !properties[allowedProperty]);
      }
    });
  });
}

/**
 * Update a slider node based on a value.
 *
 * @param {HTMLElement} node A DOM node for a slider.
 * @param {boolean} enabled True if should be enabled, false otherwise.
 */
function setState(node, enabled) {
  var elem = $(node);
  if (enabled) {
    elem.addClass(CLASSNAME_ENABLED);
  } else {
    elem.removeClass(CLASSNAME_ENABLED);
  }
}

/**
 * Update a slider node based on whether is disabled
 *
 * @param {HTMLElement} node A DOM node for a slider.
 * @param {boolean} disabled True if should be disabled, false otherwise.
 */
function disableNode(node, disabled) {
  var elem = $(node);
  if (disabled) {
    elem.addClass(CLASSNAME_DISABLED);
  } else {
    elem.removeClass(CLASSNAME_DISABLED);
  }
}

/**
 * Emit a change event on center. It will have the following format:
 * {
 *   element: HTMLElement,
 *   id: 'id from data-slider attribute' || null,
 *   enabled: true // the new value
 * }
 *
 * @param {HTMLElement} node A DOM node for a slider.
 * @param {boolean} enabled True if enabled, false otherwise.
 */
function emitChangeEvent(node, enabled) {
  var id = $(node).data(ATTR_SLIDER) || null;
  center.emit('slider-change', {
    element: node,
    id: id,
    enabled: enabled
  });
}

/**
 * Get a URI from a node.
 *
 * @param {HTMLElement} node A DOM node.
 *
 * @return {string?} A URI string or null if not found.
 */
function getUriFromNode(node) {
  var stateNode = node.closest('[data-uri]');
  if (!stateNode) return null;
  return stateNode.getAttribute('data-uri');
}

var isAttached = false;

/**
 * Update the module based on the current DOM state.
 *
 * @param {HTMLElement=} opt_node Optional DOM node to make changes inside.
 */
exports.update = function (opt_node) {
  if (!isAttached) return;

  var nodes = $(opt_node || document).search(SELECTOR_SLIDER);
  if (!nodes) return;

  nodes.forEach(updateNode);
};

/**
 * Attach event listeners etc.
 */
exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  var doc = $(document);
  doc.delegate('click', SELECTOR_SLIDER, handleClick);
  doc.delegate('keyup', SELECTOR_SLIDER, handleKeyUp);

  center.on('slider-set', onSliderSet);
};

/**
 * Detach event listeners etc.
 */
exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  var doc = $(document);
  doc.undelegate('click', SELECTOR_SLIDER, handleClick);
  doc.undelegate('keyup', SELECTOR_SLIDER, handleKeyUp);

  center.off('slider-set', onSliderSet);
};

},{"../spotify-elements":231,"../spotify-live":512,"./center":242}],302:[function(require,module,exports){
'use strict';

var live = require('../spotify-live');
var center = require('./center');
var sortUriUtils = require('../spotify-live-sort-uri');

var UIInteraction5 = require('../spotify-logger/messages/UIInteraction5');

var ASC = 'tl-sort-asc';
var DESC = 'tl-sort-desc';

var handleSort = function handleSort(event, node) {
  var listNode = node.parent('[data-list]');
  if (!listNode) return;

  var uri = listNode.data('uri');
  if (!uri) return;

  var queryCurrent = sortUriUtils.getQuery(uri);
  var directionCurrent = sortUriUtils.getDirection(uri);

  var query = node.data('sort');

  var reverse = directionCurrent === 'asc' ? 'desc' : 'asc';
  var direction = queryCurrent === query ? reverse : 'asc';
  var reset = queryCurrent === query && directionCurrent === 'desc';

  var origin = sortUriUtils.getOriginUri(uri) || uri;

  var nextUri;
  if (reset) {
    nextUri = origin;
    query = null;
    direction = null;
  } else {
    nextUri = sortUriUtils.create(origin, direction, query);
  }

  // The first time a live model for the sorted URI is created, the sortlist
  // model will set up the sorting queries based on the URI.
  var nextList = live(nextUri);

  // We then need to trigger the sort to happen by asking for rows
  // The app itself will most likely request rows anyway, but by doing it
  // early might make it slightly faster.
  nextList.get('rows', function () {});

  var player = live('spotify:player');

  player.get('variant', function (error, context) {
    if (error) throw error;

    if (context && context.get('uri') === uri) {
      player.emit('update-context', {
        context: nextUri
      });
    }
  });

  setClassNames(listNode, query, direction);

  center.emit('sort-header-click', {
    uri: origin,
    requested: {
      query: query || null,
      direction: direction || null
    },
    current: {
      query: queryCurrent || null,
      direction: directionCurrent || null
    }
  });

  center.emit('list-swap', { before: uri, after: nextUri });

  UIInteraction5.log({
    pageuri: live('spotify:application').get('appURI') || 'unknown',
    feature_id: 'zlink',
    section_id: 'sort-header',
    target_uri: nextUri,
    interaction_type: 'hit',
    user_intent: 'sort',
    timestamp: Math.round(Date.now() / 1000)
  });
};

var setClassNames = function setClassNames(list, opt_query, opt_direction) {

  var uri = list.data('uri');
  var query = opt_query !== undefined ? opt_query : sortUriUtils.getQuery(uri);
  var direction = opt_direction !== undefined ? opt_direction : sortUriUtils.getDirection(uri);
  var headers = list.search('[data-sort]');
  if (!headers) {
    return;
  }

  var $ = require('../spotify-elements');

  for (var i = 0, header; header = $(headers[i]); i++) {
    header.removeClass(ASC + ' ' + DESC);
    if (header.data('sort') === query) {
      header.addClass(direction === 'asc' ? ASC : DESC);
    }
  }
};

var handlePreviousProxyClick = function handlePreviousProxyClick(event, node) {
  handleSort(null, node.previousSibling());
};

var isAttached = false;

exports.update = function (node) {
  if (!isAttached) return;

  var $ = require('../spotify-elements');

  node = $(node) || $(document);

  var lists = node.matches('[data-list]') ? [node] : node.search('[data-list]');
  if (!lists) return;

  for (var i = 0, list; list = $(lists[i]); i++) {
    var headers = list.search('[data-sort]');
    if (!headers) {
      continue;
    }
    setClassNames(list);
  }
};

exports.attach = function attach() {
  if (isAttached) return;
  isAttached = true;

  var $ = require('../spotify-elements');

  $(document).delegate('click', '[data-sort]', handleSort);
  $(document).delegate('click', '[data-sort-previous]', handlePreviousProxyClick);
};

exports.detach = function detach() {
  if (!isAttached) return;
  isAttached = false;

  var $ = require('../spotify-elements');

  $(document).undelegate('click', '[data-sort]', handleSort);
  $(document).undelegate('click', '[data-sort-previous]', handlePreviousProxyClick);
};

},{"../spotify-elements":231,"../spotify-live":512,"../spotify-live-sort-uri":510,"../spotify-logger/messages/UIInteraction5":529,"./center":242}],303:[function(require,module,exports){
'use strict';

var _frameUpdater = require('../frame-updater');

var center = require('./center');
var sort = require('./sort');

var DEFAULT_STICKY_CLASS_NAME = 'sticky-top';

var isAttached = false;
var scrollListenerId = 0;
var nodesGBCR = null;
var rootGBCR = null;
var timestamp;
var lastTotalStickyHeight = 0;
var isDragScrolling = false;
var dragScrollingSpeed = 0;

var scrollTopOffset = 0;
var currentScrollX = 0;
var currentScrollY = 0;
var rects = null;
var scrollNode = null;

var readValuesWithTTL = function readValuesWithTTL(ttl) {
  var topBarHeight = document.documentElement.getAttribute('data-new-headers-top-bar-height');
  scrollTopOffset = parseInt(topBarHeight, 10) || 0;

  currentScrollY = scrollNode === document ? window.scrollY : scrollNode.scrollTop;

  rects = getRects(ttl);
};

var updateStickies = function updateStickies() {
  var scrollTop = currentScrollY + scrollTopOffset;
  var width = rects.root.width;
  var top = rects.root.top;
  var height = scrollTopOffset;
  var stickyNodes = rects.nodes;

  resetOldStickies();

  stickyNodes.forEach(function (nodeInfo, i) {
    var node = nodeInfo.node;
    var rect = nodeInfo.rect;
    var stickyClone = node.stickyClone;
    var stickyClassName = nodeInfo.stickyClassName;
    var stickyNode = stickyClone || node;

    // Check if the node should be sticked or not (if true, it should be).
    if (rect.top - top < scrollTop) {
      var previousNodeInfo = stickyNodes[i - 1];
      if (previousNodeInfo) {
        var previousNode = previousNodeInfo.node;
        var previousRect = previousNodeInfo.rect;
        if (previousNode.hasAttribute('data-sticky-single') && previousNode.classList.contains(stickyClassName)) {
          // This is the position of the current node relative to the bottom
          // edge of the stickies.
          var currentTopToEdge = Math.abs(rect.top - rects.root.top - (scrollTop + height));

          if (currentTopToEdge < previousRect.height) {
            var previousTop = height - previousRect.height;
            var newPreviousTop = previousTop - currentTopToEdge;
            previousNode.style.top = newPreviousTop + 'px';
            top -= currentTopToEdge;
            height -= currentTopToEdge;
          } else {
            // Unstick the sticky above if it's pushed past its original spot
            resetSticky(previousNode);
            top -= previousRect.height;
            height -= previousRect.height;
          }
        }
      }

      // Offset the position by the offset of the root layer (an issue when a
      // custom scroll node is used).
      var left = rect.left - rects.root.left;
      var right = rect.right - rects.root.left;

      if (!stickyNode.classList.contains(stickyClassName)) {
        // <THEAD>s can't be made sticky, so we clone it and add it to the DOM.
        if (node.nodeName.toLowerCase() === 'thead' && !node.stickyClone) {
          stickyNode = createClone(node);
        }

        stickyNode.classList.add(stickyClassName);

        var headerNode = stickyNode.closest('[data-glue-page-header]');
        if (headerNode) {
          headerNode.classList.add('glue-page-header--with-active-sticky-header');
        }

        // Update styles accordingly.
        stickyNode.setAttribute('data-sticky-active', '');
        stickyNode.style.right = width - right + 'px';
        stickyNode.style.left = left + 'px';
        stickyNode.style.position = 'fixed';
        stickyNode.style.top = height + 'px';
      } else {
        stickyNode.style.right = width - right + 'px';
        stickyNode.style.left = left + 'px';
        stickyNode.style.top = height + 'px';
      }

      // Increment the top reference and the height. Do it even if the element is already sticked.
      height += rect.height;
      top += rect.height;
    } else {
      if (stickyNode.classList.contains(stickyClassName)) {
        resetSticky(node);
      }
    }
  });

  lastTotalStickyHeight = height;
};

var handleResize = function handleResize() {
  readValuesWithTTL(0);
  updateStickies();
};

var handleMouseDown = function handleMouseDown() {
  document.addEventListener('dragover', onPointerDragMove);
  document.addEventListener('dragend', onPointerDragEnd);

  // Ideally we shouldn't need `mouseup`, but for some reason `dragend` is not
  // being triggered while scrolling. We can also not solely use mouseup, since
  // that is only triggered when releasing the pointer inside the iframe.
  document.addEventListener('mouseup', onPointerDragEnd);
};

var onPointerDragEnd = function onPointerDragEnd() {
  isDragScrolling = false;

  document.removeEventListener('dragover', onPointerDragMove);
  document.removeEventListener('dragend', onPointerDragEnd);
  document.removeEventListener('mouseup', onPointerDragEnd);
};

var onPointerDragMove = function onPointerDragMove(event) {
  var distanceFromContentEdge = event.clientY - lastTotalStickyHeight;
  var scrollEdgeThickness = 20;
  var isBelowContentEdge = distanceFromContentEdge > 0;
  var isAboveScrollEdge = distanceFromContentEdge < scrollEdgeThickness;

  if (isBelowContentEdge && isAboveScrollEdge) {
    var speedFactor = (scrollEdgeThickness - Math.max(0, distanceFromContentEdge)) / scrollEdgeThickness;
    dragScrollingSpeed = speedFactor * 20;

    if (!isDragScrolling) {
      isDragScrolling = true;
      dragScrollingTick();
    }
  } else {
    isDragScrolling = false;
  }
};

var dragScrollingTick = function dragScrollingTick() {
  if (isDragScrolling && currentScrollY > 0) {
    (0, _frameUpdater.requestFrame)(function () {
      currentScrollX = window.scrollX;
      currentScrollY = window.scrollY;
    }, function () {
      dragScrollingTick();
    });

    window.scrollTo(currentScrollX, currentScrollY - dragScrollingSpeed);
  }
};

var resetSticky = function resetSticky(node) {
  // <THEAD>s can't be made sticky, so verify if we are using a clone and remove it from the DOM.
  if (node.nodeName.toLowerCase() === 'thead' && node.stickyClone) {
    removeClone(node);
  }

  node.classList.remove(getStickyClassName(node));

  var headerNode = node.closest('[data-glue-page-header]');
  if (headerNode) {
    headerNode.classList.remove('glue-page-header--with-active-sticky-header');
  }

  // Update styles accordingly.
  node.removeAttribute('data-sticky-active', '');
  node.style.right = '';
  node.style.left = '';
  node.style.position = '';
  node.style.top = '';
};

var resetOldStickies = function resetOldStickies() {
  var selector = '[data-sticky-active]:not([data-sticky])';
  var nodes = document.querySelectorAll(selector);
  for (var i = 0, l = nodes.length; i < l; i++) {
    if (!nodes[i].isStickyClone) {
      resetSticky(nodes[i]);
    }
  }
};

var getRects = function getRects(ttl) {
  var reference = timestamp + ttl;
  var nodes = document.querySelectorAll('[data-sticky]');

  // Refresh timestamp (always).
  timestamp = Date.now();

  // If the reference time is still valid, and nodes are the same, then return data.
  if (reference > timestamp && nodesGBCR && nodes.length === nodesGBCR.length) {
    var equal = true;

    for (var i = 0; i < nodes.length; i++) {
      equal = equal && nodes[i] === nodesGBCR[i].node;
    }

    if (equal) {
      return {
        nodes: nodesGBCR,
        root: rootGBCR
      };
    }
  }

  // Otherwise, compute and cache.
  if (scrollNode === document) {
    rootGBCR = document.documentElement.getBoundingClientRect();
  } else {
    rootGBCR = scrollNode.getBoundingClientRect();
    rootGBCR = {
      top: rootGBCR.top - currentScrollY,
      right: rootGBCR.right,
      bottom: rootGBCR.bottom,
      left: rootGBCR.left,
      width: rootGBCR.width,
      height: rootGBCR.height
    };
  }
  nodesGBCR = Array.prototype.map.call(document.querySelectorAll('[data-sticky]'), function (node) {
    var parentRect = node.parentNode.getBoundingClientRect();
    var nodeRect = node.getBoundingClientRect();

    // Return a structure per node. Only some fields are stored in the rect object (the ones used).
    return {
      stickyClassName: getStickyClassName(node),
      node: node,
      rect: {
        top: parentRect.top,
        height: nodeRect.height,
        left: parentRect.left,
        right: parentRect.right
      }
    };
  });

  return {
    nodes: nodesGBCR,
    root: rootGBCR
  };
};

var createClone = function createClone(node) {
  var div = document.createElement('div');
  var thead = node.cloneNode(true);
  var table = node.parentNode.cloneNode(false);
  var onListSwap;

  table.appendChild(thead).removeAttribute('data-sticky');
  div.appendChild(table);
  div.className = 'sticky-clone';
  div.isStickyClone = true;

  onListSwap = function onListSwap(data) {
    var table = thead.parentNode;
    var uri = table && table.getAttribute('data-uri');

    // Update the "data-uri" of the cloned table, and the sort state of the original one.
    if (uri) {
      table.setAttribute('data-uri', data.after);
      sort.update(node.parentNode);
    }
  };

  center.on('list-swap', onListSwap);

  node.parentNode.parentNode.appendChild(div);
  node.style.visibility = 'hidden';
  node.stickyListSwapListener = onListSwap;
  node.stickyClone = div;

  return div;
};

var removeClone = function removeClone(node) {
  var stickyClone = node.stickyClone;

  if (stickyClone.parentNode) {
    stickyClone.parentNode.removeChild(stickyClone);
  }

  if (node.stickyListSwapListener) {
    center.off('list-swap', node.stickyListSwapListener);
  }

  node.style.removeProperty('visibility');

  delete node.stickyClone;
  delete node.stickyListSwapListener;
};

var getStickyClassName = function getStickyClassName(stickyNode) {
  var root = document.documentElement;
  var classSticky;
  var node;

  for (node = stickyNode; node !== root; node = node.parentNode) {
    if (classSticky = node.getAttribute('data-class-sticky')) {
      return classSticky;
    }
  }

  return DEFAULT_STICKY_CLASS_NAME;
};

exports.DEFAULT_STICKY_CLASS_NAME = DEFAULT_STICKY_CLASS_NAME;

exports.attach = function attach() {
  if (!isAttached) {
    isAttached = true;

    if (!scrollNode) {
      scrollNode = document;
    }

    scrollListenerId = (0, _frameUpdater.addDebouncedScrollListener)(scrollNode, function () {
      readValuesWithTTL(4000);
    }, function () {
      updateStickies();
    });

    window.addEventListener('resize', handleResize);
    document.addEventListener('mousedown', handleMouseDown);
  }
};

exports.detach = function detach() {
  if (isAttached) {
    isAttached = false;

    (0, _frameUpdater.removeDebouncedScrollListener)(scrollListenerId);
    window.removeEventListener('resize', handleResize);
    document.removeEventListener('mousedown', handleMouseDown);

    nodesGBCR = null;
    rootGBCR = null;
    lastTotalStickyHeight = 0;
    isDragScrolling = false;
    dragScrollingSpeed = 0;
    scrollNode = null;
  }
};

exports.update = function () {
  if (isAttached) {
    nodesGBCR = null;
    rootGBCR = null;

    readValuesWithTTL(4000);
    updateStickies();
  }
};

// A way to let an app override the node to listen for scroll events on.
// This has to be called before `attach` is called.
exports.setScrollNode = function setScrollNode(node) {
  scrollNode = node;
};

exports._getStickyClassName = getStickyClassName;

},{"../frame-updater":126,"./center":242,"./sort":302}],304:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
var live = require('../spotify-live');
var dom = require('./util/dom');

var SELECTOR_THUMBS_DOWN_BUTTON = '[data-button=thumbs-down]';
var SELECTOR_THUMBS_UP_BUTTON = '[data-button=thumbs-up]';

/**
 * Handle the click on a Thumbs button.
 *
 * @param {MouseEvent} event An event object for a click event.
 * @param {HTMLElement} button A button DOM node.
 *
 * @private
 */
function handleThumbsButtonClick(event, button) {
  var type = dom.getAttributeFromNodeOrParent(button[0], 'data-button');
  var trackUri = dom.getAttributeFromNodeOrParent(button[0], 'data-uri');
  var contextUri = dom.getContextFromNodeOrParent(button[0]);

  // Must use track uri
  if (!trackUri || !contextUri) return;

  // Emit thumb event on context
  if (type === 'thumbs-down') {
    live(contextUri).emit('thumb-down', trackUri);
  } else if (type === 'thumbs-up') {
    live(contextUri).emit('thumb-up', trackUri);
  }
}

var isAttached = false;

/**
 * Attach the event listeners for the module.
 * Part of the spotify-events interface.
 */
exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  var doc = $(document);
  doc.delegate('click', SELECTOR_THUMBS_DOWN_BUTTON, handleThumbsButtonClick);
  doc.delegate('click', SELECTOR_THUMBS_UP_BUTTON, handleThumbsButtonClick);
};

/**
 * Detach the event listeners for the module.
 * Part of the spotify-events interface.
 */
exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  var doc = $(document);
  doc.undelegate('click', SELECTOR_THUMBS_DOWN_BUTTON, handleThumbsButtonClick);
  doc.undelegate('click', SELECTOR_THUMBS_UP_BUTTON, handleThumbsButtonClick);
};

exports.update = function () {};

},{"../spotify-elements":231,"../spotify-live":512,"./util/dom":311}],305:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');

var tooltipMargin = 8; // We want some spacing around the tooltip

var tooltipNode = document.createElement('div');
tooltipNode.id = 'tooltip';

var tooltipTextNode = document.createElement('span');

var tooltipArrowTop = document.createElement('div');
tooltipArrowTop.className = 'tooltip-arrow-top';

var tooltipArrowBottom = document.createElement('div');
tooltipArrowBottom.className = 'tooltip-arrow-bottom';

tooltipNode.appendChild(tooltipArrowTop);
tooltipNode.appendChild(tooltipArrowBottom);
tooltipNode.appendChild(tooltipTextNode);

var attachedNode = null;
var tooltipContainer = null;

// tooltipArrow will point to the current visible tooltipArrow
// that can be either tooltipArrowTop or tooltipArrowBottom
var tooltipArrow = null;

var addTooltipToDOM = function addTooltipToDOM(container) {
  tooltipContainer = container;
  tooltipContainer.appendChild(tooltipNode);
};

var removeTooltipFromDOM = function removeTooltipFromDOM() {
  attachedNode = null;
  if (tooltipNode.parentNode) {
    tooltipContainer.removeChild(tooltipNode);
  }

  tooltipContainer = null;
};

var getTooltipContainer = function getTooltipContainer(node) {
  var containerSelector = node.getAttribute('data-tooltip-container');
  var containerNode;

  if (containerSelector) {
    containerNode = document.querySelector(containerSelector);
  }

  return containerNode || document.body;
};

var showTooltip = function showTooltip(event, node) {
  var realNode = node[0];
  var top = 0;
  var left = 0;

  var tooltipText = node.data('tooltip') || node.getAttribute('title');
  if (!tooltipText) return;

  // Remember the node we set the text from so that text can be updated.
  attachedNode = node;

  if (!node.tooltipCheck) {
    node.removeAttribute('title');
    node.setAttribute('data-tooltip', tooltipText);
    node.tooltipCheck = true;
  }

  var container = getTooltipContainer(node);
  if (!tooltipContainer || container !== tooltipContainer) {
    addTooltipToDOM(container);
  }

  setText(tooltipText);

  var tooltipHeight = tooltipNode.clientHeight;
  var tooltipWidth = tooltipNode.offsetWidth;

  // Don't use window.scrollY because cross browser issues.
  // https://developer.mozilla.org/en-US/docs/Web/API/Window.scrollY
  var scrollY = window.pageYOffset;

  var bounds = realNode.getBoundingClientRect();
  var targetHeight = realNode.offsetHeight;
  var targetWidth = realNode.offsetWidth;
  var targetTop = parseInt(bounds.top, 10) + scrollY;
  var targetLeft = parseInt(bounds.left, 10);
  var targetCenter = targetLeft + targetWidth / 2;
  var targetBottom = targetTop + targetHeight;
  var viewportWidth = document.documentElement.clientWidth;
  var viewportHeight = document.documentElement.clientHeight;

  // Decide if the tooltip should be over or under the node
  if (targetBottom + tooltipHeight + tooltipMargin - scrollY > viewportHeight) {
    // On top
    top = targetTop - tooltipHeight - tooltipMargin;
    tooltipArrowTop.classList.remove('visible');
    tooltipArrowBottom.classList.add('visible');
    tooltipArrow = tooltipArrowBottom;
  } else {
    top = targetTop + targetHeight + tooltipMargin;
    if (top - scrollY > viewportHeight) {
      top = viewportHeight - tooltipHeight;
    }
    tooltipArrowTop.classList.add('visible');
    tooltipArrowBottom.classList.remove('visible');
    tooltipArrow = tooltipArrowTop;
  }

  var distanceToTheRight = viewportWidth - tooltipMargin - targetCenter;
  var distanceToTheLeft = targetCenter - tooltipMargin;
  var tooltipOffsetRight = Math.max(0, tooltipWidth / 2 - distanceToTheRight);
  var tooltipOffsetLeft = Math.max(0, tooltipWidth / 2 - distanceToTheLeft);

  left = targetCenter - tooltipWidth / 2 - (tooltipOffsetRight || -tooltipOffsetLeft);

  tooltipNode.style.top = top + 'px';
  tooltipNode.style.left = left + 'px';
  tooltipArrow.style.left = targetCenter - left + 'px';

  if (node.hasAttribute('data-tooltip-instant')) {
    tooltipNode.classList.add('instant');
  } else {
    tooltipNode.classList.remove('instant');
  }

  tooltipNode.classList.add('visible');
};

var hideTooltip = function hideTooltip() {
  if (!attachedNode) {
    return;
  }
  attachedNode = null;
  setText('');
  tooltipNode.classList.remove('visible');
  tooltipNode.style.left = 0;
  tooltipNode.style.top = 0;
  if (tooltipArrow) {
    tooltipArrow.style.left = 0;
  }
};

var setText = function setText(text) {
  tooltipTextNode.innerHTML = text;
};

var isAttached = false;

exports.attach = function attach() {
  if (isAttached) return;
  isAttached = true;

  var doc = $(document);
  doc.delegate('mouseover', '[data-tooltip]', showTooltip);
  doc.delegate('mouseout', '[data-tooltip]', hideTooltip);
  doc.on('keydown', hideTooltip);
  doc.on('mousedown', hideTooltip);
};

exports.detach = function detach() {
  if (!isAttached) return;
  isAttached = false;

  removeTooltipFromDOM();
  var doc = $(document);
  doc.undelegate('mouseover', '[data-tooltip]', showTooltip);
  doc.undelegate('mouseout', '[data-tooltip]', hideTooltip);
  doc.off('keydown', hideTooltip);
  doc.off('mousedown', hideTooltip);
};

/** Forces an update of the tooltip text. */
exports.update = function update() {
  if (!isAttached) return;

  if (!attachedNode) return;

  if (attachedNode.data('tooltip')) {
    showTooltip(null, attachedNode);
  } else {
    // The tooltip no longer has text and should be hidden.
    hideTooltip();
  }
};

// Export for testing purposes
exports._setText = setText;

},{"../spotify-elements":231}],306:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');

var doc = $(document);
var hoverActive = true;

/* Store events in an array */
var touchArray = [];
var addEvent = function addEvent(touchEvent) {
  touchArray.push(touchEvent);
};

function getMediaObjects() {
  return doc.search('.media-object');
}

function isMediaObject(element) {
  return !!element.closest('.media-object');
}

function handleEvent(e) {
  var target = e.target;
  if (isMediaObject(target)) {
    switch (e.type) {
      case 'touchstart':
        addEvent(e);
        if (hoverActive) {
          disableHover(e);
        }
        break;

      case 'touchmove':
        addEvent(e);
        break;

      case 'touchend':

        if (target && touchArray.length === 1 && touchArray[0].type === 'touchstart') {
          e.preventDefault();
          target.click();
        }
        touchArray = [];
        break;

      case 'contextmenu':
        addEvent(e);
        break;

      case 'mousemove':
        if (!hoverActive) {
          enableHover(e);
        }
        break;
    }
  }
}

function disableHover() {
  var mediaObjects = getMediaObjects();
  if (mediaObjects) {
    mediaObjects.forEach(function (object) {
      // Find available hover elements
      var overlay = $(object).find('.mo-overlay');
      // Hide hover elements
      if (overlay) {
        var add = $(object).find('.mo-add');
        var play = $(object).find('.mo-play');
        var more = $(object).find('.mo-more');
        var del = $(object).find('.mo-delete');

        hide(overlay);
        if (add) {
          hide(add);
        }
        if (play) {
          hide(play);
        }
        if (more) {
          hide(more);
        }
        if (del) {
          hide(del);
        }
      }
    });
    hoverActive = false;
  }

  function hide(element) {
    element.addClass('not-visible');
  }
}

function enableHover() {
  var mediaObjects = getMediaObjects();
  if (mediaObjects) {
    // Show hover elements
    mediaObjects.forEach(function (object) {
      var elements = $(object).search('.not-visible');
      if (elements) {
        show(elements);
        hoverActive = true;
      }
    });
  }

  function show(element) {
    element.removeClass('not-visible');
  }
}

var isAttached = false;

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  doc.on('touchstart', handleEvent);
  doc.on('touchmove', handleEvent);
  doc.on('touchend', handleEvent);
  doc.on('mousemove', handleEvent);
  doc.on('contextmenu', handleEvent);
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  doc.off('touchstart', handleEvent);
  doc.off('touchmove', handleEvent);
  doc.off('touchend', handleEvent);
  doc.off('mousemove', handleEvent);
  doc.off('contextmenu', handleEvent);
};

exports.update = function () {};

exports._reset = function () {
  hoverActive = true;
  touchArray = [];
};

},{"../spotify-elements":231}],307:[function(require,module,exports){
'use strict';

var prime = require('../../../libs/prime');
var Emitter = require('../../../libs/prime/emitter');
var Range = require('../../spotify-range2');

var SYNC = Emitter.EMIT_SYNC;

module.exports = prime({
  mixin: Emitter,

  constructor: function constructor(container, params) {
    this.container = container;

    this.height = params.height || 0;
    this.length = params.length || 0;

    this.tag = params.tag || 'li';
    this.request = params.request;

    // Unique call identificator.
    this._id = 0;

    this.reset();
  },

  resetFrom: function resetFrom(fromIndex, length, hiddenIndices) {
    var range = this._range;

    // Redirect the call to reset.
    if (fromIndex < range.end) {
      this.reset(length, hiddenIndices);
      this.show(range);
    }
  },

  reset: function reset(length, hiddenIndices) {
    var tag = this.tag;
    var totalHeight;

    if (typeof length !== 'undefined') {
      this.length = length;
    }

    totalHeight = this.length * this.height;

    // Hidden indices are not supported anymore (legacy).
    if (hiddenIndices) {
      throw new TypeError('Hidden indices are not supported anymore!');
    }

    this.container.innerHTML = '<' + tag + ' style="height:' + totalHeight + 'px"></' + tag + '>' + '<' + tag + ' style="height:0px"></' + tag + '>';

    this._range = new Range(0, 0);
    this._waitingRange = new Range(0, 0);

    // An array of ranges representing the visible nodes.
    this.emit('index-change', [], SYNC);
  },

  show: function show(range) {
    var length = this.length;
    var actual = this._range;
    var waiting = this._waitingRange;

    // Limit range to the [0, length) interval.
    var bound = new Range(Math.max(0, range.start), Math.min(length, range.end));

    // If the range requested is the same, do nothing.
    if (bound.start === actual.start && bound.end === actual.end) {
      return;
    }

    // If the range requested is the same, do nothing.
    if (bound.start === waiting.start && bound.end === waiting.end) {
      return;
    }

    this._drawRange(bound);
  },

  _drawRange: function _drawRange(range) {
    var container = this.container;
    var oldRange = this._range;
    var height = this.height;
    var length = this.length;
    var id = ++this._id;
    var self = this;

    this._waitingRange = range;

    // Request the whole range. We will manually intersect later with the current one.
    this.request(range, function (err, nodes) {
      var diff = 0;
      var first;
      var last;
      var i;

      // If a new range has been requested in the meantime, don't draw/modify anything.
      if (id !== self._id) {
        return;
      }

      // Cache the range requested.
      self._range = range;
      self._waitingRange = new Range(0, 0);

      // Get first and last nodes as references. We will use them for removing/adding nodes.
      first = container.firstChild;
      last = container.lastChild;

      // Change heights of the paddings.
      first.style.height = range.start * height + 'px';
      last.style.height = (length - range.end) * height + 'px';

      // Remove old nodes. Since nodes change their position when removing them one by one,
      // we have to keep the cumulative sum of nodes removed cached.
      oldRange.subtract(range).forEach(function (subrange) {
        var length = subrange.length;

        for (i = 0; i < length; i++) {
          // We add one to the children index because the first child is not a row but the top padding.
          container.removeChild(container.children[subrange.start - oldRange.start - diff + 1]);
        }

        diff += length;
      });

      // Add new nodes. If the new nodes are below the old range, insert them at the top;
      // otherwise, insert them at the bottom.
      range.subtract(oldRange).forEach(function (subrange) {
        var length = subrange.length;
        var start = subrange.start - range.start;
        var subnodes = nodes.slice(start, start + length);
        var ref;

        // Emit a change before.
        self.emit('before-show', subrange, subnodes, SYNC);

        // Get the reference node. If the range is below, then insert at the top.
        // Otherwise, insert at the bottom.
        if (subrange.below(oldRange)) {
          ref = first.nextSibling;
        } else {
          ref = last;
        }

        for (i = 0; i < length; i++) {
          container.insertBefore(subnodes[i], ref);
        }

        // Emit a change after.
        self.emit('after-show', subrange, subnodes, SYNC);
      });

      self.emit('index-change', [range], SYNC);
    });
  }
});

},{"../../../libs/prime":222,"../../../libs/prime/emitter":221,"../../spotify-range2":551}],308:[function(require,module,exports){
'use strict';

var Position = function Position(containerIndex, index) {
  this.containerIndex = containerIndex;
  this.index = index;
};

Position.prototype.isSame = function (position) {
  return this.containerIndex === position.containerIndex && this.index === position.index;
};

module.exports = Position;

},{}],309:[function(require,module,exports){
'use strict';

var live = require('../../spotify-live');

function checkIfActive() {
  return live('spotify:application').get('active') || false;
}

function checkIfFocused() {

  // If the active element of the top frame has a contentWindow that matches
  // this window, it means the iframe of this app is in focus.
  var topActiveElement = window.top.document.activeElement;
  var activeWindow = topActiveElement && topActiveElement.contentWindow;
  if (activeWindow) {
    return activeWindow === window;
  }

  // Top frame (zlink)
  if (window.top === window) {
    return true;
  }

  return false;
}

exports.isActive = function () {
  return checkIfActive();
};

exports.isActiveAndFocused = function () {
  return checkIfActive() && checkIfFocused();
};

},{"../../spotify-live":512}],310:[function(require,module,exports){
/**
 * @module spotify-events/util/cosmos
 * @private
 */

'use strict';

var live = require('../../spotify-live');
var cosmos = require('spotify-cosmos-api');
var liburi = require('spotify-liburi');

var ASAP = live.ASAP;

function DELETE(options, opt_callback) {
  options.method = exports.cosmos.Action.DELETE;
  return request(options, opt_callback);
}

function GET(options, opt_callback) {
  options.method = exports.cosmos.Action.GET;
  return request(options, opt_callback);
}

function SUB(options, opt_callback) {
  options.method = exports.cosmos.Action.SUB;
  return request(options, opt_callback);
}

function POST(options, opt_callback) {
  options.method = exports.cosmos.Action.POST;
  return request(options, opt_callback);
}

function PUT(options, opt_callback) {
  options.method = exports.cosmos.Action.PUT;
  return request(options, opt_callback);
}

function HEAD(options, opt_callback) {
  options.method = exports.cosmos.Action.HEAD;
  return request(options, opt_callback);
}

function request(options, opt_callback) {
  var method = options.method;
  delete options.method;

  var subscription, canceled;

  sanitizeURL(options.url, function (error, url) {
    if (error) {
      opt_callback(error);
      return;
    }

    // if you cancel before the userName is replaced.
    if (canceled) return;

    var request = new exports.cosmos.Request(method || exports.cosmos.Action.GET, url, options.headers, options.body);
    subscription = exports.cosmos.resolver.resolve(request, function (error, response) {
      if (!opt_callback) return;
      if (error) {
        opt_callback(error);
        return;
      }
      try {
        opt_callback(null, {
          body: JSON.parse(response.getBody() || '{}'),
          headers: response.getHeaders(),
          status: response.getStatusCode()
        });
      } catch (parseError) {
        parseError.response = response;
        opt_callback(parseError);
      }
    });
  });

  return {
    cancel: function cancel() {
      if (subscription && subscription.cancel) {
        // we already subscribed, cancel it.
        subscription.cancel();
        subscription = null;
      } else if (!canceled) {
        // not subscribed yet, don't even subscribe.
        canceled = true;
      }
      return null;
    }
  };
}

function sanitizeURL(url, callback) {
  if (url.indexOf('@') > -1) {
    live('spotify:client').query('currentUser(username)', function (error, data) {
      if (error) {
        callback(error);
        return;
      }
      callback(null, url.replace('@', liburi.getCanonicalUsername(data.currentUser.username)));
    }, ASAP);
  } else {
    callback(null, url);
  }
}

exports.request = request;
exports.get = GET;
exports.post = POST;
exports.subscribe = SUB;
exports.delete = DELETE;
exports.put = PUT;
exports.head = HEAD;
exports.cosmos = cosmos;

exports.sanitizeURL = sanitizeURL;

},{"../../spotify-live":512,"spotify-cosmos-api":890,"spotify-liburi":899}],311:[function(require,module,exports){
'use strict';

/**
 * @public
 */

/**
 * Get the context URI from the specified node or its parents.
 *
 * @param {HTMLElement} node A DOM node.
 *
 * @return {string} The context URI or empty string if not found.
 */

function getContextFromNodeOrParent(node) {
  var contextNode = node.closest('[data-context]');
  return contextNode && contextNode.getAttribute('data-uri') || '';
}

/**
 * Get the value for the passed attribute name, either from the passed node
 * or from any parent node.
 *
 * @param {HTMLElement} node The node to start searching from.
 * @param {string} attributeName The name of the attribute.
 *
 * @return {string} The value, or empty string if not found.
 */
function getAttributeFromNodeOrParent(node, attributeName) {
  var selector = '[' + attributeName + ']';
  var attributeNode = node.closest(selector);
  return attributeNode && attributeNode.getAttribute(attributeName) || '';
}

exports.getContextFromNodeOrParent = getContextFromNodeOrParent;
exports.getAttributeFromNodeOrParent = getAttributeFromNodeOrParent;

},{}],312:[function(require,module,exports){
'use strict';

module.exports = function getLogContext(target) {
  var currentNode = target;
  var logContext = [];
  while (currentNode) {
    if (currentNode.matches && currentNode.matches('[data-log-context]')) {
      logContext.unshift(currentNode.getAttribute('data-log-context'));
    }
    currentNode = currentNode.parentNode;
  }
  return logContext.join('/') || null;
};

},{}],313:[function(require,module,exports){
'use strict';

var rAF = window.requestAnimationFrame || function (fn) {
  setTimeout(fn, 16);
};

/**
 * Throttle the function calls to only trigger once per tick.
 * This will return a new function that you will use when you want
 * to call your function. Calling it multiple times in the same
 * run loop will only really call it once.
 *
 * @param {function} fn A function.
 * @param {Object=} opt_ctx The context to run the function in ('this').
 *
 * @return {function} A new function.
 */
function throttle(fn, opt_ctx) {
  var queued = false;
  var args;

  return function () {
    args = arguments;
    if (!queued) {
      queued = true;
      rAF(function () {
        queued = false;
        fn.apply(opt_ctx, args);
      });
    }
  };
}

module.exports = throttle;

},{}],314:[function(require,module,exports){
(function (global){
'use strict';

exports.init = function () {
  require('./expose-debug-global').expose(global, 'bridge', require('../spotify-bridge-request'));
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-bridge-request":225,"./expose-debug-global":316}],315:[function(require,module,exports){
(function (global){
'use strict';

exports.init = function () {
  require('./expose-debug-global').expose(global, 'cosmos', require('spotify-cosmos-api'));
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./expose-debug-global":316,"spotify-cosmos-api":890}],316:[function(require,module,exports){
'use strict';

exports.expose = function (global, name, object, output) {
  if (global.__spotify && global.__spotify.developer_mode) {
    Object.defineProperty(global, name, {
      get: function get() {
        (output || console.warn.bind(console))('window.' + name + ' should only be accessed from the ' + 'console! If you see this and did not use the console something ' + 'is misbehaving.');
        return object;
      },
      enumerable: true,
      configurable: true
    });
  }
};

},{}],317:[function(require,module,exports){
(function (global){
'use strict';

exports.init = function () {
  require('./expose-debug-global').expose(global, 'live', require('../spotify-live'));
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":512,"./expose-debug-global":316}],318:[function(require,module,exports){
(function (global){
'use strict';

exports.init = function () {
  require('./expose-debug-global').expose(global, 'spfetch', require('../spotify-http-requests').spFetch);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-http-requests":340,"./expose-debug-global":316}],319:[function(require,module,exports){
'use strict';

// Usage
// Data {{#compare 'myvalue' value}}has{{else}}doesn't have{{/compare}} myvalue.
// Data {{#compare '5' tracks.length true}}has{{else}}doesn't have{{/compare}} 5 tracks.
// Data {{#compare tracks.length 5 operator='>'}}has more than{{else}}has less than or equal to{{/compare}} 5 tracks.

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var operators = {
  '==': function _(a, b) {
    /* eslint eqeqeq: 0 */return a == b;
  },
  '===': function _(a, b) {
    return a === b;
  },
  '!=': function _(a, b) {
    /* eslint eqeqeq: 0 */return a != b;
  },
  '<': function _(a, b) {
    return a < b;
  },
  '>': function _(a, b) {
    return a > b;
  },
  '<=': function _(a, b) {
    return a <= b;
  },
  '>=': function _(a, b) {
    return a >= b;
  },
  'typeof': function _typeof(a, b) {
    return (typeof a === 'undefined' ? 'undefined' : _typeof2(a)) == b;
  }
};

function compare(a, b, s) {
  var options = arguments[arguments.length - 1];
  var soft = s !== options ? s : false;
  var operator = soft ? '==' : options.hash.operator || '===';

  var match = operators[operator](a, b);

  return match ? options.fn(this) : options.inverse(this);
}

compare.displayName = 'compare';

module.exports = compare;

},{}],320:[function(require,module,exports){
'use strict';

var duration = function duration(ms) {
  if (isNaN(ms)) return ms;

  var s = Math.round(ms / 1000);
  var oneMinute = 60;
  var oneHour = 60 * oneMinute;

  var hours = Math.floor(s / oneHour);
  var minutes = Math.floor(s % oneHour / oneMinute);
  var seconds = Math.round(s % oneHour % oneMinute);

  // Include hours if needed
  if (hours) {
    hours += ':';

    // If hours are specified, minutes should always be with two digits
    if (minutes < 10) minutes = '0' + minutes;
  } else {
    hours = '';
  }

  // Since minutes should always be displayed, seconds should always be with two digits
  if (seconds < 10) seconds = '0' + seconds;

  return hours + minutes + ':' + seconds;
};

duration.displayName = 'duration';

module.exports = duration;

},{}],321:[function(require,module,exports){
'use strict';

var nameListTooltip = require('./name-list-tooltip');

var facepile = function facepile(list, options) {
  if (!list) {
    return '';
  }

  var len = list.length;
  var thresh = Math.min(3, len);
  var ret = '';

  // Display faces.
  for (var i = 0; i < thresh; i++) {
    var obj = list[i];
    obj.modifiers = 'media-object-link media-object-simple';
    ret += options.fn(obj);
  }

  // Display badge count for hidden faces.
  if (len > thresh) {
    ret += options.inverse({
      badgeCount: len - thresh,
      badgeTooltip: nameListTooltip(list.slice(thresh), len - thresh)
    });
  }
  return ret;
};

facepile.displayName = 'facepile';

module.exports = facepile;

},{"./name-list-tooltip":328}],322:[function(require,module,exports){
(function (global){
'use strict';

var getHTTPLink = require('../util/link');

var isDesktop = !!global._getSpotifyModule;

var href = function href(uri) {
  if (isDesktop) return uri;
  return getHTTPLink(uri, 'https://play.spotify.com');
};

href.displayName = 'href';

module.exports = href;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../util/link":335}],323:[function(require,module,exports){
'use strict';

var loc = require('./loc');

var humanizeDuration = function humanizeDuration(ms) {
  if (isNaN(ms)) return ms;

  var s = Math.round(ms / 1000);
  var oneMinute = 60;
  var oneHour = 60 * oneMinute;

  var hours = Math.floor(s / oneHour);
  var minutes = Math.floor(s % oneHour / oneMinute);
  var seconds = Math.round(s % oneHour % oneMinute);

  var formattedDuration = '';

  if (hours) {
    formattedDuration += loc('HoursShort', hours, {});
  }

  if (minutes) {
    formattedDuration += ' ';
    formattedDuration += loc('MinutesShort', minutes, {});
  }

  if (!hours && !minutes || hours === 0 && minutes < 10) {
    formattedDuration += ' ';
    formattedDuration += loc('SecondsShort', seconds, {});
  }

  return formattedDuration.trim();
};

humanizeDuration.displayName = 'humanizeDuration';

module.exports = humanizeDuration;

},{"./loc":327}],324:[function(require,module,exports){
'use strict';

exports.compare = require('./compare');
exports.duration = require('./duration');
exports.facepile = require('./facepile');
exports.href = require('./href');
exports.humanizeDuration = require('./humanize-duration');
exports.list = require('./list');
exports.loc = require('./loc');
exports.nameListTooltip = require('./name-list-tooltip');
exports.numeral = require('./numeral');
exports.share = require('./share');
exports.slice = require('./slice');
exports.type = require('./type');
exports.userReaction = require('./user-reaction');
exports.json = require('./json');

},{"./compare":319,"./duration":320,"./facepile":321,"./href":322,"./humanize-duration":323,"./json":325,"./list":326,"./loc":327,"./name-list-tooltip":328,"./numeral":329,"./share":330,"./slice":331,"./type":332,"./user-reaction":333}],325:[function(require,module,exports){
'use strict';

var json = function json(context) {
  return JSON.stringify(context);
};

json.displayName = 'json';

module.exports = json;

},{}],326:[function(require,module,exports){
'use strict';

var map = require('mout/array/map');

var Handlebars = require('handlebars/dist/cjs/handlebars.runtime').default;

var lists = {};

var list = function list(array) {
  if (!array) {
    return '';
  }

  var args = Array.prototype.slice.call(arguments);
  var options = args.pop();
  var listID = args[1];

  if (array === 'reset') {
    delete lists[listID];
    return '';
  }

  if (listID && lists[listID] === undefined) {
    lists[listID] = -1;
  }

  return map(array, function (item, i) {
    var data = Handlebars.createFrame(options.data || {});
    data.index = listID ? ++lists[listID] : i;
    data.number = data.index + 1;
    data.localIndex = i;
    data.localNumber = i + 1;
    return options.fn(item, { data: data });
  }).join(options.hash && options.hash.join || '');
};

list.displayName = 'list';

module.exports = list;

},{"handlebars/dist/cjs/handlebars.runtime":608,"mout/array/map":662}],327:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _mixIn = require('mout/object/mixIn');

var _mixIn2 = _interopRequireDefault(_mixIn);

var _pickString2 = require('../../spotify-i18n/src/pick-string');

var _pickString3 = _interopRequireDefault(_pickString2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var slice_ = Array.prototype.slice;

var locale = 'en';
var numberFormat = new Intl.NumberFormat(locale);
var storage = {};

var loc = function loc(key) {
  var args = slice_.call(arguments, 1);
  var options = {};

  var lastArg = args[args.length - 1];
  if ((typeof lastArg === 'undefined' ? 'undefined' : _typeof(lastArg)) === 'object' && 'hash' in lastArg) {
    options = args.pop();
  }

  var hash = options.hash;

  var value = (0, _pickString3.default)(_defineProperty({}, locale, storage), locale, key, args[0]);
  if (!value) return '';

  // If we are passed an array, use that for replacements
  if (Array.isArray(args[0])) {
    args = args[0];
  }

  return value.replace(/\{([\w-]+)\}/g, function (full, match) {
    var n = +match;
    var interpolated;

    if (isNaN(n)) {
      interpolated = hash[match];
    } else {
      interpolated = args[n];
    }

    if (typeof interpolated === 'number') {
      interpolated = numberFormat.format(interpolated);
    }

    return interpolated !== null ? interpolated : '';
  });
};

loc.displayName = 'loc';

loc.register = function (object) {
  (0, _mixIn2.default)(storage, object);
  return this;
};

loc.setLocale = function (newLocale) {
  locale = newLocale;
  numberFormat = new Intl.NumberFormat(locale);
};

module.exports = loc;

},{"../../spotify-i18n/src/pick-string":458,"mout/object/mixIn":692}],328:[function(require,module,exports){
'use strict';

var loc = require('./loc');

var nameListTooltip = function nameListTooltip(users, totalCount) {
  if (totalCount === 0) {
    return undefined;
  }

  var len = users.length;
  var textTokens = users.map(function (user) {
    return user.name;
  });

  if (totalCount - len > 0) {
    var andMoreText = loc('AndMore', totalCount - len);
    textTokens.push(andMoreText);
  }

  return textTokens.join('<br>\n').replace(/'/g, '&#39;');
};

nameListTooltip.displayName = 'nameListTooltip';

module.exports = nameListTooltip;

},{"./loc":327}],329:[function(require,module,exports){
'use strict';

var isNumber = require('mout/lang/isNumber');

/**
 * If the first argument is a number, pipe it through spotify-numeral with an
 * optional format propety in the options hash, otherwise return it untouched.
 *
 * Example usage – results when using fr locale:
 *
 * {{numeral 1000}} -> '1 000'
 * {{numeral 1000 format='0,0.000'}} -> '1 000,000'
 * {{numeral 1000 format='$0,0.00'}} -> '€1 000,00'
 *
 * @param {Number|String} number - The number to format (or string to leave
 *     untouched).
 * @param {Object} [options] - The handlebars options object.
 * @param {Object} [options.hash] - The handlebars options hash object.
 * @param {String} [options.hash.format] - The optional format to pass to
 *     numeraljs.
 * @return {String} The formatted (or untouched) string.
 */
var numeralHelper = function numeralHelper(number, options) {
  var format = options && options.hash && options.hash.format;
  var numeral = numeralHelper._numeral;
  return isNumber(number) ? numeral(number).format(format) : number;
};

numeralHelper.displayName = 'numeral';

module.exports = numeralHelper;

// This is tricky, but is a way to allow for the locale to be injected
// from the consuming app instead of from within spotify-numeral, removing
// the dependency on spotify-quickstart.
module.exports.setLocale = function (locale) {
  numeralHelper._numeral = require('../../spotify-numeral')(locale);
};

},{"../../spotify-numeral":549,"mout/lang/isNumber":677}],330:[function(require,module,exports){
'use strict';

var getHTTPLink = require('../util/link');

var share = function share(uri) {
  return getHTTPLink(uri, 'https://open.spotify.com');
};

share.displayName = 'share';

module.exports = share;

},{"../util/link":335}],331:[function(require,module,exports){
'use strict';

var kindOf = require('mout/lang/kindOf');
var map = require('mout/array/map');
var forEach = require('mout/array/forEach');

var Handlebars = require('handlebars/dist/cjs/handlebars.runtime').default;
var slice_ = Array.prototype.slice;

var slice = function slice(arr) {
  var array = arr;

  if (!array) {
    return '';
  }

  var sep;
  var begin;
  var end;
  var options;

  forEach(slice_.call(arguments, 1), function (arg) {
    switch (kindOf(arg)) {
      case 'String':
        sep = arg;
        break;

      case 'Number':
        if (begin === null) {
          begin = arg;
        } else if (end === null) {
          end = arg;
        }
        break;

      case 'Object':
        options = arg;
        break;

      default:
      // Do nothing.
    }
  });

  if (begin !== null) {
    array = array.slice(begin, end !== null ? end : array.length);
  }

  return map(array, function (item) {
    var data = Handlebars.createFrame(options.data || {});

    return options.fn(item, { data: data });
  }).join(sep || '');
};

slice.displayName = 'slice';

module.exports = slice;

},{"handlebars/dist/cjs/handlebars.runtime":608,"mout/array/forEach":659,"mout/array/map":662,"mout/lang/kindOf":681}],332:[function(require,module,exports){
'use strict';

var getType = require('../util/type');

// This needs at least the uri param to get the type:
// {{type uri}}
//
// If you pass more parameters you can use it like a matcher:
// {{#type uri "track" "album"}}YAY{{/type}}
// This will print 'YAY' for tracks or albums.

var type = function type(uri) {
  if (arguments.length <= 2) {
    // Simple get type.
    return getType(uri);
  }

  // Match type.
  var context = arguments[arguments.length - 1];
  var success = false;
  var uriType = getType(uri);

  for (var i = 1; i < arguments.length - 1; i++) {
    if (uriType === arguments[i]) {
      success = true;
      break;
    }
  }

  return success ? context.fn(this) : context.inverse(this);
};

type.displayName = 'type';

module.exports = type;

},{"../util/type":336}],333:[function(require,module,exports){
'use strict';

var loc = require('./loc');

var userReaction = function userReaction(users, totalCount, reactionType) {
  if (!totalCount) return '';
  var key = reactionType + 'Reaction' + (totalCount > 1 ? 'Multi' : 'Single');

  if (totalCount > 1) {
    return loc(key, totalCount);
  }

  if (!users.length) {
    return '';
  }

  var firstListener = users[0].name;
  return loc(key, firstListener);
};

userReaction.displayName = 'userReaction';

module.exports = userReaction;

},{"./loc":327}],334:[function(require,module,exports){
'use strict';

var kindOf = require('mout/lang/kindOf');

var Handlebars = require('handlebars/dist/cjs/handlebars.runtime').default;

// Expose the runtime to make partials easier to register.
exports.runtime = Handlebars;

exports.register = function (helpers) {
  var list = {};

  if (kindOf(helpers) === 'Function') {
    list[helpers.displayName] = helpers;
  } else {
    list = helpers;
  }

  for (var key in list) {
    if (list.hasOwnProperty(key)) {
      Handlebars.registerHelper(key, list[key]);
    }
  }

  return this;
};

},{"handlebars/dist/cjs/handlebars.runtime":608,"mout/lang/kindOf":681}],335:[function(require,module,exports){
'use strict';

module.exports = function (uri, base) {
  var matches = (uri || '').match(/^spotify:(.+)$/);

  if (!matches) {
    return uri || '';
  }

  var parts = matches.pop().replace(/:$/, '').split(/:/);
  var type = parts.shift();

  if (type === 'search') {
    parts = [parts.join(':')];
  }

  parts.unshift(base, type);

  return parts.join('/');
};

},{}],336:[function(require,module,exports){
'use strict';

module.exports = function (uri) {
  if (!uri || !uri.split) {
    return null;
  }
  var parts = uri.split(':');
  var result = null;
  switch (parts[1]) {
    case 'album':
      // spotify:album:<id>:<disc>
      if (parts.length === 4) {
        return 'disc';
      } else if (parts.length === 3) {
        return 'album';
      }
      break;

    case 'artist':
      if (parts.length === 3) {
        return 'artist';
      }
      break;

    case 'track':
      if (parts.length === 3) {
        return 'track';
      }
      break;

    case 'genre':
      if (parts.length === 3) {
        return 'genre';
      }
      break;

    case 'station':
      if (parts.length > 3) {
        return 'station';
      }
      break;

    case 'episode':
      // spotify:episode:<id>
      if (parts.length === 3) {
        return 'episode';
      }
      break;

    case 'local':
      if (parts.length === 6) {
        return 'track';
      } else if (parts.length === 4) {
        return 'album';
      } else if (parts.length === 3) {
        return 'artist';
      }
      break;

    case 'user':
      // spotify:user:<username>:collection
      if (parts.length > 3 && parts[3] === 'collection') {
        return 'collection';
      }

      // spotify:user:<username>:folder:<id>
      if (parts.length === 5 && parts[3] === 'folder') {
        return 'playlist-folder';
      }

      // spotify:user:<username>:cluster:<id>
      if (parts.length === 5 && parts[3] === 'cluster') {
        return 'cluster';
      }

      // spotify:user:<username>:<playlist:<id>|starred|toplist>
      if (parts.length > 3 && parts.length <= 5 && parts[2] !== 'facebook') {
        return 'playlist';
      } else if (parts.length === 3) {
        return 'user';
      }
      break;

    case 'internal':
      // spotify:internal:local-files
      return parts[2];

    case 'app':
      // spotify:app:collection:albums, spotify:app:radio
      return parts.slice(1).join('-');

    default:
    // Do nothing.
  }

  return result;
};

},{}],337:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = spFetch;

var _getToken = require('./get-token');

var _getWebgateHeaders = require('./get-webgate-headers');

function spFetch(input) {
  var init = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { headers: new Headers() };

  return new Promise(function (resolve, reject) {
    (0, _getToken.getToken)().then(function (_ref) {
      var accessToken = _ref.accessToken,
          tokenType = _ref.tokenType;

      var headerdKey = 'Authorization';
      var headerValue = tokenType + ' ' + accessToken;

      var url = typeof input === 'string' ? input : input.url;
      var webgateHeaders = []; // empty by default

      if (url.indexOf('https://spclient') === 0) {
        webgateHeaders = (0, _getWebgateHeaders.getWebgateHeaders)();
      }

      if (init.headers instanceof Headers) {
        init.headers.append(headerdKey, headerValue);
        webgateHeaders.forEach(function (keyVal) {
          init.headers.append(keyVal[0], keyVal[1]);
        });
      } else {
        // headers got supplied as object literal instead
        init.headers[headerdKey] = headerValue;
        webgateHeaders.forEach(function (keyVal) {
          init.headers[keyVal[0]] = keyVal[1];
        });
      }

      fetch(input, init).then(function resolveFetch() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        resolve.apply(this, args);
      }, function rejectFetch() {
        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        reject.apply(this, args);
      });
    }).catch(function (err) {
      reject(err);
    });
  });
}

},{"./get-token":338,"./get-webgate-headers":339}],338:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getToken = getToken;

var _spotifyCosmosApi = require('spotify-cosmos-api');

var _spotifyCosmosApi2 = _interopRequireDefault(_spotifyCosmosApi);

var _debug = require('debug');

var _debug2 = _interopRequireDefault(_debug);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var debug = (0, _debug2.default)('spotify-http-requests:get-token');

function getToken() {
  return new Promise(function (resolve, reject) {
    _spotifyCosmosApi2.default.resolver.get('sp://webgate/v1/token', function (err, response) {
      if (err) {
        debug('Error retrieving token from keymaster:', err);
        reject(err);
        return;
      }
      var data = response.getJSONBody();
      if (data && data.accessToken && data.tokenType) {
        debug('Retrieved access token, valid until: %s', new Date(data.expiresAtTime));
        resolve({
          accessToken: data.accessToken,
          tokenType: data.tokenType
        });
        return;
      }
      var tokenError = 'Error: missing accessToken or tokenType';
      debug(tokenError, data);
      reject(new Error(tokenError));
    });
  });
}

},{"debug":582,"spotify-cosmos-api":890}],339:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports._setHeaders = _setHeaders;
exports.getWebgateHeaders = getWebgateHeaders;
// Header keys outlined here:
// https://ghe.spotify.net/messaging/webgate/blob/master/src/main/java/com/spotify/webgate/hermes/UserInfoHeaderDecorator.java#L117-L118
var SPOTIFY_APP_VERSION_KEY = 'Spotify-App-Version';
var APP_PLATFORM_KEY = 'App-Platform';

var SPOTIFY_APP_VERSION = typeof window !== 'undefined' && window.__spotify && window.__spotify.client_version || '';
var RAW_PLATFORM = typeof window !== 'undefined' && window.navigator && window.navigator.platform || '';
var APP_PLATFORM = '';

// These values come from here:
// https://ghe.spotify.net/messaging/webgate/blob/master/src/main/java/com/spotify/webgate/hermes/UserInfoHeaderDecorator.java#L154
if (RAW_PLATFORM.indexOf('Mac') !== -1) {
  APP_PLATFORM = 'OSX';
} else if (RAW_PLATFORM.indexOf('Win') !== -1) {
  APP_PLATFORM = 'Win32';
} else if (RAW_PLATFORM.indexOf('Linux') !== -1) {
  APP_PLATFORM = 'Linux';
}

function getSpotifyAppVersion() {
  if (!SPOTIFY_APP_VERSION) {
    throw new Error('Missing Spotify App Version! Something is wrong: talk to #desktop-squad.');
  }
  return [SPOTIFY_APP_VERSION_KEY, SPOTIFY_APP_VERSION];
}

function getAppPlatform() {
  if (!APP_PLATFORM) {
    throw new Error('Missing App Platform! Something is wrong: talk to #desktop-squad.');
  }
  return [APP_PLATFORM_KEY, APP_PLATFORM];
}

var DEFAULT_HEADER_VALUE = 'default';
var DEFAULT_HEADERS = {};
DEFAULT_HEADERS[SPOTIFY_APP_VERSION_KEY] = DEFAULT_HEADER_VALUE;
DEFAULT_HEADERS[APP_PLATFORM_KEY] = DEFAULT_HEADER_VALUE;

/**
 * To only be used by unit tests when window doesnt exist
 */
function _setHeaders() {
  var headers = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_HEADERS;

  SPOTIFY_APP_VERSION = headers[SPOTIFY_APP_VERSION_KEY];
  APP_PLATFORM = headers[APP_PLATFORM_KEY];
}

/*
 * @return {Array} - [[key, value]]
 */
function getWebgateHeaders() {
  return [getSpotifyAppVersion(), getAppPlatform()];
}

},{}],340:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.httpMockHelper = exports.addWebgateHeaders = exports.addToken = exports.spFetch = undefined;

var _fetch = require('./fetch.js');

var _fetch2 = _interopRequireDefault(_fetch);

var _xhr = require('./xhr.js');

var _mockHelper = require('./util/mock-helper.js');

var httpMockHelper = _interopRequireWildcard(_mockHelper);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.spFetch = _fetch2.default;
exports.addToken = _xhr.addToken;
exports.addWebgateHeaders = _xhr.addWebgateHeaders;
exports.httpMockHelper = httpMockHelper;

},{"./fetch.js":337,"./util/mock-helper.js":341,"./xhr.js":342}],341:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mockTokenRequest = mockTokenRequest;
exports.restoreTokenRequest = restoreTokenRequest;

var _getToken = require('../get-token');

var getTokenSingleton = _interopRequireWildcard(_getToken);

var _getWebgateHeaders = require('../get-webgate-headers');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var originalGetToken = getTokenSingleton.getToken;

var proxiedGetToken = function get() {
  return Promise.resolve({
    'accessToken': 'at',
    'tokenType': 'tt'
  });
};

function mockTokenRequest() {
  var get = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : proxiedGetToken;

  (0, _getWebgateHeaders._setHeaders)();
  getTokenSingleton.getToken = get;
  getTokenSingleton.restore = restoreTokenRequest;
  return getTokenSingleton;
}

function restoreTokenRequest() {
  getTokenSingleton.get = originalGetToken;
}

},{"../get-token":338,"../get-webgate-headers":339}],342:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addToken = addToken;
exports.addWebgateHeaders = addWebgateHeaders;

var _getToken = require('./get-token');

var _getWebgateHeaders = require('./get-webgate-headers');

function addToken(xhr) {
  if (!xhr || !xhr.setRequestHeader) {
    throw new Error('Expected argument to be an XMLHttpRequest');
  }
  return (0, _getToken.getToken)().then(function (_ref) {
    var accessToken = _ref.accessToken,
        tokenType = _ref.tokenType;

    xhr.setRequestHeader('Authorization', tokenType + ' ' + accessToken);
    return xhr;
  });
}

function addWebgateHeaders(xhr) {
  if (!xhr || !xhr.setRequestHeader) {
    throw new Error('Expected argument to be an XMLHttpRequest');
  }
  (0, _getWebgateHeaders.getWebgateHeaders)().forEach(function (keyVal) {
    xhr.setRequestHeader(keyVal[0], keyVal[1]);
  });
  return xhr;
}

},{"./get-token":338,"./get-webgate-headers":339}],343:[function(require,module,exports){
'use strict';

var types = require('bfs-km-types');

var ConfigurationState = require('./ConfigurationState.js');
var Creator = require('./Creator.js');
var Environment = require('./Environment.js');

var LOCAL_STORAGE_KEY = 'configuration-v1';

/**
 * A class that is responsible for maintaining the application configuration.
 * The class maintains three layers of configurations which are default, client
 * and preferences. The default layer contains values found in the config such
 * as application name and version. The client layer contains values found in
 * the client such as user attributes while the preferences layer contains
 * overridden values and settings. Each layer is allowed to override the values
 * set by a previous layer.
 */
var Configuration = function Configuration(environment, creator, configJson) {
  types.check.type(environment, Environment);
  types.check.type(creator, Creator);
  types.check.object(configJson);

  this.environment = environment;
  this.creator = creator;
  this.configJson = types.clone(configJson);
};

types.define(Configuration);

/**
 * A method that fetches the stored values from local storage. The given
 * callback will be called using the given caller and with the parsed json
 * object as the only argument.
 */
Configuration.prototype.fetchFromLocalStorage = function (callback, caller) {
  types.check.function(callback);

  this.environment.fetchFromSpotifyLocalStorage(LOCAL_STORAGE_KEY, callback, caller);
};

/**
 * A method that returns the current state. The given callback will be called
 * using the given caller and with an instance of the current state as the only
 * argument.
 */
Configuration.prototype.getCurrentState = function (callback, caller) {
  var configurationState;

  types.check.function(callback);

  configurationState = this.getDefaultState();

  this.environment.queryClientSessionState(function (clientVersion, userCatalogue, userCountry, userEmployee, userLanguage, userUsername) {
    if (types.is.string(clientVersion)) {
      configurationState.setString('client/version', clientVersion);
    }

    if (types.is.string(userCatalogue)) {
      configurationState.setString('user/catalogue', userCatalogue);
    }

    if (types.is.string(userCountry)) {
      configurationState.setString('user/country', userCountry);
    }

    if (types.is.boolean(userEmployee)) {
      configurationState.setBoolean('user/employee', userEmployee);
    }

    if (types.is.string(userLanguage)) {
      configurationState.setString('user/language', userLanguage);
    }

    if (types.is.string(userUsername)) {
      configurationState.setString('user/username', userUsername);
    }

    this.fetchFromLocalStorage(function (json) {
      var key;

      for (key in json) {
        if (types.is.boolean(json[key])) {
          configurationState.setBoolean(key, json[key]);

          continue;
        }

        if (types.is.number(json[key])) {
          configurationState.setNumber(key, json[key]);

          continue;
        }

        if (types.is.string(json[key])) {
          configurationState.setString(key, json[key]);

          continue;
        }
      }

      callback.call(caller, configurationState);
    }, this);
  }, this);
};

/**
 * A method that returns the default state. This is usable before the bridge has
 * been initialized.
 */
Configuration.prototype.getDefaultState = function () {
  var configurationState;
  var key;

  configurationState = this.creator.create(ConfigurationState, []);

  for (key in this.configJson) {
    if (types.is.boolean(this.configJson[key])) {
      configurationState.setBoolean(key, this.configJson[key]);

      continue;
    }

    if (types.is.number(this.configJson[key])) {
      configurationState.setNumber(key, this.configJson[key]);

      continue;
    }

    if (types.is.string(this.configJson[key])) {
      configurationState.setString(key, this.configJson[key]);

      continue;
    }
  }

  return configurationState;
};

/**
 * A method that removes the stored value for the given key.
 */
Configuration.prototype.removeValue = function (key) {
  types.check.string(key);

  this.fetchFromLocalStorage(function (json) {
    delete json[key];

    this.storeInLocalStorage(json);
  }, this);
};

/**
 * A method that stores the given json in local storage.
 */
Configuration.prototype.storeInLocalStorage = function (json) {
  types.check.object(json);

  this.environment.storeInSpotifyLocalStorage(LOCAL_STORAGE_KEY, json);
};

/**
 * A method that stores the given value for the given key.
 */
Configuration.prototype.storeValue = function (key, value) {
  types.check.string(key);

  this.fetchFromLocalStorage(function (json) {
    json[key] = value;

    this.storeInLocalStorage(json);
  }, this);
};

module.exports = Configuration;

},{"./ConfigurationState.js":344,"./Creator.js":345,"./Environment.js":347,"bfs-km-types":570}],344:[function(require,module,exports){
(function (global){
'use strict';

var types = require('bfs-km-types');

/**
 * A class that is responsible for storing a snapshot of the configuration.
 * Instances of the class can be produced by the configuration as needed.
 */
var ConfigurationState = function ConfigurationState() {
  this.values = {};
};

types.define(ConfigurationState);

/**
 * A method that returns the stored value for the given key if the value is a
 * boolean. Throws if there is no boolean value stored for the given key.
 */
ConfigurationState.prototype.getBoolean = function (key) {
  var value;

  types.check.string(key);

  value = this.values[key];

  if (!types.is.boolean(value)) {
    throw new global.Error('No boolean value for key "' + key + '"!');
  }

  return value;
};

/**
 * A method that returns the stored value for the given key if the value is a
 * boolean. If no boolean value is stored, the given fallback will be returned.
 */
ConfigurationState.prototype.getBooleanOr = function (key, fallback) {
  var value;

  types.check.string(key);
  types.check.boolean(fallback);

  value = this.values[key];

  if (types.is.boolean(value)) {
    return value;
  }

  return fallback;
};

/**
 * A method that returns the stored value for the given key if the value is a
 * number. Throws if there is no number value stored for the given key.
 */
ConfigurationState.prototype.getNumber = function (key) {
  var value;

  types.check.string(key);

  value = this.values[key];

  if (!types.is.number(value)) {
    throw new global.Error('No number value for key "' + key + '"!');
  }

  return value;
};

/**
 * A method that returns the stored value for the given key if the value is a
 * number. If no number value is stored, the given fallback will be returned.
 */
ConfigurationState.prototype.getNumberOr = function (key, fallback) {
  var value;

  types.check.string(key);
  types.check.number(fallback);

  value = this.values[key];

  if (types.is.number(value)) {
    return value;
  }

  return fallback;
};

/**
 * A method that returns the stored value for the given key if the value is a
 * string. Throws if there is no string value stored for the given key.
 */
ConfigurationState.prototype.getString = function (key) {
  var value;

  types.check.string(key);

  value = this.values[key];

  if (!types.is.string(value)) {
    throw new global.Error('No string value for key "' + key + '"!');
  }

  return value;
};

/**
 * A method that returns the stored value for the given key if the value is a
 * string. If no string value is stored, the given fallback will be returned.
 */
ConfigurationState.prototype.getStringOr = function (key, fallback) {
  var value;

  types.check.string(key);
  types.check.string(fallback);

  value = this.values[key];

  if (types.is.string(value)) {
    return value;
  }

  return fallback;
};

/**
 * A method that checks if there is a boolean value stored for the given key.
 */
ConfigurationState.prototype.hasBoolean = function (key) {
  types.check.string(key);

  return types.is.boolean(this.values[key]);
};

/**
 * A method that checks if there is a number value stored for the given key.
 */
ConfigurationState.prototype.hasNumber = function (key) {
  types.check.string(key);

  return types.is.number(this.values[key]);
};

/**
 * A method that checks if there is a string value stored for the given key.
 */
ConfigurationState.prototype.hasString = function (key) {
  types.check.string(key);

  return types.is.string(this.values[key]);
};

/**
 * A method that stores the given boolean value for the given key.
 */
ConfigurationState.prototype.setBoolean = function (key, value) {
  types.check.string(key);
  types.check.boolean(value);

  this.values[key] = value;
};

/**
 * A method that stores the given number value for the given key.
 */
ConfigurationState.prototype.setNumber = function (key, value) {
  types.check.string(key);
  types.check.number(value);

  this.values[key] = value;
};

/**
 * A method that stores the given string value for the given key.
 */
ConfigurationState.prototype.setString = function (key, value) {
  types.check.string(key);
  types.check.string(value);

  this.values[key] = value;
};

module.exports = ConfigurationState;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"bfs-km-types":570}],345:[function(require,module,exports){
(function (global){
'use strict';

var types = require('bfs-km-types');

/**
 * A class that is responsible for creating instances of other classes during
 * the application lifecycle. This is very useful for unit testing since it aids
 * in isolating specific classes by providing a hook for injecting mock
 * implementations.
 */
var Creator = function Creator() {};

types.define(Creator);

/**
 * A method that creates an instance of the given type. The given args will be
 * passed to the type constructor.
 */
Creator.prototype.create = function (type, args) {
  var instance;

  types.check.function(type);
  types.check.array(args);

  if (args.length === 0) {
    instance = new type(); // eslint-disable-line new-cap
  } else {
    instance = global.Object.create(type.prototype);

    type.apply(instance, args);
  }

  return instance;
};

module.exports = Creator;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"bfs-km-types":570}],346:[function(require,module,exports){
(function (global){
'use strict';

var types = require('bfs-km-types');
var rectIntersect = require('./utils/rectIntersect.js');

/**
 * A class that is responsible for turning html strings into html document
 * nodes. The class provides methods for locating html elements using css
 * selectors as well as for building html documents.
 */
var DocumentFragment = function DocumentFragment(string) {
  var storageElement;

  types.check.string(string);

  storageElement = global.document.createElement('div');

  storageElement.innerHTML = string;

  this.containerElement = null;
  this.storageElement = storageElement;
  this.rootElements = global.Array.prototype.slice.call(storageElement.children);
};

types.define(DocumentFragment);

/**
 * A method that attaches all root nodes to the given container element.
 */
DocumentFragment.prototype.attach = function (containerElement) {
  var i;

  types.check.type(containerElement, global.window.Element);

  this.detach();

  this.containerElement = containerElement;

  for (i = 0; i < this.rootElements.length; i++) {
    this.containerElement.appendChild(this.rootElements[i]);
  }
};

/**
 * A method that cleans up the instance in a way that should aid the garbage
 * collector.
 */
DocumentFragment.prototype.destroy = function () {
  this.detach();

  this.containerElement = null;
  this.storageElement = null;
  this.rootElements = null;
};

/**
 * A method that detaches all root nodes from the container element of the
 * document fragment.
 */
DocumentFragment.prototype.detach = function () {
  var i;

  if (this.containerElement !== null) {
    for (i = 0; i < this.rootElements.length; i++) {
      this.storageElement.appendChild(this.rootElements[i]);
    }

    this.containerElement = null;
  }
};

/**
 * A method that returns an element matching the given selector or null if no
 * element matches. This method only works when the document fragment is in a
 * detached state since the method shouldn't return elements belonging to other
 * views.
 */
DocumentFragment.prototype.find = function (selector) {
  types.check.string(selector);

  return this.storageElement.querySelector(selector);
};

/**
 * A method that determines if the document fragment is attached.
 */
DocumentFragment.prototype.isAttached = function () {
  return this.containerElement !== null;
};

/**
 * A method that determines if the document fragment is partially visible within
 * the window.
 */
DocumentFragment.prototype.isPartiallyVisible = function () {
  function isInvisible(style) {
    return style.opacity === '0' || style.visibility === 'hidden';
  }

  function isVisibleInParent(elementRect, elementStyle, parent) {
    if (!parent) {
      return false;
    }

    if (parent === global.document.body) {
      return true;
    }

    var parentRect = parent.getBoundingClientRect();
    var parentStyle = window.getComputedStyle(parent);

    if (isInvisible(parentStyle)) {
      return false;
    }

    if (parentStyle.overflow === 'hidden' && !rectIntersect(elementRect, parentRect)) {
      return false;
    }

    return isVisibleInParent(elementRect, elementStyle, parent.parentNode);
  }

  var i;
  var element;
  var elementRect;
  var elementStyle;
  var viewportWidth = global.window.innerWidth;
  var viewportHeight = global.window.innerHeight;
  var windowRect = {
    left: 0,
    right: viewportWidth,
    top: 0,
    bottom: viewportHeight,
    width: viewportWidth,
    height: viewportHeight
  };

  for (i = 0; i < this.rootElements.length; i++) {
    element = this.rootElements[i];
    elementRect = element.getBoundingClientRect();
    elementStyle = window.getComputedStyle(element);

    if (isInvisible(elementStyle)) {
      return false;
    }

    if (!rectIntersect(elementRect, windowRect)) {
      continue;
    }

    if (isVisibleInParent(elementRect, elementStyle, element.parentNode)) {
      return true;
    }
  }

  return false;
};

/**
 * A method that returns all elements matching the given selector or an empty
 * array if no elements match. This method only works when the document fragment
 * is in a detached state since the method shouldn't return elements belonging
 * to other views.
 */
DocumentFragment.prototype.query = function (selector) {
  var elements;

  types.check.string(selector);

  elements = this.storageElement.querySelectorAll(selector);

  return global.Array.prototype.slice.call(elements);
};

module.exports = DocumentFragment;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./utils/rectIntersect.js":372,"bfs-km-types":570}],347:[function(require,module,exports){
(function (global){
'use strict';

var _pageIdentifiers = require('../../spotify-navigation/page-identifiers.js');

var types = require('bfs-km-types');


/**
 * A class that is responsible for handling interactions with the Spotify
 * environment. This class encapsulates shared Spotify libraries in a way that
 * is very useful for unit testing.
 */
var Environment = function Environment() {
  this.globalSpotify = global.__spotify;
  this.hpto = require('../../ad-formats').HptoAd;
  this.spotifyCosmosApi = require('spotify-cosmos-api');
  this.uiImpression5 = require('../../spotify-logger/messages/UIImpression5');
  this.uiInteraction5 = require('../../spotify-logger/messages/UIInteraction5');
  this.spotifyEvents = require('../../spotify-events');
  this.spotifyGlueCatStrings = require('../../glue/strings/index.js');
  this.spotifyGlueCatGrid = require('../../glue').gridOverlay;
  this.spotifyHandlebars = require('../../spotify-handlebars');
  this.spotifyHandlebarsHelpers = require('../../spotify-handlebars/helpers/index.js');
  this.spotifyLive = require('../../spotify-live');
  this.spotifyLiveModels = require('../../spotify-live-models');
  this.spotifyLocales = require('../../spotify-locales');
  this.spotifyLocalStorage = require('../../spotify-local-storage');
};

types.define(Environment);

/**
 * A method that attaches the spotify events.
 */
Environment.prototype.attachSpotifyEvents = function () {
  this.spotifyEvents.attach();
};

/**
 * A method that creates a hpto and puts it in the given hpto element. The two
 * listeners will be triggered when the hpto is rendered and hidden,
 * respectively.
 */
Environment.prototype.createHomePageTakeOverFor = function (hptoElement, onHptoRendered, onHptoHidden) {
  types.check.type(hptoElement, global.window.Element);
  types.check.function(onHptoRendered);
  types.check.function(onHptoHidden);

  this.hpto.subscribeToRender(onHptoRendered);
  this.hpto.subscribeToHide(onHptoHidden);
  this.hpto.init(hptoElement);
};

/**
 * A method that destroys the hpto and removes the two listeners.
 */
Environment.prototype.destroyHomePageTakeOver = function (onHptoRendered, onHptoHidden) {
  types.check.function(onHptoRendered);
  types.check.function(onHptoHidden);

  this.hpto.unsubscribeToRender(onHptoRendered);
  this.hpto.unsubscribeToHide(onHptoHidden);
};

/**
 * A method that fetches the json stored in spotify local storage for the given
 * key. The given callback will be called with the given caller and the stored
 * json.
 */
Environment.prototype.fetchFromSpotifyLocalStorage = function (key, callback, caller) {
  types.check.string(key);
  types.check.function(callback);

  var json;
  var string = this.spotifyLocalStorage.get(key);

  try {
    json = global.JSON.parse(string);
  } catch (exception) {
    // continue regardless of error
  }

  if (!types.is.object(json)) {
    json = {};
  }

  callback.call(caller, json);
};

/**
 * A method that checks if the given locale is supported by the spotify-locales
 * library.
 */
Environment.prototype.isSupportedLocale = function (locale) {
  types.check.string(locale);

  return this.spotifyLocales.all().indexOf(locale) !== -1;
};

/**
 * A method that starts to listen for the GLUE grid overlay, that can be
 * triggered from a menu item or keyboard shortcut.
 */
Environment.prototype.listenForOverlayGrid = function () {
  this.spotifyGlueCatGrid.listen();
};

/**
 * A method that listens for application arguments changes. When the arguments
 * change, the given callback will be called with the given caller and an array
 * of application arguments.
 */
Environment.prototype.listenForApplicationArgumentsChanges = function (callback, caller) {
  types.check.function(callback);

  this.spotifyLive('spotify:application').on('update', function (json) {
    if (types.conforms(json, { arguments: '' })) {
      callback.call(caller, json.arguments.split(':'));
    }
  });
};

/**
 * A method that listens the session online status.
 */
Environment.prototype.listenForSessionOnlineStatusChanges = function (callback, caller) {
  types.check.function(callback);

  var client = this.spotifyLive('spotify:client');

  client.query('session(online)', function (error, data) {
    client.get('session').on('update', function (json) {
      if (types.conforms(json, { online: false })) {
        callback.call(caller, json.online);
      }
    });
  });
};

Environment.prototype.listenForAppActiveChanges = function (callback, caller) {
  types.check.function(callback);

  this.spotifyLive('spotify:application').on('update', function (json) {
    if (types.conforms(json, { active: true })) {
      callback.call(caller, json.active);
    }
  });
};

/**
 * A method that logs a UIImpression5 message from the given json. The message
 * will only be sent to the logging endpoint if the log in console parameter is
 * false.
 */
Environment.prototype.logUIImpression5 = function (json, logInConsole) {
  var message = {};

  types.check.object(json);
  types.check.boolean(logInConsole);

  if (types.is.string(json.request_id)) {
    message.request_id = json.request_id;
  }

  if (types.is.string(json.feature_id)) {
    message.feature_id = json.feature_id;
  }

  if (types.is.string(json.section_id)) {
    message.section_id = json.section_id;
  }

  if (types.is.string(json.pageuri)) {
    message.pageuri = json.pageuri;
  }

  if (types.is.number(json.item_index)) {
    message.item_index = json.item_index;
  }

  if (types.is.string(json.target_uri)) {
    message.target_uri = json.target_uri;
  }

  if (types.is.string(json.impression_type)) {
    message.impression_type = json.impression_type;
  }

  if (types.is.string(json.render_type)) {
    message.render_type = json.render_type;
  }

  message.timestamp = Date.now();

  if (logInConsole) {
    console.log(global.JSON.stringify(message, null, 2));
  } else {
    this.uiImpression5.log(message);
  }
};

/**
 * A method that logs a UIInteraction5 message from the given json. The message
 * will only be sent to the logging endpoint if the log in console parameter is
 * false.
 */
Environment.prototype.logUIInteraction5 = function (json, logInConsole) {
  var message = {};

  types.check.object(json);
  types.check.boolean(logInConsole);

  if (types.is.string(json.request_id)) {
    message.request_id = json.request_id;
  }

  if (types.is.string(json.pageuri)) {
    message.pageuri = json.pageuri;
  }

  if (types.is.string(json.feature_id)) {
    message.feature_id = json.feature_id;
  }

  if (types.is.string(json.section_id)) {
    message.section_id = json.section_id;
  }

  if (types.is.number(json.item_index)) {
    message.item_index = json.item_index;
  }

  if (types.is.string(json.target_uri)) {
    message.target_uri = json.target_uri;
  }

  if (types.is.string(json.interaction_type)) {
    message.interaction_type = json.interaction_type;
  }

  if (types.is.string(json.user_intent)) {
    message.user_intent = json.user_intent;
  }

  message.timestamp = Date.now();

  if (logInConsole) {
    console.log(global.JSON.stringify(message, null, 2));
  } else {
    this.uiInteraction5.log(message);
  }
};

/**
 * A method that make a tracklist live model from the given model for the given
 * uri.
 */
Environment.prototype.makeTracklistLiveModel = function (uri, model) {
  types.check.string(uri);
  types.check.object(model);

  if (!this.spotifyLive.has(uri)) {
    this.spotifyLive(model);
  } else {
    this.spotifyLive(uri).update(model);
  }
};

/**
 * A method that adds any object with a uri to the live cache.
 */
Environment.prototype.addToLiveCache = function (model) {
  types.check.object(model);
  this.spotifyLive(model);
};

/**
 * A method that queries the client to know if the application is online.
 */
Environment.prototype.querySessionOnline = function (callback, caller) {
  this.spotifyLive('spotify:client').query('session(online)', function (error, json) {
    if (types.conforms(json, { session: { online: true } })) {
      callback.call(caller, json.session.online);
    }
  });
};

/**
 * A method that queries the application arguments. The given callback will be
 * called with the given caller and an array of application arguments.
 */
Environment.prototype.queryApplicationArguments = function (callback, caller) {
  types.check.function(callback);

  this.spotifyLive('spotify:application').query('arguments', function (error, json) {
    if (types.conforms(json, { arguments: '' })) {
      callback.call(caller, json.arguments.split(':'));
    }
  });
};

/**
 * A method that queries the client session state. The given callback will be
 * called with the given caller and a clientVersion (nullable), userCatalogue
 * (nullable), userCountry (nullable), userEmployee (nullable), userLanguage
 * (nullable) and userUsername (nullable).
 */
Environment.prototype.queryClientSessionState = function (callback, caller) {
  var query;

  types.check.function(callback);

  query = 'currentUser(username), session(country, employee, language)';

  this.spotifyLive('spotify:client').query(query, function (error, json) {
    var clientVersion;
    var userCatalogue;
    var userCountry;
    var userEmployee;
    var userLanguage;
    var userUsername;

    if (types.conforms(this.globalSpotify, { client_version: '' })) {
      clientVersion = this.globalSpotify.client_version;
    } else {
      clientVersion = null;
    }

    if (types.conforms(this.globalSpotify, { product_state: { catalogue: '' } })) {
      userCatalogue = this.globalSpotify.product_state.catalogue;
    } else {
      userCatalogue = null;
    }

    if (types.conforms(json, { session: { country: '' } })) {
      userCountry = json.session.country;
    } else {
      userCountry = null;
    }

    if (types.conforms(json, { session: { employee: false } })) {
      userEmployee = json.session.employee;
    } else {
      userEmployee = null;
    }

    if (types.conforms(json, { session: { language: '' } })) {
      userLanguage = json.session.language;
    } else {
      userLanguage = null;
    }

    if (types.conforms(json, { currentUser: { username: '' } })) {
      userUsername = json.currentUser.username;
    } else {
      userUsername = null;
    }

    callback.call(caller, clientVersion, userCatalogue, userCountry, userEmployee, userLanguage, userUsername);
  }.bind(this));
};

/**
 * A method that registers the spotify handlebars helpers for the given user
 * language.
 */
Environment.prototype.registerSpotifyHandlebarsHelpersFor = function (userLanguage) {
  types.check.string(userLanguage);

  this.spotifyHandlebarsHelpers.loc.register(this.spotifyGlueCatStrings[userLanguage]);
  this.spotifyHandlebarsHelpers.loc.setLocale(userLanguage);
  this.spotifyHandlebarsHelpers.numeral.setLocale(userLanguage);

  this.spotifyHandlebars.register(this.spotifyHandlebarsHelpers);
};

/**
 * A method that registers the spotify live models.
 */
Environment.prototype.registerSpotifyLiveModels = function () {
  this.spotifyLiveModels.register();
};

/**
 * A method that resolves a cosmos cosmos api get request for the given uri. The
 * given callback will be called with the given caller and a json response
 * (nullable).
 */
Environment.prototype.resolveSpotifyCosmosApiGetRequest = function (uri, callback, caller) {
  types.check.string(uri);
  types.check.function(callback);

  this.spotifyCosmosApi.resolver.get(uri, function (error, response) {
    var json;

    if (response) {
      json = response.getJSONBody();
    } else {
      json = null;
    }

    callback.call(caller, json);
  });
};

/**
 * A method that stores the given json for the given key in spotify local
 * storage.
 */
Environment.prototype.storeInSpotifyLocalStorage = function (key, json) {
  types.check.string(key);
  types.check.object(json);

  this.spotifyLocalStorage.set(key, global.JSON.stringify(json));
};

/**
 * A method that updates spotify events in the given container element.
 */
Environment.prototype.updateSpotifyEventsIn = function (containerElement) {
  types.check.type(containerElement, global.window.Element);

  this.spotifyEvents.update(containerElement);
};

/**
 * Notifies the outside world that this app is loaded though a cosmos request
 */
Environment.prototype.sendViewLoaded = function (appName) {
  this.queryApplicationArguments(function (appArgs) {
    // Send message to assure that View Load metrics are sent
    var pageId = (0, _pageIdentifiers.getPageIdFromAppArguments)(appName, appArgs);

    window.parent.postMessage({
      type: 'notify_loaded',
      pageId: pageId,
      now: window.parent.performance.now()
    }, '*');
    // Send message to assure that App Startup metrics are sent
    this.spotifyCosmosApi.resolver.post({
      url: 'sp://messages/v1/container/control',
      body: {
        'name': appName,
        'type': 'view_loaded'
      }
    });
  }, this);
};

module.exports = Environment;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../ad-formats":72,"../../glue":148,"../../glue/strings/index.js":151,"../../spotify-events":279,"../../spotify-handlebars":334,"../../spotify-handlebars/helpers/index.js":324,"../../spotify-live":512,"../../spotify-live-models":477,"../../spotify-local-storage":517,"../../spotify-locales":518,"../../spotify-logger/messages/UIImpression5":528,"../../spotify-logger/messages/UIInteraction5":529,"../../spotify-navigation/page-identifiers.js":548,"bfs-km-types":570,"spotify-cosmos-api":890}],348:[function(require,module,exports){
'use strict';

var types = require('bfs-km-types');

var EventListener = require('./EventListener.js');

/**
 * A class that is responsible for routing events between the different
 * components of the framework in an anonymous fashion. A component may register
 * its interest in any number of different event types. When another component
 * dispatches an event, all components which have registered their interest in
 * the specific event type will get notified. The dispatching component can
 * choose to include event data as json.
 */
var EventDispatcher = function EventDispatcher() {
  this.eventListeners = {};
};

types.define(EventDispatcher);

/**
 * A method that dispatches an event of the given type with the given json.
 */
EventDispatcher.prototype.dispatch = function (type, json) {
  var i;
  var eventListeners;

  types.check.string(type);
  types.check.object(json);

  if (type in this.eventListeners) {
    eventListeners = this.eventListeners[type].slice();

    for (i = 0; i < eventListeners.length; i++) {
      eventListeners[i].trigger(json);
    }
  }
};

/**
 * A method that registers the given event listener with the event dispatcher.
 */
EventDispatcher.prototype.register = function (eventListener) {
  var type;

  types.check.type(eventListener, EventListener);

  type = eventListener.getType();

  if (!(type in this.eventListeners)) {
    this.eventListeners[type] = [];
  }

  if (this.eventListeners[type].indexOf(eventListener) === -1) {
    this.eventListeners[type].push(eventListener);
  }
};

/**
 * A method that unregisters the given event listener with the event dispatcher.
 */
EventDispatcher.prototype.unregister = function (eventListener) {
  var type;
  var index;

  types.check.type(eventListener, EventListener);

  type = eventListener.getType();

  if (type in this.eventListeners) {
    index = this.eventListeners[type].indexOf(eventListener);

    if (index !== -1) {
      this.eventListeners[type].splice(index, 1);
    }

    if (this.eventListeners[type].length === 0) {
      delete this.eventListeners[type];
    }
  }
};

module.exports = EventDispatcher;

},{"./EventListener.js":349,"bfs-km-types":570}],349:[function(require,module,exports){
'use strict';

var types = require('bfs-km-types');

/**
 * A class that is responsible for containing the data that comprises an event
 * listener. This class wraps a callback function, a caller and the event type
 * for which to trigger the listener.
 */
var EventListener = function EventListener(type, callback, caller) {
  types.check.string(type);
  types.check.function(callback);

  this.type = type;
  this.callback = callback;
  this.caller = caller;
};

types.define(EventListener);

/**
 * A method that returns the callback of the event listener.
 */
EventListener.prototype.getCallback = function () {
  return this.callback;
};

/**
 * A method that returns the caller of the event listener.
 */
EventListener.prototype.getCaller = function () {
  return this.caller;
};

/**
 * A method that returns the type of the event listener.
 */
EventListener.prototype.getType = function () {
  return this.type;
};

/**
 * A method that triggers the event listener with the given json.
 */
EventListener.prototype.trigger = function (json) {
  types.check.object(json);

  this.callback.call(this.caller, json);
};

module.exports = EventListener;

},{"bfs-km-types":570}],350:[function(require,module,exports){
(function (global){
'use strict';

var types = require('bfs-km-types');

/**
 * A class that is responsible for containing the data that comprises an
 * interaction handler. Interactions are user actions that occur on html
 * elements within a view component. This class wraps a callback function, a
 * caller, the interaction type for which to trigger the handler and the element
 * on which the handler is attached.
 */
var InteractionHandler = function InteractionHandler(element, type, callback, caller) {
  var wrapped;

  types.check.type(element, global.window.Element);
  types.check.string(type);
  types.check.function(callback);

  wrapped = function wrapped(event) {
    this.callback.call(this.caller, this.element);
  };

  this.element = element;
  this.type = type;
  this.callback = callback;
  this.caller = caller;
  this.wrapped = wrapped.bind(this);
};

types.define(InteractionHandler);

/**
 * A method that attaches the interaction handler to the element.
 */
InteractionHandler.prototype.attach = function () {
  this.element.addEventListener(this.type, this.wrapped);
};

/**
 * A method that detaches the interaction handler from the element.
 */
InteractionHandler.prototype.detach = function () {
  this.element.removeEventListener(this.type, this.wrapped);
};

module.exports = InteractionHandler;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"bfs-km-types":570}],351:[function(require,module,exports){
'use strict';

var types = require('bfs-km-types');

var Service = require('./services/Service.js');

/**
 * A class that is responsible for delegating service requests to the services
 * registered with the service router. When a component makes a service request,
 * the service router asks each of the registered services to handle the
 * request. The first service that accepts the request is tasked with handling
 * the request.
 */
var ServiceRouter = function ServiceRouter() {
  this.services = [];
};

types.define(ServiceRouter);

/**
 * A method that registers a service with the service router.
 */
ServiceRouter.prototype.register = function (service) {
  types.check.type(service, Service);

  if (this.services.indexOf(service) === -1) {
    this.services.push(service);
  }
};

/**
 * A method that attempts to find a suitable service providing a view tree for
 * the given uri.
 */
ServiceRouter.prototype.request = function (uri, callback, caller) {
  var i;
  var service;

  types.check.string(uri);
  types.check.function(callback);

  for (i = 0; i < this.services.length; i++) {
    service = this.services[i];

    if (service.responds(uri)) {
      service.request(uri, callback, caller);

      return;
    }
  }

  callback.call(caller, null);
};

module.exports = ServiceRouter;

},{"./services/Service.js":369,"bfs-km-types":570}],352:[function(require,module,exports){
'use strict';

var types = require('bfs-km-types');

var Configuration = require('./Configuration.js');
var Creator = require('./Creator.js');
var Environment = require('./Environment.js');
var EventDispatcher = require('./EventDispatcher.js');
var ServiceRouter = require('./ServiceRouter.js');
var View = require('./views/View.js');

/**
 * A class that is responsible for parsing backend json responses into view
 * component trees. Unknown view components in the json response get discarded
 * (and by that also their children). The same is true if a view component
 * rejects the json model which it may choose to do if required data is missing
 * or malformed.
 */
var ViewParser = function ViewParser(eventDispatcher, serviceRouter, configuration, environment, creator) {
  types.check.type(eventDispatcher, EventDispatcher);
  types.check.type(serviceRouter, ServiceRouter);
  types.check.type(configuration, Configuration);
  types.check.type(environment, Environment);
  types.check.type(creator, Creator);

  this.eventDispatcher = eventDispatcher;
  this.serviceRouter = serviceRouter;
  this.configuration = configuration;
  this.environment = environment;
  this.creator = creator;
  this.viewClasses = {};
};

types.define(ViewParser);

/**
 * A method that attempts to create a view from the given id and the given
 * model.
 */
ViewParser.prototype.create = function (id, model) {
  var view;
  var viewClass;

  types.check.string(id);
  types.check.object(model);

  view = null;

  if (id in this.viewClasses) {
    viewClass = this.viewClasses[id];

    try {
      view = this.creator.create(viewClass, [model, this.eventDispatcher, this.serviceRouter, this.configuration, this.environment]);
    } catch (error) {
      console.warn('View construction failed for view with type "' + id + '"! Error:', error);
    }
  } else {
    console.warn('No view class registered for type "' + id + '"!');
  }

  return view;
};

/**
 * A method that recursively parses the given json into a view tree.
 */
ViewParser.prototype.parse = function (json) {
  var view;
  var i;
  var child;

  view = null;

  if (types.conforms(json, { id: '', model: {}, 'views?': [] })) {
    // eslint-disable-line quote-props
    view = this.create(json.id, json.model);

    if (view !== null) {
      if ('views' in json) {
        for (i = 0; i < json.views.length; i++) {
          child = this.parse(json.views[i]);

          if (child !== null) {
            view.addChild(child);
          }
        }
      }
    }
  }

  return view;
};

/**
 * A method that registers a view class for the given id with the view parser.
 */
ViewParser.prototype.register = function (id, viewClass) {
  types.check.string(id);
  types.check.type(viewClass.prototype, View);

  this.viewClasses[id] = viewClass;
};

module.exports = ViewParser;

},{"./Configuration.js":343,"./Creator.js":345,"./Environment.js":347,"./EventDispatcher.js":348,"./ServiceRouter.js":351,"./views/View.js":373,"bfs-km-types":570}],353:[function(require,module,exports){
(function (global){
'use strict';

var types = require('bfs-km-types');

/**
 * An interface that is responsible for providing the data transport of a
 * backend request. Implementations of this interface are required to provide a
 * deserialized json response (or null to indicate an error) and may choose to
 * do so in an asynchronous fashion.
 */
var Backend = function Backend() {};

types.define(Backend);

/**
 * An abstract method that makes a request to the backend. If the request
 * succeeds, the callback will be called with the json response. If the request
 * fails or times out, the callback will be called with null.
 */
Backend.prototype.request = function (uri, callback, caller) {
  types.check.string(uri);
  types.check.function(callback);

  throw new global.Error('Abstract method called!');
};

module.exports = Backend;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"bfs-km-types":570}],354:[function(require,module,exports){
'use strict';

var types = require('bfs-km-types');

var Backend = require('./Backend.js');
var Environment = require('../Environment.js');

/**
 * An implementation of the backend interface that uses cosmos for data
 * transport. This is the standard backend implementation that should be used
 * for normal users in production.
 */
var Cosmos = function Cosmos(environment) {
  types.check.type(environment, Environment);

  Backend.call(this);

  this.environment = environment;
};

types.extend(Cosmos, Backend);

/**
 * A method that makes a request to the backend. If the request succeeds, the
 * callback will be called with the json response. If the request fails or times
 * out, the callback will be called with null.
 */
Cosmos.prototype.request = function (uri, callback, caller) {
  types.check.string(uri);
  types.check.function(callback);

  this.environment.resolveSpotifyCosmosApiGetRequest(uri, callback, caller);
};

module.exports = Cosmos;

},{"../Environment.js":347,"./Backend.js":353,"bfs-km-types":570}],355:[function(require,module,exports){
(function (global){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * A class that provides the current date. The purpose of this class is to
 * provide a class that can be stubbed in tests and by that make the tests
 * deterministic. This way, the global context will not be mutated and no tear
 * down is required.
 */
var DateProvider = function () {
  function DateProvider() {
    _classCallCheck(this, DateProvider);
  }

  _createClass(DateProvider, [{
    key: "getDate",
    value: function getDate() {
      return new global.Date();
    }
  }]);

  return DateProvider;
}();

exports.default = DateProvider;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],356:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _bfsKmTypes = require('bfs-km-types');

var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

var _index = require('./content_providers/index.js');

var _index2 = _interopRequireDefault(_index);

var _index3 = require('./hub_apps/index.js');

var _index4 = _interopRequireDefault(_index3);

var _index5 = require('./uri_builders/index.js');

var _index6 = _interopRequireDefault(_index5);

var _index7 = require('../views/index.js');

var _index8 = _interopRequireDefault(_index7);

var _Configuration = require('../Configuration.js');

var _Configuration2 = _interopRequireDefault(_Configuration);

var _Cosmos = require('../backends/Cosmos.js');

var _Cosmos2 = _interopRequireDefault(_Cosmos);

var _Creator = require('../Creator.js');

var _Creator2 = _interopRequireDefault(_Creator);

var _DateProvider = require('./DateProvider.js');

var _DateProvider2 = _interopRequireDefault(_DateProvider);

var _Environment = require('../Environment.js');

var _Environment2 = _interopRequireDefault(_Environment);

var _EventDispatcher = require('../EventDispatcher.js');

var _EventDispatcher2 = _interopRequireDefault(_EventDispatcher);

var _Scheduler = require('./Scheduler.js');

var _Scheduler2 = _interopRequireDefault(_Scheduler);

var _ServiceRouter = require('../ServiceRouter.js');

var _ServiceRouter2 = _interopRequireDefault(_ServiceRouter);

var _TimerHandler = require('./TimerHandler.js');

var _TimerHandler2 = _interopRequireDefault(_TimerHandler);

var _ViewParser = require('../ViewParser.js');

var _ViewParser2 = _interopRequireDefault(_ViewParser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * A class that makes the dependency injection used in the framework less
 * awkward for the consumer. The factory pattern is especially useful when
 * components need to be shared and the constructor provides a single entry
 * point for injecting external dependencies like configuration.
 */
var HubFactory = function () {
  function HubFactory(config) {
    _classCallCheck(this, HubFactory);

    this._config = _bfsKmTypes2.default.is.object(config) ? _bfsKmTypes2.default.clone(config) : {};
  }

  _createClass(HubFactory, [{
    key: 'newSurfaceHubApp',
    value: function newSurfaceHubApp(uri) {
      _bfsKmTypes2.default.check.string(uri);
      var eventDispatcher = new _EventDispatcher2.default();
      var serviceRouter = new _ServiceRouter2.default();
      var environment = new _Environment2.default();
      var creator = new _Creator2.default();
      var configuration = new _Configuration2.default(environment, creator, this._config);
      var viewParser = new _ViewParser2.default(eventDispatcher, serviceRouter, configuration, environment, creator);
      var backend = new _Cosmos2.default(environment);
      var contentProvider = new _index2.default.BackendContentProvider(backend, viewParser, uri);
      var timerHandler = new _TimerHandler2.default();
      var scheduler = new _Scheduler2.default(timerHandler);
      viewParser.register('bfs-card-album', _index8.default.CardAlbum);
      viewParser.register('bfs-card-artist', _index8.default.CardArtist);
      viewParser.register('bfs-card-chart', _index8.default.CardChart);
      viewParser.register('bfs-card-episode', _index8.default.CardEpisode);
      viewParser.register('bfs-card-link', _index8.default.CardLink);
      viewParser.register('bfs-card-playlist', _index8.default.CardPlaylist);
      viewParser.register('bfs-card-profile', _index8.default.CardProfile);
      viewParser.register('bfs-cell', _index8.default.Cell);
      viewParser.register('bfs-container', _index8.default.Container);
      viewParser.register('bfs-grid', _index8.default.Grid);
      viewParser.register('bfs-puff', _index8.default.Puff);
      viewParser.register('bfs-section', _index8.default.Section);
      viewParser.register('bfs-section-carousel', _index8.default.SectionCarousel);
      return new _index4.default.SurfaceHubApp(contentProvider, environment, scheduler, eventDispatcher);
    }
  }, {
    key: 'newVanillaUriBuilder',
    value: function newVanillaUriBuilder() {
      var environment = new _Environment2.default();
      var creator = new _Creator2.default();
      var configuration = new _Configuration2.default(environment, creator, this._config);
      var dateProvider = new _DateProvider2.default();
      return new _index6.default.VanillaUriBuilder(configuration, dateProvider);
    }
  }]);

  return HubFactory;
}();

exports.default = HubFactory;

},{"../Configuration.js":343,"../Creator.js":345,"../Environment.js":347,"../EventDispatcher.js":348,"../ServiceRouter.js":351,"../ViewParser.js":352,"../backends/Cosmos.js":354,"../views/index.js":422,"./DateProvider.js":355,"./Scheduler.js":357,"./TimerHandler.js":358,"./content_providers/index.js":361,"./hub_apps/index.js":364,"./uri_builders/index.js":368,"bfs-km-types":570}],357:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _bfsKmTypes = require('bfs-km-types');

var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

var _TimerHandler = require('./TimerHandler.js');

var _TimerHandler2 = _interopRequireDefault(_TimerHandler);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * A class that may be used to schedule callbacks. The scheduled callbacks will
 * run on the first animation frame that occurs after the desired amount of time
 * has passed. The class keeps track of scheduled callbacks that haven't fired
 * and supports life-cycle management.
 */
var Scheduler = function () {
  function Scheduler(timerHandler) {
    _classCallCheck(this, Scheduler);

    _bfsKmTypes2.default.check.type(timerHandler, _TimerHandler2.default);
    this._timerHandler = timerHandler;
    this._setTimeoutTokens = {};
    this._requestAnimationFrameTokens = {};
  }

  _createClass(Scheduler, [{
    key: 'destroy',
    value: function destroy() {
      this._clearPendingSetTimeoutCallbacks();
      this._clearPendingRequestAnimationFrameCallbacks();
      this._timerHandler = null;
      this._setTimeoutTokens = null;
      this._requestAnimationFrameTokens = null;
      return null;
    }
  }, {
    key: 'scheduleInAbout',
    value: function scheduleInAbout(ms, callback, caller) {
      var _this = this;

      _bfsKmTypes2.default.check.number(ms);
      _bfsKmTypes2.default.check.function(callback);
      var setTimeoutToken = this._timerHandler.setTimeout(function () {
        delete _this._setTimeoutTokens[setTimeoutToken];
        var requestAnimationFrameToken = _this._timerHandler.requestAnimationFrame(function () {
          delete _this._requestAnimationFrameTokens[requestAnimationFrameToken];
          callback.call(caller);
        });
        _this._requestAnimationFrameTokens[requestAnimationFrameToken] = requestAnimationFrameToken;
      }, ms);
      this._setTimeoutTokens[setTimeoutToken] = setTimeoutToken;
      return this;
    }
  }, {
    key: '_clearPendingSetTimeoutCallbacks',
    value: function _clearPendingSetTimeoutCallbacks() {
      for (var key in this._setTimeoutTokens) {
        if (this._setTimeoutTokens.hasOwnProperty(key)) {
          this._timerHandler.clearTimeout(this._setTimeoutTokens[key]);
        }
      }
      this._setTimeoutTokens = {};
      return this;
    }
  }, {
    key: '_clearPendingRequestAnimationFrameCallbacks',
    value: function _clearPendingRequestAnimationFrameCallbacks() {
      for (var key in this._requestAnimationFrameTokens) {
        if (this._requestAnimationFrameTokens.hasOwnProperty(key)) {
          this._timerHandler.cancelAnimationFrame(this._requestAnimationFrameTokens[key]);
        }
      }
      this._requestAnimationFrameTokens = {};
      return this;
    }
  }]);

  return Scheduler;
}();

exports.default = Scheduler;

},{"./TimerHandler.js":358,"bfs-km-types":570}],358:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _bfsKmTypes = require('bfs-km-types');

var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * A class that acts as a proxy for timer handling methods on the global window
 * object. The purpose of this class is to provide a class that can be stubbed
 * in tests and by that properly isolate the unit under test instead of stubbing
 * the global window object. This requires no tear down and does not mutate
 * global state.
 */
var TimerHandler = function () {
  function TimerHandler() {
    _classCallCheck(this, TimerHandler);

    this._window = global.window;
  }

  _createClass(TimerHandler, [{
    key: 'cancelAnimationFrame',
    value: function cancelAnimationFrame(token) {
      _bfsKmTypes2.default.check.number(token);
      return this._window.cancelAnimationFrame(token);
    }
  }, {
    key: 'clearTimeout',
    value: function clearTimeout(token) {
      _bfsKmTypes2.default.check.number(token);
      return this._window.clearTimeout(token);
    }
  }, {
    key: 'requestAnimationFrame',
    value: function requestAnimationFrame(callback) {
      _bfsKmTypes2.default.check.function(callback);
      return this._window.requestAnimationFrame(callback);
    }
  }, {
    key: 'setTimeout',
    value: function setTimeout(callback, ms) {
      _bfsKmTypes2.default.check.function(callback);
      _bfsKmTypes2.default.check.number(ms);
      return this._window.setTimeout(callback, ms);
    }
  }]);

  return TimerHandler;
}();

exports.default = TimerHandler;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"bfs-km-types":570}],359:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _bfsKmTypes = require('bfs-km-types');

var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

var _Backend = require('../../backends/Backend.js');

var _Backend2 = _interopRequireDefault(_Backend);

var _ContentProvider2 = require('./ContentProvider.js');

var _ContentProvider3 = _interopRequireDefault(_ContentProvider2);

var _ViewParser = require('../../ViewParser.js');

var _ViewParser2 = _interopRequireDefault(_ViewParser);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * An extension of the ContentProvider class that requests the given uri from
 * the given Backend and lets the given ViewParser parse the returned json into
 * a tree of view components. In the event of an error, null is passed instead
 * of view component tree.
 */
var BackendContentProvider = function (_ContentProvider) {
  _inherits(BackendContentProvider, _ContentProvider);

  function BackendContentProvider(backend, viewParser, uri) {
    _classCallCheck(this, BackendContentProvider);

    var _this = _possibleConstructorReturn(this, (BackendContentProvider.__proto__ || Object.getPrototypeOf(BackendContentProvider)).call(this));

    _bfsKmTypes2.default.check.type(backend, _Backend2.default);
    _bfsKmTypes2.default.check.type(viewParser, _ViewParser2.default);
    _bfsKmTypes2.default.check.string(uri);
    _this._backend = backend;
    _this._viewParser = viewParser;
    _this._uri = uri;
    return _this;
  }

  _createClass(BackendContentProvider, [{
    key: 'getContent',
    value: function getContent(callback, caller) {
      var _this2 = this;

      _bfsKmTypes2.default.check.function(callback);
      this._backend.request(this._uri, function (json) {
        var view = void 0;
        if (_bfsKmTypes2.default.conforms(json, { root: {} })) {
          view = _this2._viewParser.parse(json.root);
        } else {
          view = null;
        }
        callback.call(caller, view);
      });
      return null;
    }
  }]);

  return BackendContentProvider;
}(_ContentProvider3.default);

exports.default = BackendContentProvider;

},{"../../ViewParser.js":352,"../../backends/Backend.js":353,"./ContentProvider.js":360,"bfs-km-types":570}],360:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * A class that defines a unified interface for providing view components to the
 * hub app. The purpose of this class is to abstract the underlying
 * implementation of how content is delivered to the hub app. Some content
 * providers may depend on application arguments, some on configuration and some
 * may depend on a combination of these. Classes extending from this class
 * should override all methods as these will throw by default.
 */
var ContentProvider = function () {
  function ContentProvider() {
    _classCallCheck(this, ContentProvider);
  }

  _createClass(ContentProvider, [{
    key: 'getContent',
    value: function getContent(callback, caller) {
      throw new global.Error('Abstract method called!');
    }
  }]);

  return ContentProvider;
}();

exports.default = ContentProvider;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],361:[function(require,module,exports){
'use strict';

exports.BackendContentProvider = require('./BackendContentProvider.js').default;
exports.ContentProvider = require('./ContentProvider.js').default;

},{"./BackendContentProvider.js":359,"./ContentProvider.js":360}],362:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * A class that defines a unified interface for the life-cycle management of hub
 * apps. Classes extending from this class should override all methods as these
 * will throw by default.
 */
var HubApp = function () {
  function HubApp() {
    _classCallCheck(this, HubApp);
  }

  _createClass(HubApp, [{
    key: 'destroy',
    value: function destroy() {
      throw new global.Error('Abstract method called!');
    }
  }, {
    key: 'loadViewComponentTree',
    value: function loadViewComponentTree(callback) {
      throw new global.Error('Abstract method called!');
    }
  }, {
    key: 'mountRootViewIn',
    value: function mountRootViewIn(containerElement) {
      throw new global.Error('Abstract method called!');
    }
  }]);

  return HubApp;
}();

exports.default = HubApp;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],363:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _bfsKmTypes = require('bfs-km-types');

var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

var _ContentProvider = require('../content_providers/ContentProvider.js');

var _ContentProvider2 = _interopRequireDefault(_ContentProvider);

var _Environment = require('../../Environment.js');

var _Environment2 = _interopRequireDefault(_Environment);

var _EventDispatcher = require('../../EventDispatcher.js');

var _EventDispatcher2 = _interopRequireDefault(_EventDispatcher);

var _HubApp2 = require('./HubApp.js');

var _HubApp3 = _interopRequireDefault(_HubApp2);

var _Scheduler = require('../Scheduler.js');

var _Scheduler2 = _interopRequireDefault(_Scheduler);

var _View = require('../../views/View.js');

var _View2 = _interopRequireDefault(_View);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var IMPRESSION_LOGGING_PERIODIC_CHECK_MS = 1000;

/**
 * An extension of the HubApp class that manages a hub app that may be embedded
 * into surfaces of other apps. This class delegates fetching the view component
 * tree to the given ContentProvider and dispatches impression logging checks
 * through the given Scheduler and EventDispatcher.
 */

var SurfaceHubApp = function (_HubApp) {
  _inherits(SurfaceHubApp, _HubApp);

  function SurfaceHubApp(contentProvider, environment, scheduler, eventDispatcher) {
    _classCallCheck(this, SurfaceHubApp);

    var _this = _possibleConstructorReturn(this, (SurfaceHubApp.__proto__ || Object.getPrototypeOf(SurfaceHubApp)).call(this));

    _bfsKmTypes2.default.check.type(contentProvider, _ContentProvider2.default);
    _bfsKmTypes2.default.check.type(environment, _Environment2.default);
    _bfsKmTypes2.default.check.type(scheduler, _Scheduler2.default);
    _bfsKmTypes2.default.check.type(eventDispatcher, _EventDispatcher2.default);
    _this._contentProvider = contentProvider;
    _this._environment = environment;
    _this._scheduler = scheduler;
    _this._eventDispatcher = eventDispatcher;
    _this._rootView = null;
    _this._schedulePeriodic();
    return _this;
  }

  _createClass(SurfaceHubApp, [{
    key: 'destroy',
    value: function destroy() {
      this._scheduler.destroy();
      this._destroyRootView();
      this._contentProvider = null;
      this._environment = null;
      this._rootView = null;
      this._scheduler = null;
      this._eventDispatcher = null;
      return null;
    }
  }, {
    key: 'loadViewComponentTree',
    value: function loadViewComponentTree(callback) {
      var _this2 = this;

      this._contentProvider.getContent(function (view) {
        _this2._setRootView(view);
        if (_bfsKmTypes2.default.is.function(callback)) {
          callback(null, view);
        }
      });
      return null;
    }
  }, {
    key: 'mountRootViewIn',
    value: function mountRootViewIn(containerElement) {
      _bfsKmTypes2.default.check.type(containerElement, global.window.Element);
      if (this._rootView !== null) {
        this._rootView.attach(containerElement);
        this._environment.updateSpotifyEventsIn(containerElement);
      }
      return this;
    }
  }, {
    key: '_destroyRootView',
    value: function _destroyRootView() {
      if (this._rootView !== null) {
        this._rootView.destroy();
        this._rootView = null;
      }
      return this;
    }
  }, {
    key: '_schedulePeriodic',
    value: function _schedulePeriodic() {
      var _this3 = this;

      var scheduledFunction = function scheduledFunction() {
        _this3._eventDispatcher.dispatch('periodic-update', {});
        _this3._scheduler.scheduleInAbout(IMPRESSION_LOGGING_PERIODIC_CHECK_MS, scheduledFunction);
      };
      this._scheduler.scheduleInAbout(IMPRESSION_LOGGING_PERIODIC_CHECK_MS, scheduledFunction);
      return null;
    }
  }, {
    key: '_setRootView',
    value: function _setRootView(view) {
      this._destroyRootView();
      if (view !== null) {
        _bfsKmTypes2.default.check.type(view, _View2.default);
        this._rootView = view;
      }
      return this;
    }
  }]);

  return SurfaceHubApp;
}(_HubApp3.default);

exports.default = SurfaceHubApp;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../Environment.js":347,"../../EventDispatcher.js":348,"../../views/View.js":373,"../Scheduler.js":357,"../content_providers/ContentProvider.js":360,"./HubApp.js":362,"bfs-km-types":570}],364:[function(require,module,exports){
'use strict';

exports.HubApp = require('./HubApp.js').default;
exports.SurfaceHubApp = require('./SurfaceHubApp.js').default;

},{"./HubApp.js":362,"./SurfaceHubApp.js":363}],365:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _bfsKmTypes = require('bfs-km-types');

var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

var _UriBuilder2 = require('./UriBuilder.js');

var _UriBuilder3 = _interopRequireDefault(_UriBuilder2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * An extension of the UriBuilder class that builds Hermes uris for any generic
 * service and that handles uri encoding of path components and query
 * parameters. Path component is used interchangeably for both host and path
 * since this implementation does not support the full authority specification
 * as there is currently no need for that.
 */
var GenericUriBuilder = function (_UriBuilder) {
  _inherits(GenericUriBuilder, _UriBuilder);

  function GenericUriBuilder() {
    _classCallCheck(this, GenericUriBuilder);

    var _this = _possibleConstructorReturn(this, (GenericUriBuilder.__proto__ || Object.getPrototypeOf(GenericUriBuilder)).call(this));

    _this._pathComponents = [];
    _this._queryParameters = [];
    return _this;
  }

  _createClass(GenericUriBuilder, [{
    key: 'addPathComponent',
    value: function addPathComponent(pathComponent) {
      _bfsKmTypes2.default.check.string(pathComponent);
      this._pathComponents.push(pathComponent);
      return this;
    }
  }, {
    key: 'addQueryParameter',
    value: function addQueryParameter(key, value) {
      _bfsKmTypes2.default.check.string(key);
      _bfsKmTypes2.default.check.string(value);
      var queryParameter = {
        key: key,
        value: value
      };
      this._queryParameters.push(queryParameter);
      return this;
    }
  }, {
    key: 'build',
    value: function build(callback, caller) {
      _bfsKmTypes2.default.check.function(callback);
      var pathUriPart = this._getPathUriPart();
      var queryUriPart = this._getQueryUriPart();
      var uri = 'hm://' + pathUriPart + queryUriPart;
      callback.call(caller, uri);
      return null;
    }
  }, {
    key: '_getPathUriPart',
    value: function _getPathUriPart() {
      var encodedPathComponents = this._pathComponents.map(function (pathComponent) {
        var encodedPathComponent = global.encodeURIComponent(pathComponent);
        return encodedPathComponent;
      });
      var pathUriPart = encodedPathComponents.join('/');
      return pathUriPart;
    }
  }, {
    key: '_getQueryUriPart',
    value: function _getQueryUriPart() {
      var queryUriPart = void 0;
      if (this._queryParameters.length > 0) {
        var encodedQueryParameters = this._queryParameters.map(function (queryParameter) {
          var encodedKey = global.encodeURIComponent(queryParameter.key);
          var encodedValue = global.encodeURIComponent(queryParameter.value);
          var encodedQueryParameter = {
            key: encodedKey,
            value: encodedValue
          };
          return encodedQueryParameter;
        });
        var encodedQueryParameterPairs = encodedQueryParameters.map(function (encodedQueryParameter) {
          var encodedQueryParameterPair = encodedQueryParameter.key + '=' + encodedQueryParameter.value;
          return encodedQueryParameterPair;
        });
        queryUriPart = '?' + encodedQueryParameterPairs.join('&');
      } else {
        queryUriPart = '';
      }
      return queryUriPart;
    }
  }]);

  return GenericUriBuilder;
}(_UriBuilder3.default);

exports.default = GenericUriBuilder;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./UriBuilder.js":366,"bfs-km-types":570}],366:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * A class that defines a unified interface for building Hermes uris. The
 * purpose of this class is to abstract the underlying implementation of how the
 * Hermes uri is built. Some uri builders may talk with other async libraries
 * while some may build the uri synchronously. Classes extending from this class
 * should override all methods as these will throw by default. This class could
 * eventually be replaced by a Promise.
 */
var UriBuilder = function () {
  function UriBuilder() {
    _classCallCheck(this, UriBuilder);
  }

  _createClass(UriBuilder, [{
    key: 'build',
    value: function build(callback, caller) {
      throw new global.Error('Abstract method called!');
    }
  }]);

  return UriBuilder;
}();

exports.default = UriBuilder;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],367:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _bfsKmTypes = require('bfs-km-types');

var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

var _getDateTime = require('../../utils/getDateTime.js');

var _getDateTime2 = _interopRequireDefault(_getDateTime);

var _Configuration = require('../../Configuration.js');

var _Configuration2 = _interopRequireDefault(_Configuration);

var _DateProvider = require('../DateProvider.js');

var _DateProvider2 = _interopRequireDefault(_DateProvider);

var _GenericUriBuilder = require('./GenericUriBuilder.js');

var _GenericUriBuilder2 = _interopRequireDefault(_GenericUriBuilder);

var _UriBuilder2 = require('./UriBuilder.js');

var _UriBuilder3 = _interopRequireDefault(_UriBuilder2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * An extension of the UriBuilder class that builds Hermes uris for the Vanilla
 * service. This class supports sending signals (a special form of query
 * parameters that propagate to upstream services in the programming platform)
 * and will add query parameters with user and client information from the given
 * Configuration. At a minimum, the class requires a space to be specified with
 * the setSpace() method before calling the build() method.
 */
var VanillaUriBuilder = function (_UriBuilder) {
  _inherits(VanillaUriBuilder, _UriBuilder);

  function VanillaUriBuilder(configuration, dateProvider) {
    _classCallCheck(this, VanillaUriBuilder);

    var _this = _possibleConstructorReturn(this, (VanillaUriBuilder.__proto__ || Object.getPrototypeOf(VanillaUriBuilder)).call(this));

    _bfsKmTypes2.default.check.type(configuration, _Configuration2.default);
    _bfsKmTypes2.default.check.type(dateProvider, _DateProvider2.default);
    _this._configuration = configuration;
    _this._dateProvider = dateProvider;
    _this._space = null;
    _this._signals = [];
    return _this;
  }

  _createClass(VanillaUriBuilder, [{
    key: 'addSignal',
    value: function addSignal(key, value) {
      _bfsKmTypes2.default.check.string(key);
      _bfsKmTypes2.default.check.string(value);
      this._signals.push({
        key: key,
        value: value
      });
      return this;
    }
  }, {
    key: 'build',
    value: function build(callback, caller) {
      var _this2 = this;

      _bfsKmTypes2.default.check.function(callback);
      this._configuration.getCurrentState(function (configurationState) {
        var genericUriBuilder = new _GenericUriBuilder2.default();
        _this2._addPathComponents(genericUriBuilder);
        _this2._addQueryParameters(genericUriBuilder, configurationState);
        _this2._addSignals(genericUriBuilder);
        genericUriBuilder.build(callback, caller);
      });
      return null;
    }
  }, {
    key: 'setSpace',
    value: function setSpace(space) {
      _bfsKmTypes2.default.check.string(space);
      this._space = space;
      return this;
    }
  }, {
    key: '_addPathComponents',
    value: function _addPathComponents(genericUriBuilder) {
      genericUriBuilder.addPathComponent('vanilla');
      genericUriBuilder.addPathComponent('v1');
      genericUriBuilder.addPathComponent('views');
      genericUriBuilder.addPathComponent('km');
      genericUriBuilder.addPathComponent(this._space);
      return null;
    }
  }, {
    key: '_addQueryParameters',
    value: function _addQueryParameters(genericUriBuilder, configurationState) {
      genericUriBuilder.addQueryParameter('dt', (0, _getDateTime2.default)(this._dateProvider.getDate()));
      genericUriBuilder.addQueryParameter('platform', 'km');
      if (configurationState.hasString('user/language')) {
        genericUriBuilder.addQueryParameter('locale', configurationState.getString('user/language'));
      }
      if (configurationState.hasString('user/catalogue')) {
        genericUriBuilder.addQueryParameter('product', configurationState.getString('user/catalogue'));
      }
      if (configurationState.hasString('user/country')) {
        genericUriBuilder.addQueryParameter('region', configurationState.getString('user/country'));
      }
      if (configurationState.hasString('user/username')) {
        genericUriBuilder.addQueryParameter('username', configurationState.getString('user/username'));
      }
      if (configurationState.hasString('client/version')) {
        genericUriBuilder.addQueryParameter('version', configurationState.getString('client/version'));
      }
      if (!configurationState.getBooleanOr('caching/enabled', true)) {
        genericUriBuilder.addQueryParameter('no-cache', '' + this._dateProvider.getDate().getTime());
      }
      return null;
    }
  }, {
    key: '_addSignals',
    value: function _addSignals(genericUriBuilder) {
      this._signals.forEach(function (signal) {
        var key = 'signal';
        var value = signal.key + ':' + signal.value;
        genericUriBuilder.addQueryParameter(key, value);
      });
      return null;
    }
  }]);

  return VanillaUriBuilder;
}(_UriBuilder3.default);

exports.default = VanillaUriBuilder;

},{"../../Configuration.js":343,"../../utils/getDateTime.js":370,"../DateProvider.js":355,"./GenericUriBuilder.js":365,"./UriBuilder.js":366,"bfs-km-types":570}],368:[function(require,module,exports){
'use strict';

exports.GenericUriBuilder = require('./GenericUriBuilder.js').default;
exports.UriBuilder = require('./UriBuilder.js').default;
exports.VanillaUriBuilder = require('./VanillaUriBuilder.js').default;

},{"./GenericUriBuilder.js":365,"./UriBuilder.js":366,"./VanillaUriBuilder.js":367}],369:[function(require,module,exports){
(function (global){
'use strict';

var types = require('bfs-km-types');

/**
 * An interface that is responsible for handling service requests.
 * Implementations of this interface may choose to only handle certain service
 * requests but must provide a view component tree (or null to indicate an
 * error) if they choose to do so. This may be done in an asynchronous fashion.
 */
var Service = function Service() {};

types.define(Service);

/**
 * An abstract method that makes a request to the service. The given callback
 * will be called with the view response if the request succeeds or null if the
 * request fails.
 */
Service.prototype.request = function (uri, callback, caller) {
  types.check.string(uri);
  types.check.function(callback);

  throw new global.Error('Abstract method called!');
};

/**
 * An abstract method that determines if the service responds for the given uri.
 */
Service.prototype.responds = function (uri) {
  types.check.string(uri);

  throw new global.Error('Abstract method called!');
};

module.exports = Service;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"bfs-km-types":570}],370:[function(require,module,exports){
(function (global){
'use strict';

var types = require('bfs-km-types');

/**
 * A method that returns the given date in the format expected by the
 * Programming Platform's services.
 */
module.exports = function getDateTime(date) {
  var y;
  var m;
  var d;
  var h;

  types.check.type(date, global.Date);

  y = date.getFullYear();
  m = date.getMonth() + 1;
  d = date.getDate();
  h = date.getHours();

  y = '' + y;
  m = (m < 10 ? '0' : '') + m;
  d = (d < 10 ? '0' : '') + d;
  h = (h < 10 ? '0' : '') + h;

  return y + '-' + m + '-' + d + 'T' + h + ':00:00';
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"bfs-km-types":570}],371:[function(require,module,exports){
(function (global){
'use strict';

module.exports = function getGridBreakPoint() {
  var style = global.window.getComputedStyle(global.document.body, ':before');
  var value = style.getPropertyValue('content');
  return value.replace(/^"(.+)"$/, '$1');
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],372:[function(require,module,exports){
"use strict";

module.exports = function rectIntersect(a, b) {
  if (a.left >= a.right) {
    return false;
  }

  if (a.top >= a.bottom) {
    return false;
  }

  if (b.left >= b.right) {
    return false;
  }

  if (b.top >= b.bottom) {
    return false;
  }

  if (b.right <= a.left) {
    return false;
  }

  if (b.bottom <= a.top) {
    return false;
  }

  if (b.left >= a.right) {
    return false;
  }

  if (b.top >= a.bottom) {
    return false;
  }

  return true;
};

},{}],373:[function(require,module,exports){
(function (global){
'use strict';

var types = require('bfs-km-types');

var Configuration = require('../Configuration.js');
var DocumentFragment = require('../DocumentFragment.js');
var Environment = require('../Environment.js');
var EventDispatcher = require('../EventDispatcher.js');
var EventListener = require('../EventListener.js');
var InteractionHandler = require('../InteractionHandler.js');
var ServiceRouter = require('../ServiceRouter.js');

/**
 * An abstract class that is responsible for maintaining a view component node
 * in the view component tree. This class automatically handles html document
 * construction, based on the state of the view component node and updates the
 * html document on state changes such as when a child view component is added
 * or removed.
 */
var View = function View(model, eventDispatcher, serviceRouter, configuration, environment) {
  types.check.object(model);
  types.check.type(eventDispatcher, EventDispatcher);
  types.check.type(serviceRouter, ServiceRouter);
  types.check.type(configuration, Configuration);
  types.check.type(environment, Environment);

  this.model = types.clone(model);
  this.eventDispatcher = eventDispatcher;
  this.serviceRouter = serviceRouter;
  this.configuration = configuration;
  this.environment = environment;
  this.documentFragment = new DocumentFragment(this.render());
  this.eventListeners = [];
  this.parentView = null;
  this.childViews = [];
  this.interactionHandlers = [];
  this.childContainerElement = this.documentFragment.find('[data-child-container]');
};

types.define(View);

/**
 * A method that adds the given child view as a child to the view. The child
 * view will be attached if the view is already attached to a container element.
 */
View.prototype.addChild = function (childView) {
  types.check.type(childView, View);

  childView.removeFromParent();

  this.childViews.push(childView);

  childView.parentView = this;

  if (this.documentFragment.isAttached()) {
    if (this.childContainerElement !== null) {
      childView.attach(this.childContainerElement);
    }
  }

  return this;
};

/**
 * A method that adds an event listener to the view. The given callback will be
 * called with the json data for the event when events of the given type occur.
 */
View.prototype.addEventListener = function (type, callback) {
  var eventListener;

  types.check.string(type);
  types.check.function(callback);

  eventListener = new EventListener(type, callback, this);

  this.eventListeners.push(eventListener);

  this.eventDispatcher.register(eventListener);
};

/**
 * A method that adds an interaction handler to the view. The given callback
 * will be called with the given element as a parameter when events of the given
 * type occur on the given element.
 */
View.prototype.addInteractionHandler = function (element, type, callback) {
  var interactionHandler;

  types.check.type(element, global.window.Element);
  types.check.string(type);
  types.check.function(callback);

  interactionHandler = new InteractionHandler(element, type, callback, this);

  this.interactionHandlers.push(interactionHandler);

  interactionHandler.attach();
};

/**
 * A method that attaches the document fragment of the view to the given
 * container element. The method is called recursively for each child view.
 */
View.prototype.attach = function (containerElement) {
  var i;

  types.check.type(containerElement, global.window.Element);

  if (this.childContainerElement !== null) {
    for (i = 0; i < this.childViews.length; i++) {
      this.childViews[i].attach(this.childContainerElement);
    }
  }

  this.documentFragment.attach(containerElement);
};

/**
 * A method that cleans up the instance in a way that should aid the garbage
 * collector.
 */
View.prototype.destroy = function () {
  var i;

  for (i = 0; i < this.childViews.length; i++) {
    this.childViews[i].destroy();
  }

  for (i = 0; i < this.eventListeners.length; i++) {
    this.eventDispatcher.unregister(this.eventListeners[i]);
  }

  for (i = 0; i < this.interactionHandlers.length; i++) {
    this.interactionHandlers[i].detach();
  }

  this.documentFragment.destroy();

  this.model = null;
  this.eventDispatcher = null;
  this.serviceRouter = null;
  this.configuration = null;
  this.environment = null;
  this.documentFragment = null;
  this.eventListeners = null;
  this.parentView = null;
  this.childViews = null;
  this.interactionHandlers = null;
  this.childContainerElement = null;
};

/**
 * A method that detaches the document fragment of the view from its container
 * element. The method is called recursively for each child view.
 */
View.prototype.detach = function () {
  var i;

  this.documentFragment.detach();

  for (i = 0; i < this.childViews.length; i++) {
    this.childViews[i].detach();
  }
};

/**
 * A method that determines if the view handles a change to the given list of
 * arguments.
 */
View.prototype.handlesArgumentsChange = function (argumentsList) {
  var i;

  types.check.array(argumentsList);

  for (i = 0; i < this.childViews.length; i++) {
    if (this.childViews[i].handlesArgumentsChange(argumentsList)) {
      return true;
    }
  }

  return false;
};

/**
 * A method that logs a UIImpression5 message.
 */
View.prototype.logUIImpression5 = function (json) {
  types.check.object(json);

  this.configuration.getCurrentState(function (configurationState) {
    this.environment.logUIImpression5(json, configurationState.getBooleanOr('logging/enabled', false));
  }, this);
};

/**
 * A method that logs a UIInteraction5 message.
 */
View.prototype.logUIInteraction5 = function (json) {
  types.check.object(json);

  this.configuration.getCurrentState(function (configurationState) {
    this.environment.logUIInteraction5(json, configurationState.getBooleanOr('logging/enabled', false));
  }, this);
};

/**
 * A method that removes any event listener that might be registered for the
 * given type and the given callback.
 */
View.prototype.removeEventListener = function (type, callback) {
  var i;
  var eventListener;

  types.check.string(type);
  types.check.function(callback);

  for (i = this.eventListeners.length - 1; i >= 0; i--) {
    eventListener = this.eventListeners[i];

    if (eventListener.getType() === type && eventListener.getCallback() === callback) {
      this.eventDispatcher.unregister(eventListener);

      this.eventListeners.splice(i, 1);

      break;
    }
  }
};

/**
 * A method that removes the view from its parent.
 */
View.prototype.removeFromParent = function () {
  var index;

  if (this.parentView !== null) {
    this.detach();

    index = this.parentView.childViews.indexOf(this);

    if (index !== -1) {
      this.parentView.childViews.splice(index, 1);
    }

    this.parentView = null;
  }
};

/**
 * An abstract method that creates the html string for the view.
 */
View.prototype.render = function () {
  throw new global.Error('Abstract method called!');
};

/**
 * A method that registers the event routing for the view.
 */
View.prototype.route = function () {};

/**
 * A method that sets up standard impression logging to happen when the view is
 * partially visible on screen.
 */
View.prototype.setUpStandardImpressionLogging = function () {
  if ('logs' in this.model && 'impression' in this.model.logs) {
    this.addEventListener('periodic-update', function onPeriodicUpdate(json) {
      types.check.object(json);

      if (this.documentFragment.isPartiallyVisible()) {
        this.logUIImpression5(this.model.logs.impression);

        this.removeEventListener('periodic-update', onPeriodicUpdate);
      }
    });
  }
};

/**
 * Recursively traverses the view tree and sums up the number of content chunks that is deferred
 */
View.prototype.totalNrOfDeferredContentLoads = function () {
  var nrOfDeferredContentLoads = this.nrOfDeferredContentLoads();
  if (this.hasVisibleChildren()) {
    for (var i = 0; i < this.childViews.length; i++) {
      nrOfDeferredContentLoads += this.childViews[i].totalNrOfDeferredContentLoads();
    }
  }
  return nrOfDeferredContentLoads;
};

/**
 * The amount of deferred content loads for this single view
 */
View.prototype.nrOfDeferredContentLoads = function () {
  // 0 should be the default, override this if your view has deferred content loads
  return 0;
};

/**
 * Used to deduce if a views children should be disregarded in the calculation of deferred content loads
 */
View.prototype.hasVisibleChildren = function () {
  return this.childViews.length > 0;
};

module.exports = View;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../Configuration.js":343,"../DocumentFragment.js":346,"../Environment.js":347,"../EventDispatcher.js":348,"../EventListener.js":349,"../InteractionHandler.js":350,"../ServiceRouter.js":351,"bfs-km-types":570}],374:[function(require,module,exports){
(function (global){
'use strict';

var types = require('bfs-km-types');

var View = require('../View.js');
var schema = require('./schema.json');

/**
 * A view component that presents a card for an album. The card provides
 * playback overlay controls as long as the "link" attribute is not explicitly
 * set to true. The metadata may be positioned to the right of the card by
 * explicitly setting the "horizontal" attribute to true. If the "image"
 * attribute is absent, a placeholder image is shown.
 */
var CardAlbum = function CardAlbum(model, eventDispatcher, serviceRouter, configuration, environment) {
  if (!types.conforms(model, schema, true)) {
    throw new global.Error();
  }

  View.call(this, model, eventDispatcher, serviceRouter, configuration, environment);
  environment.addToLiveCache(model);
  this.route();
};

types.extend(CardAlbum, View);

/**
 * A method that is triggered by an interaction handler.
 */
CardAlbum.prototype.onClickDataLogClick = function (element) {
  var type;

  types.check.type(element, global.window.Element);

  type = element.getAttribute('data-log-click');

  if (type === 'add-button') {
    if ('logs' in this.model && 'addToCollection' in this.model.logs) {
      this.logUIInteraction5(this.model.logs.addToCollection);
    }

    return;
  }

  if (type === 'artist-name') {
    if ('logs' in this.model && 'navigateToArtist' in this.model.logs) {
      this.logUIInteraction5(this.model.logs.navigateToArtist);
    }

    return;
  }

  if (type === 'context-menu-button') {
    if ('logs' in this.model && 'openContextMenu' in this.model.logs) {
      this.logUIInteraction5(this.model.logs.openContextMenu);
    }

    return;
  }

  if (type === 'media-image') {
    if ('logs' in this.model && 'navigateToAlbum' in this.model.logs) {
      this.logUIInteraction5(this.model.logs.navigateToAlbum);
    }

    return;
  }

  if (type === 'media-title') {
    if ('logs' in this.model && 'navigateToAlbum' in this.model.logs) {
      this.logUIInteraction5(this.model.logs.navigateToAlbum);
    }

    return;
  }

  if (type === 'pause-button') {
    if ('logs' in this.model && 'stopPlayback' in this.model.logs) {
      this.logUIInteraction5(this.model.logs.stopPlayback);
    }

    return;
  }

  if (type === 'play-button') {
    if ('logs' in this.model && 'startPlayback' in this.model.logs) {
      this.logUIInteraction5(this.model.logs.startPlayback);
    }

    return;
  }

  if (type === 'remove-button') {
    if ('logs' in this.model && 'removeFromCollection' in this.model.logs) {
      this.logUIInteraction5(this.model.logs.removeFromCollection);
    }

    return;
  }
};

CardAlbum.prototype._getTemplateData = function () {
  var model = types.clone(this.model);
  var modifiers;

  modifiers = [];

  if ('horizontal' in model && model.horizontal) {
    modifiers.push('media-object-horizontal');

    if ('description' in model) {
      modifiers.push('media-object-horizontal-force-description');
    }
  }

  if ('link' in model && model.link) {
    modifiers.push('media-object-link');
  }

  if ('image' in model) {
    model.imageUrl = model.image;
  } else {
    modifiers.push('show-placeholder');
  }

  model.title = model.name;

  if (this.configuration.getDefaultState().getBooleanOr('style/small-cards', false)) {
    modifiers.push('media-object-small');
    delete model.description;
    delete model.meta;
  }

  if (modifiers.length > 0) {
    model.modifiers = modifiers.join(' ');
  }

  return model;
};

CardAlbum.prototype._getTemplateDataNewCard = function () {
  var model = types.clone(this.model);
  model.useNewCard = true;

  if ('image' in model) {
    model.imageUrl = model.image;
  }
  if ('artists' in model) {
    model.subtitleLinks = model.artists;
  }
  model.title = model.name;

  if ('horizontal' in model && model.horizontal && 'description' in model) {
    delete model.metadata;
  }

  if (this.configuration.getDefaultState().getBooleanOr('style/small-cards', false)) {
    model.playButtonOnly = true;
    delete model.description;
    delete model.metadata;
  }

  return model;
};

CardAlbum.prototype.render = function () {
  var useNewCard = global.top.initialState.newCards;
  var model = useNewCard ? this._getTemplateDataNewCard() : this._getTemplateData();

  return require('./template.hbs')(model);
};

/**
 * A method that registers the event routing for the view.
 */
CardAlbum.prototype.route = function () {
  this.documentFragment.query('[data-log-click]').forEach(function (element) {
    this.addInteractionHandler(element, 'click', this.onClickDataLogClick);
  }, this);

  this.setUpStandardImpressionLogging();
};

module.exports = CardAlbum;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../View.js":373,"./schema.json":375,"./template.hbs":376,"bfs-km-types":570}],375:[function(require,module,exports){
module.exports={
  "artists?":
  [
    {
      "name": "",
      "uri": ""
    }
  ],
  "horizontal?": false,
  "image?": "",
  "link?": false,
  "logs?":
  {
    "addToCollection?": {},
    "impression?": {},
    "navigateToAlbum?": {},
    "navigateToArtist?": {},
    "openContextMenu?": {},
    "removeFromCollection?": {},
    "startPlayback?": {},
    "stopPlayback?": {}
  },
  "name": "",
  "uri": ""
}

},{}],376:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('../../../../glue/templates/cards/card-horizontal.hbs');
HandlebarsCompiler.registerPartial('../../../../glue/templates/cards/card-horizontal.hbs', partial$0);
var partial$1 = require('../../../../glue/templates/cards/card.hbs');
HandlebarsCompiler.registerPartial('../../../../glue/templates/cards/card.hbs', partial$1);
var partial$2 = require('../../../../glue/templates/cards/card.hbs');
HandlebarsCompiler.registerPartial('../../../../glue/templates/cards/card.hbs', partial$2);
var partial$3 = require('../../../../glue/templates/media-object.hbs');
HandlebarsCompiler.registerPartial('../../../../glue/templates/media-object.hbs', partial$3);
var partial$4 = require('../../../../glue/templates/media-object.hbs');
HandlebarsCompiler.registerPartial('../../../../glue/templates/media-object.hbs', partial$4);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.horizontal), {hash:{},inverse:self.program(4, program4, data),fn:self.program(2, program2, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n    ";
  stack1 = self.invokePartial(partials['../../../../glue/templates/cards/card-horizontal.hbs'], '../../../../glue/templates/cards/card-horizontal.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }

function program4(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n    ";
  stack1 = self.invokePartial(partials['../../../../glue/templates/cards/card.hbs'], '../../../../glue/templates/cards/card.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }

function program6(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n  ";
  stack1 = self.invokePartial(partials['../../../../glue/templates/media-object.hbs'], '../../../../glue/templates/media-object.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  }

  stack1 = helpers['if'].call(depth0, (depth0 && depth0.useNewCard), {hash:{},inverse:self.program(6, program6, data),fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"../../../../glue/templates/cards/card-horizontal.hbs":154,"../../../../glue/templates/cards/card.hbs":156,"../../../../glue/templates/media-object.hbs":181,"hbsfy/runtime":615}],377:[function(require,module,exports){
(function (global){
'use strict';

var types = require('bfs-km-types');

var View = require('../View.js');
var schema = require('./schema.json');

/**
 * A view component that presents a card for an artist. The card provides
 * playback overlay controls as long as the "link" attribute is not explicitly
 * set to true. The metadata may be positioned to the right of the card by
 * explicitly setting the "horizontal" attribute to true. If the "image"
 * attribute is absent, a placeholder image is shown.
 */
var CardArtist = function CardArtist(model, eventDispatcher, serviceRouter, configuration, environment) {
  if (!types.conforms(model, schema, true)) {
    throw new global.Error();
  }

  View.call(this, model, eventDispatcher, serviceRouter, configuration, environment);
  environment.addToLiveCache(model);
  this.route();
};

types.extend(CardArtist, View);

/**
 * A method that is triggered by an interaction handler.
 */
CardArtist.prototype.onClickDataLogClick = function (element) {
  var type;

  types.check.type(element, global.window.Element);

  type = element.getAttribute('data-log-click');

  if (type === 'media-image' || type === 'card-image') {
    if ('logs' in this.model && 'navigateToArtist' in this.model.logs) {
      this.logUIInteraction5(this.model.logs.navigateToArtist);
    }

    return;
  }

  if (type === 'media-title' || type === 'card-info-title') {
    if ('logs' in this.model && 'navigateToArtist' in this.model.logs) {
      this.logUIInteraction5(this.model.logs.navigateToArtist);
    }

    return;
  }

  if (type === 'pause-button') {
    if ('logs' in this.model && 'stopPlayback' in this.model.logs) {
      this.logUIInteraction5(this.model.logs.stopPlayback);
    }

    return;
  }

  if (type === 'play-button') {
    if ('logs' in this.model && 'startPlayback' in this.model.logs) {
      this.logUIInteraction5(this.model.logs.startPlayback);
    }

    return;
  }
};

CardArtist.prototype._getTemplateData = function () {
  var model = types.clone(this.model);
  var modifiers;

  modifiers = [];

  if ('horizontal' in model && model.horizontal) {
    modifiers.push('media-object-horizontal');

    if ('description' in model) {
      modifiers.push('media-object-horizontal-force-description');
    }
  }

  if ('link' in model && model.link) {
    modifiers.push('media-object-link');
  }

  model.hideSubtitle = true;

  if ('image' in model) {
    model.imageUrl = model.image;
  } else {
    modifiers.push('show-placeholder');
  }

  model.title = model.name;

  if (this.configuration.getDefaultState().getBooleanOr('style/small-cards', false)) {
    modifiers.push('media-object-small');
    delete model.description;
    delete model.meta;
  }

  if (modifiers.length > 0) {
    model.modifiers = modifiers.join(' ');
  }

  return model;
};

CardArtist.prototype._getTemplateDataNewCard = function () {
  var model = types.clone(this.model);
  model.useNewCard = true;

  if ('image' in model) {
    model.imageUrl = model.image;
  }
  model.title = model.name;

  if ('horizontal' in model && model.horizontal && 'description' in model) {
    delete model.metadata;
  }

  if (this.configuration.getDefaultState().getBooleanOr('style/small-cards', false)) {
    model.playButtonOnly = true;
    delete model.description;
    delete model.metadata;
  }

  return model;
};

/**
 * A method that creates the html string for the view.
 */
CardArtist.prototype.render = function () {
  var useNewCard = global.top.initialState.newCards;
  var model = useNewCard ? this._getTemplateDataNewCard(this.model) : this._getTemplateData(this.model);

  return require('./template.hbs')(model);
};

/**
 * A method that registers the event routing for the view.
 */
CardArtist.prototype.route = function () {
  this.documentFragment.query('[data-log-click]').forEach(function (element) {
    this.addInteractionHandler(element, 'click', this.onClickDataLogClick);
  }, this);

  this.setUpStandardImpressionLogging();
};

module.exports = CardArtist;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../View.js":373,"./schema.json":378,"./template.hbs":379,"bfs-km-types":570}],378:[function(require,module,exports){
module.exports={
  "horizontal?": false,
  "image?": "",
  "link?": false,
  "logs?":
  {
    "impression?": {},
    "navigateToArtist?": {},
    "startPlayback?": {},
    "stopPlayback?": {}
  },
  "name": "",
  "uri": ""
}

},{}],379:[function(require,module,exports){
arguments[4][376][0].apply(exports,arguments)
},{"../../../../glue/templates/cards/card-horizontal.hbs":154,"../../../../glue/templates/cards/card.hbs":156,"../../../../glue/templates/media-object.hbs":181,"dup":376,"hbsfy/runtime":615}],380:[function(require,module,exports){
(function (global){
'use strict';

var types = require('bfs-km-types');

var View = require('../View.js');
var schema = require('./schema.json');

/**
 * A view component that presents a card for a chart.
 * The metadata may be positioned to the right of the card by
 * explicitly setting the "horizontal" attribute to true. If the "image"
 * attribute is absent, a placeholder image is shown.
 */
var CardChart = function CardChart(model, eventDispatcher, serviceRouter, configuration, environment) {
  if (!types.conforms(model, schema, true)) {
    throw new global.Error();
  }

  View.call(this, model, eventDispatcher, serviceRouter, configuration, environment);
  environment.addToLiveCache(model);
  this.route();
};

types.extend(CardChart, View);

/**
 * A method that is triggered by an interaction handler.
 */
CardChart.prototype.onClickDataLogClick = function (element) {
  var type;

  types.check.type(element, global.window.Element);

  type = element.getAttribute('data-log-click');

  if (type === 'media-image') {
    if ('logs' in this.model && 'navigateToChart' in this.model.logs) {
      this.logUIInteraction5(this.model.logs.navigateToChart);
    }

    return;
  }

  if (type === 'media-title') {
    if ('logs' in this.model && 'navigateToChart' in this.model.logs) {
      this.logUIInteraction5(this.model.logs.navigateToChart);
    }

    return;
  }
};

CardChart.prototype._getTemplateData = function () {
  var model;
  var modifiers;

  model = types.clone(this.model);

  modifiers = [];

  if ('horizontal' in model && model.horizontal) {
    modifiers.push('media-object-horizontal');

    if ('description' in model) {
      modifiers.push('media-object-horizontal-force-description');
    }
  }

  if ('link' in model && model.link) {
    modifiers.push('media-object-link');
  }

  model.hideSubtitle = true;

  if ('image' in model) {
    model.imageUrl = model.image;
  } else {
    modifiers.push('show-placeholder');
  }

  if (model.description === '') {
    model.description = ' '; // Force description to be shown.
  }

  if (model.meta === '') {
    model.meta = ' '; // Force meta to be shown.
  }

  model.title = model.name;

  if (this.configuration.getDefaultState().getBooleanOr('style/small-cards', false)) {
    modifiers.push('media-object-small');
    delete model.description;
    delete model.meta;
  }

  if (modifiers.length > 0) {
    model.modifiers = modifiers.join(' ');
  }

  return model;
};

CardChart.prototype._getTemplateDataNewCard = function () {
  var model = types.clone(this.model);
  model.useNewCard = true;

  if ('image' in model) {
    model.imageUrl = model.image;
  }

  model.title = model.name;

  if ('horizontal' in model && model.horizontal && 'description' in model) {
    delete model.metadata;
  }

  if (this.configuration.getDefaultState().getBooleanOr('style/small-cards', false)) {
    model.playButtonOnly = true;
    delete model.description;
    delete model.metadata;
  }

  return model;
};

/**
* A method that creates the html string for the view.
*/
CardChart.prototype.render = function () {
  var useNewCard = global.top.initialState.newCards;
  var model = useNewCard ? this._getTemplateDataNewCard() : this._getTemplateData();

  return require('./template.hbs')(model);
};

/**
 * A method that registers the event routing for the view.
 */
CardChart.prototype.route = function () {
  this.documentFragment.query('[data-log-click]').forEach(function (element) {
    this.addInteractionHandler(element, 'click', this.onClickDataLogClick);
  }, this);

  this.setUpStandardImpressionLogging();
};

module.exports = CardChart;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../View.js":373,"./schema.json":381,"./template.hbs":382,"bfs-km-types":570}],381:[function(require,module,exports){
module.exports={
  "description?": "",
  "horizontal?": false,
  "image?": "",
  "link?": false,
  "logs?":
  {
    "impression?": {},
    "navigateToChart?": {}
  },
  "meta?": "",
  "name": "",
  "uri": ""
}

},{}],382:[function(require,module,exports){
arguments[4][376][0].apply(exports,arguments)
},{"../../../../glue/templates/cards/card-horizontal.hbs":154,"../../../../glue/templates/cards/card.hbs":156,"../../../../glue/templates/media-object.hbs":181,"dup":376,"hbsfy/runtime":615}],383:[function(require,module,exports){
(function (global){
'use strict';

var types = require('bfs-km-types');

var View = require('../View.js');
var schema = require('./schema.json');

/**
 * A view component that presents a card for an episode. The card provides
 * playback overlay controls as long as the "link" attribute is not explicitly
 * set to true. The metadata may be positioned to the right of the card by
 * explicitly setting the "horizontal" attribute to true. If the "image"
 * attribute is absent, a placeholder image is shown. The cover image will be
 * square as long as the "wideImage" attribute is not explicitly set to true.
 */
var CardEpisode = function CardEpisode(model, eventDispatcher, serviceRouter, configuration, environment) {
  if (!types.conforms(model, schema, true)) {
    throw new global.Error();
  }

  View.call(this, model, eventDispatcher, serviceRouter, configuration, environment);
  environment.addToLiveCache(model);
  this.route();
};

types.extend(CardEpisode, View);

/**
 * A method that is triggered by an interaction handler.
 */
CardEpisode.prototype.onClickDataLogClick = function (element) {
  var type;

  types.check.type(element, global.window.Element);

  type = element.getAttribute('data-log-click');

  if (type === 'play-button') {
    if ('logs' in this.model && 'startPlayback' in this.model.logs) {
      this.logUIInteraction5(this.model.logs.startPlayback);
    }

    return;
  }
};

CardEpisode.prototype._getTemplateData = function () {
  var model;
  var modifiers;

  model = types.clone(this.model);

  modifiers = [];

  if ('horizontal' in model && model.horizontal) {
    modifiers.push('media-object-horizontal');

    if ('description' in model) {
      modifiers.push('media-object-horizontal-force-description');
    }
  }

  if ('link' in model && model.link) {
    modifiers.push('media-object-link');
  }

  model.noLink = true;
  model.hideSubtitle = true;

  if ('image' in model) {
    model.imageUrl = model.image;
  } else {
    modifiers.push('show-placeholder');
  }

  if (model.meta === '') {
    model.meta = ' '; // Force meta to be shown.
  }

  model.title = model.name;

  if (this.configuration.getDefaultState().getBooleanOr('style/small-cards', false)) {
    modifiers.push('media-object-small');
    delete model.description;
    delete model.meta;
  }

  if (modifiers.length > 0) {
    model.modifiers = modifiers.join(' ');
  }

  return model;
};

CardEpisode.prototype._getTemplateDataNewCard = function () {
  var model = types.clone(this.model);
  model.useNewCard = true;

  if ('image' in model) {
    model.imageUrl = model.image;
  }

  if (model.meta === '') {
    model.meta = ' '; // Force meta to be shown.
  }

  model.metadata = model.meta;
  model.title = model.name;
  model.noLink = true;

  if ('horizontal' in model && model.horizontal && 'description' in model) {
    delete model.metadata;
  }

  if (this.configuration.getDefaultState().getBooleanOr('style/small-cards', false)) {
    model.playButtonOnly = true;
    delete model.description;
    delete model.metadata;
  }

  return model;
};

/**
 * A method that creates the html string for the view.
 */
CardEpisode.prototype.render = function () {
  var useNewCard = global.top.initialState.newCards;
  var model = useNewCard ? this._getTemplateDataNewCard() : this._getTemplateData();

  return require('./template.hbs')(model);
};

/**
 * A method that registers the event routing for the view.
 */
CardEpisode.prototype.route = function () {
  this.documentFragment.query('[data-log-click]').forEach(function (element) {
    this.addInteractionHandler(element, 'click', this.onClickDataLogClick);
  }, this);

  this.setUpStandardImpressionLogging();
};

module.exports = CardEpisode;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../View.js":373,"./schema.json":384,"./template.hbs":385,"bfs-km-types":570}],384:[function(require,module,exports){
module.exports={
  "horizontal?": false,
  "image?": "",
  "link?": false,
  "logs?":
  {
    "impression?": {},
    "startPlayback?": {}
  },
  "meta?": "",
  "name": "",
  "uri": "",
  "wideImage?": false
}

},{}],385:[function(require,module,exports){
arguments[4][376][0].apply(exports,arguments)
},{"../../../../glue/templates/cards/card-horizontal.hbs":154,"../../../../glue/templates/cards/card.hbs":156,"../../../../glue/templates/media-object.hbs":181,"dup":376,"hbsfy/runtime":615}],386:[function(require,module,exports){
(function (global){
'use strict';

var types = require('bfs-km-types');

var View = require('../View.js');
var schema = require('./schema.json');

/**
 * A view component that presents a card for a link. In difference to the other
 * cards, this view component positions the "title" attribute over the image. If
 * the "cols" attribute is present, the height of the view component is computed
 * from the width with respect to the value of the "cols" attribute. If the
 * attribute is absent, the component uses a fixed height.
 */
var CardLink = function CardLink(model, eventDispatcher, serviceRouter, configuration, environment) {
  if (!types.conforms(model, schema, true)) {
    throw new global.Error();
  }

  View.call(this, model, eventDispatcher, serviceRouter, configuration, environment);

  this.route();
};

types.extend(CardLink, View);

/**
 * A method that is triggered by an interaction handler.
 */
CardLink.prototype.onClickDataLogClick = function (element) {
  var type;

  types.check.type(element, global.window.Element);

  type = element.getAttribute('data-log-click');

  if (type === 'genre-card') {
    if ('logs' in this.model && 'navigateToLink' in this.model.logs) {
      this.logUIInteraction5(this.model.logs.navigateToLink);
    }

    return;
  }
};

/**
 * A method that creates the html string for the view.
 */
CardLink.prototype.render = function () {
  var model;

  model = types.clone(this.model);

  model.imageUrl = model.image;
  model.useNewCard = global.top && global.top.initialState ? !!global.top.initialState.newCards : false;

  return require('./template.hbs')(model);
};

/**
 * A method that registers the event routing for the view.
 */
CardLink.prototype.route = function () {
  this.documentFragment.query('[data-log-click]').forEach(function (element) {
    this.addInteractionHandler(element, 'click', this.onClickDataLogClick);
  }, this);

  this.setUpStandardImpressionLogging();
};

module.exports = CardLink;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../View.js":373,"./schema.json":387,"./template.hbs":388,"bfs-km-types":570}],387:[function(require,module,exports){
module.exports={
  "cols?" : 0,
  "image": "",
  "logs?":
  {
    "impression?": {},
    "navigateToLink?": {}
  },
  "title": "",
  "uri": ""
}

},{}],388:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('../../../../glue/templates/genre-card.hbs');
HandlebarsCompiler.registerPartial('../../../../glue/templates/genre-card.hbs', partial$0);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, self=this;


  stack1 = self.invokePartial(partials['../../../../glue/templates/genre-card.hbs'], '../../../../glue/templates/genre-card.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"../../../../glue/templates/genre-card.hbs":167,"hbsfy/runtime":615}],389:[function(require,module,exports){
(function (global){
'use strict';

var types = require('bfs-km-types');

var View = require('../View.js');
var schema = require('./schema.json');

/**
 * A view component that presents a card for a playlist. The card provides
 * playback overlay controls as long as the "link" attribute is not explicitly
 * set to true. The metadata may be positioned to the right of the card by
 * explicitly setting the "horizontal" attribute to true. If the "image"
 * attribute is absent, a placeholder image is shown.
 */
var CardPlaylist = function CardPlaylist(model, eventDispatcher, serviceRouter, configuration, environment) {
  if (!types.conforms(model, schema, true)) {
    throw new global.Error();
  }

  View.call(this, model, eventDispatcher, serviceRouter, configuration, environment);
  environment.addToLiveCache(model);
  this.route();
};

types.extend(CardPlaylist, View);

/**
 * A method that is triggered by an interaction handler.
 */
CardPlaylist.prototype.onClickDataLogClick = function (element) {
  var type;

  types.check.type(element, global.window.Element);

  type = element.getAttribute('data-log-click');

  if (type === 'add-button') {
    if ('logs' in this.model && 'followPlaylist' in this.model.logs) {
      this.logUIInteraction5(this.model.logs.followPlaylist);
    }

    return;
  }

  if (type === 'context-menu-button') {
    if ('logs' in this.model && 'openContextMenu' in this.model.logs) {
      this.logUIInteraction5(this.model.logs.openContextMenu);
    }

    return;
  }

  if (type === 'media-image') {
    if ('logs' in this.model && 'navigateToPlaylist' in this.model.logs) {
      this.logUIInteraction5(this.model.logs.navigateToPlaylist);
    }

    return;
  }

  if (type === 'media-title') {
    if ('logs' in this.model && 'navigateToPlaylist' in this.model.logs) {
      this.logUIInteraction5(this.model.logs.navigateToPlaylist);
    }

    return;
  }

  if (type === 'pause-button') {
    if ('logs' in this.model && 'stopPlayback' in this.model.logs) {
      this.logUIInteraction5(this.model.logs.stopPlayback);
    }

    return;
  }

  if (type === 'play-button') {
    if ('logs' in this.model && 'startPlayback' in this.model.logs) {
      this.logUIInteraction5(this.model.logs.startPlayback);
    }

    return;
  }

  if (type === 'remove-button') {
    if ('logs' in this.model && 'unfollowPlaylist' in this.model.logs) {
      this.logUIInteraction5(this.model.logs.unfollowPlaylist);
    }

    return;
  }
};

CardPlaylist.prototype._getTemplateData = function () {
  var model;
  var modifiers;

  model = types.clone(this.model);

  modifiers = [];

  if ('horizontal' in model && model.horizontal) {
    modifiers.push('media-object-horizontal');

    if ('description' in model) {
      modifiers.push('media-object-horizontal-force-description');
    }
  }

  if ('link' in model && model.link) {
    modifiers.push('media-object-link');
  }

  model.hideSubtitle = true;

  if ('image' in model) {
    model.imageUrl = model.image;
  } else {
    modifiers.push('show-placeholder');
  }

  if (model.description === '') {
    model.description = ' '; // Force description to be shown.
  }

  if (model.meta === '') {
    model.meta = ' '; // Force meta to be shown.
  }

  model.title = model.name;

  if (this.configuration.getDefaultState().getBooleanOr('style/small-cards', false)) {
    modifiers.push('media-object-small');
    delete model.description;
    delete model.meta;
  }

  if (modifiers.length > 0) {
    model.modifiers = modifiers.join(' ');
  }

  return model;
};

CardPlaylist.prototype._getTemplateDataNewCard = function () {
  var model = types.clone(this.model);
  model.useNewCard = true;

  if ('image' in model) {
    model.imageUrl = model.image;
  }

  model.title = model.name;
  if (model.description === '') {
    model.description = ' '; // Force description to be shown.
  }

  if (model.meta === '') {
    model.meta = ' '; // Force meta to be shown.
  }

  model.metadata = model.meta;

  if ('horizontal' in model && model.horizontal && 'description' in model) {
    delete model.metadata;
  }

  if (this.configuration.getDefaultState().getBooleanOr('style/small-cards', false)) {
    model.playButtonOnly = true;
    delete model.description;
    delete model.metadata;
  }

  return model;
};

/**
 * A method that creates the html string for the view.
 */
CardPlaylist.prototype.render = function () {
  var useNewCard = global.top.initialState.newCards;
  var model = useNewCard ? this._getTemplateDataNewCard() : this._getTemplateData();

  return require('./template.hbs')(model);
};

/**
 * A method that registers the event routing for the view.
 */
CardPlaylist.prototype.route = function () {
  this.documentFragment.query('[data-log-click]').forEach(function (element) {
    this.addInteractionHandler(element, 'click', this.onClickDataLogClick);
  }, this);

  this.setUpStandardImpressionLogging();
};

module.exports = CardPlaylist;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../View.js":373,"./schema.json":390,"./template.hbs":391,"bfs-km-types":570}],390:[function(require,module,exports){
module.exports={
  "description?": "",
  "horizontal?": false,
  "image?": "",
  "link?": false,
  "logs?":
  {
    "followPlaylist?": {},
    "impression?": {},
    "navigateToPlaylist?": {},
    "openContextMenu?": {},
    "startPlayback?": {},
    "stopPlayback?": {},
    "unfollowPlaylist?": {}
  },
  "meta?": "",
  "name": "",
  "uri": ""
}

},{}],391:[function(require,module,exports){
arguments[4][376][0].apply(exports,arguments)
},{"../../../../glue/templates/cards/card-horizontal.hbs":154,"../../../../glue/templates/cards/card.hbs":156,"../../../../glue/templates/media-object.hbs":181,"dup":376,"hbsfy/runtime":615}],392:[function(require,module,exports){
(function (global){
'use strict';

var types = require('bfs-km-types');

var View = require('../View.js');
var schema = require('./schema.json');

/**
 * A view component that presents a card for a profile. The metadata may be
 * positioned to the right of the card by explicitly setting the "horizontal"
 * attribute to true. If the "image" attribute is absent, a placeholder image is
 * shown.
 */
var CardProfile = function CardProfile(model, eventDispatcher, serviceRouter, configuration, environment) {
  if (!types.conforms(model, schema, true)) {
    throw new global.Error();
  }

  View.call(this, model, eventDispatcher, serviceRouter, configuration, environment);
  environment.addToLiveCache(model);
  this.route();
};

types.extend(CardProfile, View);

/**
 * A method that is triggered by an interaction handler.
 */
CardProfile.prototype.onClickDataLogClick = function (element) {
  var type;

  types.check.type(element, global.window.Element);

  type = element.getAttribute('data-log-click');

  if (type === 'media-image') {
    if ('logs' in this.model && 'navigateToProfile' in this.model.logs) {
      this.logUIInteraction5(this.model.logs.navigateToProfile);
    }

    return;
  }

  if (type === 'media-title') {
    if ('logs' in this.model && 'navigateToProfile' in this.model.logs) {
      this.logUIInteraction5(this.model.logs.navigateToProfile);
    }

    return;
  }
};

CardProfile.prototype._getTemplateData = function () {
  var model;
  var modifiers;

  model = types.clone(this.model);

  modifiers = [];

  if ('horizontal' in model && model.horizontal) {
    modifiers.push('media-object-horizontal');

    if ('description' in model) {
      modifiers.push('media-object-horizontal-force-description');
    }
  }

  modifiers.push('media-object-link');

  model.hideSubtitle = true;

  if ('image' in model) {
    model.imageUrl = model.image;
  } else {
    modifiers.push('show-placeholder');
  }

  if (model.meta === '') {
    model.meta = ' '; // Force meta to be shown.
  }

  model.title = model.name;

  if (this.configuration.getDefaultState().getBooleanOr('style/small-cards', false)) {
    modifiers.push('media-object-small');
    delete model.description;
    delete model.meta;
  }

  if (modifiers.length > 0) {
    model.modifiers = modifiers.join(' ');
  }

  return model;
};

CardProfile.prototype._getTemplateDataNewCard = function () {
  var model = types.clone(this.model);

  if ('image' in model) {
    model.imageUrl = model.image;
  }

  if (model.meta === '') {
    model.meta = ' '; // Force meta to be shown.
  }

  model.title = model.name;
  model.metadata = model.meta;

  if ('horizontal' in model && model.horizontal && 'description' in model) {
    delete model.metadata;
  }

  if (this.configuration.getDefaultState().getBooleanOr('style/small-cards', false)) {
    model.playButtonOnly = true;
    delete model.description;
    delete model.metadata;
  }

  return model;
};

/**
* A method that creates the html string for the view.
*/
CardProfile.prototype.render = function () {
  var useNewCard = global.top.initialState.newCards;
  var model = useNewCard ? this._getTemplateDataNewCard() : this._getTemplateData();
  model.useNewCard = useNewCard;
  return require('./template.hbs')(model);
};

/**
 * A method that registers the event routing for the view.
 */
CardProfile.prototype.route = function () {
  this.documentFragment.query('[data-log-click]').forEach(function (element) {
    this.addInteractionHandler(element, 'click', this.onClickDataLogClick);
  }, this);

  this.setUpStandardImpressionLogging();
};

module.exports = CardProfile;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../View.js":373,"./schema.json":393,"./template.hbs":394,"bfs-km-types":570}],393:[function(require,module,exports){
module.exports={
  "horizontal?": false,
  "image?": "",
  "logs?":
  {
    "impression?": {},
    "navigateToProfile?": {}
  },
  "meta?": "",
  "name": "",
  "uri": ""
}

},{}],394:[function(require,module,exports){
arguments[4][376][0].apply(exports,arguments)
},{"../../../../glue/templates/cards/card-horizontal.hbs":154,"../../../../glue/templates/cards/card.hbs":156,"../../../../glue/templates/media-object.hbs":181,"dup":376,"hbsfy/runtime":615}],395:[function(require,module,exports){
(function (global){
'use strict';

var types = require('bfs-km-types');

var View = require('../View.js');
var schema = require('./schema.json');

/**
 * A view component that presents a grid cell. The "large", "medium", "small"
 * and "xSmall" attributes control how many of the 12 columns in the glue grid
 * that should be spanned by the view component for different window sizes.
 */
var Cell = function Cell(model, eventDispatcher, serviceRouter, configuration, environment) {
  if (!types.conforms(model, schema, true)) {
    throw new global.Error();
  }

  View.call(this, model, eventDispatcher, serviceRouter, configuration, environment);

  this.route();
};

types.extend(Cell, View);

/**
 * A method that creates the html string for the view.
 */
Cell.prototype.render = function () {
  var model = this.model;

  // The "xSmall" size was added after the other sizes, so if the model doesn't
  // have it, fall back to the size used for "small".
  if (!model.xSmall) {
    model = types.clone(this.model);
    model.xSmall = model.small;
  }

  return require('./template.hbs')(model);
};

module.exports = Cell;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../View.js":373,"./schema.json":396,"./template.hbs":397,"bfs-km-types":570}],396:[function(require,module,exports){
module.exports={
  "large": 0,
  "medium": 0,
  "small": 0,
  "xSmall?": 0
}

},{}],397:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<div class=\"crsl-item col-xs-";
  if (helper = helpers.xSmall) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.xSmall); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + " col-sm-";
  if (helper = helpers.small) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.small); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + " col-md-";
  if (helper = helpers.medium) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.medium); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + " col-lg-";
  if (helper = helpers.large) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.large); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-child-container>\n</div>\n";
  return buffer;
  });

},{"hbsfy/runtime":615}],398:[function(require,module,exports){
(function (global){
'use strict';

var types = require('bfs-km-types');

var View = require('../View.js');
var schema = require('./schema.json');

/**
 * A view component that presents a container. The container component adds the
 * left and right gutters and should be the parent component of layout
 * controlling cells.
 */
var Container = function Container(model, eventDispatcher, serviceRouter, configuration, environment) {
  if (!types.conforms(model, schema, true)) {
    throw new global.Error();
  }

  View.call(this, model, eventDispatcher, serviceRouter, configuration, environment);

  this.route();
};

types.extend(Container, View);

/**
 * A method that creates the html string for the view.
 */
Container.prototype.render = function () {
  return require('./template.hbs')(this.model);
};

Container.prototype.route = function () {
  this.setUpStandardImpressionLogging();
};

module.exports = Container;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../View.js":373,"./schema.json":399,"./template.hbs":400,"bfs-km-types":570}],399:[function(require,module,exports){
module.exports={
  "logs?":
  {
    "impression?": {}
  }
}

},{}],400:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  


  return "<div class=\"container bfs-container\" data-test-id=\"container\">\n  <div class=\"row\" data-child-container>\n  </div>\n</div>\n";
  });

},{"hbsfy/runtime":615}],401:[function(require,module,exports){
(function (global){
'use strict';

var types = require('bfs-km-types');

var View = require('../View.js');
var schema = require('./schema.json');

/**
 * A view component that presents a debug control panel. The view component is
 * positioned over any other content and provides tools, switches and overrides
 * that can aid development.
 */
var DebugControls = function DebugControls(model, eventDispatcher, serviceRouter, configuration, environment) {
  if (!types.conforms(model, schema, true)) {
    throw new global.Error();
  }

  View.call(this, model, eventDispatcher, serviceRouter, configuration, environment);

  this.overlayElement = this.documentFragment.find('[data-node="overlay"]');
  this.toggleElement = this.documentFragment.find('[data-node="toggle"]');
  this.reloadElement = this.documentFragment.find('[data-node="reload"]');
  this.controlsElement = this.documentFragment.find('[data-node="controls"]');
  this.appInfoElement = this.documentFragment.find('[data-node="appInfo"]');
  this.proxyEnabledSliderElement = this.documentFragment.find('[data-slider="proxyEnabledSlider"]');
  this.proxyPortCheckboxElement = this.documentFragment.find('[data-node="proxyPortCheckbox"]');
  this.proxyPortInputElement = this.documentFragment.find('[data-node="proxyPortInput"]');
  this.loggingEnabledSliderElement = this.documentFragment.find('[data-slider="loggingEnabledSlider"]');
  this.userCountryCheckboxElement = this.documentFragment.find('[data-node="userCountryCheckbox"]');
  this.userCountryInputElement = this.documentFragment.find('[data-node="userCountryInput"]');
  this.userLanguageCheckboxElement = this.documentFragment.find('[data-node="userLanguageCheckbox"]');
  this.userLanguageInputElement = this.documentFragment.find('[data-node="userLanguageInput"]');
  this.cachingEnabledSliderElement = this.documentFragment.find('[data-slider="cachingEnabledSlider"]');

  this.updateFormFromConfiguration();
  this.route();
};

types.extend(DebugControls, View);

/**
 * A method that is triggered by an interaction handler.
 */
DebugControls.prototype.onClickCachingEnabledSliderElement = function (element) {
  types.check.type(element, global.window.Element);

  if (this.cachingEnabledSliderElement.classList.toggle('enabled')) {
    this.configuration.removeValue('caching/enabled');
  } else {
    this.configuration.storeValue('caching/enabled', false);
  }
};

/**
 * A method that is triggered by an interaction handler.
 */
DebugControls.prototype.onClickLoggingEnabledSliderElement = function (element) {
  types.check.type(element, global.window.Element);

  if (this.loggingEnabledSliderElement.classList.toggle('enabled')) {
    this.configuration.storeValue('logging/enabled', true);
  } else {
    this.configuration.removeValue('logging/enabled');
  }
};

/**
 * A method that is triggered by an interaction handler.
 */
DebugControls.prototype.onClickProxyEnabledSliderElement = function (element) {
  types.check.type(element, global.window.Element);

  if (this.proxyEnabledSliderElement.classList.toggle('enabled')) {
    this.configuration.storeValue('proxy/enabled', true);
  } else {
    this.configuration.removeValue('proxy/enabled');
  }
};

/**
 * A method that is triggered by an interaction handler.
 */
DebugControls.prototype.onClickProxyPortCheckboxElement = function (element) {
  types.check.type(element, global.window.Element);

  if (this.proxyPortCheckboxElement.checked) {
    this.proxyPortInputElement.disabled = false;
    this.configuration.storeValue('debug-controls/port-enabled', true);
    this.updateProxyPortFromInput();
  } else {
    this.proxyPortInputElement.disabled = true;
    this.configuration.removeValue('proxy/port');
    this.configuration.removeValue('debug-controls/port-enabled');
  }
};

/**
 * A method that is triggered by an interaction handler.
 */
DebugControls.prototype.onClickReloadElement = function (element) {
  types.check.type(element, global.window.Element);

  this.eventDispatcher.dispatch('reload-view', {});
};

/**
 * A method that is triggered by an interaction handler.
 */
DebugControls.prototype.onClickToggleElement = function (element) {
  types.check.type(element, global.window.Element);

  if (this.controlsElement.classList.contains('hide')) {
    this.controlsElement.classList.remove('hide');
    this.configuration.storeValue('debug-controls/controls-visible', true);
  } else {
    this.controlsElement.classList.add('hide');
    this.configuration.removeValue('debug-controls/controls-visible');
  }
};

/**
 * A method that is triggered by an interaction handler.
 */
DebugControls.prototype.onClickUserCountryCheckboxElement = function (element) {
  types.check.type(element, global.window.Element);

  if (this.userCountryCheckboxElement.checked) {
    this.userCountryInputElement.disabled = false;
    this.configuration.storeValue('debug-controls/country-enabled', true);
    this.updateUserCountryFromInput();
  } else {
    this.userCountryInputElement.disabled = true;
    this.configuration.removeValue('user/country');
    this.configuration.removeValue('debug-controls/country-enabled');
  }
};

/**
 * A method that is triggered by an interaction handler.
 */
DebugControls.prototype.onClickUserLanguageCheckboxElement = function (element) {
  types.check.type(element, global.window.Element);

  if (this.userLanguageCheckboxElement.checked) {
    this.userLanguageInputElement.disabled = false;
    this.configuration.storeValue('debug-controls/language-enabled', true);
    this.updateUserLanguageFromInput();
  } else {
    this.userLanguageInputElement.disabled = true;
    this.configuration.removeValue('user/language');
    this.configuration.removeValue('debug-controls/language-enabled');
  }
};

/**
 * A method that is triggered by an interaction handler.
 */
DebugControls.prototype.onInputProxyPortInputElement = function (element) {
  types.check.type(element, global.window.Element);

  this.updateProxyPortFromInput();
};

/**
 * A method that is triggered by an interaction handler.
 */
DebugControls.prototype.onInputUserCountryInputElement = function (element) {
  types.check.type(element, global.window.Element);

  this.updateUserCountryFromInput();
};

/**
 * A method that is triggered by an interaction handler.
 */
DebugControls.prototype.onInputUserLanguageInputElement = function (element) {
  types.check.type(element, global.window.Element);

  this.updateUserLanguageFromInput();
};

/**
 * A method that creates the html string for the view.
 */
DebugControls.prototype.render = function () {
  var model;

  model = {
    proxy: {
      id: 'proxyEnabledSlider'
    },
    logging: {
      id: 'loggingEnabledSlider'
    },
    caching: {
      id: 'cachingEnabledSlider'
    }
  };

  return require('./template.hbs')(model);
};

/**
 * A method that registers the event routing for the view.
 */
DebugControls.prototype.route = function () {
  this.addInteractionHandler(this.toggleElement, 'click', this.onClickToggleElement);
  this.addInteractionHandler(this.reloadElement, 'click', this.onClickReloadElement);
  this.addInteractionHandler(this.proxyEnabledSliderElement, 'click', this.onClickProxyEnabledSliderElement);
  this.addInteractionHandler(this.proxyPortCheckboxElement, 'click', this.onClickProxyPortCheckboxElement);
  this.addInteractionHandler(this.proxyPortInputElement, 'input', this.onInputProxyPortInputElement);
  this.addInteractionHandler(this.loggingEnabledSliderElement, 'click', this.onClickLoggingEnabledSliderElement);
  this.addInteractionHandler(this.userCountryCheckboxElement, 'click', this.onClickUserCountryCheckboxElement);
  this.addInteractionHandler(this.userCountryInputElement, 'input', this.onInputUserCountryInputElement);
  this.addInteractionHandler(this.userLanguageCheckboxElement, 'click', this.onClickUserLanguageCheckboxElement);
  this.addInteractionHandler(this.userLanguageInputElement, 'input', this.onInputUserLanguageInputElement);
  this.addInteractionHandler(this.cachingEnabledSliderElement, 'click', this.onClickCachingEnabledSliderElement);
};

/**
 * A method that updates the proxy/port override from the value in the input
 * field.
 */
DebugControls.prototype.updateProxyPortFromInput = function () {
  var port;

  port = global.parseInt(this.proxyPortInputElement.value, 10);

  this.configuration.storeValue('proxy/port', port);
};

/**
 * A method that updates the user/country override from the value in the input
 * field.
 */
DebugControls.prototype.updateUserCountryFromInput = function () {
  var country;

  country = this.userCountryInputElement.value;

  this.configuration.storeValue('user/country', country);
};

/**
 * A method that updates the user/language override from the value in the input
 * field.
 */
DebugControls.prototype.updateUserLanguageFromInput = function () {
  var language;

  language = this.userLanguageInputElement.value;

  if (this.environment.isSupportedLocale(language)) {
    this.userLanguageInputElement.classList.remove('invalid');

    this.configuration.storeValue('user/language', language);
  } else {
    this.userLanguageInputElement.classList.add('invalid');
  }
};

/**
 * A method that queries the configuration for its current state and updates the
 * form with the returned values.
 */
DebugControls.prototype.updateFormFromConfiguration = function () {
  var defaultConfigurationState = this.configuration.getDefaultState();

  this.appInfoElement.textContent = defaultConfigurationState.getString('app/name') + ' ' + defaultConfigurationState.getString('app/version');

  this.configuration.getCurrentState(function (configurationState) {
    if (configurationState.getBooleanOr('proxy/enabled', false)) {
      this.proxyEnabledSliderElement.classList.add('enabled');
    }

    if (configurationState.hasNumber('proxy/port')) {
      this.proxyPortInputElement.value = '' + configurationState.getNumber('proxy/port');
    }

    if (configurationState.getBooleanOr('logging/enabled', false)) {
      this.loggingEnabledSliderElement.classList.add('enabled');
    }

    if (configurationState.hasString('user/country')) {
      this.userCountryInputElement.value = configurationState.getString('user/country');
    }

    if (configurationState.hasString('user/language')) {
      this.userLanguageInputElement.value = configurationState.getString('user/language');
    }

    if (configurationState.getBooleanOr('debug-controls/port-enabled', false)) {
      this.proxyPortCheckboxElement.checked = true;
      this.proxyPortInputElement.disabled = false;
    }

    if (configurationState.getBooleanOr('debug-controls/country-enabled', false)) {
      this.userCountryCheckboxElement.checked = true;
      this.userCountryInputElement.disabled = false;
    }

    if (configurationState.getBooleanOr('debug-controls/language-enabled', false)) {
      this.userLanguageCheckboxElement.checked = true;
      this.userLanguageInputElement.disabled = false;
    }

    if (configurationState.getBooleanOr('debug-controls/controls-visible', false)) {
      this.controlsElement.classList.remove('hide');
    }

    if (configurationState.getBooleanOr('caching/enabled', true)) {
      this.cachingEnabledSliderElement.classList.add('enabled');
    }
  }, this);
};

module.exports = DebugControls;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../View.js":373,"./schema.json":402,"./template.hbs":403,"bfs-km-types":570}],402:[function(require,module,exports){
module.exports={

}

},{}],403:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('../../../../glue/templates/slider.hbs');
HandlebarsCompiler.registerPartial('../../../../glue/templates/slider.hbs', partial$0);
var partial$1 = require('../../../../glue/templates/slider.hbs');
HandlebarsCompiler.registerPartial('../../../../glue/templates/slider.hbs', partial$1);
var partial$2 = require('../../../../glue/templates/slider.hbs');
HandlebarsCompiler.registerPartial('../../../../glue/templates/slider.hbs', partial$2);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n          ";
  stack1 = self.invokePartial(partials['../../../../glue/templates/slider.hbs'], '../../../../glue/templates/slider.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        ";
  return buffer;
  }

  buffer += "<div class=\"bfs-debug-controls-overlay\" data-node=\"overlay\">\n  <div class=\"bfs-debug-controls-buttons\">\n    <span class=\"bfs-debug-controls-button spoticon-refresh-32\" data-node=\"reload\"></span>\n    <span class=\"bfs-debug-controls-button spoticon-gears-32\" data-node=\"toggle\"></span>\n  </div>\n  <div class=\"bfs-debug-controls-controls hide\" data-node=\"controls\">\n\n    <div class=\"bfs-debug-controls-row\">\n      <div class=\"bfs-debug-controls-col-expanding\">\n        <h4 class=\"bfs-debug-controls-no-margin\" data-node=\"appInfo\"></h4>\n      </div>\n    </div>\n\n    <div class=\"bfs-debug-controls-row\">\n      <div class=\"bfs-debug-controls-col-expanding\">\n        <h4 class=\"bfs-debug-controls-no-margin\">Proxy</h4>\n      </div>\n    </div>\n\n    <div class=\"bfs-debug-controls-row\">\n      <div class=\"bfs-debug-controls-col-expanding\">\n        <p class=\"bfs-debug-controls-no-margin\">Enable backend development on your local machine using the HTTP proxy.</p>\n      </div>\n    </div>\n\n    <div class=\"bfs-debug-controls-row\">\n      <div class=\"bfs-debug-controls-col-wrapping\">\n        ";
  stack1 = helpers['with'].call(depth0, (depth0 && depth0.proxy), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      </div>\n    </div>\n\n    <div class=\"bfs-debug-controls-row\">\n      <div class=\"bfs-debug-controls-col-wrapping\">\n        <input data-node=\"proxyPortCheckbox\" type=\"checkbox\" />\n      </div>\n      <div class=\"bfs-debug-controls-col-expanding\">\n        <p class=\"bfs-debug-controls-no-margin\">Port:</p>\n      </div>\n      <div class=\"bfs-debug-controls-col-wrapping\">\n        <input class=\"bfs-debug-controls-input\" data-node=\"proxyPortInput\" disabled=\"disabled\" type=\"text\" />\n      </div>\n    </div>\n\n    <div class=\"bfs-debug-controls-row\">\n      <div class=\"bfs-debug-controls-col-expanding\">\n        <h4 class=\"bfs-debug-controls-no-margin\">Logging</h4>\n      </div>\n    </div>\n\n    <div class=\"bfs-debug-controls-row\">\n      <div class=\"bfs-debug-controls-col-expanding\">\n        <p class=\"bfs-debug-controls-no-margin\">Log messages to the console instead of the logging endpoint.</p>\n      </div>\n    </div>\n\n    <div class=\"bfs-debug-controls-row\">\n      <div class=\"bfs-debug-controls-col-wrapping\">\n        ";
  stack1 = helpers['with'].call(depth0, (depth0 && depth0.logging), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      </div>\n    </div>\n\n    <div class=\"bfs-debug-controls-row\">\n      <div class=\"bfs-debug-controls-col-expanding\">\n        <h4 class=\"bfs-debug-controls-no-margin\">Caching</h4>\n      </div>\n    </div>\n\n    <div class=\"bfs-debug-controls-row\">\n      <div class=\"bfs-debug-controls-col-expanding\">\n        <p class=\"bfs-debug-controls-no-margin\">Use the native response cache for Hermes requests. Disabling this will add a new cache entry for each request.</p>\n      </div>\n    </div>\n\n    <div class=\"bfs-debug-controls-row\">\n      <div class=\"bfs-debug-controls-col-wrapping\">\n        ";
  stack1 = helpers['with'].call(depth0, (depth0 && depth0.caching), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      </div>\n    </div>\n\n    <div class=\"bfs-debug-controls-row\">\n      <div class=\"bfs-debug-controls-col-expanding\">\n        <h4 class=\"bfs-debug-controls-no-margin\">Overrides</h4>\n      </div>\n    </div>\n\n    <div class=\"bfs-debug-controls-row\">\n      <div class=\"bfs-debug-controls-col-expanding\">\n        <p class=\"bfs-debug-controls-no-margin\">Override certain user attributes to test regionalized content programming. The overrides are only active in this app.</p>\n      </div>\n    </div>\n\n    <div class=\"bfs-debug-controls-row\">\n      <div class=\"bfs-debug-controls-col-wrapping\">\n        <input data-node=\"userCountryCheckbox\" type=\"checkbox\" />\n      </div>\n      <div class=\"bfs-debug-controls-col-expanding\">\n        <p class=\"bfs-debug-controls-no-margin\">Country:</p>\n      </div>\n      <div class=\"bfs-debug-controls-col-wrapping\">\n        <input class=\"bfs-debug-controls-input\" data-node=\"userCountryInput\" disabled=\"disabled\" type=\"text\" />\n      </div>\n    </div>\n\n    <div class=\"bfs-debug-controls-row\">\n      <div class=\"bfs-debug-controls-col-wrapping\">\n        <input data-node=\"userLanguageCheckbox\" type=\"checkbox\" />\n      </div>\n      <div class=\"bfs-debug-controls-col-expanding\">\n        <p class=\"bfs-debug-controls-no-margin\">Language:</p>\n      </div>\n      <div class=\"bfs-debug-controls-col-wrapping\">\n        <input class=\"bfs-debug-controls-input\" data-node=\"userLanguageInput\" disabled=\"disabled\" type=\"text\" />\n      </div>\n    </div>\n\n  </div>\n</div>\n";
  return buffer;
  });

},{"../../../../glue/templates/slider.hbs":188,"hbsfy/runtime":615}],404:[function(require,module,exports){
(function (global){
'use strict';

var types = require('bfs-km-types');

var View = require('../View.js');
var schema = require('./schema.json');

/**
 * A view component that can load data to display in its container only after
 * the view component is rendered.
 */
var DeferredContainer = function DeferredContainer(model, eventDispatcher, serviceRouter, configuration, environment) {
  if (!types.conforms(model, schema, true)) {
    throw new global.Error();
  }

  View.call(this, model, eventDispatcher, serviceRouter, configuration, environment);

  this.contentLoaded = false;
  this.pendingPageRequest = false;

  this.route();
};

types.extend(DeferredContainer, View);

/**
 * A method that creates the html string for the view.
 */
DeferredContainer.prototype.render = function () {
  return require('./template.hbs')(this.model);
};

/**
 * Extends attach method from View and loads content of the view if it was not
 * not loaded yet.
 */
DeferredContainer.prototype.attach = function (containerElement) {
  View.prototype.attach.call(this, containerElement);

  // TODO: Display throbber until content is loaded?

  this.loadContent();
};

/**
 * A method that loads the content of the view component.
 */
DeferredContainer.prototype.loadContent = function () {
  if (this.contentLoaded || this.pendingPageRequest) {
    return;
  }

  this.pendingPageRequest = true;

  this.serviceRouter.request(this.model.uri, function (view) {
    var childViews;
    var i;

    if (view === null) {
      this.contentLoaded = true;
      this.pendingPageRequest = false;

      // TODO: Display an error message?

      return;
    }

    childViews = view.childViews.slice();

    for (i = 0; i < childViews.length; i++) {
      this.addChild(childViews[i]);
    }

    view.destroy();

    this.contentLoaded = true;
    this.pendingPageRequest = false;

    this.environment.updateSpotifyEventsIn(this.childContainerElement);

    this.eventDispatcher.dispatch('deferred-content-load', {});
  }, this);
};

/**
 * The amount of deferred content loads for this single view
 */
DeferredContainer.prototype.nrOfDeferredContentLoads = function () {
  return 1;
};

module.exports = DeferredContainer;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../View.js":373,"./schema.json":405,"./template.hbs":406,"bfs-km-types":570}],405:[function(require,module,exports){
module.exports={
  "uri": ""
}

},{}],406:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  


  return "<div data-child-container>\n</div>\n";
  });

},{"hbsfy/runtime":615}],407:[function(require,module,exports){
(function (global){
'use strict';

var types = require('bfs-km-types');

var View = require('../View.js');
var schema = require('./schema.json');
var HUB_EMBEDDED_RESIZE = 'hub-embedded-resize';

/**
 * A view component that renders an iframe.
 */
var EmbeddedApp = function EmbeddedApp(model, eventDispatcher, serviceRouter, configuration, environment) {
  if (!types.conforms(model, schema, true)) {
    throw new global.Error();
  }

  View.call(this, model, eventDispatcher, serviceRouter, configuration, environment);

  this.hasBeenAttached = false;
  this.mainContainer = this.documentFragment.find('div');
  this.iframe = this.documentFragment.find('iframe');

  this.route();
};

types.extend(EmbeddedApp, View);

/**
 * A method that creates the html string for the view.
 */
EmbeddedApp.prototype.render = function () {
  var model = types.clone(this.model);
  model.origin = global.window.location.origin;
  model.postMessageName = HUB_EMBEDDED_RESIZE;

  return require('./template.hbs')(model);
};

/**
 * A method that registers the event routing for the view.
 */
EmbeddedApp.prototype.route = function () {
  this.addEventListener('window-message', this.onWindowMessage);
};

/**
 * Extends attach method from View. It shows the view if
 * it has been hidden (when `detach` is called).
 */
EmbeddedApp.prototype.attach = function (containerElement) {
  if (!this.hasBeenAttached) {
    View.prototype.attach.call(this, containerElement);
    this.hasBeenAttached = true;
  }

  this.mainContainer.classList.remove('hide');
};

/**
 * A method that detaches the document fragment of the view from its container
 * element.
 */
EmbeddedApp.prototype.detach = function () {
  this.mainContainer.classList.add('hide');
};

/**
 * A method that is triggered when a message is sent to the window.
 */
EmbeddedApp.prototype.onWindowMessage = function (data) {
  if (data.name !== HUB_EMBEDDED_RESIZE || data.uri !== this.model.uri) {
    return;
  }

  this.iframe.height = this.iframe.style.height = data.height + 'px';
};

module.exports = EmbeddedApp;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../View.js":373,"./schema.json":408,"./template.hbs":409,"bfs-km-types":570}],408:[function(require,module,exports){
arguments[4][405][0].apply(exports,arguments)
},{"dup":405}],409:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<div class=\"embedded-app-row hide\">\n  <iframe\n    src=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n    class=\"embedded-app-iframe\"\n    data-embedded=\"true\"\n    data-origin=\"";
  if (helper = helpers.origin) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.origin); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n    data-post-message-name=\"";
  if (helper = helpers.postMessageName) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.postMessageName); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n  </iframe>\n</div>\n";
  return buffer;
  });

},{"hbsfy/runtime":615}],410:[function(require,module,exports){
(function (global){
'use strict';

var types = require('bfs-km-types');

var View = require('../View.js');
var schema = require('./schema.json');

/**
 * A view component that presents an error screen. The view component is
 * positioned over any other content and may be used to indicate that an error
 * occured. A default message is used when both the "title" and "subtitle"
 * attributes are absent. The view component also supports an optional
 * call-to-action button.
 */
var ErrorScreen = function ErrorScreen(model, eventDispatcher, serviceRouter, configuration, environment) {
  if (!types.conforms(model, schema, true)) {
    throw new global.Error();
  }

  View.call(this, model, eventDispatcher, serviceRouter, configuration, environment);

  this.route();
};

types.extend(ErrorScreen, View);

/**
 * A method that creates the html string for the view.
 */
ErrorScreen.prototype.render = function () {
  var model;

  model = {};

  model.useDefaultError = true;

  if ('title' in this.model) {
    model.errorTitle = this.model.title;
    model.useDefaultError = false;
  }

  if ('subtitle' in this.model) {
    model.errorMessage = this.model.subtitle;
    model.useDefaultError = false;
  }

  if ('button' in this.model) {
    model.errorEscapeUrl = this.model.button.uri;
    model.errorEscapeMessage = this.model.button.title;
  }

  return require('./template.hbs')(model);
};

module.exports = ErrorScreen;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../View.js":373,"./schema.json":411,"./template.hbs":412,"bfs-km-types":570}],411:[function(require,module,exports){
module.exports={
  "button?":
  {
    "title": "",
    "uri": ""
  },
  "subtitle?": "",
  "title?": ""
}

},{}],412:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('../../../../glue/templates/error-and-offline.hbs');
HandlebarsCompiler.registerPartial('../../../../glue/templates/error-and-offline.hbs', partial$0);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, self=this;


  buffer += "<div class=\"show-error-screen\">\n  ";
  stack1 = self.invokePartial(partials['../../../../glue/templates/error-and-offline.hbs'], '../../../../glue/templates/error-and-offline.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n";
  return buffer;
  });

},{"../../../../glue/templates/error-and-offline.hbs":164,"hbsfy/runtime":615}],413:[function(require,module,exports){
(function (global){
'use strict';

var types = require('bfs-km-types');

var View = require('../View.js');
var schema = require('./schema.json');
var getGridBreakPoint = require('../../utils/getGridBreakPoint.js');

var NEXT_PAGE_MARGIN_BOTTOM_THRESHOLD_PX = 800;

/**
 * A view component that presents a grid of cells. The number of visible cells
 * may be controlled by the "layout" attribute. The view component also supports
 * infini-scrolling when the "nextPage" attribute is present.
 */
var Grid = function Grid(model, eventDispatcher, serviceRouter, configuration, environment) {
  if (!types.conforms(model, schema, true)) {
    throw new global.Error();
  }

  View.call(this, model, eventDispatcher, serviceRouter, configuration, environment);

  this.pendingPageRequest = false;
  this.numberOfVisibleChildren = null;

  if ('layout' in this.model) {
    this.model.layout.expansions = 0;
    this.model.layout.currentRows = this.model.layout.rows;
  }

  this.route();
};

types.extend(Grid, View);

/**
 * Overridden because the number of visible children might be controlled by the
 * grid.
 */
Grid.prototype.attach = function (containerElement) {
  var i;

  types.check.type(containerElement, global.window.Element);

  this.updateVisibility();

  if (this.numberOfVisibleChildren !== null) {
    if (this.childContainerElement !== null) {
      for (i = 0; i < this.numberOfVisibleChildren; i++) {
        this.childViews[i].attach(this.childContainerElement);
      }
    }

    this.documentFragment.attach(containerElement);
  } else {
    View.prototype.attach.call(this, containerElement);
  }
};

/**
 * A method that returns a string describing the current grid size.
 */
Grid.prototype.getMaximumNumberOfVisibleChildren = function () {
  var breakPoint;

  if ('layout' in this.model) {
    breakPoint = getGridBreakPoint();

    if (breakPoint === 'lg') {
      return this.model.layout.cols.large * this.model.layout.currentRows;
    }

    if (breakPoint === 'md') {
      return this.model.layout.cols.medium * this.model.layout.currentRows;
    }

    if (breakPoint === 'sm') {
      return this.model.layout.cols.small * this.model.layout.currentRows;
    }

    return (this.model.layout.cols.xSmall || this.model.layout.cols.small) * this.model.layout.currentRows;
  }

  return global.Infinity;
};

/**
 * A method that loads the next page for the grid.
 */
Grid.prototype.loadNextPage = function () {
  this.pendingPageRequest = true;

  this.serviceRouter.request(this.model.nextPage, function (view) {
    var childViews;
    var i;

    if (view !== null) {
      if (types.is.type(view, Grid)) {
        childViews = view.childViews.slice();

        for (i = 0; i < childViews.length; i++) {
          this.addChild(childViews[i]);
        }

        if ('nextPage' in view.model && childViews.length > 0) {
          this.model.nextPage = view.model.nextPage;
        } else {
          delete this.model.nextPage;
        }

        view.destroy();

        this.pendingPageRequest = false;

        this.environment.updateSpotifyEventsIn(this.childContainerElement);

        this.maybeLoadNextPage();
      } else {
        view.destroy();

        delete this.model.nextPage;

        this.pendingPageRequest = false;
      }
    } else {
      delete this.model.nextPage;

      this.pendingPageRequest = false;
    }
  }, this);
};

/**
 * A method that loads the next page for the grid if the next page should be
 * loaded.
 */
Grid.prototype.maybeLoadNextPage = function () {
  var scrollHeight;
  var innerHeight;
  var scrollY;
  var remainingHeight;

  if (this.documentFragment.isAttached()) {
    if (!this.pendingPageRequest) {
      if ('nextPage' in this.model) {
        scrollHeight = global.document.body.scrollHeight;
        innerHeight = global.window.innerHeight;
        scrollY = global.window.scrollY;

        remainingHeight = scrollHeight - (innerHeight + scrollY);

        if (remainingHeight <= NEXT_PAGE_MARGIN_BOTTOM_THRESHOLD_PX) {
          this.loadNextPage();
        }
      }
    }
  }
};

/**
 * A method that is triggered by an event listener.
 */
Grid.prototype.onClickAll = function (json) {
  types.check.object(json);

  if ('layout' in this.model && json.id === this.model.id) {
    this.model.layout.expansions++;
    this.model.layout.currentRows = global.Infinity;

    this.updateVisibility();
  }
};

/**
 * A method that is triggered by an event listener.
 */
Grid.prototype.onClickLess = function (json) {
  types.check.object(json);

  if ('layout' in this.model && json.id === this.model.id) {
    this.model.layout.expansions = 0;
    this.model.layout.currentRows = this.model.layout.rows;

    this.updateVisibility();

    this.eventDispatcher.dispatch('set-button-position', json);
  }
};

/**
 * A method that is triggered by an event listener.
 */
Grid.prototype.onClickMore = function (json) {
  types.check.object(json);

  if ('layout' in this.model && json.id === this.model.id) {
    this.model.layout.expansions++;
    this.model.layout.currentRows += this.model.layout.rows;

    this.updateVisibility();
  }
};

/**
 * A method that is triggered by an event listener.
 */
Grid.prototype.onRootViewUpdate = function (json) {
  types.check.object(json);

  this.updateVisibility();
  this.maybeLoadNextPage();
};

/**
 * A method that is triggered by an event listener.
 */
Grid.prototype.onWindowResize = function (json) {
  types.check.object(json);

  this.updateVisibility();
};

/**
 * A method that is triggered by an event listener.
 */
Grid.prototype.onWindowScroll = function (json) {
  types.check.object(json);

  this.maybeLoadNextPage();
};

/**
 * A method that creates the html string for the view.
 */
Grid.prototype.render = function () {
  return require('./template.hbs')(this.model);
};

/**
 * A method that registers the event routing for the view.
 */
Grid.prototype.route = function () {
  if ('layout' in this.model) {
    this.addEventListener('click-all', this.onClickAll);
    this.addEventListener('click-less', this.onClickLess);
    this.addEventListener('click-more', this.onClickMore);
    this.addEventListener('window-resize', this.onWindowResize);
  }

  if ('nextPage' in this.model) {
    this.addEventListener('window-scroll', this.onWindowScroll);
  }

  if ('layout' in this.model || 'nextPage' in this.model) {
    this.addEventListener('root-view-update', this.onRootViewUpdate);
  }
};

/**
 * A method that updates the visibility of the grid cells based on the current
 * layout settings.
 */
Grid.prototype.updateVisibility = function () {
  var visible;
  var hidden;
  var i;
  var json;

  if ('layout' in this.model) {
    visible = this.getMaximumNumberOfVisibleChildren();
    visible = global.Math.min(visible, this.childViews.length);

    if (this.numberOfVisibleChildren !== visible) {
      hidden = this.childViews.length - visible;

      for (i = 0; i < visible; i++) {
        this.childViews[i].attach(this.childContainerElement);
      }

      for (i = visible; i < this.childViews.length; i++) {
        this.childViews[i].detach();
      }

      this.environment.updateSpotifyEventsIn(this.childContainerElement);

      this.numberOfVisibleChildren = visible;

      json = {};

      json.id = this.model.id;
      json.expansions = this.model.layout.expansions;
      json.hidden = hidden;
      json.visible = visible;

      this.eventDispatcher.dispatch('grid-update', json);
    }
  }
};

module.exports = Grid;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../utils/getGridBreakPoint.js":371,"../View.js":373,"./schema.json":414,"./template.hbs":415,"bfs-km-types":570}],414:[function(require,module,exports){
module.exports={
  "id": "",
  "layout?":
  {
    "cols":
    {
      "large": 0,
      "medium": 0,
      "small": 0,
      "xSmall?": 0
    },
    "rows": 0
  },
  "nextPage?": ""
}

},{}],415:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  


  return "<div class=\"row standard-grid\" data-child-container>\n</div>\n";
  });

},{"hbsfy/runtime":615}],416:[function(require,module,exports){
(function (global){
'use strict';

var types = require('bfs-km-types');

var View = require('../View.js');
var schema = require('./schema.json');

/**
 * A view component that presents a header for the browse view. The view
 * component provides a container for the home page take over and creates a tab
 * bar from the "tabs" attribute.
 */
var HeaderBrowse = function HeaderBrowse(model, eventDispatcher, serviceRouter, configuration, environment) {
  if (!types.conforms(model, schema, true)) {
    throw new global.Error();
  }

  this.useNewHeaders = global.top && global.top.initialState ? !!global.top.initialState.newHeaders : false;

  View.call(this, model, eventDispatcher, serviceRouter, configuration, environment);

  this.hptoElement = this.documentFragment.find('[data-node="hpto"]');
  this.hptoWrapperElement = this.documentFragment.find('[data-node="hpto-wrapper"]');
  this.headerElement = this.documentFragment.find('[data-node="header"]');
  this.navbarElement = this.documentFragment.find('[data-node="navbar"]');

  this.route();

  this.onHptoRendered = function () {
    this.hptoWrapperElement.classList.remove('hide');
    this.headerElement.classList.add('hide');

    if (this.useNewHeaders) {
      this.navbarElement.classList.remove('hide');
      this.environment.updateSpotifyEventsIn(this.navbarElement);
    }

    this.environment.updateSpotifyEventsIn(this.hptoElement);
  }.bind(this);

  this.onHptoHidden = function () {
    this.hptoWrapperElement.classList.add('hide');
    this.headerElement.classList.remove('hide');

    if (this.useNewHeaders) {
      this.navbarElement.classList.add('hide');
      this.environment.updateSpotifyEventsIn(this.headerElement);
    } else {
      this.environment.updateSpotifyEventsIn(this.navbarElement);
    }
  }.bind(this);

  this.environment.createHomePageTakeOverFor(this.hptoElement, this.onHptoRendered, this.onHptoHidden);
};

types.extend(HeaderBrowse, View);

/**
 * A method that cleans up the instance in a way that should aid the garbage
 * collector.
 */
HeaderBrowse.prototype.destroy = function () {
  this.environment.destroyHomePageTakeOver(this.onHptoRendered, this.onHptoHidden);

  View.prototype.destroy.call(this);
};

/**
 * A method that determines if the view handles a change to the given list of
 * arguments.
 */
HeaderBrowse.prototype.handlesArgumentsChange = function (argumentsList) {
  var tabIdToShow;
  var i;

  types.check.array(argumentsList);

  if (argumentsList.length >= 1) {
    tabIdToShow = this.model.tabs[0].id;

    for (i = 1; i < this.model.tabs.length; i++) {
      if (this.model.tabs[i].id === argumentsList[0]) {
        tabIdToShow = this.model.tabs[i].id;

        break;
      }
    }

    this.eventDispatcher.dispatch('show-tab', {
      id: tabIdToShow
    });

    return true;
  }

  return false;
};

/**
 * A method that is triggered by an event listener.
 */
HeaderBrowse.prototype.onRootViewUpdate = function (json) {
  types.check.object(json);

  this.eventDispatcher.dispatch('show-tab', {
    id: this.model.tab
  });
};

/**
 * A method that creates the html string for the view.
 */
HeaderBrowse.prototype.render = function () {
  var templateData = types.clone(this.model);

  templateData.useNewHeaders = this.useNewHeaders;

  templateData.navBar = {
    'nav-items': templateData.tabs.map(function (tab) {
      return {
        id: tab.uri,
        name: tab.title,
        url: tab.uri
      };
    })
  };

  if (this.useNewHeaders) {
    templateData.pageHeader = {
      background: {
        type: 'color'
      },
      navBar: templateData.navBar,
      title: this.model.title
    };
  }

  return require('./template.hbs')(templateData);
};

/**
 * A method that registers the event routing for the view.
 */
HeaderBrowse.prototype.route = function () {
  this.addEventListener('root-view-update', this.onRootViewUpdate);

  this.setUpStandardImpressionLogging();
};

module.exports = HeaderBrowse;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../View.js":373,"./schema.json":417,"./template.hbs":418,"bfs-km-types":570}],417:[function(require,module,exports){
module.exports={
  "logs?":
  {
    "impression?": {}
  },
  "tab": "",
  "tabs":
  [
    {
      "id": "",
      "title": "",
      "uri": ""
    }
  ],
  "title": ""
}

},{}],418:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('../../../../glue/templates/headers/page-header.hbs');
HandlebarsCompiler.registerPartial('../../../../glue/templates/headers/page-header.hbs', partial$0);
var partial$1 = require('../../../../glue/templates/navbar.hbs');
HandlebarsCompiler.registerPartial('../../../../glue/templates/navbar.hbs', partial$1);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, self=this, functionType="function", escapeExpression=this.escapeExpression;

function program1(depth0,data) {
  
  
  return "\n      <div class=\"hpto-top-bar\"></div>\n    ";
  }

function program3(depth0,data) {
  
  
  return "\n          hpto-container--with-new-headers\n        ";
  }

function program5(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n      ";
  stack1 = self.invokePartial(partials['../../../../glue/templates/headers/page-header.hbs'], '../../../../glue/templates/headers/page-header.hbs', (depth0 && depth0.pageHeader), helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  return buffer;
  }

function program7(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      <div class=\"container\">\n        <h1 data-node=\"title\">";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</h1>\n      </div>\n    ";
  return buffer;
  }

  buffer += "<header class=\"app-header\">\n  <div data-node=\"hpto-wrapper\" class=\"hide\">\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.useNewHeaders), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    <div\n      data-node=\"hpto\"\n      class=\"\n        hpto-container\n        ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.useNewHeaders), {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      \"\n    ></div>\n  </div>\n  <div data-node=\"header\">\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.useNewHeaders), {hash:{},inverse:self.program(7, program7, data),fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n  <div data-node=\"navbar\">\n    ";
  stack1 = self.invokePartial(partials['../../../../glue/templates/navbar.hbs'], '../../../../glue/templates/navbar.hbs', (depth0 && depth0.navBar), helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n</header>\n\n<div class=\"app-content container bfs-container\">\n  <div class=\"row\" data-child-container>\n  </div>\n</div>\n";
  return buffer;
  });

},{"../../../../glue/templates/headers/page-header.hbs":180,"../../../../glue/templates/navbar.hbs":186,"hbsfy/runtime":615}],419:[function(require,module,exports){
(function (global){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _bfsKmTypes = require('bfs-km-types');

var _bfsKmTypes2 = _interopRequireDefault(_bfsKmTypes);

var _View2 = require('../View.js');

var _View3 = _interopRequireDefault(_View2);

var _schema = require('./schema.json');

var _schema2 = _interopRequireDefault(_schema);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * A view component that presents a header for the genre view. The view
 * component will show a cover image when the "image" attribute is present and
 * may also show a subtitle.
 */
var HeaderGenre = function (_View) {
  _inherits(HeaderGenre, _View);

  function HeaderGenre(model, eventDispatcher, serviceRouter, configuration, environment) {
    _classCallCheck(this, HeaderGenre);

    var _this = _possibleConstructorReturn(this, (HeaderGenre.__proto__ || Object.getPrototypeOf(HeaderGenre)).call(this, model, eventDispatcher, serviceRouter, configuration, environment));

    if (!_bfsKmTypes2.default.conforms(model, _schema2.default, true)) {
      throw new global.Error();
    }

    _this.route();
    return _this;
  }

  _createClass(HeaderGenre, [{
    key: 'render',
    value: function render() {
      var templateData = _bfsKmTypes2.default.clone(this.model);
      var modifiers = [];

      templateData.useNewHeaders = global.top && global.top.initialState ? !!global.top.initialState.newHeaders : false;

      if (!('image' in templateData)) {
        modifiers.push('bfs-header-no-image');
      }

      if (modifiers.length > 0) {
        templateData.modifiers = modifiers.join(' ');
      }

      if (templateData.useNewHeaders) {
        templateData.pageHeader = {
          background: {
            type: 'color'
          },
          title: templateData.title
        };

        if (templateData.subtitle) {
          templateData.pageHeader.description = templateData.subtitle;
        }

        if (templateData.image) {
          templateData.pageHeader.background = {
            type: 'image',
            imageUrl: templateData.image
          };

          templateData.pageHeader.useResponsiveHeightLarge = true;
        }
      }

      return require('./template.hbs')(templateData);
    }
  }, {
    key: 'route',
    value: function route() {
      this.setUpStandardImpressionLogging();
    }
  }]);

  return HeaderGenre;
}(_View3.default);

module.exports = HeaderGenre;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../View.js":373,"./schema.json":420,"./template.hbs":421,"bfs-km-types":570}],420:[function(require,module,exports){
module.exports={
  "image?": "",
  "logs?":
  {
    "impression?": {}
  },
  "subtitle?": "",
  "title": ""
}

},{}],421:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('../../../../glue/templates/headers/page-header.hbs');
HandlebarsCompiler.registerPartial('../../../../glue/templates/headers/page-header.hbs', partial$0);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, self=this, functionType="function", escapeExpression=this.escapeExpression;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n    ";
  stack1 = self.invokePartial(partials['../../../../glue/templates/headers/page-header.hbs'], '../../../../glue/templates/headers/page-header.hbs', (depth0 && depth0.pageHeader), helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n    <header\n      class=\"header header-image bfs-header-hub ";
  if (helper = helpers.modifiers) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.modifiers); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n      ";
  stack1 = helpers['with'].call(depth0, (depth0 && depth0.image), {hash:{},inverse:self.noop,fn:self.program(4, program4, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    >\n      <div class=\"content container\">\n        <h1 ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.subtitle), {hash:{},inverse:self.noop,fn:self.program(6, program6, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</h1>\n        ";
  stack1 = helpers['with'].call(depth0, (depth0 && depth0.subtitle), {hash:{},inverse:self.noop,fn:self.program(8, program8, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      </div>\n    </header>\n  ";
  return buffer;
  }
function program4(depth0,data) {
  
  var buffer = "";
  buffer += "style=\"background-image: url("
    + escapeExpression((typeof depth0 === functionType ? depth0.apply(depth0) : depth0))
    + ");\"";
  return buffer;
  }

function program6(depth0,data) {
  
  
  return "class=\"no-bottom-margin\"";
  }

function program8(depth0,data) {
  
  var buffer = "";
  buffer += "\n          <div class=\"info\">\n            <p class=\"subtitle\">"
    + escapeExpression((typeof depth0 === functionType ? depth0.apply(depth0) : depth0))
    + "</p>\n          </div>\n        ";
  return buffer;
  }

  buffer += "<div class=\"app-header\" data-node=\"header\">\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.useNewHeaders), {hash:{},inverse:self.program(3, program3, data),fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n\n<div class=\"app-content container\">\n  <div class=\"row\" data-child-container>\n  </div>\n</div>\n";
  return buffer;
  });

},{"../../../../glue/templates/headers/page-header.hbs":180,"hbsfy/runtime":615}],422:[function(require,module,exports){
'use strict';

exports.CardAlbum = require('./card-album/CardAlbum.js');
exports.CardArtist = require('./card-artist/CardArtist.js');
exports.CardChart = require('./card-chart/CardChart.js');
exports.CardEpisode = require('./card-episode/CardEpisode.js');
exports.CardLink = require('./card-link/CardLink.js');
exports.CardPlaylist = require('./card-playlist/CardPlaylist.js');
exports.CardProfile = require('./card-profile/CardProfile.js');
exports.Cell = require('./cell/Cell.js');
exports.Container = require('./container/Container.js');
exports.DebugControls = require('./debug-controls/DebugControls.js');
exports.DeferredContainer = require('./deferred-container/DeferredContainer.js');
exports.EmbeddedApp = require('./embedded-app/EmbeddedApp.js');
exports.ErrorScreen = require('./error-screen/ErrorScreen.js');
exports.Grid = require('./grid/Grid.js');
exports.HeaderBrowse = require('./header-browse/HeaderBrowse.js');
exports.HeaderGenre = require('./header-genre/HeaderGenre.js');
exports.ItemAlbum = require('./item-album/ItemAlbum.js');
exports.ItemConcert = require('./item-concert/ItemConcert.js');
exports.ListGroup = require('./list-group/ListGroup.js');
exports.OfflineScreen = require('./offline-screen/OfflineScreen.js');
exports.Puff = require('./puff/Puff.js');
exports.Section = require('./section/Section.js');
exports.SectionCarousel = require('./section-carousel/SectionCarousel.js');
exports.SectionGrid = require('./section-grid/SectionGrid.js');
exports.SectionGridButtons = require('./section-grid-buttons/SectionGridButtons.js');
exports.Tab = require('./tab/Tab.js');
exports.Tracklist = require('./tracklist/Tracklist.js');
exports.View = require('./View.js');

},{"./View.js":373,"./card-album/CardAlbum.js":374,"./card-artist/CardArtist.js":377,"./card-chart/CardChart.js":380,"./card-episode/CardEpisode.js":383,"./card-link/CardLink.js":386,"./card-playlist/CardPlaylist.js":389,"./card-profile/CardProfile.js":392,"./cell/Cell.js":395,"./container/Container.js":398,"./debug-controls/DebugControls.js":401,"./deferred-container/DeferredContainer.js":404,"./embedded-app/EmbeddedApp.js":407,"./error-screen/ErrorScreen.js":410,"./grid/Grid.js":413,"./header-browse/HeaderBrowse.js":416,"./header-genre/HeaderGenre.js":419,"./item-album/ItemAlbum.js":423,"./item-concert/ItemConcert.js":426,"./list-group/ListGroup.js":429,"./offline-screen/OfflineScreen.js":432,"./puff/Puff.js":435,"./section-carousel/SectionCarousel.js":438,"./section-grid-buttons/SectionGridButtons.js":441,"./section-grid/SectionGrid.js":444,"./section/Section.js":447,"./tab/Tab.js":450,"./tracklist/Tracklist.js":453}],423:[function(require,module,exports){
(function (global){
'use strict';

var types = require('bfs-km-types');

var View = require('../View.js');
var schema = require('./schema.json');

/**
 * A view component that presents an item for an album. The card provides
 * playback overlay controls. If the "image" attribute is absent, a placeholder
 * image is shown.
 */
var ItemAlbum = function ItemAlbum(model, eventDispatcher, serviceRouter, configuration, environment) {
  if (!types.conforms(model, schema, true)) {
    throw new global.Error();
  }

  View.call(this, model, eventDispatcher, serviceRouter, configuration, environment);

  this.route();
};

types.extend(ItemAlbum, View);

/**
 * A method that creates the html string for the view.
 */
ItemAlbum.prototype.render = function () {
  var model;
  var modifiers;

  model = types.clone(this.model);

  modifiers = [];

  modifiers.push('media-object-horizontal');
  modifiers.push('media-object-link');
  modifiers.push('media-object-medium');

  if ('image' in model) {
    model.imageUrl = model.image;
  } else {
    modifiers.push('show-placeholder');
  }

  if (modifiers.length > 0) {
    model.modifiers = modifiers.join(' ');
  }

  model.title = model.name;

  return require('./template.hbs')(model);
};

module.exports = ItemAlbum;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../View.js":373,"./schema.json":424,"./template.hbs":425,"bfs-km-types":570}],424:[function(require,module,exports){
module.exports={
  "artists?":
  [
    {
      "name": "",
      "uri": ""
    }
  ],
  "image?": "",
  "name": "",
  "uri": ""
}

},{}],425:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('../../../../glue/templates/media-object.hbs');
HandlebarsCompiler.registerPartial('../../../../glue/templates/media-object.hbs', partial$0);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, self=this;


  stack1 = self.invokePartial(partials['../../../../glue/templates/media-object.hbs'], '../../../../glue/templates/media-object.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"../../../../glue/templates/media-object.hbs":181,"hbsfy/runtime":615}],426:[function(require,module,exports){
(function (global){
'use strict';

var types = require('bfs-km-types');

var View = require('../View.js');
var schema = require('./schema.json');

/**
 * A view component that presents an item for a concert. The view component
 * requires most of the attributes to be present and have no special behaviour.
 */
var ItemConcert = function ItemConcert(model, eventDispatcher, serviceRouter, configuration, environment) {
  if (!types.conforms(model, schema, true)) {
    throw new global.Error();
  }

  View.call(this, model, eventDispatcher, serviceRouter, configuration, environment);

  this.route();
};

types.extend(ItemConcert, View);

/**
 * A method that is triggered by an interaction handler.
 */
ItemConcert.prototype.onClickDataLogClick = function (element) {
  var type;

  types.check.type(element, global.window.Element);

  type = element.getAttribute('data-log-click');

  if (type === 'concert-name') {
    if ('logs' in this.model && 'navigateToConcert' in this.model.logs) {
      this.logUIInteraction5(this.model.logs.navigateToConcert);
    }

    return;
  }
};

/**
 * A method that creates the html string for the view.
 */
ItemConcert.prototype.render = function () {
  return require('./template.hbs')(this.model);
};

/**
 * A method that registers the event routing for the view.
 */
ItemConcert.prototype.route = function () {
  this.documentFragment.query('[data-log-click]').forEach(function (element) {
    this.addInteractionHandler(element, 'click', this.onClickDataLogClick);
  }, this);

  this.setUpStandardImpressionLogging();
};

module.exports = ItemConcert;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../View.js":373,"./schema.json":427,"./template.hbs":428,"bfs-km-types":570}],427:[function(require,module,exports){
module.exports={
  "date":
  {
    "day": "",
    "month": ""
  },
  "logs?":
  {
    "impression?": {},
    "navigateToConcert?": {}
  },
  "name": "",
  "uri": "",
  "venue":
  {
    "city": "",
    "name": ""
  }
}

},{}],428:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      <div class=\"bfs-calendar-icon\">\n        <div class=\"bfs-calendar-month\">";
  if (helper = helpers.month) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.month); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n        <div class=\"bfs-calendar-day\">";
  if (helper = helpers.day) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.day); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n      </div>\n    ";
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      <div class=\"bfs-concert-info-venue\">";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + " &#x2022; ";
  if (helper = helpers.city) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.city); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n    ";
  return buffer;
  }

  buffer += "<div class=\"bfs-concert\">\n  <div class=\"bfs-concert-date\">\n    ";
  stack1 = helpers['with'].call(depth0, (depth0 && depth0.date), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n  <div class=\"bfs-concert-info\">\n    <div class=\"bfs-concert-info-name\">\n      <a class=\"bfs-concert-info-link\" href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"concert-name\">";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</a>\n    </div>\n    ";
  stack1 = helpers['with'].call(depth0, (depth0 && depth0.venue), {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n</div>\n";
  return buffer;
  });

},{"hbsfy/runtime":615}],429:[function(require,module,exports){
(function (global){
'use strict';

var types = require('bfs-km-types');

var View = require('../View.js');
var schema = require('./schema.json');

/**
 * A view component that presents a list of links. The view component requires
 * most of the attributes to be present and have no special behaviour.
 */
var ListGroup = function ListGroup(model, eventDispatcher, serviceRouter, configuration, environment) {
  if (!types.conforms(model, schema, true)) {
    throw new global.Error();
  }

  View.call(this, model, eventDispatcher, serviceRouter, configuration, environment);

  this.route();
};

types.extend(ListGroup, View);

/**
 * A method that creates the html string for the view.
 */
ListGroup.prototype.render = function () {
  return require('./template.hbs')(this.model);
};

module.exports = ListGroup;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../View.js":373,"./schema.json":430,"./template.hbs":431,"bfs-km-types":570}],430:[function(require,module,exports){
module.exports={
  "items":
  [
    {
      "title": "",
      "uri": ""
    }
  ],
  "title": ""
}

},{}],431:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n    <div class=\"list-group-item list-group-item-media\">\n      <a class=\"item-link\" href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n        <div class=\"item-data\">";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n      </a>\n    </div>\n  ";
  return buffer;
  }

  buffer += "<div class=\"bfs-list-group\" data-node=\"list-group\">\n  <div class=\"section-divider section-divider-borderless\">\n    <div>\n      <h2 class=\"section-divider-title\">";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</h2>\n    </div>\n  </div>\n  ";
  stack1 = helpers.each.call(depth0, (depth0 && depth0.items), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n";
  return buffer;
  });

},{"hbsfy/runtime":615}],432:[function(require,module,exports){
(function (global){
'use strict';

var types = require('bfs-km-types');

var View = require('../View.js');
var schema = require('./schema.json');

/**
 * A view component that presents an offline screen. The view component is
 * positioned over any other content and may be used to indicate that the
 * application is offline. A default message is used when both the "title"
 * and "subtitle" attributes are absent. The view component also supports an
 * optional call-to-action button.
 */
var OfflineScreen = function OfflineScreen(model, eventDispatcher, serviceRouter, configuration, environment) {
  if (!types.conforms(model, schema, true)) {
    throw new global.Error();
  }

  View.call(this, model, eventDispatcher, serviceRouter, configuration, environment);

  this.route();
};

types.extend(OfflineScreen, View);

/**
 * A method that creates the html string for the view.
 */
OfflineScreen.prototype.render = function () {
  var model;

  model = {};

  model.useDefaultOffline = true;

  if ('title' in this.model) {
    model.offlineTitle = this.model.title;
    model.useDefaultOffline = false;
  }

  if ('subtitle' in this.model) {
    model.offlineMessage = this.model.subtitle;
    model.useDefaultOffline = false;
  }

  if ('button' in this.model) {
    model.offlineEscapeUrl = this.model.button.uri;
    model.offlineEscapeMessage = this.model.button.title;
  }

  return require('./template.hbs')(model);
};

module.exports = OfflineScreen;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../View.js":373,"./schema.json":433,"./template.hbs":434,"bfs-km-types":570}],433:[function(require,module,exports){
arguments[4][411][0].apply(exports,arguments)
},{"dup":411}],434:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('../../../../glue/templates/error-and-offline.hbs');
HandlebarsCompiler.registerPartial('../../../../glue/templates/error-and-offline.hbs', partial$0);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, self=this;


  buffer += "<div class=\"show-offline-screen\">\n  ";
  stack1 = self.invokePartial(partials['../../../../glue/templates/error-and-offline.hbs'], '../../../../glue/templates/error-and-offline.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n";
  return buffer;
  });

},{"../../../../glue/templates/error-and-offline.hbs":164,"hbsfy/runtime":615}],435:[function(require,module,exports){
(function (global){
'use strict';

var types = require('bfs-km-types');

var View = require('../View.js');
var schema = require('./schema.json');

/**
 * A view component that presents a puff with three cover images. The view
 * component requires most of the attributes to be present and have no special
 * behaviour.
 */
var Puff = function Puff(model, eventDispatcher, serviceRouter, configuration, environment) {
  if (!types.conforms(model, schema, true)) {
    throw new global.Error();
  }

  View.call(this, model, eventDispatcher, serviceRouter, configuration, environment);

  this.route();
};

types.extend(Puff, View);

/**
 * A method that is triggered by an interaction handler.
 */
Puff.prototype.onClickDataLogClick = function (element) {
  var type;

  types.check.type(element, global.window.Element);

  type = element.getAttribute('data-log-click');

  if (type === 'puff') {
    if ('logs' in this.model && 'navigateToLink' in this.model.logs) {
      this.logUIInteraction5(this.model.logs.navigateToLink);
    }

    return;
  }
};

Puff.prototype._getTemplateData = function () {
  var model;
  var images;

  model = types.clone(this.model);

  images = [];

  if (model.images.middle === '') {
    images.push({
      modifiers: 'media-object-playlist show-placeholder'
    });
  } else {
    images.push({
      imageUrl: model.images.middle
    });
  }

  if (model.images.left === '') {
    images.push({
      modifiers: 'media-object-playlist show-placeholder'
    });
  } else {
    images.push({
      imageUrl: model.images.left
    });
  }

  if (model.images.right === '') {
    images.push({
      modifiers: 'media-object-playlist show-placeholder'
    });
  } else {
    images.push({
      imageUrl: model.images.right
    });
  }

  model.imageBackgroundUrl = model.images.middle;

  model.images = images;

  return model;
};

Puff.prototype._getTemplateDataNewCard = function () {
  var model;
  var images;

  model = types.clone(this.model);
  model.useNewCard = true;

  images = [];

  images.push({
    imageUrl: model.images.right
  });

  images.push({
    imageUrl: model.images.left
  });

  images.push({
    imageUrl: model.images.middle
  });

  model.images = images;

  return model;
};

/**
 * A method that creates the html string for the view.
 */
Puff.prototype.render = function () {
  var useNewCard = global.top && global.top.initialState ? !!global.top.initialState.newCards : false;
  var model = useNewCard ? this._getTemplateDataNewCard() : this._getTemplateData();

  return require('./template.hbs')(model);
};

/**
 * A method that registers the event routing for the view.
 */
Puff.prototype.route = function () {
  this.documentFragment.query('[data-log-click]').forEach(function (element) {
    this.addInteractionHandler(element, 'click', this.onClickDataLogClick);
  }, this);

  this.setUpStandardImpressionLogging();
};

module.exports = Puff;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../View.js":373,"./schema.json":436,"./template.hbs":437,"bfs-km-types":570}],436:[function(require,module,exports){
module.exports={
  "images":
  {
    "left": "",
    "middle": "",
    "right": ""
  },
  "logs?":
  {
    "impression?": {},
    "navigateToLink?": {}
  },
  "subtitle": "",
  "title": "",
  "uri": ""
}

},{}],437:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('../../../../glue/templates/cards/puff.hbs');
HandlebarsCompiler.registerPartial('../../../../glue/templates/cards/puff.hbs', partial$0);
var partial$1 = require('../../../../glue/templates/puff.hbs');
HandlebarsCompiler.registerPartial('../../../../glue/templates/puff.hbs', partial$1);
var partial$2 = require('../../../../glue/templates/puff.hbs');
HandlebarsCompiler.registerPartial('../../../../glue/templates/puff.hbs', partial$2);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n  ";
  stack1 = self.invokePartial(partials['../../../../glue/templates/cards/puff.hbs'], '../../../../glue/templates/cards/puff.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n  ";
  stack1 = self.invokePartial(partials['../../../../glue/templates/puff.hbs'], '../../../../glue/templates/puff.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  }

  stack1 = helpers['if'].call(depth0, (depth0 && depth0.useNewCard), {hash:{},inverse:self.program(3, program3, data),fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"../../../../glue/templates/cards/puff.hbs":163,"../../../../glue/templates/puff.hbs":187,"hbsfy/runtime":615}],438:[function(require,module,exports){
(function (global){
'use strict';

var types = require('bfs-km-types');

var View = require('../View.js');
var schema = require('./schema.json');

/**
 * A view component that presents a section carousel. The view component can
 * display an optional description.
 */
var SectionCarousel = function SectionCarousel(model, eventDispatcher, serviceRouter, configuration, environment) {
  if (!types.conforms(model, schema, true)) {
    throw new global.Error();
  }

  View.call(this, model, eventDispatcher, serviceRouter, configuration, environment);

  this.route();
};

types.extend(SectionCarousel, View);

/**
 * A method that creates the html string for the view.
 */
SectionCarousel.prototype.render = function () {
  return require('./template.hbs')(this.model);
};

module.exports = SectionCarousel;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../View.js":373,"./schema.json":439,"./template.hbs":440,"bfs-km-types":570}],439:[function(require,module,exports){
module.exports={
  "description?": "",
  "id": "",
  "title": "",
  "editorialTitle?": false
}

},{}],440:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <h4 class=\"section-divider-editorial-title\">";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</h4>\n      ";
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <h2 class=\"section-divider-title\">";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</h2>\n      ";
  return buffer;
  }

function program5(depth0,data) {
  
  var buffer = "";
  buffer += "\n        <p class=\"section-divider-description\">"
    + escapeExpression((typeof depth0 === functionType ? depth0.apply(depth0) : depth0))
    + "</p>\n      ";
  return buffer;
  }

  buffer += "<section>\n  <div>\n    <div class=\"section-divider\">\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.editorialTitle), {hash:{},inverse:self.program(3, program3, data),fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      <div class=\"section-auxiliary\">\n        <button class=\"button button-icon-only spoticon-chevron-left-16\" data-carousel=\"";
  if (helper = helpers.id) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.id); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-button=\"carousel-left\"></button>\n        <button class=\"button button-icon-only spoticon-chevron-right-16\" data-carousel=\"";
  if (helper = helpers.id) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.id); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-button=\"carousel-right\"></button>\n      </div>\n      ";
  stack1 = helpers['with'].call(depth0, (depth0 && depth0.description), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    </div>\n  </div>\n  <div class=\"carousel\" data-carousel=\"";
  if (helper = helpers.id) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.id); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-carousel-main>\n    <div class=\"row standard-grid\">\n      <div class=\"crsl-inner\" data-carousel-inner data-child-container>\n      </div>\n    </div>\n  </div>\n</section>\n";
  return buffer;
  });

},{"hbsfy/runtime":615}],441:[function(require,module,exports){
(function (global){
'use strict';

var types = require('bfs-km-types');

var View = require('../View.js');
var schema = require('./schema.json');

/**
 * A view component that presents a button for pagination control that may be
 * used in conjunction with the grids to load in more content.
 */
var SectionGridButtons = function SectionGridButtons(model, eventDispatcher, serviceRouter, configuration, environment) {
  if (!types.conforms(model, schema, true)) {
    throw new global.Error();
  }

  View.call(this, model, eventDispatcher, serviceRouter, configuration, environment);

  this.allElement = this.documentFragment.find('[data-node="all"]');
  this.containerElement = this.documentFragment.find('[data-node="container"]');
  this.lessElement = this.documentFragment.find('[data-node="less"]');
  this.moreElement = this.documentFragment.find('[data-node="more"]');

  this.route();
};

types.extend(SectionGridButtons, View);

/**
 * A method that is triggered by an interaction handler.
 */
SectionGridButtons.prototype.onClickAll = function (element) {
  types.check.type(element, global.window.Element);

  this.eventDispatcher.dispatch('click-all', {
    id: this.model.id
  });
};

/**
 * A method that is triggered by an interaction handler.
 */
SectionGridButtons.prototype.onClickLess = function (element) {
  var rect;

  types.check.type(element, global.window.Element);

  rect = element.getBoundingClientRect();

  this.eventDispatcher.dispatch('click-less', {
    id: this.model.id,
    top: rect.top
  });
};

/**
 * A method that is triggered by an interaction handler.
 */
SectionGridButtons.prototype.onClickMore = function (element) {
  types.check.type(element, global.window.Element);

  this.eventDispatcher.dispatch('click-more', {
    id: this.model.id
  });
};

/**
 * A method that is triggered by an event listener.
 */
SectionGridButtons.prototype.onGridUpdate = function (json) {
  var expansions;
  var hidden;
  var visible;

  types.check.object(json);

  if (types.conforms(json, { id: '', expansions: 0, hidden: 0, visible: 0 })) {
    if (json.id === this.model.id) {
      expansions = json.expansions;
      hidden = json.hidden;
      visible = json.visible;

      this.allElement.classList.add('hide');

      if (expansions === 0 && hidden > 0 && hidden <= visible) {
        this.allElement.classList.remove('hide');
      }

      if (expansions === 1 && hidden > 0) {
        this.allElement.classList.remove('hide');
      }

      this.lessElement.classList.add('hide');

      if (expansions > 0 && hidden === 0) {
        this.lessElement.classList.remove('hide');
      }

      this.moreElement.classList.add('hide');

      if (expansions === 0 && hidden > visible) {
        this.moreElement.classList.remove('hide');
      }
    }
  }
};

/**
 * A method that is triggered by an event listener.
 */
SectionGridButtons.prototype.onSetButtonPosition = function (json) {
  var rect;

  types.check.object(json);

  if (types.conforms(json, { id: '', top: 0 })) {
    if (json.id === this.model.id) {
      rect = this.containerElement.getBoundingClientRect();

      global.window.scrollBy(0, rect.top - json.top);
    }
  }
};

/**
 * A method that creates the html string for the view.
 */
SectionGridButtons.prototype.render = function () {
  return require('./template.hbs')(this.model);
};

/**
 * A method that registers the event routing for the view.
 */
SectionGridButtons.prototype.route = function () {
  this.addEventListener('grid-update', this.onGridUpdate);
  this.addEventListener('set-button-position', this.onSetButtonPosition);

  this.addInteractionHandler(this.allElement, 'click', this.onClickAll);
  this.addInteractionHandler(this.lessElement, 'click', this.onClickLess);
  this.addInteractionHandler(this.moreElement, 'click', this.onClickMore);
};

module.exports = SectionGridButtons;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../View.js":373,"./schema.json":442,"./template.hbs":443,"bfs-km-types":570}],442:[function(require,module,exports){
module.exports={
  "id": "",
  "titles":
  {
    "all": "",
    "less": "",
    "more": ""
  }
}

},{}],443:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n    <button type=\"button\" class=\"button button-with-stroke grid-button\" data-node=\"all\">\n      ";
  if (helper = helpers.all) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.all); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n    </button>\n    <button type=\"button\" class=\"button button-with-stroke grid-button\" data-node=\"less\">\n      ";
  if (helper = helpers.less) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.less); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n    </button>\n    <button type=\"button\" class=\"button button-with-stroke grid-button\" data-node=\"more\">\n      ";
  if (helper = helpers.more) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.more); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n    </button>\n  ";
  return buffer;
  }

  buffer += "<div class=\"text-center\" data-node=\"container\">\n  ";
  stack1 = helpers['with'].call(depth0, (depth0 && depth0.titles), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n";
  return buffer;
  });

},{"hbsfy/runtime":615}],444:[function(require,module,exports){
(function (global){
'use strict';

var types = require('bfs-km-types');

var View = require('../View.js');
var schema = require('./schema.json');
var getGridBreakPoint = require('../../utils/getGridBreakPoint.js');

/**
 * A view component that presents a section grid. The view component can display
 * an optional description. The number of visible cells may be controlled by the
 * "layout" attribute.
 */
var SectionGrid = function SectionGrid(model, eventDispatcher, serviceRouter, configuration, environment) {
  if (!types.conforms(model, schema, true)) {
    throw new global.Error();
  }

  View.call(this, model, eventDispatcher, serviceRouter, configuration, environment);

  this.numberOfVisibleChildren = null;

  if ('layout' in this.model) {
    this.model.layout.expansions = 0;
    this.model.layout.currentRows = this.model.layout.rows;
  }

  this.route();
};

types.extend(SectionGrid, View);

/**
 * Overridden because the number of visible children might be controlled by the
 * grid.
 */
SectionGrid.prototype.attach = function (containerElement) {
  var i;

  types.check.type(containerElement, global.window.Element);

  this.updateVisibility();

  if (this.numberOfVisibleChildren !== null) {
    if (this.childContainerElement !== null) {
      for (i = 0; i < this.numberOfVisibleChildren; i++) {
        this.childViews[i].attach(this.childContainerElement);
      }
    }

    this.documentFragment.attach(containerElement);
  } else {
    View.prototype.attach.call(this, containerElement);
  }
};

/**
 * A method that returns a string describing the current grid size.
 */
SectionGrid.prototype.getMaximumNumberOfVisibleChildren = function () {
  var breakPoint;

  if ('layout' in this.model) {
    breakPoint = getGridBreakPoint();

    if (breakPoint === 'lg') {
      return this.model.layout.cols.large * this.model.layout.currentRows;
    }

    if (breakPoint === 'md') {
      return this.model.layout.cols.medium * this.model.layout.currentRows;
    }

    if (breakPoint === 'sm') {
      return this.model.layout.cols.small * this.model.layout.currentRows;
    }

    return (this.model.layout.cols.xSmall || this.model.layout.cols.small) * this.model.layout.currentRows;
  }

  return global.Infinity;
};

/**
 * A method that is triggered by an event listener.
 */
SectionGrid.prototype.onClickAll = function (json) {
  types.check.object(json);

  if ('layout' in this.model && json.id === this.model.id) {
    this.model.layout.expansions++;
    this.model.layout.currentRows = global.Infinity;

    this.updateVisibility();
  }
};

/**
 * A method that is triggered by an event listener.
 */
SectionGrid.prototype.onClickLess = function (json) {
  types.check.object(json);

  if ('layout' in this.model && json.id === this.model.id) {
    this.model.layout.expansions = 0;
    this.model.layout.currentRows = this.model.layout.rows;

    this.updateVisibility();

    this.eventDispatcher.dispatch('set-button-position', json);
  }
};

/**
 * A method that is triggered by an event listener.
 */
SectionGrid.prototype.onClickMore = function (json) {
  types.check.object(json);

  if ('layout' in this.model && json.id === this.model.id) {
    this.model.layout.expansions++;
    this.model.layout.currentRows += this.model.layout.rows;

    this.updateVisibility();
  }
};

/**
 * A method that is triggered by an event listener.
 */
SectionGrid.prototype.onRootViewUpdate = function (json) {
  types.check.object(json);

  this.updateVisibility();
};

/**
 * A method that is triggered by an event listener.
 */
SectionGrid.prototype.onWindowResize = function (json) {
  types.check.object(json);

  this.updateVisibility();
};

/**
 * A method that creates the html string for the view.
 */
SectionGrid.prototype.render = function () {
  return require('./template.hbs')(this.model);
};

/**
 * A method that registers the event routing for the view.
 */
SectionGrid.prototype.route = function () {
  if ('layout' in this.model) {
    this.addEventListener('click-all', this.onClickAll);
    this.addEventListener('click-less', this.onClickLess);
    this.addEventListener('click-more', this.onClickMore);
    this.addEventListener('window-resize', this.onWindowResize);
    this.addEventListener('root-view-update', this.onRootViewUpdate);
  }
};

/**
 * A method that updates the visibility of the grid cells based on the current
 * layout settings.
 */
SectionGrid.prototype.updateVisibility = function () {
  var visible;
  var hidden;
  var i;
  var json;

  if ('layout' in this.model) {
    visible = this.getMaximumNumberOfVisibleChildren();
    visible = global.Math.min(visible, this.childViews.length);

    if (this.numberOfVisibleChildren !== visible) {
      hidden = this.childViews.length - visible;

      for (i = 0; i < visible; i++) {
        this.childViews[i].attach(this.childContainerElement);
      }

      for (i = visible; i < this.childViews.length; i++) {
        this.childViews[i].detach();
      }

      this.environment.updateSpotifyEventsIn(this.childContainerElement);

      this.numberOfVisibleChildren = visible;

      json = {};

      json.id = this.model.id;
      json.expansions = this.model.layout.expansions;
      json.hidden = hidden;
      json.visible = visible;

      this.eventDispatcher.dispatch('grid-update', json);
    }
  }
};

module.exports = SectionGrid;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../utils/getGridBreakPoint.js":371,"../View.js":373,"./schema.json":445,"./template.hbs":446,"bfs-km-types":570}],445:[function(require,module,exports){
module.exports={
  "description?": "",
  "id": "",
  "layout?":
  {
    "cols":
    {
      "large": 0,
      "medium": 0,
      "small": 0,
      "xSmall?": 0
    },
    "rows": 0
  },
  "title": ""
}

},{}],446:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "";
  buffer += "\n      <p class=\"section-divider-description\">"
    + escapeExpression((typeof depth0 === functionType ? depth0.apply(depth0) : depth0))
    + "</p>\n    ";
  return buffer;
  }

  buffer += "<section>\n  <div class=\"section-divider\">\n    <h2 class=\"section-divider-title\">";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</h2>\n    ";
  stack1 = helpers['with'].call(depth0, (depth0 && depth0.description), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n  <div class=\"row standard-grid\" data-child-container>\n  </div>\n</section>\n";
  return buffer;
  });

},{"hbsfy/runtime":615}],447:[function(require,module,exports){
(function (global){
'use strict';

var types = require('bfs-km-types');

var View = require('../View.js');
var schema = require('./schema.json');

/**
 * A view component that presents a section. The view component can display an
 * optional title and/or description and may show link to a drilldown view.
 */
var Section = function Section(model, eventDispatcher, serviceRouter, configuration, environment) {
  if (!types.conforms(model, schema, true)) {
    throw new global.Error();
  }

  View.call(this, model, eventDispatcher, serviceRouter, configuration, environment);

  this.route();
};

types.extend(Section, View);

/**
 * A method that is triggered by an interaction handler.
 */
Section.prototype.onClickDataLogClick = function (element) {
  var type;

  types.check.type(element, global.window.Element);

  type = element.getAttribute('data-log-click');

  if (type === 'show-all') {
    if ('logs' in this.model && 'navigateToShowAll' in this.model.logs) {
      this.logUIInteraction5(this.model.logs.navigateToShowAll);
    }

    return;
  }
};

/**
 * A method that creates the html string for the view.
 */
Section.prototype.render = function () {
  return require('./template.hbs')(this.model);
};

/**
 * A method that registers the event routing for the view.
 */
Section.prototype.route = function () {
  this.documentFragment.query('[data-log-click]').forEach(function (element) {
    this.addInteractionHandler(element, 'click', this.onClickDataLogClick);
  }, this);
};

module.exports = Section;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../View.js":373,"./schema.json":448,"./template.hbs":449,"bfs-km-types":570}],448:[function(require,module,exports){
module.exports={
  "description?": "",
  "id?": "",
  "link?":
  {
    "title": "",
    "uri": ""
  },
  "logs?":
  {
    "navigateToShowAll?": {}
  },
  "title?": ""
}

},{}],449:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "";
  buffer += "\n        <h2 class=\"section-divider-title\">"
    + escapeExpression((typeof depth0 === functionType ? depth0.apply(depth0) : depth0))
    + "</h2>\n      ";
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <div class=\"section-auxiliary\" data-node=\"show-all\">\n          <a href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"show-all\">";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</a>\n        </div>\n      ";
  return buffer;
  }

function program5(depth0,data) {
  
  var buffer = "";
  buffer += "\n        <p class=\"section-divider-description\" data-description>"
    + escapeExpression((typeof depth0 === functionType ? depth0.apply(depth0) : depth0))
    + "</p>\n      ";
  return buffer;
  }

  buffer += "<section>\n  <div class=\"section-divider-sticky-wrapper\">\n    <div class=\"section-divider\">\n      ";
  stack1 = helpers['with'].call(depth0, (depth0 && depth0.title), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = helpers['with'].call(depth0, (depth0 && depth0.link), {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = helpers['with'].call(depth0, (depth0 && depth0.description), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    </div>\n  </div>\n  <div class=\"section-divider-section-content\" data-child-container></div>\n</section>\n";
  return buffer;
  });

},{"hbsfy/runtime":615}],450:[function(require,module,exports){
(function (global){
'use strict';

var types = require('bfs-km-types');

var View = require('../View.js');
var schema = require('./schema.json');

/**
 * A view component that presents a tab. The view component may be used in
 * conjunction with headers supporting tab bars to switch the currently
 * displayed content.
 */
var Tab = function Tab(model, eventDispatcher, serviceRouter, configuration, environment) {
  if (!types.conforms(model, schema, true)) {
    throw new global.Error();
  }

  this.areChildrenShown = false;

  View.call(this, model, eventDispatcher, serviceRouter, configuration, environment);

  this.route();
};

types.extend(Tab, View);

/**
 * A method that attaches the document fragment of the view to the given
 * container element. The method is called recursively for each child view.
 */
Tab.prototype.attach = function (containerElement) {
  types.check.type(containerElement, global.window.Element);

  this.documentFragment.attach(containerElement);
};

/**
 * A method that is triggered by an event listener.
 */
Tab.prototype.onShowTab = function (json) {
  var i;

  types.check.object(json);

  if ('id' in this.model) {
    if (types.conforms(json, { id: '' })) {
      if (json.id === this.model.id) {
        this.areChildrenShown = true;
        for (i = 0; i < this.childViews.length; i++) {
          this.childViews[i].attach(this.childContainerElement);
        }

        this.environment.updateSpotifyEventsIn(this.childContainerElement);
      } else {
        this.areChildrenShown = false;
        for (i = 0; i < this.childViews.length; i++) {
          this.childViews[i].detach();
        }
      }
    }
  }
};

/**
 * A method that creates the html string for the view.
 */
Tab.prototype.render = function () {
  return require('./template.hbs')(this.model);
};

/**
 * A method that registers the event routing for the view.
 */
Tab.prototype.route = function () {
  if ('id' in this.model) {
    this.addEventListener('show-tab', this.onShowTab);
  }
};

/**
 * Used to deduce if a views children should be disregarded in the calculation of deferred content loads
 */
Tab.prototype.hasVisibleChildren = function () {
  return this.areChildrenShown && View.prototype.hasVisibleChildren.call(this);
};

module.exports = Tab;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../View.js":373,"./schema.json":451,"./template.hbs":452,"bfs-km-types":570}],451:[function(require,module,exports){
module.exports={
  "id?": ""
}

},{}],452:[function(require,module,exports){
arguments[4][406][0].apply(exports,arguments)
},{"dup":406,"hbsfy/runtime":615}],453:[function(require,module,exports){
(function (global){
'use strict';

var types = require('bfs-km-types');

var View = require('../View.js');
var schema = require('./schema.json');

/**
 * A view component that presents a list of tracks. The tracklist is playable
 * and shows the 5 first tracks until the button at the bottom is clicked.
 */
var Tracklist = function Tracklist(model, eventDispatcher, serviceRouter, configuration, environment) {
  if (!types.conforms(model, schema, true)) {
    throw new global.Error();
  }

  View.call(this, model, eventDispatcher, serviceRouter, configuration, environment);

  this.lessElement = this.documentFragment.find('[data-node="less"]');
  this.moreElement = this.documentFragment.find('[data-node="more"]');
  this.tracklistElement = this.documentFragment.find('[data-node="tracklist"]');

  this.makePlayableLiveModel();

  this.route();
};

types.extend(Tracklist, View);

/**
 * A method that makes the tracklist playable by creating a playable live model
 * from the given model.
 */
Tracklist.prototype.makePlayableLiveModel = function () {
  var model;

  model = {};

  model.rows = this.model.tracks.map(function (track) {
    return {
      track: types.clone(track)
    };
  }, this);

  model.uri = this.model.uri;

  this.environment.makeTracklistLiveModel(model.uri, model);
};

/**
 * A method that is triggered by an interaction handler.
 */
Tracklist.prototype.onClickLess = function (element) {
  var rectBefore;
  var rectAfter;
  var tracklistRect;

  types.check.type(element, global.window.Element);

  rectBefore = this.lessElement.getBoundingClientRect();

  this.lessElement.classList.add('hide');
  this.moreElement.classList.remove('hide');
  this.tracklistElement.classList.add('summary');

  rectAfter = this.moreElement.getBoundingClientRect();
  tracklistRect = this.tracklistElement.getBoundingClientRect();

  if (tracklistRect.top < 0) {
    global.window.scrollBy(0, rectAfter.top - rectBefore.top);
  }
};

/**
 * A method that is triggered by an interaction handler.
 */
Tracklist.prototype.onClickMore = function (element) {
  types.check.type(element, global.window.Element);

  this.lessElement.classList.remove('hide');
  this.moreElement.classList.add('hide');
  this.tracklistElement.classList.remove('summary');
};

/**
 * A method that creates the html string for the view.
 */
Tracklist.prototype.render = function () {
  var model;

  model = types.clone(this.model);

  model.rows = model.tracks.map(function (track) {
    return {
      track: types.clone(track)
    };
  }, this);

  return require('./template.hbs')(model);
};

/**
 * A method that registers the event routing for the view.
 */
Tracklist.prototype.route = function () {
  this.addInteractionHandler(this.lessElement, 'click', this.onClickLess);
  this.addInteractionHandler(this.moreElement, 'click', this.onClickMore);
};

module.exports = Tracklist;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../View.js":373,"./schema.json":454,"./template.hbs":455,"bfs-km-types":570}],454:[function(require,module,exports){
module.exports={
  "titles":
  {
    "less": "",
    "more": ""
  },
  "tracks":
  [
    {
      "album":
      {
        "name": "",
        "uri": ""
      },
      "artists":
      [
        {
          "name": "",
          "uri": ""
        }
      ],
      "duration": 0,
      "explicit?": false,
      "name": "",
      "popularity": 0,
      "unavailable?": false,
      "uri": ""
    }
  ],
  "uri": ""
}

},{}],455:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('../../../../glue/templates/tracklist-search.hbs');
HandlebarsCompiler.registerPartial('../../../../glue/templates/tracklist-search.hbs', partial$0);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n    <button type=\"button\" class=\"button button-with-stroke grid-button hide\" data-node=\"less\">\n      ";
  if (helper = helpers.less) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.less); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n    </button>\n    <button type=\"button\" class=\"button button-with-stroke grid-button\" data-node=\"more\">\n      ";
  if (helper = helpers.more) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.more); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n    </button>\n  ";
  return buffer;
  }

  buffer += "<div class=\"bfs-tracklist summary\" data-node=\"tracklist\">\n  ";
  stack1 = self.invokePartial(partials['../../../../glue/templates/tracklist-search.hbs'], '../../../../glue/templates/tracklist-search.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n<div class=\"text-center\">\n  ";
  stack1 = helpers['with'].call(depth0, (depth0 && depth0.titles), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n";
  return buffer;
  });

},{"../../../../glue/templates/tracklist-search.hbs":190,"hbsfy/runtime":615}],456:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _strings = require('../glue/strings');

var _strings2 = _interopRequireDefault(_strings);

var _interpolateString = require('./src/interpolate-string');

var _interpolateString2 = _interopRequireDefault(_interpolateString);

var _pickString = require('./src/pick-string');

var _pickString2 = _interopRequireDefault(_pickString);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

module.exports = function (locales) {
  if (!locales || (typeof locales === 'undefined' ? 'undefined' : _typeof(locales)) !== 'object') {
    throw new Error('' + 'Locale strings must be a plain object. ' + 'See spotify-i18n/README.md');
  }

  function getClientLocale() {
    var preference = typeof window !== 'undefined' && window && window.__spotify && window.__spotify.locale;
    return locales[preference] ? preference : 'en';
  }

  return {
    locale: getClientLocale,

    get: function get(key) {
      var parameters = Array.prototype.slice.call(arguments, 1);
      var string = (0, _pickString2.default)(locales, getClientLocale(), key, parameters[0]);
      if (typeof string === 'undefined') {
        return key;
      }
      var translation = (0, _interpolateString2.default)(string, parameters, getClientLocale());
      return translation;
    },

    getGlueString: function getGlueString(key) {
      var parameters = Array.prototype.slice.call(arguments, 1);
      var string = (0, _pickString2.default)(_strings2.default, getClientLocale(), key, parameters[0]);
      if (typeof string === 'undefined') {
        return key;
      }
      var translation = (0, _interpolateString2.default)(string, parameters, getClientLocale());
      return translation;
    },

    glueStrings: function glueStrings() {
      return _strings2.default[getClientLocale()];
    },

    appStrings: function appStrings() {
      return locales[getClientLocale()];
    }
  };
};

},{"../glue/strings":151,"./src/interpolate-string":457,"./src/pick-string":458}],457:[function(require,module,exports){
'use strict';

/**
 * Replaces placeholders with their corresponding parameters
 *
 * This used to be a part of the spotify-translations lib. That package was
 * absorbed into spotify-i18n during the addition of pluralization.
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = interpolateString;
function interpolateString(string) {
  var parameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var locale = arguments[2];

  var numberFormat = new Intl.NumberFormat(locale || 'en');

  return string.replace(/\{(\d+?)\}/g, function (str, num) {
    var value = parameters[num];

    if (typeof value === 'undefined') {
      return str;
    }

    if (typeof value === 'number') {
      return numberFormat.format(value);
    }

    return value;
  });
}

},{}],458:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

exports.default = pickString;

var _pluralization = require('./pluralization');

var _pluralization2 = _interopRequireDefault(_pluralization);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Selects the string for the given key
 *
 * This used to be a simple property existence check on the object containing
 * the strings. Now that we have proper pluralization it's become a little more
 * complex. Before, only the locale and key mattered. Now, we sometimes have to
 * run a pluralization check on the first parameter in case it's a count for a
 * plural form string.
 */
function pickString(strings, locale, key, count) {
  if (typeof strings[locale][key] === 'string') {
    return strings[locale][key];
  }

  if (_typeof(strings[locale][key]) === 'object') {
    var pluralizer = _pluralization2.default[locale];
    var pluralKey = pluralizer(count);
    if (strings[locale][key][pluralKey]) {
      return strings[locale][key][pluralKey];
    }
    if (strings[locale][key].other) {
      // This will mainly happen while waiting for translations to come back,
      // during which time the Polish lang file (for example) will contain the
      // English plural forms. Falling back to "other" covers this quite nicely.
      return strings[locale][key].other;
    }
  }

  // satisfy the consistent-return linter rule
  return undefined;
}

},{"./pluralization":459}],459:[function(require,module,exports){
'use strict';

var oneOther = function oneOther(n) {
  return n === 1 ? 'one' : 'other';
};
var other = function other() {
  return 'other';
};

var polish = function polish(n) {
  var mod10 = n % 10;
  var mod100 = n % 100;
  if (n === 1) {
    return 'one';
  }
  if ([2, 3, 4].indexOf(mod10) !== -1 && [12, 13, 14].indexOf(mod100) === -1) {
    return 'few';
  }
  if ([0, 1, 5, 6, 7, 8, 9].indexOf(mod10) !== -1 || [12, 13, 14].indexOf(mod100) !== -1) {
    return 'many';
  }
  return 'other';
};

var westSlavic = function westSlavic(n) {
  if (n === 1) {
    return 'one';
  }
  if (n >= 2 && n <= 4) {
    return 'few';
  }
  return 'other';
};

module.exports = {
  'cs': westSlavic,
  'en': oneOther,
  'de': oneOther,
  'el': oneOther,
  'es-419': oneOther,
  'es': oneOther,
  'fi': oneOther,
  'fr': oneOther,
  'fr-CA': oneOther,
  'hu': oneOther,
  'id': other,
  'it': oneOther,
  'ja': other,
  'nl': oneOther,
  'pl': polish,
  'pt-BR': oneOther,
  'sv': oneOther,
  'tr': oneOther,
  'zh-Hant': other,
  'zsm': other
};

},{}],460:[function(require,module,exports){
'use strict';

var base = 'spotify:internal:filterlist';
var regExp = /^spotify:internal:filterlist:([^:]*):(.*)$/;

/**
 * Create a URI representing a filtered variant of a list.
 *
 * @param {string} originUri The original list URI.
 * @param {string} query The query string (compatible with Core). Filter
 *     implementations might not look at all values.
 *
 * @return {string} URI of the filtered variant of the list. The URI will have
 *     the query string URL encoded.
 */
exports.create = function (originUri, query) {
  originUri = originUri.replace(/^spotify:/, '');

  query = encodeURIComponent(query);

  return [base, query, originUri].join(':');
};

/**
 * Get the query string from a filter URI.
 *
 * @param {string} filterUri The URI of the filtered list.
 *
 * @return {string} The query string, URL decoded. If URI is
 *     invalid, this returns an empty string.
 */
exports.getQuery = function (filterUri) {
  var matches = filterUri.match(regExp);
  if (!matches) return '';

  return decodeURIComponent(matches[1]);
};

/**
 * Get the URI of the original list.
 *
 * @param {string} filterUri The URI of the filtered list.
 *
 * @return {string} The URI of the original list. If the filter URI is invalid,
 *     this returns an empty string.
 */
exports.getOriginUri = function (filterUri) {
  var matches = filterUri.match(regExp);
  if (!matches) return '';

  return 'spotify:' + matches[2];
};

/**
 * Parse and return all parts of the filter URI.
 *
 * @param {string} filterUri The URI of the filtered list.
 *
 * @return {Object?} An object with properties `direction`, `query` and `originUri`,
 *     or null if the URI is not valid.
 */
exports.parse = function (filterUri) {
  var matches = filterUri.match(regExp);
  if (!matches) return null;

  return {
    query: decodeURIComponent(matches[1]),
    originUri: 'spotify:' + matches[2]
  };
};

/**
 * Test if the provided URI is a valid filter URI.
 *
 * @param {string} filterUri The URI of the filtered list.
 *
 * @return {boolean} True if it's valid, false otherwise.
 */
exports.isValid = function (filterUri) {
  return regExp.test(filterUri);
};

/**
 * The regular expression that matches filter URIs.
 */
exports.regExp = regExp;

},{}],461:[function(require,module,exports){
'use strict';

var Range = require('../spotify-range2');

/**
 * Get the needed operations for inserting items at a specific index.
 *
 * @param {Array} items Array of items to insert.
 * @param {number} index Index to insert the items at, relative to the list
 *     before the operations.
 *
 * @return {Array.<Object>} Array of operation objects.
 */
function getInsertOperations(items, index) {
  return [{ type: 'insert', index: index, values: items }];
}

/**
 * Get the needed operations for removing items from the specified indices.
 *
 * @param {Array.<number>} indices Array of indices relative to the list before
 *     the operations.
 *
 * @return {Array.<Object>} Array of operation objects.
 */
function getRemoveOperations(indices) {
  var ranges = Range.fromIndices(indices);

  var removed = 0;
  var operations = [];

  for (var r = 0, range; ranges[r]; r++) {
    range = ranges[r];
    operations.push({ type: 'remove', index: range.start - removed, length: range.length });
    removed += range.length;
  }

  return operations;
}

/**
 * Get the needed operations for moving items from a set of indices to a
 * target index.
 *
 * @param {Array.<number>} fromIndices Array of indices relative to the list
 *     before the operations.
 * @param {number} toIndex Index to move the items to, relative to the list
 *     before the operations.
 *
 * @return {Array.<Object>} Array of operation objects.
 */
function getMoveOperations(fromIndices, toIndex) {
  // We're going through one range at a time, and when a range is moved down,
  // we need to decrease the start of the next range to account for the
  // range we moved down (since each operation is based on the result of
  // the previous operation).
  var movedAbove = 0;

  // The maximum index starts at the index we want to move to.
  // When operations are created to move ranges, this maximum index
  // is increased to always point to the bottom index of the moved
  // items. If five items are moved from far down up to the 'to' index,
  // the new maxIndex will be toIndex + 5.
  var maxIndex = toIndex;

  var ranges = Range.fromIndices(fromIndices);
  var r;
  var range;
  var toRange;

  // Find any range that intersects with the 'to' index. Referred below as
  // the 'to' range. This range can't be split, so we need to move items to
  // positions above or below this range if it exists.
  for (r = 0; ranges[r]; r++) {
    range = ranges[r];
    if (range.start <= toIndex && range.end >= toIndex) {
      toRange = range;
      break;
    }
  }

  var operations = [];

  for (r = 0; ranges[r]; r++) {
    range = ranges[r];
    var length = range.length;
    var to;
    var from = range.start - movedAbove;

    // If the 'to' index is inside a range
    if (toRange) {
      // Range is above the 'to' range, so move it to right above that range.
      if (range.end < toRange.start) {
        from = range.start - movedAbove;
        to = toRange.start - length;
        movedAbove += length;

        // Range is the 'to' range, which means it will not move anywhere.
      } else if (range === toRange) {
        maxIndex = Math.max(maxIndex, range.end);
        continue;

        // Range is below the 'to' range, so move it to the maximum index
        // we've reached so far.
      } else {
        from = range.start;
        to = maxIndex;
        maxIndex = Math.max(maxIndex, to + length);
      }
      // If the 'to' index is not inside a range
    } else {
      // Range is above the 'to' index, so move it to right above the maximum index.
      if (range.end < toIndex) {
        from = range.start - movedAbove;
        to = maxIndex - length;
        movedAbove += length;

        // Range is below the 'to' index, so move it to the maximum index we've
        // reached so far.
      } else {
        from = range.start;
        to = maxIndex;
        maxIndex = Math.max(maxIndex, to + length);
      }
    }

    operations.push({ type: 'move', from: from, length: length, to: to });
  }

  return operations;
}

exports.getInsertOperations = getInsertOperations;
exports.getRemoveOperations = getRemoveOperations;
exports.getMoveOperations = getMoveOperations;

},{"../spotify-range2":551}],462:[function(require,module,exports){
(function (global){
'use strict';

var live = require('../../spotify-live');
var cosmos = require('../util/cosmos');
var Collection = require('./collection');

var endpoints = {
  isInCollection: 'sp://core-collection/v1/contains',
  updateIsInCollection: 'sp://core-collection/v1/items',
  changes: 'hm://collection-web/v1/@/changes',
  broadcast: 'sp://messages/v1/collectionstate',
  pubsub: 'hm://collection/collection/@/json'
};

var onCollectionPublish = function onCollectionPublish(error, response) {
  if (error) {
    if (global.console) console.error(error);
    return;
  }

  // Currently, we only store tracks in collection2, and derive albums from
  // these. Because of this, we only get tracks in the pubsub events, but
  // adding/removing a track might have altered the calculated Collection state
  // of its album. To check this, we pass the change set down to
  // the changes endpoint and will receive a list of objects with
  // uri and isInCollection properties that we can forward to live.
  cosmos.sanitizeURL(endpoints.changes, function (error, url) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    // FIXME: Hack alert
    // Because of enum weirdness in Java, we need to
    // uppercase the value in the type field.
    // Remove this map once FESK-1921 is fixed.
    response.body.items = response.body.items.map(function (item) {
      item.type = item.type.toUpperCase();
      return item;
    });
    // End hack alert

    cosmos.post({ url: url, body: response.body }, function (error, response) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }
      response.body.items.forEach(function (item) {
        if (item.hasOwnProperty('isInCollection') && !item.hasOwnProperty('added')) {
          // Patch items to contain added
          item.added = item.isInCollection;
        }
      });
      live(response.body.items);
    });
  });
};

var albumCollection;
var broadcastSubscription;
var collectionSubscription;

var regExp = exports.matches = /^spotify:album:[^:]+$/;
var registered = false;
exports.register = function () {
  if (registered) return;
  registered = true;

  albumCollection = new Collection(endpoints);

  live.subscribe(regExp, 'publish', albumCollection.onPublish);
  live.subscribe(regExp, 'wait', albumCollection.onWait);

  broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, Collection.onBroadcast);
  collectionSubscription = cosmos.subscribe({ url: endpoints.pubsub }, onCollectionPublish);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'publish', albumCollection.onPublish);
  live.unsubscribe(regExp, 'wait', albumCollection.onWait);

  albumCollection = null;

  if (broadcastSubscription) {
    broadcastSubscription.cancel();
    broadcastSubscription = null;
  }

  if (collectionSubscription) {
    collectionSubscription.cancel();
    collectionSubscription = null;
  }
};

exports._endpoints = endpoints;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-live":512,"../util/cosmos":508,"./collection":464}],463:[function(require,module,exports){
'use strict';

var profile = require('./profile');

var regExp = exports.matches = /^spotify:artist:/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  profile.register(regExp);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  profile.unregister(regExp);
};

},{"./profile":468}],464:[function(require,module,exports){
(function (global){
'use strict';

// This model will take a URI and create a live model for that URI.
//
//
// It will listen for publish events on the live model. The publish
// events are only triggered when someone actually wants to update
// something on the backend.
// When a publish event is detected, it will:
//
// * If the changed property was "added", it will contact
//   the backend to update the stored collection state. If this
//   fails, it will set it to the opposite of what was pusblished.
//
// * On success, broadcast the changes to the rest of the client via
//   cosmos, as "isInCollection" / "isFollowing" and as "added".
//
// This model will also listen for update events on the live model.
// The update event will be triggered when someone changes the data
// on the live model, without an intention to update the backend.
// When an update event is detected, it will:
//
// This model will also listen for broadcast events from the rest
// of the client. When a broadcast event is received, this happens:
//
// * If the URI for the broadcast message does not match this model,
//   do nothing.
//
// * It will then update the live model with the data it received
//   from the broadcast event. This will trigger the update listener
//   described above, but it won't run the code because all properties
//   are there.

var prime = require('../../../libs/prime');
var defer = require('../../../libs/prime/defer');

var live = require('../../spotify-live');
var contains = require('mout/array/contains');

var cosmos = require('../util/cosmos');

var INSUFFICIENT_STORAGE = 507;

// COLLECTION

var Collection = prime({

  constructor: function constructor(endpoints) {
    var self = this;
    this.endpoints = endpoints;
    this.onPublish = this.onPublish.bind(this);
    this.waitQueue = [];
    this.onWait = this.onWait.bind(this);
    this.fetch = this.fetch.bind(this);
  },

  onPublish: function onPublish(model, data) {
    // If the property is "added", update the backend with the new value
    // If the update fails, revert the state
    // If the update does not fail, broadcast the new state, as "isInCollection" and "added"
    if ('added' in data) {

      var endpoints = this.endpoints;
      var state = !!data.added;

      // optimistic
      model.update({ added: state });

      var method = state ? 'post' : 'delete';
      this._publish(method, [model], function (error, data) {
        if (error) {
          // that's what being optimistic gets you
          model.update({ added: !state });
          if (error.response && error.response.getStatusCode() === INSUFFICIENT_STORAGE) {
            cosmos.post({
              url: 'sp://messages/v1/container/user-message',
              body: { id: 'collection-limit-exceeded' }
            });
          }
        } else {
          cosmos.post({ url: endpoints.broadcast, body: { uri: model.uri, isInCollection: state, added: state } });
          if (data && data.items) {
            data.items.forEach(function (item) {
              // Patch items to contain added
              item.added = item.isInCollection;
              cosmos.post({ url: endpoints.broadcast, body: item });
            });
          }
        }
      });
    }
  },

  onWait: function onWait(model, properties) {
    if (contains(properties, 'added')) {
      this.fetch(model);
    }
  },

  fetch: function fetch(model) {
    var endpoints = this.endpoints;
    var queue = this.waitQueue;

    queue.push(model);

    // The first thing that gets added to the queue should defer a batch fetch
    // for the next tick. On the next tick, it will batch fetch status for all
    // models added to the queue.
    if (queue.length === 1) {
      defer.immediate(this._fetchBatch, this);
    }
  },

  _fetchBatch: function _fetchBatch() {
    var queue = this.waitQueue;
    if (queue.length === 0) return;

    // Create a new queue for requests coming after this
    this.waitQueue = [];

    this._contains(queue, function (error, result) {
      // Collection returns 404 for a user without a collection. This is sent as an error,
      // but we will just interpret that as `isInCollection` is false. All other errors
      // we just throw.
      if (error && (!error.response || error.response && error.response.getStatusCode() !== 404)) {
        if (global.console) console.error(error);
        return;
      }

      queue.forEach(function (model, i) {
        var added = false;
        if (!error) added = result[i];
        model.update({ added: added });
      });
    });
  },

  _contains: function _contains(models, callback) {
    var url = this.endpoints.isInCollection;
    var body = this._getRequestBody(models);

    cosmos.post({ url: url, body: body }, function (error, result) {
      callback(error, result && result.body && result.body.found);
    });
  },

  _publish: function _publish(method, models, callback) {
    var url = this.endpoints.updateIsInCollection;
    var body = this._getRequestBody(models);

    cosmos[method]({ url: url, body: body }, function (error, result) {
      callback(error, result && result.body);
    });
  },

  _getRequestBody: function _getRequestBody(models) {
    return {
      items: models.map(function (model) {
        return model.uri;
      }),
      source: global.__spotify && global.__spotify.app_uri || null
    };
  }

});

// ----------------------

Collection.onBroadcast = function (error, response) {
  if (error) {
    if (global.console) console.error(error);
    return;
  }

  var value;
  if ('added' in response.body) value = response.body.added;
  // Deal with older versions of this package that send isInCollection / isFollowing
  else if ('isInCollection' in response.body) value = response.body.isInCollection;

  live(response.body.uri).update({
    added: value
  });
};

module.exports = Collection;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../libs/prime":222,"../../../libs/prime/defer":220,"../../spotify-live":512,"../util/cosmos":508,"mout/array/contains":652}],465:[function(require,module,exports){
'use strict';

var album = require('./album');
var artist = require('./artist');
var playlist = require('./playlist');
var track = require('./track');
var user = require('./user');
var local = require('./local');

exports.register = function () {
  album.register();
  artist.register();
  playlist.register();
  track.register();
  user.register();
  local.register();
};

exports.unregister = function () {
  album.unregister();
  artist.unregister();
  playlist.unregister();
  track.unregister();
  user.unregister();
  local.unregister();
};

},{"./album":462,"./artist":463,"./local":466,"./playlist":467,"./track":469,"./user":470}],466:[function(require,module,exports){
'use strict';

var live = require('../../spotify-live');
var contains = require('mout/array/contains');

var onWait = function onWait(model, properties) {
  if (contains(properties, 'added')) {
    // Neither tracks nor albums or artists can ever be added to YM.
    model.update({ added: false });
  }
};

// Matches local track, albums and artists.
var regExp = exports.matches = /^spotify:local:[^:]*:[^:]*:[^:]*:\d*$|^spotify:local:[^:]*:[^:]*$|^spotify:local:[^:]*$/;
var registered = false;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
};

},{"../../spotify-live":512,"mout/array/contains":652}],467:[function(require,module,exports){
(function (global){
'use strict';

// The 'playlist' function will be called when a new live object is
// created for the pattern in playlist.matches. We use this function
// to automatically add data to the live model when requested, and to
// push any needed updates to the backend.
//
//
// It will listen for publish events on the live model. The publish
// events are only triggered when someone actually wants to update
// something on the backend.
// When a publish event is detected, it will:
//
// * Broadcast the changes to the rest of the client via cosmos.
//
// * If the changed property was `added`, it will contact
//   the backend to update the stored collection state for the
//   currently logged in user. If this fails, it will revert the
//   state for the live model and broadcast the reverted state.
//
// This function will also listen for update events on the live model.
// The update event will be triggered when someone changes the data
// on the live model, without an intention to update the backend.
// When an update event is detected, it will:
//
// This function will also listen for broadcast events from the rest
// of the client. When a broadcast event is received, this happens:
//
// * If the URI for the broadcast message does not match this model,
//   do nothing.
//
// * It will then update the live model with the data it received
//   from the broadcast event. This will trigger the update listener
//   described above, but it won't run the code because all properties
//   are there.

var contains = require('mout/array/contains');

var live = require('../../spotify-live');
var liburi = require('spotify-liburi');

var cosmos = require('../util/cosmos');
var bridge = require('../util/bridge').request;

var endpoints = {
  broadcast: 'sp://messages/v1/followstate'
};

function onPublish(model, data) {
  // If the property is "added", update the backend with the new
  // value. If the update fails somewhere along the way, revert the state
  // and broadcast the reverted state to the rest of the client.
  if ('added' in data) {
    model.update({ added: data.added });

    if (model.get('followersCount') != null) {
      model.update({
        followersCount: model.get('followersCount') + (data.added ? 1 : -1)
      });
    }

    updateBackend(model, !!data.added, function (error) {
      if (error) {
        // Revert optimistic change
        model.update({ added: !data.added });

        if (model.get('followersCount') != null) {
          model.update({
            followersCount: model.get('followersCount') + (!data.added ? 1 : -1)
          });
        }
      } else {
        broadcast(model);
      }
    });
  }
}

function onBroadcast(error, response) {
  if (error) {
    if (global.console) console.error(error);
    return;
  }
  var value;
  if ('added' in response.body) {
    value = response.body.added;
  } else if ('isFollowing' in response.body) {
    value = response.body.isFollowing;
  }

  if (value !== undefined) {
    live(response.body.uri).update({
      added: value
    });
  }
}

function fetchAdded(model) {
  cosmos.get({
    url: 'sp://core-playlist/v1/playlist/' + encodeURIComponent(model.uri) + '/metadata',
    body: {
      policy: {
        followed: true
      }
    }
  }, function (error, response) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    model.update({
      added: response.body.metadata.followed
    });
  });
}

function fetchFollowersCount(model) {
  bridge('playlist_subscribers_snapshot', [{ type: 'list', uri: model.uri }, 0, 0], function (error, data) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    model.update({
      followersCount: data.length
    });
  });
}

function getRequestData(callback) {
  // Assumes that the client live object either already has the data about the current user,
  // or that there is code included for getting this data on request.
  live('spotify:client').query('currentUser(username)', function (error, data) {
    if (error) return callback(error);

    callback(null, {
      username: data.currentUser.username
    });
  });
}

function broadcast(model) {
  var value = model.get('added');
  cosmos.post({
    url: endpoints.broadcast,
    body: {
      uri: model.uri,
      isFollowing: value,
      added: value
    }
  });
}

function updateBackend(model, added, callback) {
  if (added) {
    cosmos.post({
      url: 'sp://core-playlist/v1/rootlist',
      body: {
        operation: 'add',
        uris: [model.uri],
        before: 'start'
      }
    }, function (error, response) {
      if (error) return callback(error);
      model.update({
        added: true
      });
      callback(null);
    });
  } else {
    // Removing using Core needs the `rowId`, which we don't necessarily have,
    // so stick with old bridge message for now. It's only adding that needs to
    // be done using Core to fix KM-8804.
    bridge('library_unsubscribe', [liburi.profileURI(__spotify.username).toURI(), model.uri], function (error, data) {
      if (error) return callback(error, data);
      callback(null, data);
    });
  };
}

var onWait = function onWait(model, properties) {
  var needsAdded = contains(properties, 'added');
  var needsFollowersCount = contains(properties, 'followersCount');
  if (needsAdded) {
    var subscribed = model.get('subscribed');
    if (subscribed !== undefined) {
      model.update({ added: subscribed });
    } else {
      fetchAdded(model);
    }
  }
  if (needsFollowersCount) {
    fetchFollowersCount(model);
  }
};

var regExp = exports.matches = /^spotify:user:[^:]+:playlist:[^:]+$/;

var broadcastSubscription;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'publish', onPublish);
  live.subscribe(regExp, 'wait', onWait);
  broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, onBroadcast);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'publish', onPublish);
  live.unsubscribe(regExp, 'wait', onWait);

  broadcastSubscription.cancel();
  broadcastSubscription = null;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-live":512,"../util/bridge":506,"../util/cosmos":508,"mout/array/contains":652,"spotify-liburi":899}],468:[function(require,module,exports){
(function (global){
'use strict';

// This model will, when registered to live, listen for publish
// events on the live model. The publish events are only triggered
// when someone actually wants to update something on the backend.
// When a publish event is detected, it will:
//
// * Broadcast the changes to the rest of the client via cosmos.
//
// * If the changed property was isFollowing, it will contact
//   the backend to update the stored following state for the
//   currently logged in user. If this fails, it will revert the
//   state for the live model and broadcast the reverted state.
//
// This function will also listen for update events on the live model.
// The update event will be triggered when someone changes the data
// on the live model, without an intention to update the backend.
// When an update event is detected, it will:
//
// * If the changed property was isFollowing, it will automatically
//   update followersCount on the live model.
//
// This function will also listen for broadcast events from the rest
// of the client. When a broadcast event is received, this happens:
//
// * If the URI for the broadcast message does not match this model,
//   do nothing.
//
// * It will then update the live model with the data it received
//   from the broadcast event. This will trigger the update listener
//   described above, but it won't run the code because all properties
//   are there.
//

var intersection = require('mout/array/intersection');
var live = require('../../spotify-live');
var cosmos = require('../util/cosmos');
var requestsInProgress = {};

var endpoints = {
  isFollowing: 'hm://socialgraph/v2/is_following?format=json',
  followCounts: 'hm://socialgraph/v2/counts?format=json',
  updateIsFollowing: 'hm://socialgraph/v2/following?format=json',
  broadcast: 'sp://messages/v1/followstate'
};

function onUpdate(model, data) {

  // Only update followers count if that data was not present in the changed data
  if ('added' in data && !('followersCount' in data)) {
    var followersCount = model.get('followersCount');
    if (followersCount !== undefined) {
      var newFollowersCount = followersCount + (data.added ? 1 : -1);
      model.update({ followersCount: newFollowersCount });
    }
  }
}

function onPublish(model, data) {
  // If the property is added, update the backend with the new value.
  // If the update fails, revert the model state.
  // If the update is successful, broadcast the state to the client.
  if ('added' in data) {
    // if there is a request in course, do not launch a new request
    // as this can mess up with the Backend
    if (requestsInProgress[model.uri]) {
      return;
    }
    requestsInProgress[model.uri] = true;

    // we're optimistic this will work
    model.update({ 'added': data.added });

    updateBackend(model, !!data.added, function (error) {
      // request finished, we can accept more requests now
      delete requestsInProgress[model.uri];
      if (error) {
        // such is life.
        model.update({ added: !data.added });
      } else {
        model.update({ added: data.added });
        broadcast(model);
      }
    });
  }
}

function onBroadcast(error, response) {
  if (error) {
    if (global.console) console.error(error);
    return;
  }

  var body = response.body;
  var data = {};

  if ('added' in body) data.added = body.added;
  // Also accept broadcast from older versions that only send "isFollowing"
  else if ('isFollowing' in body) data.added = body.isFollowing;

  if ('followersCount' in body) data.followersCount = body.followersCount;
  if ('followingCount' in body) data.followingCount = body.followingCount;

  live(body.uri).update(data);
}

function onWait(model, properties) {
  if (intersection(properties, followProperties).length) getRequestData(model, function (error, data) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    updateIsFollowing(model, data);
    updateCounts(model, data);
  });
}

function updateIsFollowing(model, requestData, opt_callback) {
  var options = {
    url: endpoints.isFollowing,
    body: requestData
  };
  cosmos.get(options, function (error, response) {
    if (error && opt_callback) return opt_callback(error);
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    var value = response.body[0].is_following;
    model.update({ added: value });

    if (opt_callback) opt_callback();
  });
}

function updateCounts(model, requestData, opt_callback) {
  var options = {
    url: endpoints.followCounts,
    body: requestData
  };
  cosmos.get(options, function (error, response) {
    if (error && opt_callback) return opt_callback(error);
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    var body = response.body[0];

    model.update({
      followersCount: body.followers_count,
      followingCount: body.following_count
    });

    if (opt_callback) opt_callback();
  });
}

function getRequestData(model, callback) {
  // Assumes that the client live object either already has the data about the current user,
  // or that there is code included for getting this data on request.
  live('spotify:client').query('currentUser(uri)', function (error, data) {
    if (error) return callback(error);

    callback(null, {
      // Social graph v2 expects decoded uris (i.e. spotify:user:someone!
      // rather than spotify:user:someone%21). `currentUser(uri)` returns a
      // uri-encoded user name.
      source_uri: decodeURIComponent(data.currentUser.uri),
      target_uris: [decodeURIComponent(model.uri)]
    });
  });
}

function updateBackend(model, isFollowing, callback) {

  getRequestData(model, function (error, data) {
    if (error) return callback(error);
    var requestMethod = isFollowing ? 'post' : 'delete';
    cosmos[requestMethod]({ url: endpoints.updateIsFollowing, body: data }, function (error) {
      if (error) return callback(error);
      callback(null);
    });
  });
}

function broadcast(model) {
  var added = model.get('added');
  cosmos.post({
    url: endpoints.broadcast,
    body: {
      uri: model.uri,
      isFollowing: added,
      added: added,
      followersCount: model.get('followersCount'),
      followingCount: model.get('followingCount')
    }
  });
}

var followProperties = ['added', 'followersCount', 'followingCount'];

var broadcastSubscription;

exports.register = function (regExp) {
  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'update', onUpdate);
  live.subscribe(regExp, 'publish', onPublish);

  // reset the requestsInProgress variable
  requestsInProgress = {};

  if (!broadcastSubscription) {
    broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, onBroadcast);
  }
};

exports.unregister = function (regExp) {
  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'update', onUpdate);
  live.unsubscribe(regExp, 'publish', onPublish);

  if (broadcastSubscription) {
    broadcastSubscription.cancel();
    broadcastSubscription = null;
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-live":512,"../util/cosmos":508,"mout/array/intersection":661}],469:[function(require,module,exports){
(function (global){
'use strict';

var live = require('../../spotify-live');
var cosmos = require('../util/cosmos');
var Collection = require('./collection');

var endpoints = {
  isInCollection: 'sp://core-collection/v1/contains',
  updateIsInCollection: 'sp://core-collection/v1/items',
  broadcast: 'sp://messages/v1/collectionstate',
  pubsub: 'hm://collection/collection/@/json'
};

var onCollectionPublish = function onCollectionPublish(error, response) {
  if (error) {
    if (global.console) console.error(error);
    return;
  }

  var items = response.body.items;
  items.forEach(function (item) {
    // FIXME: Hack alert
    // Because of enum weirdness in Java, we need to
    // uppercase the value in the type field.
    // Remove this once FESK-1921 is fixed.
    if (item.type.toUpperCase() === 'TRACK') {
      var uri = 'spotify:track:' + item.identifier;
      live(uri).update({ added: !item.removed });
    }
  });
};

var trackCollection;
var broadcastSubscription;
var collectionSubscription;

var regExp = exports.matches = /^spotify:track:[^:]+$/;
var registered = false;
exports.register = function () {
  if (registered) return;
  registered = true;

  trackCollection = new Collection(endpoints);

  live.subscribe(regExp, 'publish', trackCollection.onPublish);
  live.subscribe(regExp, 'wait', trackCollection.onWait);

  broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, Collection.onBroadcast);
  collectionSubscription = cosmos.subscribe({ url: endpoints.pubsub }, onCollectionPublish);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'publish', trackCollection.onPublish);
  live.unsubscribe(regExp, 'wait', trackCollection.onWait);

  trackCollection = null;

  if (broadcastSubscription) {
    broadcastSubscription.cancel();
    broadcastSubscription = null;
  }

  if (collectionSubscription) {
    collectionSubscription.cancel();
    collectionSubscription = null;
  }
};

exports._endpoints = endpoints;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-live":512,"../util/cosmos":508,"./collection":464}],470:[function(require,module,exports){
'use strict';

var profile = require('./profile');

var regExp = exports.matches = /^spotify:user:[^:]+$/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  profile.register(regExp);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  profile.unregister(regExp);
};

},{"./profile":468}],471:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/album
 */
'use strict';

var live = require('../spotify-live');

var liburi = require('spotify-liburi');

var intersection = require('mout/array/intersection');
var contains = require('mout/array/contains');
var mixIn = require('mout/object/mixIn');

var bridge = require('./util/bridge').request;

function isLocalAlbum(uri) {
  return liburi.from(uri).type === liburi.Type.LOCAL_ALBUM;
}

function isLocalArtist(uri) {
  return liburi.from(uri).type === liburi.Type.LOCAL_ARTIST;
}

function updateMetadata(model) {
  if (isLocalAlbum(model.uri)) {
    var uriObject = liburi.from(model.uri);
    if (uriObject) {
      var data = {
        local: true,
        name: uriObject.album,
        artists: [{
          uri: 'spotify:local:',
          name: '',
          local: true
        }]
      };
      if (uriObject.artist) {
        data.artists[0].uri = liburi.localArtistURI(uriObject.artist).toURI();
        data.artists[0].name = uriObject.artist;
        data.artists[0].local = true;
      }
      model.update(data);
    }
  } else {
    bridge('album_metadata', [model.uri], function (error, payload) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }
      model.update(payload);
    });
  }
}

function updateLocal(model) {
  model.update({
    local: isLocalAlbum(model.uri)
  });
}

var idCounter = 1000;

function getRowUri(trackUri) {
  return trackUri.replace('spotify:', 'spotify:row:' + (++idCounter).toString(36) + ':');
}

function updateRows(model) {
  var descriptor = { type: 'list', uri: model.uri };

  bridge('album_tracks_snapshot', [descriptor, 0, 0, false], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    bridge('album_tracks_snapshot', [descriptor, 0, payload.length, false], function (error, payload) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }

      var discs = [];
      var uriId = liburi.from(model.uri).id;

      var rows = payload.metadata && payload.metadata.map(function (trackdata, i) {
        var track = mixIn({ uri: payload.array[i] }, trackdata);
        var discNum = track.disc ? track.disc - 1 : 0;
        track.unavailable = !track.playable;
        setLocalProperty(track);
        if (!discs[discNum]) {
          discs[discNum] = {
            rows: [],
            uri: uriId ? liburi.albumURI(uriId, discNum + 1).toURI() : ''
          };
        }
        var uri = getRowUri(track.uri);
        var trackObject = {
          track: track,
          uri: uri
        };
        discs[discNum].rows.push(trackObject);
        return trackObject;
      });

      model.update({ rows: rows, discs: discs });
    });
  });
}

function setLocalProperty(track) {
  if (track.album && track.album.uri) {
    track.album.local = isLocalAlbum(track.album.uri);
  }
  if (track.artists) {
    for (var i = 0, l = track.artists.length; i < l; i++) {
      var artist = track.artists[i];
      if (artist.uri) {
        artist.local = isLocalArtist(artist.uri);
      }
    }
  }
}

function onWait(model, properties) {
  var hasLocal = contains(properties, 'local');
  var hasRows = contains(properties, 'rows');
  var hasDiscs = contains(properties, 'discs');

  var metaFields = ['artists', 'image', 'images', 'name', 'playable', 'type', 'availability', 'date', 'label', 'copyrights'];

  var hasMetadata = !!intersection(properties, metaFields).length;

  if (hasMetadata) updateMetadata(model);
  if (hasRows || hasDiscs) updateRows(model);
  if (hasLocal) updateLocal(model);
}

var regExp = exports.matches = /^spotify:album:[0-9a-zA-Z]+$|^spotify:local:[^:]*:[^:]*$/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":512,"./util/bridge":506,"mout/array/contains":652,"mout/array/intersection":661,"mout/object/mixIn":692,"spotify-liburi":899}],472:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/application
 */
'use strict';

var live = require('../spotify-live');
var bridge = require('./util/bridge').request;
var AppState = require('../spotify-navigation/app-state');

var BACKOFF = 100;

function onMessage(message) {
  if (message.data && message.data.name) {
    if (message.data.name === 'set_active') {
      live('spotify:application').update({
        active: message.data.active
      });
    } else if (message.data.name === 'set_arguments') {
      // Arguments come as an array of un-encoded values, but we need to
      // concatenate them to a single colon-separated string for the
      // current design of the API. This is incorrect, as arguments should
      // be encoded if they are joined in a string. We should fix this, but
      // not without a breaking change.
      // https://jira.spotify.net/browse/KM-2353
      live('spotify:application').update({
        arguments: message.data.arguments.join(':')
      });
    } else if (message.data.name === 'set_state') {
      live('spotify:application').update({
        state: AppState.unserialize(message.data.state)
      });
    }
  }
}

function onRegister(model) {
  model.update({
    version: global.__spotify && global.__spotify.app_version || '0.0.0'
  });

  bridge('application_query', [], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    var data = {};
    if (payload.uri) data.appURI = payload.uri;
    if (payload.arguments) data.arguments = payload.arguments.join(':');
    if ('active' in payload) data.active = payload.active;

    model.update(data);
  });
}

var regExp = exports.matches = /^spotify:application$/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  global.addEventListener('message', onMessage);
  onRegister(live('spotify:application'));
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  global.removeEventListener('message', onMessage);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":512,"../spotify-navigation/app-state":544,"./util/bridge":506}],473:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/artist
 */
'use strict';

var liburi = require('spotify-liburi');
var contains = require('mout/array/contains');
var live = require('../spotify-live');
var bridge = require('./util/bridge').request;

function isLocalArtist(uri) {
  return liburi.from(uri).type === liburi.Type.LOCAL_ARTIST;
}

function updateMetadata(model) {
  if (isLocalArtist(model.uri)) {
    var uriObject = liburi.from(model.uri);
    if (uriObject) {
      model.update({
        local: true,
        name: uriObject.artist
      });
    }
  } else {
    bridge('artist_metadata', [model.uri], function (error, payload) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }
      if (!payload.image && !model.get('image')) payload.image = '';
      if (!payload.images && !model.get('images')) payload.images = [];
      model.update(payload);
    });
  }
}

function updateLocal(model) {
  model.update({
    local: isLocalArtist(model.uri)
  });
}

function onWait(model, properties) {
  var hasLocal = contains(properties, 'local');
  var hasMetadata = false;
  var metaFields = ['image', 'images', 'name', 'popularity'];
  for (var i = 0, l = properties.length; i < l; i++) {
    if (contains(metaFields, properties[i])) {
      hasMetadata = true;
      break;
    }
  }

  if (hasMetadata) updateMetadata(model);
  if (hasLocal) updateLocal(model);
}

var regExp = exports.matches = /^spotify:artist:|^spotify:local:[^:]*$/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":512,"./util/bridge":506,"mout/array/contains":652,"spotify-liburi":899}],474:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/client-storage
 */
'use strict';

var forOwn = require('mout/object/forOwn');
var combine = require('mout/array/combine');
var remove = require('mout/array/remove');
var contains = require('mout/array/contains');

var URI = 'spotify:client-storage';
var live = require('../spotify-live');
var cosmos = require('./util/cosmos');
var endpoints = {
  broadcast: 'sp://messages/v1/client-storage'
};

var waiting = [];

function onInit(model) {
  // Set a flag for showing that the model has been implemented and
  // registered. This is so that we can check this in player without
  // making a breaking change. Would be great with a future live API
  // to see if someone has implemented a specific model.
  model.update({ implemented: true });
}

function onWait(model, properties) {
  // Ask the top frame to broadcast the properties.
  // Values will be null when they weren't stored.
  waiting = combine(waiting, properties);
  global.top.postMessage({
    type: 'client_storage',
    name: 'broadcast_client_storage',
    data: properties
  }, '*');
}

function onPublish(model, properties) {
  // Tell the top frame to persist and broadcast
  global.top.postMessage({
    type: 'client_storage',
    name: 'set_client_storage',
    data: properties
  }, '*');

  // Optimistic update
  model.update(properties);
}

function onBroadcast(error, event) {
  var update = {};
  var model = live(URI);
  forOwn(event.body, function (value, key) {

    // Update model if this instance of storage knows that the model waits for it
    var isWaiting = contains(waiting, key);

    // Or if the model has a potentially outdated value in the live cache
    var hasKey = model.get(key) !== undefined;

    if (isWaiting || hasKey) update[key] = value;
    if (isWaiting) remove(waiting, key);
  });
  model.update(update);
}

var broadcastSubscription;
var regExp = exports.matches = new RegExp('^' + URI + '$');
var registered;

exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'init', onInit);
  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'publish', onPublish);
  broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, onBroadcast);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'init', onInit);
  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'publish', onPublish);

  if (broadcastSubscription) {
    broadcastSubscription.cancel();
    broadcastSubscription = null;
  }
  waiting.length = 0;
};

exports._endpoints = endpoints;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":512,"./util/cosmos":508,"mout/array/combine":651,"mout/array/contains":652,"mout/array/remove":663,"mout/object/forOwn":689}],475:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/client
 */
'use strict';

var live = require('../spotify-live');
var bridge = require('./util/bridge').request;
var liburi = require('spotify-liburi');

var BACKOFF = 100;

function updateCurrentUser(model) {
  bridge('user_metadata', ['spotify:user:@'], function (error, payload) {
    if (error) {
      if (global.__spotify && global.__spotify.username) {
        var username = global.__spotify.username;
        model.update({
          currentUser: {
            uri: liburi.profileURI(username).toURI(),
            username: username
          }
        });
      }

      if (global.console) console.error(error);
      return;
    }

    model.update({
      currentUser: {
        uri: liburi.profileURI(payload.username).toURI(),
        name: payload.name,
        username: payload.username
      }
    });
  });
}

function updateSessionData(model) {
  bridge('session_query', [], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    // Not all the clients expose employee property so it needs to be set if it does not exist
    if (payload.employee === undefined) {
      if (global.__spotify && global.__spotify.product_state && global.__spotify.product_state.employee) {
        // For Zelda
        payload.employee = global.__spotify.product_state.employee === '1' ? true : false;
      } else {
        // Clients older than 0.9.16 do not expose employee flag.
        payload.employee = false;
      }
    }

    model.update({ session: payload });

    // Initiate session subscription since data has been requested once.
    bridgeWaitSession(model);
  });
}

function bridgeWaitSession(model) {
  bridge('session_event_wait', [], function (error, event) {
    if (!registered) return;
    if (error) {
      setTimeout(function () {
        bridgeWaitSession(model);
      }, BACKOFF);
      if (global.console) console.error(error);
      return;
    }

    if (event.type === 'change') {
      model.get('session').update(event.data);
    }

    bridgeWaitSession(model);
  });
}

function showContextMenu(model, data) {
  if (global === window && window.top && window.top.postMessage) {
    window.top.postMessage({
      type: 'client_show_context_ui',
      data: data
    }, '*');
  }
}

function onWait(model, properties) {
  if (properties.indexOf('currentUser') > -1) {
    updateCurrentUser(model);
  }

  if (properties.indexOf('session') > -1) {
    updateSessionData(model);
  }
}

function onInit(model) {
  // Get container_features and put it into it's own place on the client model.
  var __spotify = global.__spotify || {};
  var containerFeatures = live(__spotify.container_features || {});
  containerFeatures.on('wait', function (properties) {
    var update = {};
    for (var i = 0, property; property = properties[i]; i++) {
      update[property] = false;
    }
    containerFeatures.update(update);
  });

  model.update({
    containerFeatures: containerFeatures
  });

  // Grab the username from __spotify where available
  if (global.__spotify && global.__spotify.username) {
    var username = global.__spotify.username;
    model.update({
      currentUser: {
        uri: liburi.profileURI(username).toURI(),
        username: username
      }
    });
  }

  // Async fetch from bridge to complete currentUser to a user model
  // while we don't have all the info available elsewhere.
  updateCurrentUser(model);
}

var regExp = exports.matches = /^spotify:client$/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'init', onInit);
  live.subscribe(regExp, 'show-context-menu', showContextMenu);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'init', onInit);
  live.unsubscribe(regExp, 'show-context-menu', showContextMenu);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":512,"./util/bridge":506,"spotify-liburi":899}],476:[function(require,module,exports){
'use strict';

var live = require('../spotify-live');
var cosmos = require('./util/cosmos');

function onWait(model, properties) {
  model.on('wait', function (keys) {
    if (keys.indexOf('episode') > -1) {
      cosmos.get({
        url: 'sp://core-show/unstable/decorate',
        body: { items: [model.uri] }
      }, function (error, data) {
        if (error) throw error;

        var episode = data.body.items[model.uri];
        model.update({ episode: episode });
      });
    }
  });
}

var regExp = exports.matches = /^spotify:episode:[^:]+$/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
};

},{"../spotify-live":512,"./util/cosmos":508}],477:[function(require,module,exports){
'use strict';

var album = require('./album');
var application = require('./application');
var artist = require('./artist');
var client = require('./client');
var clientStorage = require('./client-storage');
var sessionStorage = require('./session-storage');
var player = require('./player');
var playlist = require('./playlist');
var sortlist = require('./sortlist');
var track = require('./track');
var user = require('./user');
var add = require('./add');
var localFiles = require('./local-files');
var listVariant = require('./list-variant');
var episode = require('./episode');

exports.register = function () {
  album.register();
  application.register();
  artist.register();
  client.register();
  clientStorage.register();
  sessionStorage.register();
  player.register();
  playlist.register();
  sortlist.register();
  track.register();
  user.register();
  add.register();
  localFiles.register();
  listVariant.register();
  episode.register();
};

exports.unregister = function () {
  album.unregister();
  application.unregister();
  artist.unregister();
  client.unregister();
  clientStorage.unregister();
  sessionStorage.unregister();
  player.unregister();
  playlist.unregister();
  sortlist.unregister();
  track.unregister();
  user.unregister();
  add.unregister();
  localFiles.unregister();
  listVariant.unregister();
  episode.unregister();
};

},{"./add":465,"./album":471,"./application":472,"./artist":473,"./client":475,"./client-storage":474,"./episode":476,"./list-variant":478,"./local-files":479,"./player":484,"./playlist":488,"./session-storage":489,"./sortlist":497,"./track":504,"./user":505}],478:[function(require,module,exports){
/**
 * @module spotify-live-models/list-variant
 */
'use strict';

var contains = require('mout/array/contains');
var showUnplayableTracks = require('./util/unplayable-tracks-playlist-setting.js');
var legacySortUris = require('./sorting/legacy-sort-uris');

var live = require('../spotify-live');
var sortUriUtils = require('../spotify-live-sort-uri');
var filterUriUtils = require('../spotify-live-filter-uri');
var URI = require('spotify-liburi');

var SESSION_STORAGE = 'spotify:session-storage';
var CLIENT_STORAGE = 'spotify:client-storage';
var SORT_VARIANT_KEY = 'list-variant-';
var STRING_FILTER_KEY = 'list-filter-string-';

var sessionStorageListeners = {};

function onWait(model, properties) {
  if (!contains(properties, 'listVariant')) {
    return;
  }

  var uri = getOriginUri(model.uri);

  // listVariant objects are shared amongst all variants.
  var listVariant = live(uri).get('listVariant');
  if (!listVariant) {
    listVariant = live({
      origin: {
        uri: uri
      }
    });
    listVariant.on('wait', onVariantWait.bind(null, listVariant));
  }

  model.update({ listVariant: listVariant });

  // If the model is a variant, set that list variant on the origin too
  // so it can be accessed there for the next variant to ask.
  if (uri !== model.uri) {
    live(uri).update({ listVariant: listVariant });
  }
}

function onVariantWait(model, properties) {
  if (contains(properties, 'currentUri')) {
    addAndWatchCurrentUri(model);
    // This will fulfill and watch all other properties
    return;
  }

  if (contains(properties, 'filterString')) {
    addAndWatchFilterString(model);
  }
  if (contains(properties, 'sortQuery') || contains(properties, 'sortDirection') || contains(properties, 'sortUri')) {
    addAndWatchSortQuery(model);
  }
  if (contains(properties, 'showUnplayable')) {
    addAndWatchUnplayable(model);
  }
}

function addAndWatchCurrentUri(model) {

  model.on('update', update);
  update();

  function update() {
    var props = 'filterString, sortQuery, sortDirection, sortUri, showUnplayable, origin(uri)';
    model.query(props, function (error, data) {
      if (error) {
        console.error('Error when getting', props, ':', Error);
        return;
      }

      var result = data.origin.uri;
      var filters = [];

      if (data.filterString) {
        filters.push('text contains ' + encodeURIComponent(data.filterString));
      }

      if (!data.showUnplayable) {
        filters.push('playable eq true');
      }

      if (filters.length) {
        result = filterUriUtils.create(result, filters.join(','));
      }

      var sortUriParams = data.sortUri && sortUriUtils.parse(data.sortUri);

      if (sortUriParams) {
        result = sortUriUtils.create(result, sortUriParams.direction, sortUriParams.query);
      }

      model.update({
        currentUri: result
      });
    });
  }
}

function addAndWatchUnplayable(model) {
  var uri = model.get('origin').uri;
  var type = URI.fromString(uri).type;

  if (type !== URI.Type.PLAYLIST) {
    model.update({ showUnplayable: true });
    return;
  }

  live(uri).get('formatListType', function (error, formatListType) {
    if (error || formatListType !== 'chart') {
      subscribeToUnplayablePref(model);
    } else {
      model.update({ showUnplayable: true });
    }
  });
};

var showUnplayablePref;
var updateUnavailablePrefOn = [];

function subscribeToUnplayablePref(model) {
  updateUnavailablePrefOn.push(model);
  if (showUnplayablePref != null) {
    model.update({ showUnplayable: showUnplayablePref });
    return;
  }

  showUnplayableTracks.subscribe(function (error, showUnplayable) {
    // Cache this globally as we will never cancel this subscribe here.
    // The same setting is valid for all models.
    if (error) {
      console.error(error);
      showUnplayable = false; // Should default to hide unplayable.
    }

    showUnplayablePref = showUnplayable;
    for (var i = 0; i < updateUnavailablePrefOn.length; i++) {
      updateUnavailablePrefOn[i].update({ showUnplayable: showUnplayable });
    }
  });
}

function addAndWatchSortQuery(model) {
  var uri = model.get('origin').uri;

  var clientStorage = live(CLIENT_STORAGE);
  var key = SORT_VARIANT_KEY + uri;
  if (clientStorage.get('implemented')) {
    updateSortParams(model, uri, key);
    clientStorage.on('update', function (changed) {
      if (changed.hasOwnProperty(key)) {
        updateSortParams(model, uri, key);
      }
    });
  } else {
    // There is no clientStorage. Update the model with defaults.
    var update = getDefaultQueryParams(uri);
    model.update(update);
  }
}

function updateSortParams(model, uri, key) {
  var clientStorage = live(CLIENT_STORAGE);

  clientStorage.get(key, function (error, variant) {
    // Respond with the sort variant if it's a valid sort URI
    var sortParams = variant && sortUriUtils.parse(variant);
    if (!error && sortParams) {
      // Check for legacy sort URIs and convert them by publishing
      // the updated version on client-storage
      var convertedFromLegacy = legacySortUris.legacyQueries[sortParams.query];

      if (convertedFromLegacy != null && convertedFromLegacy !== sortParams.query) {
        // Fix the legacy query on storage
        var fixedUri = sortUriUtils.create(uri, sortParams.direction, convertedFromLegacy);
        var publish = {};
        publish[key] = fixedUri;
        clientStorage.publish(publish);
        // This will trigger another update which will then set the sort params.
        return;
      }

      model.update({
        sortQuery: sortParams.query,
        sortDirection: sortParams.direction, // this is 'asc' or 'desc'
        sortUri: variant
      });
    } else if (variant === uri) {
      // This was unsorted.
      model.update({
        sortQuery: null,
        sortDirection: null,
        sortUri: null
      });
    } else {
      // There was nothing valid in store. Update the model with defaults.
      var update = getDefaultQueryParams(uri);
      model.update(update);
    }
  });
}

function getDefaultQueryParams(uri) {
  var sortQuery = null;
  var sortDirection = null;
  var sortUri = null;

  var isLocalFiles = uri === 'spotify:internal:local-files';
  if (isLocalFiles) {
    // Local files should be sorted by trackname by default
    sortQuery = 'track(name)';
    sortDirection = 'asc';
    sortUri = sortUriUtils.create(uri, sortDirection, sortQuery);
  }

  return {
    sortQuery: sortQuery,
    sortDirection: sortDirection,
    sortUri: sortUri
  };
}

function addAndWatchFilterString(model) {
  var uri = model.get('origin').uri; // The variant object itself doesn't have a uri, this is the one for the list it's about
  var sessionStorage = live(SESSION_STORAGE);
  var key = STRING_FILTER_KEY + uri;

  if (sessionStorage.get('implemented')) {
    updateFilterString(model, uri, key);
    sessionStorage.on('update', function (changed) {
      if (changed.hasOwnProperty(key)) {
        updateFilterString(model, uri, key);
      }
    });
  } else {
    model.update({ 'filterString': '' });
  }
};

function updateFilterString(model, uri, key) {
  var sessionStorage = live(SESSION_STORAGE);

  sessionStorage.get(key, function (error, value) {
    model.update({ 'filterString': value || '' });
  }, live.ASAP);
}

function getOriginUri(uri) {
  var sorted = sortUriUtils.parse(uri);
  if (sorted) uri = sorted.originUri;

  var filtered = filterUriUtils.parse(uri);
  if (filtered) uri = filtered.originUri;

  return uri;
}

function updateRegisteredStatus(status) {
  registered = status;
  live('spotify:list-variant').update({ implemented: status });
}

var regExp = exports.matches = /^spotify:/;
var registered;
exports.register = function () {
  if (registered) return;

  live.subscribe(regExp, 'wait', onWait);
  updateRegisteredStatus(true);
};

exports.unregister = function () {
  if (!registered) return;

  updateUnavailablePrefOn = [];
  showUnplayablePref = null;

  live.unsubscribe(regExp, 'wait', onWait);
  updateRegisteredStatus(false);
};

},{"../spotify-live":512,"../spotify-live-filter-uri":460,"../spotify-live-sort-uri":510,"./sorting/legacy-sort-uris":491,"./util/unplayable-tracks-playlist-setting.js":509,"mout/array/contains":652,"spotify-liburi":899}],479:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/local-files
 */
'use strict';

var contains = require('mout/array/contains');

var live = require('../spotify-live');
var listOperations = require('../spotify-live-list-operations');
var liburi = require('spotify-liburi');
var Range = require('../spotify-range2');
var cosmos = require('./util/cosmos');

var regExp = /^spotify:internal:local-files$/;

function onWait(model, properties) {
  if (contains(properties, 'allows')) getAllows(model);
  if (contains(properties, 'rows')) getRows(model);
}

function getAllows(model) {
  model.update({
    allows: {
      insertTracks: false,
      removeTracks: false
    }
  });
}

function createRows(data) {
  var rows = new Array(data.length);

  for (var i = 0, l = data.length; i < l; i++) {
    var track = data[i];

    setLocalProperty(track);

    // We want timestamp in milliseconds, but the client gives it in seconds.
    var dateAdded = track.dateAdded * 1000;

    var row = {
      uri: getRowUri(track.uri),
      track: track,
      dateAdded: dateAdded
    };

    rows[i] = row;

    delete track.dateAdded;
    delete track.addedBy;
  }

  return rows;
}

function setLocalProperty(track) {
  if (track.album && track.album.uri) {
    var albumType = liburi.from(track.album.uri).type;
    track.album.local = albumType === liburi.Type.LOCAL_ALBUM;
  }
  if (track.artists) {
    for (var i = 0, l = track.artists.length; i < l; i++) {
      var artist = track.artists[i];
      if (artist.uri) {
        var artistType = liburi.from(artist.uri).type;
        artist.local = artistType === liburi.Type.LOCAL_ARTIST;
      }
    }
  }
}

function getRows(model) {
  cosmos.get({ url: 'sp://local-files/v1/tracks' }, function (error, response) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    model.update({
      rows: createRows(response.body)
    });

    cosmos.subscribe({ url: 'sp://local-files/v1/changes' }, function (error, response) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }

      onChange(model, response.body);
    });
  });
}

function onChange(model, event) {
  switch (event.type) {
    case 'removed':
      onTracksRemoved(model, event.data);break;
    case 'added':
      onTracksAdded(model, event.data);break;
    case 'moved':
      onTracksMoved(model, event.data);break;
    case 'changed':
      onMetadataChanged(model, event.data);break;
  }
}

function onMetadataChanged(model, data) {

  // The positions we get could in some cases be for multiple ranges.
  //
  // We need to remove each range individually, so that we can re-add
  // the same range with updated data right after removing the range.
  // The reason we can't just update rows with new data is that the
  // metadata might cause the row to get a new URI (since local files
  // contain the metadata in the URI).

  var ranges = Range.fromIndices(data.positions);

  var startOfRangeInChangeset = 0;

  for (var rangeIndex = 0, range; range = ranges[rangeIndex]; rangeIndex++) {
    var indices = range.toIndices();
    var rangeLength = range.length;
    var tracks = new Array(indices.length);

    for (var i = 0; i < rangeLength; i++) {
      tracks[i] = data.tracks[startOfRangeInChangeset + i];
    }

    // Remove range and re-add it with new data
    var removeOperations = listOperations.getRemoveOperations(indices);
    model.get('rows').update(removeOperations);
    addTracksToList(model, tracks, indices[0]);

    startOfRangeInChangeset += rangeLength;
  }
}

function onTracksMoved(model, data) {
  var moveOperations = listOperations.getMoveOperations(data.positions, data.position);
  model.get('rows').update(moveOperations);
}

function onTracksRemoved(model, data) {
  var removeOperations = listOperations.getRemoveOperations(data.positions);
  model.get('rows').update(removeOperations);
}

function onTracksAdded(model, data) {
  addTracksToList(model, data.tracks, data.position);
}

function addTracksToList(model, tracks, index) {
  var rows = createRows(tracks);

  var insertOperations = listOperations.getInsertOperations(rows, index);
  model.get('rows').update(insertOperations);
}

var idCounter = 1000;
function getRowUri(trackUri) {
  return trackUri.replace('spotify:', 'spotify:row:' + (++idCounter).toString(36) + ':');
}

var registered = false;

exports.register = function () {
  if (registered) return;
  registered = true;
  live.subscribe(regExp, 'wait', onWait);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;
  live.unsubscribe(regExp, 'wait', onWait);
};

exports.matches = regExp;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":512,"../spotify-live-list-operations":461,"../spotify-range2":551,"./util/cosmos":508,"mout/array/contains":652,"spotify-liburi":899}],480:[function(require,module,exports){
'use strict';

var cosmos = require('../util/cosmos');

var ARTIST_CONTEXT_URL = 'hm://artistplaycontext/';

function getContext(contextUri, options, opt_callback) {

  var url = contextUri.split(':').join('/');
  var resolverUrl = ARTIST_CONTEXT_URL + url + '/km';
  var postObject = { url: resolverUrl };

  cosmos.get(postObject, opt_callback);
}

module.exports = {
  getContext: getContext
};

},{"../util/cosmos":508}],481:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/player/control
 * @private
 */
'use strict';

var cosmosPlayer = require('./cosmos-player');
var playerApi = require('./player-api');
var playlistResolver = require('./playlist-resolver');
var artistResolver = require('./artist-resolver');

var dataUtils = require('./data');

var cosmos = require('../util/cosmos');

/**
 * Check AB test if it should use new artist context resolver.
 *
 * @param {Function=} callback Callback function.
 **/
function shouldUseArtistContextPlayerResolver(callback) {
  var ARTIST_CONTEXT_TEST = 'Rollout_short_artist_context_desktop';
  cosmos.post({
    url: 'sp://abba/v1/flags',
    body: { flags: [ARTIST_CONTEXT_TEST] }
  }, function (_, response) {
    var flags = response && response.body && response.body.flags || [];
    var featureFlagCell = flags[0] && flags[0].featureName === ARTIST_CONTEXT_TEST && flags[0].cell;

    callback(featureFlagCell === 'Rollout');
  });
}

/**
 * Request to play a list of track URIs.
 *
 * @param {Array.<string>} trackUris Array of track URIs.
 * @param {?Array.<string>} opt_ids Array of one id per track. Not needed when the context never needs to be updated.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} opt_callback Callback function.
 */
function playTrackUris(trackUris, opt_ids, playOptions, opt_callback) {
  playerApi.play(trackUris, opt_ids, playOptions, opt_callback);
}

/**
 * Request to play a context through the cosmos track resolver.
 *
 * @param {string} contextUri Context URI.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} opt_callback Optional callback function.
 */
function playFromResolver(contextUri, playOptions, opt_callback) {
  playerApi.playFromResolver(contextUri, playOptions, opt_callback);
}

/**
 * Play a context directly, only supported on context player
 *
 * @param {Object} context Context object that CP can deal with.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} opt_callback Optional callback function.
 */
function playContext(context, playOptions, opt_callback) {
  playerApi.playContext(context, playOptions, opt_callback);
}

/**
 * Request to play a context through the playlist resolver.
 *
 * @param {string} contextUri Context URI.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} opt_callback Optional callback function.
 */
function playFromPlaylistResolver(contextUri, playOptions, opt_callback) {
  // For playlist playback we don't need to support ranges, so we'll
  // always just pick the first.
  var skipToIndex = {};

  // Todo: This should be cleaned up, we don't need a list of uids because we
  // never need ranges now. We do that stuff using pages.
  if (playOptions.uids) {
    skipToIndex.track_uid = playOptions.uids[0];
  } else if (playOptions.uid) {
    skipToIndex.track_uid = playOptions.uid;
  }

  // Todo: This should be cleaned up, we don't need a list of uids because we
  // never need ranges now. We do that stuff using pages.
  if (playOptions.uris) {
    skipToIndex.track_uri = playOptions.uris[0];
  } else if (playOptions.trackUri) {
    skipToIndex.track_uri = playOptions.trackUri;
  }

  var preparePlayOptions = {};
  if (Object.keys(skipToIndex).length) {
    preparePlayOptions.skip_to_index = skipToIndex;
  }

  var playOrigin = {
    view_uri: playOptions.context,

    // fills in source_start & source_end
    // example values: browse, playlist-owned-by-self-non-collaborative
    feature_identifier: playOptions.source,

    // fills in referer
    // example values: spotify:app:browse
    referrer_identifier: playOptions.contextPlayerReferrer,

    // fills in referrer version
    feature_version: playOptions.referrerVersion
  };

  var options = {
    prepare_play_options: preparePlayOptions,
    play_origin: playOrigin
  };

  playlistResolver.play(contextUri, options, opt_callback);
}

/**
 * Request to play a single track.
 *
 * @param {string} uri The track URI.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} opt_callback Optional callback function.
 */
function playTrack(uri, playOptions, opt_callback) {
  playOptions.context = uri;
  playOptions.track = uri;
  playOptions.index = 0;
  playTrackUris([uri], null, playOptions, opt_callback);
}

/**
 * Request to play tracks found in the list of rows.
 *
 * @param {LiveList} rows A live list of rows with tracks.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} opt_callback Optional callback function.
 */
function playRows(rows, playOptions, opt_callback) {
  var index = playOptions.index;
  var range = playOptions.range;

  if (index === null && range) {
    dataUtils.getFirstPlayableRow(rows, range, function (error, index) {
      if (error && opt_callback) return opt_callback(error);
      if (error) {
        if (global.console) console.error(error);
        return;
      }

      var trackUris = dataUtils.getTracksFromRows(rows);
      playOptions.index = index;

      playTrackUris(trackUris, rows.keys, playOptions, opt_callback);
    });
  } else {
    var trackUris = dataUtils.getTracksFromRows(rows);
    playTrackUris(trackUris, rows.keys, playOptions, opt_callback);
  }
}

/**
 * Request to play artist context.
 *
 * @param {string} contextUri Context URI.
 * @param {Function=} opt_callback Optional callback function.
 */
function playFromArtist(uri, playOptions, opt_callback) {
  shouldUseArtistContextPlayerResolver(function (playFromArtistResolver) {
    if (playFromArtistResolver) {
      artistResolver.getContext(uri, playOptions, function (error, data) {
        if (error && opt_callback) return opt_callback(error);
        if (error) {
          if (global.console) console.error(error);
          return;
        }

        var contextObject = data.body;
        playContext(contextObject, playOptions, opt_callback);
      });
    } else {
      // If artist resolver is not enabled yet use regular resolver
      playFromResolver(uri, playOptions, opt_callback);
    }
  });
}

/**
 * Request to update the player with tracks from the provided rows list.
 * This will update the player silently without interrupting playback.
 *
 * @param {LiveList} rows A live list of rows with tracks.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} opt_callback Optional callback function.
 */
function updateWithRows(rows, playOptions, opt_callback) {

  var tracks = dataUtils.getTracksFromRows(rows);

  // Context Player matches on UIDs so let's not provide index
  delete playOptions.index;
  playerApi.update(tracks, rows.keys, playOptions, opt_callback);
}

/**
 * Request to update the player with tracks from the cosmos track resolver.
 * This will update the player silently without interrupting playback.
 *
 * @param {Object} playOptions An object with play options.
 * @param {Function=} opt_callback Optional callback function.
 */
function updateWithResolver(playOptions, opt_callback) {

  /*
    Todo:
    When currently playing from tracklist, keys need to be passed on to the new playlist and folder resolver
  */

  cosmosPlayer.update(playOptions, null, opt_callback);
}

/**
 * Request to pause the playback.
 *
 * @param {Function=} opt_callback Optional callback function.
 */
function pause(opt_callback) {
  playerApi.pause(opt_callback);
}

/**
 * Request to resume the playback.
 *
 * @param {Function=} opt_callback Optional callback function.
 */
function resume(opt_callback) {
  playerApi.resume(opt_callback);
}

/**
 * Request to skip to the previous track.
 *
 * @param {Function=} opt_callback Optional callback function.
 */
function skipPrev(opt_callback) {
  cosmosPlayer.skipPrev(opt_callback);
}

/**
 * Request to skip to the next track.
 *
 * @param {Function=} opt_callback Optional callback function.
 */
function skipNext(opt_callback) {
  cosmosPlayer.skipNext(opt_callback);
}

exports.playTrack = playTrack;
exports.playRows = playRows;
exports.playFromResolver = playFromResolver;
exports.playContext = playContext;
exports.playFromArtist = playFromArtist;
exports.updateWithRows = updateWithRows;
exports.updateWithResolver = updateWithResolver;
exports.pause = pause;
exports.resume = resume;
exports.skipPrev = skipPrev;
exports.skipNext = skipNext;
exports.playFromPlaylistResolver = playFromPlaylistResolver;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../util/cosmos":508,"./artist-resolver":480,"./cosmos-player":482,"./data":483,"./player-api":485,"./playlist-resolver":486}],482:[function(require,module,exports){
/**
 * @module spotify-live-models/player/cosmos-player
 * @private
 */
'use strict';

var cosmos = require('../util/cosmos');

var PLAYER_URI = 'sp://player/v2/main';
var TRACK_RESOLVER_URI = 'hm://track-resolver/v1?uri=';

var deepFillIn = require('mout/object/deepFillIn');
var isStationUri = require('../station').isStationUri;

var ACTIONS = {
  PLAY: 'play',
  PAUSE: 'pause',
  RESUME: 'resume',
  UPDATE: 'update',
  SKIP_PREV: 'skip_prev',
  SKIP_NEXT: 'skip_next'
};

/**
 * Request to play a list of URIs or a resolvable context URI.
 *
 * @param {Object} options Object with options and data of what to play.
 * @param {?Array} opt_trackUris List of track URIs to play.
 * @param {Function=} opt_callback Callback function.
 */
function play(options, opt_trackUris, opt_callback) {
  if (opt_trackUris) options.tracks = opt_trackUris;
  var state = createCosmosState(options.context, options);

  state.action = ACTIONS.PLAY;

  postPlayerState(state, opt_callback);
}

/**
 * Request to pause the playback.
 *
 * @param {Function=} opt_callback Optional callback function.
 */
function pause(opt_callback) {
  cosmos.post({ url: PLAYER_URI, body: { action: ACTIONS.PAUSE } }, opt_callback);
}

/**
 * Request to resume the playback.
 *
 * @param {Function=} opt_callback Optional callback function.
 */
function resume(opt_callback) {
  cosmos.post({ url: PLAYER_URI, body: { action: ACTIONS.RESUME } }, opt_callback);
}

/**
 * Request to skip playback back.
 *
 * @param {Function=} opt_callback Optional callback function.
 */
function skipPrev(opt_callback) {
  cosmos.post({ url: PLAYER_URI, body: { action: ACTIONS.SKIP_PREV } }, opt_callback);
}

/**
 * Request to skip playback forward.
 *
 * @param {Function=} opt_callback Optional callback function.
 */
function skipNext(opt_callback) {
  cosmos.post({ url: PLAYER_URI, body: { action: ACTIONS.SKIP_NEXT } }, opt_callback);
}

/**
 * Request to update the player with the new state. This will not interupt
 * playback if the context is the same.
 *
 * @param {Object} state State object for the cosmos player.
 * @param {?Array} opt_trackUris List of track URIs to play.
 * @param {Function=} opt_callback Optional callback function.
 */
function update(options, opt_trackUris, opt_callback) {
  if (opt_trackUris) options.tracks = opt_trackUris;
  var state = createCosmosState(options.context, options);

  state.action = ACTIONS.UPDATE;

  // Up the index by one, since the comsos player expects the next track when updating to a different context.
  state.index++;

  // If the new index is past the end of the list, make it the last index of
  // the list. This will make it work for the case where the list only contains
  // a single track. For lists containing more tracks, this will make the player
  // continue playing the current track as a lone track (without any context)
  // and then pick up the right context with the right highlight and all after
  // that track has played.
  if (state.tracks && state.tracks.length <= state.index) {
    state.index = state.tracks.length - 1;
  }

  postPlayerState(state, opt_callback);
}

/**
 * Post the state object to the cosmos player.
 *
 * @param {Object} state State object for the cosmos player.
 * @param {Function=} opt_callback Optional callback function.
 */
function postPlayerState(state, opt_callback) {
  if (state.context) {
    cosmos.sanitizeURL(state.context, function (error, uri) {
      if (error) return opt_callback(error);
      state.context = uri;

      if (!state.tracks) {
        if (/^spotify:user:[^:]+:(playlist:)/.test(uri)) state.next_page_url = uri;else state.next_page_url = TRACK_RESOLVER_URI + encodeURI(uri);

        // Set tracks to an empty array since cosmos player on core js expects it.
        // REMOVE ME! 2014-10-24, see KM-3914.
        state.tracks = [];
      }

      cosmos.post({ url: PLAYER_URI, body: state }, opt_callback);
    });
  } else {
    cosmos.post({ url: PLAYER_URI, body: state }, opt_callback);
  }
}

/**
 * Request to get the current state of the cosmos player.
 *
 * @param {Function} callback Callback function.
 */
function getState(callback) {
  cosmos.get({ url: PLAYER_URI }, function (error, response) {
    if (error) return callback(error);
    callback(null, response.body);
  });
}

/**
 * Request to get the current state of the cosmos player whenever the player
 * changes.
 *
 * @param {Function} callback Callback function.
 *
 * @return {Object} An object with a method to unsubscribe.
 */
function subscribe(callback) {
  var subscription = cosmos.subscribe({ url: PLAYER_URI }, function (error, response) {
    if (error) return callback(error);
    callback(null, response.body);
  });

  return {
    unsubscribe: function unsubscribe() {
      if (!subscription) return;
      subscription.cancel();
      subscription = null;
    }
  };
}

/**
 * Create a state object for the cosmos player.
 *
 * @param {string} contextUri  Context URI.
 * @param {Object} playOptions An object with play options.
 *
 * @return {Object} An object with state in a format that the cosmos player understands.
 */
function createCosmosState(contextUri, playOptions) {

  var isStationContext = isStationUri(contextUri);
  var defaultState = {
    context: null,
    index: null,
    track: null,
    options: {
      can_repeat: true,
      can_shuffle: !isStationContext,
      can_skip_prev: !isStationContext,
      can_skip_next: true,
      can_seek: true,
      use_dmca_rules: false,
      repeat: false,
      repeat_track: false,
      shuffle_context: false
    },
    play_origin: {
      source: 'unknown',
      reason: 'unknown',
      referrer: 'unknown',
      referrer_version: 'unknown',
      referrer_vendor: 'unknown'
    }
  };

  var state = {
    context: contextUri,
    play_origin: {
      source: playOptions.source,
      reason: playOptions.reason,
      referrer: playOptions.referrer,
      referrer_version: playOptions.referrerVersion
    }
  };

  if ('tracks' in playOptions) state.tracks = playOptions.tracks;
  if ('index' in playOptions) state.index = playOptions.index;
  if ('track' in playOptions) state.track = playOptions.track;

  deepFillIn(state, defaultState);

  return state;
}

exports.play = play;
exports.pause = pause;
exports.resume = resume;
exports.skipPrev = skipPrev;
exports.skipNext = skipNext;
exports.update = update;
exports.getState = getState;
exports.subscribe = subscribe;

},{"../station":498,"../util/cosmos":508,"mout/object/deepFillIn":683}],483:[function(require,module,exports){
/**
 * @module spotify-live-models/player/data
 * @private
 */
'use strict';

var live = require('../../spotify-live');
var Range = require('../../spotify-range2');

var playerApi = require('./player-api');

/**
 * Default values for play options.
 */
var PLAY_OPTIONS_DEFAULTS = {
  page: null,
  uid: null,
  trackUri: null,
  index: null,
  source: 'unknown',
  reason: 'unknown'
};

/**
 * Get the first playable row from range in a list of rows.
 *
 * @param {LiveList} rows A live list of rows.
 * @param {Range} range A range object.
 * @param {Function} callback A callback where the second argument is the
 *     index of the first playable row. If no playable track is found, the
 *     index will be the first index in the range.
 */
function getFirstPlayableRow(rows, range, callback) {
  var index = range.start;

  isRowPlayable(rows.get(index), function playableCallback(error, playable) {
    if (playable) return callback(null, index);
    if (index === range.end - 1) return callback(null, range.start);

    isRowPlayable(rows.get(++index), playableCallback);
  });
}

/**
 * Check if the row is playable.
 *
 * @param {LiveObject?} row A row live object. If this is falsy, the callback
 *     is returned with false immediately.
 * @param {Function} callback A callback where the second argument is the
 *     boolean flag for playable. The callback may run synchronously or
 *     asynchronously.
 */
function isRowPlayable(row, callback) {
  if (!row) return callback(null, false);

  row.query('track(playable)', function (error, data) {
    if (error) return callback(error);
    callback(null, data.track.playable);
  }, live.ASAP);
}

/**
 * Get options for play actions based on a data object and other state
 * like referrer set on the player or application object.
 *
 * @param {Object} data A data object.
 * @param {Function} callback A callback, where the second argument is a data
 *     object with the options.
 */
function getPlayOptions(data, callback) {
  getReferrer(function (error, viewUri, baseUri) {
    if (error) return callback(error);

    Object.keys(PLAY_OPTIONS_DEFAULTS).forEach(function (key) {
      if (data[key] === undefined) {
        data[key] = PLAY_OPTIONS_DEFAULTS[key];
      }
    });

    if (data.range) {
      data.range = new Range(data.range[0], data.range[1]);
    }

    data.referrer = viewUri;
    data.contextPlayerReferrer = baseUri;
    data.referrerVersion = getReferrerVersion();

    callback(null, data);
  });
}

/**
 * Get a list of track URIs from a live list of rows.
 *
 * @param {LiveList} rows A live list of rows.
 *
 * @return {Array.<string>} Array of track URIs. If a row is not set in the list,
 *     or if the row doesn't have a track object with a URI, an 'undefined' value
 *     will be put in that position in the output array.
 */
function getTracksFromRows(rows) {
  return rows.map(function (row) {
    var track = row && row.get('track');
    return track && track.uri;
  });
}

/**
 * Get the latest player state, in the format of the player live model.
 *
 * @param {Function} callback Callback function.
 */
function getPlayerState(callback) {
  playerApi.getState(callback);
}

/**
 * Subscribe to the cosmos player to get the latest player state,
 * in the format of the player live model.
 *
 * @param {Function} callback Callback function.
 * @return {Object} An object with a method to unsubscribe.
 */
function subscribeForPlayerState(callback) {
  return playerApi.subscribe(callback);
}

/**
 * Get the referrer for the player. This is usually the path back to the app in
 * the state where the playback started. It can be set by the user in the `referrer`
 * property of the player live object. If nothing is set there, it will generate
 * the referrer by combining the app URI with the app arguments.
 *
 * @param {Function} callback A callback where the second argument is the referrer.
 */
function getReferrer(callback) {
  // 'referrer' corresponds to fullURI below
  var referrer = live('spotify:player').get('referrer');
  var referrerBaseUri = live('spotify:player').get('referrerBaseUri');
  if (referrer) {
    if (!referrerBaseUri) {
      console.warn('referrer field is set on the player model (' + referrer + '), but referrerBaseUri isn\'t');
    }
    return callback(null, referrer, referrerBaseUri || '');
  }

  live('spotify:application').get('appURI', 'arguments', function (error, uri, args) {
    if (error) return callback(error);
    var fullUri = args ? uri + ':' + args : uri;
    callback(null, fullUri, uri);
  });
}

/**
 * Get the referrer version. This is usually the version of the app. It can be set
 * by the user in the `version` property of the application live object. If nothing
 * is set there, it will use the default version '0.0.0'.
 *
 * @return {string} The version string.
 */
function getReferrerVersion() {
  return live('spotify:application').get('version') || '0.0.0';
}

exports.getReferrer = getReferrer;
exports.getReferrerVersion = getReferrerVersion;
exports.getFirstPlayableRow = getFirstPlayableRow;
exports.isRowPlayable = isRowPlayable;
exports.getPlayOptions = getPlayOptions;
exports.getTracksFromRows = getTracksFromRows;
exports.getPlayerState = getPlayerState;
exports.subscribeForPlayerState = subscribeForPlayerState;

},{"../../spotify-live":512,"../../spotify-range2":551,"./player-api":485}],484:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/player
 */
'use strict';

var _messageProxy = require('../../../libs/message-proxy');

var live = require('../../spotify-live');
var URI = require('spotify-liburi');
var cosmos = require('spotify-cosmos-api');
var abba = require('../../../libs/abba');
var CancellationTokenSource = require('../../../libs/cancellation-token-source').default;

var playerApi = require('./player-api');
var playbackControl = require('./control');
var dataUtils = require('./data');
var updatesUtils = require('./updates');
var playlistResolver = require('./playlist-resolver');
var sortUriUtils = require('../../spotify-live-sort-uri');
var filterUriUtils = require('../../spotify-live-filter-uri');
var createStationPlayContext = require('../station/create-play-context');
var createStationPlayOptions = require('../station/create-play-options');
var isStationUri = require('../station').isStationUri;

var TYPE_TRACK = 'track';
var TYPE_TRACK_RESOLVER = 'track-resolver';
var TYPE_ROWS = 'rows';
var TYPE_CP_RESOLVER_PLAYLIST = 'context-player-resolver-playlist';
var TYPE_CP_CONTEXT = 'context-player-context';
var TYPE_CONTEXT_OBJECT = 'context-object';
var TYPE_STATION_CONTEXT = 'context-station-context';
var TYPE_CP_ARTIST_CONTEXT = 'context-player-artist';
var TYPE_CONTEXT_EPISODE = 'context-episode';
var VARIANT_KEY = 'list-variant-';

var cancellationTokenSource = new CancellationTokenSource();

// This data store will keep context objects keyed by context URI. The values
// are context objects in the format of spotify-player Context:
// https://ghe.spotify.net/spotify-sdk/spotify-player/blob/master/lib/v2/types.js#L164
var contextDataStore = {};

/**
 * Handler for when properties are requested from the model.
 *
 * @param {LiveObject} model The player live object.
 */
function onWait(model) {
  updateState(model);
}

/**
 * Handler for when the model needs to be updated by polling the player.
 *
 * @param {LiveObject} model The player live object.
 */
function onSync(model) {
  updateState(model);
}

/**
 * Handler for when the real player is updated.
 *
 * @param {Error?} error An error object, or null.
 * @param {Object} data Data object in the format of this live model.
 */
function onPlayerStateUpdate(error, data) {
  if (error) {
    if (global.console) console.error(error);
    return;
  }
  var model = live('spotify:player');
  if (model.get('pending')) return;
  model.update(data);
}

/**
 * Handler for when the model receives the 'update' event.
 *
 * @param {LiveObject} model The player live object.
 */
function onUpdate(model) {
  var index = model.get('index') && model.get('index').get('track');
  if (index != null) {
    updatesUtils.setPlayingIndex(index);
  }

  updatesUtils.clean(model);
}

/**
 * Handler for when the model receives the 'play' event.
 *
 * @param {LiveObject} model The player live object.
 * @param {Object} event The event object with data about what to play.
 *     Can contain the following properties:
 *       `context` (string, context URI)
 *       `index` (number, index within context to play)
 *       `uid` (string, uid within context to play)
 *       `page` (number, index for the context player page)
 *       `range` (array of two values, start and end index)
 *       `uids` (array of uids representing an index or a range)
 *       `uris` (array of uris connected to the uids)
 *       `source` (string)
 *       `reason` (string)
 */
function onPlay(model, event) {
  var context = event.context;
  if (!context) return;

  // The `index` property might be `null`, which should mean that no specific
  // index should be played.
  if (typeof event.index !== 'number') {
    delete event.index;
  }

  // Cancel all previous play/update context requests
  cancellationTokenSource.cancel();
  var cancellationToken = cancellationTokenSource.token();

  // Update the model optimistically
  model.update(playerApi.addContext({
    isPlaying: true,
    isPaused: false,
    index: event.index === undefined ? null : { page: 0, track: event.index },
    track: event.trackUri === undefined ? null : { uri: event.trackUri },
    contextUpdatedCrossFrame: false
  }, context));

  // Get options for the play action based on event data and other state
  // Todo: getPlayOptions creates options that fit the cosmos/v1 implementation.
  // We could probably do this a bit later from cosmos-player.js
  dataUtils.getPlayOptions(event, function (error, options) {
    if (error || !options.context) return updateState(model); // Revert state

    // Canonical contexts can have sorted and/or filtered state that needs
    // to be respected client-wide. We therefore query for the correct variant
    // to be played.
    // For spotify:internal uris on the other hand, we don't look for variants.
    // This would also be the case for contexts that already represent variants.
    // Please see docs for details.
    if (/^spotify:internal:/.test(options.context)) {
      playWithOptions(model, cancellationToken, options);
      return;
    }

    if (live('spotify:list-variant').get('implemented')) {
      live(options.context).query('listVariant(currentUri, sortUri)', function (error, data) {
        if (error) return updateState(model); // Revert state

        // Abort if a new play request has happened since this request started
        if (cancellationToken.isCanceled()) {
          return;
        }

        options.context = data.listVariant.currentUri;

        playWithOptions(model, cancellationToken, options);
      });
    } else {
      playWithOptions(model, cancellationToken, options);
    }
  });
}

/**
 * Handler for when the model receives the 'pause' event.
 *
 * @param {LiveObject} model The player live object.
 */
function onPause(model) {
  if (model.get('isPlaying') === false || model.get('isPaused') === true) {
    return;
  }

  model.update({ isPaused: true });

  playbackControl.pause(function (error) {
    if (error) return model.update({ isPaused: false });
  });
}

/**
 * Handler for when the model receives the 'resume' event.
 *
 * @param {LiveObject} model The player live object.
 */
function onResume(model) {
  if (model.get('isPlaying') === true && model.get('isPaused') === false) {
    return;
  }

  model.update({ isPaused: false });

  playbackControl.resume(function (error) {
    if (error) return model.update({ isPaused: true });
  });
}

/**
 * Handler for when the model receives the 'skip-previous' event.
 *
 * @param {LiveObject} model The player live object.
 */
function onSkipPrev() {
  // Skip prev often starts playback, but not when you're on the first track.
  // Therefor no optimistic update of 'playing' here.
  playbackControl.skipPrev();
}

/**
 * Handler for when the model receives the 'skip-next' event.
 *
 * @param {LiveObject} model The player live object.
 */
function onSkipNext() {
  // Skip next often starts playback, but not when you're on the last track.
  // Therefor no optimistic update of 'playing' here.
  playbackControl.skipNext();
}

/**
 * Handler for when the model receives the 'update-context' event.
 *
 * @param {LiveObject} model The player live object.
 * @param {Object} event An event object with a `context` property (string).
 */
function onUpdateContext(model, event) {
  var contextUri = event.context;
  if (!contextUri) return;

  var context = live(contextUri);
  // Cancel all previous play/update context requests
  cancellationTokenSource.cancel();
  var cancellationToken = cancellationTokenSource.token();

  var currentIndex = model.get('index') && model.get('index').get('track');
  var currentContext = model.get('variant');

  // Update player model optimistically with context and no index.
  // We can't know the index yet, so we must set it to nothing to
  // not get wrong highlights.
  model.update(playerApi.addContext({
    index: null,
    pending: true,
    contextUpdatedCrossFrame: false
  }, contextUri));

  // We need the rows list to be able to get the index and play the list.
  live(contextUri).get('rows', function (error, rowsList) {
    if (error) {
      model.update({ pending: false });
      if (global.console) console.error(error);
      return;
    }

    var options = { context: contextUri };
    dataUtils.getPlayOptions(options, function (error, options) {
      // Abort if a new play request has happened since this request started
      if (cancellationToken.isCanceled()) {
        return;
      }

      // Store which row is currently playing, so that we can get the index
      // of the playing row in another list.
      updatesUtils.setPlayingIndex(currentIndex, currentContext.get('rows'));

      // Find the index of the currently playing track in new list, to do an
      // optimistic update. This is not optional, since the actual player only appends
      // the next context and will not send an update until the next skip.
      // (If it does, because of play/pause for example, it will still report the old
      // list that we're not showing in the UI)

      // At the same time, find the index that we will use to actually update the playback
      var updateIndices = updatesUtils.getPlayingAndUpdateIndicesInList(rowsList);
      options.index = updateIndices.update;
      if (updateIndices.playing != null) model.update({ index: { page: 0, track: updateIndices.playing } });

      if (model.get('playOrigin') && model.get('playOrigin').get('referrerIdentifier') !== options.referrer) {
        model.update({ contextUpdatedCrossFrame: true });
      }

      playbackControl.updateWithRows(rowsList, options, function (error) {
        model.update({ pending: false });
        if (error) return updateState(model); // Revert state
      });

      updatesUtils.listen(rowsList, options, function (options) {
        playbackControl.updateWithRows(rowsList, options, function (error) {
          if (error) return updateState(model); // Revert state
        });
      });
    });
  });
}

/**
 * Request to start playback based on passed options.
 * If the request fails, it will revert the player model to the latest
 * state.
 *
 * @param {LiveObject} model The player live object.
 * @param {CancellationToken} cancellationToken
 * @param {Object} options Object with options and data of what to play.
 */
function playWithOptions(model, cancellationToken, options) {
  var contextUri = options.context;
  var resolverType = getPlaybackResolverType(contextUri);

  if (resolverType === TYPE_TRACK) {
    playbackControl.playTrack(contextUri, options, function (error) {
      if (error) return updateState(model); // Revert state
    });
  } else if (resolverType === TYPE_TRACK_RESOLVER) {
    playbackControl.playFromResolver(contextUri, options, function (error) {
      if (error) return updateState(model); // Revert state
    });
  } else if (resolverType === TYPE_ROWS) {
    var isSortedList = sortUriUtils.isValid(contextUri);

    // If it's a sorted list that is played by rows, we want to request all the track
    // URIs of the sorted list and then play that list of tracks. We will wait for all
    // tracks to be fetched and sorted, to allow clicking play on a media object in
    // Browse for example and have it play the stored sorted variant of the playlist.
    if (isSortedList) {
      getSortedRows(contextUri, function (error, rowsList) {
        if (error) return updateState(model); // Revert state

        // Abort if a new play request has happened since this request started
        if (cancellationToken.isCanceled()) {
          return;
        }

        playRows(model, rowsList, options);
      });

      // Play any other context from the rows list
    } else {
      live(contextUri).query('rows(track(uri))', function (err) {
        if (!err && !cancellationToken.isCanceled()) {
          playRows(model, live(contextUri).get('rows'), options);
        }
      });
    }
  } else if (resolverType === TYPE_CP_RESOLVER_PLAYLIST) {
    playbackControl.playFromPlaylistResolver(contextUri, options, function (error) {
      if (error) return updateState(model); // Revert state
    });
  } else if (resolverType === TYPE_CONTEXT_OBJECT) {
    var context = contextDataStore[contextUri];
    playbackControl.playContext(context, options, function (error) {
      if (error) return updateState(model); // Revert state
    });
  } else if (resolverType === TYPE_CP_CONTEXT) {

    var context = {
      url: 'context://' + contextUri,
      entity_uri: contextUri
    };

    playbackControl.playContext(context, options, function (error) {
      if (error) return updateState(model); // Revert state
    });
  } else if (resolverType === TYPE_STATION_CONTEXT) {
    var station = live(contextUri);
    station.query('rows', function (err) {
      if (!err) {
        playbackControl.playContext(createStationPlayContext(station), createStationPlayOptions(station, options), function (error) {
          if (error) return updateState(model); // Revert state
        });
        // Post message to create station in zlink
        (0, _messageProxy.messageProxy)({ method: 'POST', uri: 'station-create', target: 'top',
          body: { stationUri: contextUri }
        });
      }
    });
  } else if (resolverType === TYPE_CP_ARTIST_CONTEXT) {
    playbackControl.playFromArtist(contextUri, options, function (error) {
      if (error) return updateState(model); // Revert state
    });
  } else if (resolverType === TYPE_CONTEXT_EPISODE) {
    var episodeQueryTimeout = 3000;
    live(contextUri).query('episode(name, manifestId, show(name))', function (error, data) {
      if (error) return updateState(model); // Revert state

      var episode = data.episode;
      var context = {
        'uri': contextUri,
        'pages': [{
          'tracks': {
            'uri': contextUri,
            'metadata': {
              'title': episode.name,
              'album_title': episode.show.name,
              'media.type': 'video',
              'media.manifest_id': episode.manifestId
            }
          }
        }],
        'restrictions': {
          'disallow_skipping_prev_reasons': ['disallow-video'],
          'disallow_skipping_next_reasons': ['disallow-video'],
          'disallow_toggling_repeat_context_reasons': ['disallow-video'],
          'disallow_toggling_repeat_track_reasons': ['disallow-video'],
          'disallow_toggling_shuffle_reasons': ['disallow-video']
        }
      };

      if (!options.player_options_override) {
        options.player_options_override = {};
      }
      // Avoid repeating context when playing episode
      // This might be removed in future when we have proper shows support
      options.player_options_override.repeating_context = false;
      options.player_options_override.repeating_track = false;

      playbackControl.playContext(context, options, function (error) {
        if (error) return updateState(model); // Revert state
      });
    }, episodeQueryTimeout);
  }
}

/**
 * Request to start playback based on passed rows list and options.
 * If the request fails, it will revert the player model to the latest
 * state.
 *
 * @param {LiveObject} model The player live object.
 * @param {LiveList} rowsList The rows live list.
 * @param {Object} options Object with options and data of what to play.
 */
function playRows(model, rowsList, options) {
  playbackControl.playRows(rowsList, options, function (error) {
    if (error) return updateState(model); // Revert state

    updatesUtils.listen(rowsList, options, function (options) {
      playbackControl.updateWithRows(rowsList, options, function (error) {
        if (error) return updateState(model); // Revert state
      });
    });
  });
}

/**
 * Get the type of playback resolver to use for a certain context URI.
 *
 * @param {string} contextUri Context URI.
 *
 * @return {string} A resolver type. One of 'track-resolver', 'rows' or 'track'.
 */
function getPlaybackResolverType(contextUri) {
  var contextType = URI.from(contextUri).type;

  var isTrack = contextType === URI.Type.TRACK;
  var isPlaylist = contextType === URI.Type.PLAYLIST;
  var isPlaylistFolder = contextType === URI.Type.FOLDER;
  var isArtist = contextType === URI.Type.ARTIST;
  var isSortedList = sortUriUtils.isValid(contextUri);
  var isFilteredList = filterUriUtils.isValid(contextUri);
  var isStation = isStationUri(contextUri);
  var isEpisode = contextType === URI.Type.EPISODE;

  if (isTrack) return TYPE_TRACK;

  if (isPlaylist) {
    return TYPE_CP_RESOLVER_PLAYLIST;
  }

  if (isPlaylistFolder) {
    return TYPE_CP_CONTEXT;
  }

  if (isStation) return TYPE_STATION_CONTEXT;

  var originContextType, originUri;
  if (isSortedList) {
    originUri = sortUriUtils.parse(contextUri).originUri;

    // If the sorted URI is in fact a filtered URI, the origin URI that _that_ is based on
    // needs to be taken into account when judging the originContextType.
    if (filterUriUtils.isValid(originUri)) originUri = filterUriUtils.parse(originUri).originUri;

    originContextType = URI.from(originUri).type;

    if (originContextType === URI.Type.PLAYLIST) {
      return TYPE_CP_RESOLVER_PLAYLIST;
    }

    return TYPE_ROWS;
  }

  if (isFilteredList) {
    // If the sorted URI is in fact a filtered URI, the origin URI that _that_ is based on
    // needs to be taken into account when judging the originContextType.
    originUri = filterUriUtils.parse(contextUri).originUri;
    originContextType = URI.from(originUri).type;

    if (originContextType === URI.Type.PLAYLIST) {
      return TYPE_CP_RESOLVER_PLAYLIST;
    }

    return TYPE_ROWS;
  }

  var contextData = contextDataStore[contextUri];
  if (contextData) {
    return TYPE_CONTEXT_OBJECT;
  }

  // If it's a different URI, check if we have rows
  var rowsList = live(contextUri).get('rows');
  if (rowsList && rowsList.length) {
    return TYPE_ROWS;
  }

  // If it's an artist context but context object or rows were not defined
  if (isArtist) {
    return TYPE_CP_ARTIST_CONTEXT;
  }

  if (isEpisode) {
    return TYPE_CONTEXT_EPISODE;
  }

  // If no rows are available, final hope is on the track resolver
  return TYPE_TRACK_RESOLVER;
}

/**
 * Get the stored variant of the list. For example, if a user has sorted a
 * playlist, that is stored in the client, so playing the playlist from another
 * place should play the stored sorted variant.
 *
 * @param {string} listUri The normal list URI.
 * @param {Function} callback Callback function where second argument is the
 *     URI of the variant to play. This could be the original list URI.
 */
function getStoredSortUri(listUri, callback) {
  live('spotify:client').query('containerFeatures(clientStorage)', function (error, data) {
    if (error) return callback(null, listUri);

    var defaultUri = listUri;

    if (data.containerFeatures.clientStorage) {
      var key = VARIANT_KEY + listUri;
      var clientStorage = live('spotify:client-storage');

      // Check whether the client storage live model has been registered.
      // This is so that we can check this without making this a
      // breaking change. Would be great with a future live API to see
      // if someone has implemented a specific model.
      if (clientStorage.get('implemented')) {
        clientStorage.get(key, function (error, variant) {
          if (error) return callback(null, defaultUri);

          // Respond with the sort variant if it's a valid sort URI
          if (variant && sortUriUtils.isValid(variant) || variant === listUri) {
            return callback(null, variant);
          }

          // Fall back to the regular playlist URI if it's not valid
          callback(null, defaultUri);
        });
      } else {

        // Fall back to the regular playlist URI if client storage is not implemented
        callback(null, defaultUri);
      }
    } else {
      callback(null, defaultUri);
    }
  });
}

/**
 * Get the live list for the rows of the sorted URI.
 *
 * @param {string} sortUri The URI of the sorted list.
 * @param {Function} callback Callback function where second argument is the
 *     sorted live list.
 */
function getSortedRows(sortUri, callback) {
  var playlistUri = sortUriUtils.getOriginUri(sortUri);

  // Get the rows list for the regular playlist.
  // We could have queried for the track of every row, but by not querying we
  // avoid the conversions from live objects to plain objects.
  live(playlistUri).get('rows', function (error, rows) {
    if (error) return callback(error);

    // Get the live models for all rows.
    rows.get(0, rows.length, function (error) {
      if (error) return callback(error);

      // When we know we have the rows, we can safely sort the list
      live(sortUri).get('rows', function (error, rowsList) {
        if (error) return callback(error);

        // Finally return the sorted rows list
        callback(null, rowsList);
      });
    });
  });
}

/**
 * Update the player model with the current data of the cosmos player model.
 *
 * @param {LiveObject} model The player live object.
 */
function updateState(model) {
  dataUtils.getPlayerState(function (error, data) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    model.update(data);
  });
}

var regExp = exports.matches = /^spotify:player$/;
var registered;
var playerSubscription;
var cancelPlayerErrorSubscription;
var abbaSubscription;

exports.register = function () {
  if (registered) return;
  registered = true;

  if (!abbaSubscription) {
    abbaSubscription = abba.subscribe('windowed-playlist-show-tracklist', function (err, cell) {
      if (err) return;
      playlistResolver.setWindowedPlaylistShowTracklistCell(cell);
    });
  }

  live.subscribe(regExp, 'play', onPlay);
  live.subscribe(regExp, 'pause', onPause);
  live.subscribe(regExp, 'resume', onResume);
  live.subscribe(regExp, 'skip-previous', onSkipPrev);
  live.subscribe(regExp, 'skip-next', onSkipNext);
  live.subscribe(regExp, 'update-context', onUpdateContext);
  live.subscribe(regExp, 'update', onUpdate);
  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'sync-position', onSync);

  playerSubscription = dataUtils.subscribeForPlayerState(onPlayerStateUpdate);

  // This is a workaround the fact that some errors aren't reported to the
  // callbacks passed to Player API when we intereact normally with it.
  //
  // Here we observe all errors. If we know, by means of observation, that an
  // error is not being handled properly elsewhere, we revert the live-model
  // state when the error is reported here.
  cancelPlayerErrorSubscription = playerApi.onError(function (error, response) {
    if (error) {
      console.error(error);
      return;
    }
    var body = response.getJSONBody();
    switch (body.error) {
      case 'one_track_unplayable':
      case 'one_track_unplayable_auto_stopped':
      case 'all_tracks_unplayable_auto_stopped':
        // Revert state
        exports._syncPlayerModelState();
        break;
      default:
        break;
    }
  });
};

exports._syncPlayerModelState = function () {
  var model = live('spotify:player');
  updateState(model);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'play', onPlay);
  live.unsubscribe(regExp, 'pause', onPause);
  live.unsubscribe(regExp, 'resume', onResume);
  live.unsubscribe(regExp, 'skip-previous', onSkipPrev);
  live.unsubscribe(regExp, 'skip-next', onSkipNext);
  live.unsubscribe(regExp, 'update-context', onUpdateContext);
  live.unsubscribe(regExp, 'update', onUpdate);
  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'sync-position', onSync);

  playerSubscription.unsubscribe();
  if (cancelPlayerErrorSubscription) {
    cancelPlayerErrorSubscription();
  }
  if (abbaSubscription) {
    abbaSubscription.cancel();
    abbaSubscription = null;
  }
  playerSubscription = null;
};

exports.setContextData = function (contextUri, contextData) {
  contextDataStore[contextUri] = contextData;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../libs/abba":49,"../../../libs/cancellation-token-source":124,"../../../libs/message-proxy":214,"../../spotify-live":512,"../../spotify-live-filter-uri":460,"../../spotify-live-sort-uri":510,"../station":498,"../station/create-play-context":499,"../station/create-play-options":500,"./control":481,"./data":483,"./player-api":485,"./playlist-resolver":486,"./updates":487,"spotify-cosmos-api":890,"spotify-liburi":899}],485:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/player/player-api
 * @private
 */
'use strict';

var dataUtils = require('./data');
var cosmosUtil = require('../util/cosmos');

var live = require('../../spotify-live');
var sortUriUtils = require('../../spotify-live-sort-uri');
var filterUriUtils = require('../../spotify-live-filter-uri');

var PlayerApi = require('spotify-player/lib/v2');
var cosmos = require('spotify-cosmos-api');

var TRACK_RESOLVER_URI = 'hm://track-resolver/v2?uri=';

var player;

function getPlayer(callback) {

  if (player) {
    callback(player);
    return;
  }

  // One of a fixed list of features, since this is used for logging. It should
  // be the readable name of the feature, for example "radio", "album", "playlist"
  // and it should be the same for a given feature across platforms.
  // The list is probably this:
  // https://ghe.spotify.net/datainfra/log-parser/blob/master/spotify/log_parser/messages_specs.py#L29
  var featureIdentifier;

  // The version of the feature itself
  var featureVersion;

  var appManifest = global.__spotify && global.__spotify.app_manifest;
  if (appManifest) {
    featureVersion = appManifest.BundleVersion || null;
    featureIdentifier = appManifest.BundleIdentifier || null;
  }

  // Hard coded overwrites for apps where we needed to choose a new
  // BundleIdentifier for compat reasons
  // Todo: This is incomplete and would better be fixed by letting features
  // provide values specifically for this. See KM-6973.
  var radioFeatureIdentifier = 'radio';
  var overwrites = {
    'playlist-desktop': 'playlist',
    'station': radioFeatureIdentifier,
    'stations': radioFeatureIdentifier,
    'radio-hub': radioFeatureIdentifier,
    'daily-mix-hub': radioFeatureIdentifier
  };

  if (featureIdentifier && overwrites[featureIdentifier]) featureIdentifier = overwrites[featureIdentifier];

  // The uri of the view that's supposed to show the context where the track is
  // playing, including arguments. That's called referrer in terms of the
  // player live model.
  dataUtils.getReferrer(function (error, viewUri, baseUri) {
    if (error && console) {
      console.error('The player API could not be initialized due to a missing referrer!', error);
      return;
    }

    var options = baseUri ? { referrerIdentifier: baseUri } : null;

    player = new PlayerApi.Player(cosmos.resolver, viewUri, featureIdentifier, featureVersion, options);
    callback(player);

    // The viewUri on this player instance can't ever change, so since we cache
    // it we have to destroy it when arguments change.
    live('spotify:application').on('update', function (data) {
      if ('arguments' in data) {
        player = null;
      }
    });
  });
}

function play(trackUris, opt_rowIds, playOptions, opt_callback) {
  getPlayer(function (player) {
    var tracks = new Array(trackUris.length);
    for (var i = 0; i < trackUris.length; i++) {
      var trackUri = trackUris[i];

      var track = { uri: trackUri };

      if (opt_rowIds) {
        track.uid = '' + opt_rowIds[i];
      }

      tracks[i] = track;
    }

    var context = {
      pages: [{
        tracks: tracks
      }],
      metadata: {
        'zelda.context_uri': playOptions.context
      },
      entity_uri: getOriginUri(playOptions.context)
    };

    var options = {};
    if (typeof playOptions.index === 'number') {
      options.skip_to_index = {
        page: 0,
        track: playOptions.index
      };
    }

    player.play(context, options, opt_callback);
  });
}

function playContext(context, playOptions, opt_callback) {
  if (playOptions.uid || playOptions.uri || playOptions.page) {
    playOptions.skip_to = {};
    if (playOptions.uid) {
      playOptions.skip_to.track_uid = playOptions.uid;
    } else if (playOptions.uri) {
      playOptions.skip_to.track_uri = playOptions.uri;
    }

    // Together with UID send page_index property, so Connect can
    // figure out where to look for a track that needs to
    // be played. (Connect doesn't support UIDs at the moment).
    if (playOptions.page) {
      playOptions.skip_to.page_index = playOptions.page;
    }
  }

  getPlayer(function (player) {
    player.play(context, playOptions || {}, opt_callback);
  });
}

function update(trackUris, opt_rowIds, playOptions, opt_callback) {
  getPlayer(function (player) {

    var length = trackUris.length;
    var tracks = new Array(length);

    // Todo: When currently playing from the new playlist and folder resolver,
    // uids provided by the core resolver need to be used.

    for (var i = 0; i < length; i++) {

      tracks[i] = {
        uri: trackUris[i]
      };
      if (opt_rowIds) tracks[i].uid = '' + opt_rowIds[i];
    }

    var context = {
      pages: [{
        tracks: tracks
      }],
      metadata: {
        'zelda.context_uri': playOptions.context
      },
      entity_uri: getOriginUri(playOptions.context)
    };

    player.update(context, opt_callback);
  });
}

function playFromResolver(contextUri, playOptions, opt_callback) {
  getPlayer(function (player) {
    cosmosUtil.sanitizeURL(contextUri, function (error, uri) {
      if (error) {
        if (opt_callback) opt_callback(error);
        return;
      }

      var context = {
        entity_uri: uri
      };

      var options = null;
      if (typeof playOptions.index === 'number') {
        options = {
          skip_to_index: {
            page: 0,
            track: playOptions.index
          }
        };
      } else if (playOptions.trackUri) {
        options = {
          skip_to_index: {
            track_uri: playOptions.trackUri
          }
        };
      }

      if (typeof playOptions.seekTo === 'number') {
        options.seek_to = playOptions.seekTo;
      }

      context.pages = [{ page_url: TRACK_RESOLVER_URI + encodeURI(uri) }];

      player.play(context, options, opt_callback);
    });
  });
}

var cancelSubscribe;

function subscribe(callback, options) {
  cancelSubscribe = false;
  options = options || {};

  var subscription;
  getPlayer(function (player) {
    if (cancelSubscribe) return;
    subscription = player.subscribe(function (error, response) {
      if (error) {
        return callback(error);
      }
      callback(null, addContext(response.getJSONBody()));
    }, options);
  });

  return {
    unsubscribe: function unsubscribe() {
      cancelSubscribe = true;
      if (!subscription) return;
      subscription.cancel();
      subscription = null;
    }
  };
}

var onErrorSubscription;

function onError(callback) {
  getPlayer(function (player) {
    onErrorSubscription = player.onError(callback);
  });

  return function () {
    if (onErrorSubscription) {
      onErrorSubscription.cancel();
      onErrorSubscription = null;
    }
  };
}

function getState(callback) {
  getPlayer(function (player) {
    player.getState(function (error, response) {
      if (error) {
        callback(error, null);
      } else {
        callback(null, addContext(response.getJSONBody()));
      }
    });
  });
}

function pause(opt_callback) {
  getPlayer(function (player) {
    player.pause(opt_callback);
  });
}

function resume(opt_callback) {
  getPlayer(function (player) {
    player.resume(opt_callback);
  });
}

function clear() {
  player = null;
}

/**
 * Adds the context to a given player state.
 *
 * @param {Object} data Input data in the format of the cosmos player live model (v2).
 * @param {string?} opt_uri Optional URI to be used in first place.
 * @return {Object} Data object.
 */
function addContext(data, opt_uri) {
  var uri = opt_uri || // We provide the URI of the context.
  data.context_metadata['zelda.context_uri'] || // Best case scenario.
  data.context_uri || // No special context, use the standard one.
  data.track && data.track.uri || // If a track is present, use it.
  null; // Nothing found; there's nothing being played.

  var context = getOriginUri(uri);

  // Avoid writing it into the context. People should always use the context object.
  delete data.context_uri;

  if (uri) {
    data.variant = { uri: uri };
    data.context = { uri: context };
  } else {
    data.variant = null;
    data.context = null;
  }

  // Track and index are flagged as "optional", meaning that when the player is stopped
  // will not be returned. Because of the way "live" works (waiting for properties until
  // they're set), it could happen that we wait forever for "track" and "index". For
  // aoviding this, we set them both to "null".
  data.track = data.track || null;
  data.index = data.index || null;

  if (data.track) {
    data.uid = data.track.uid;
    delete data.track.uid;
  } else {
    data.uid = null;
  }

  return removeUnderscores(data);
}

/**
 * Returns the original URI from a given filtered & sorted URI. For example, given
 * this URL:
 *
 * spotify:internal:sortlist:desc:track(name):internal:filterlist:playable%20eq%20true:user:myuser:playlist:7h5o3lf1ithsxec0wgjznj
 *
 * This method would return:
 *
 * spotify:user:myuser:playlist:7h5o3lf1ithsxec0wgjznj
 *
 * @param {string} uri An internal URI format with sort and/or query parts.
 * @return {string} The original URI.
 */
function getOriginUri(uri) {
  if (!uri) {
    return uri;
  }

  var sorted = sortUriUtils.parse(uri);
  if (sorted) uri = sorted.originUri;

  var filtered = filterUriUtils.parse(uri);
  if (filtered) uri = filtered.originUri;

  return uri;
}

/**
 * Transforms C++ syntax for variable names and keys (underscore_names) to the JS format
 * (camelCase).
 */
function removeUnderscores(data) {
  var transformedKey;

  for (var key in data) {
    if (data.hasOwnProperty(key)) {
      transformedKey = key.replace(/_(.)/g, function (str, chr) {
        return chr.toUpperCase();
      });

      if (data[key] instanceof Object) {
        data[transformedKey] = removeUnderscores(data[key]);
      } else {
        data[transformedKey] = data[key];
      }

      if (transformedKey !== key) {
        delete data[key];
      }
    }
  }

  return data;
}

exports.play = play;
exports.playFromResolver = playFromResolver;
exports.playContext = playContext;
exports.pause = pause;
exports.resume = resume;
exports.update = update;
exports.subscribe = subscribe;
exports.onError = onError;
exports.getState = getState;
exports.clear = clear;
exports.addContext = addContext;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-live":512,"../../spotify-live-filter-uri":460,"../../spotify-live-sort-uri":510,"../util/cosmos":508,"./data":483,"spotify-cosmos-api":890,"spotify-player/lib/v2":900}],486:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.setWindowedPlaylistShowTracklistCell = setWindowedPlaylistShowTracklistCell;
exports.play = play;
var playlistData = require('../../../libs/playlist-utils/playlist-data');
var cosmos = require('../util/cosmos');
var windowedPlaylistShowTracklistCell = 'Control';
var abba = require('../../../libs/abba');
var live = require('../../../libs/spotify-live');
var wrappedUri = require('../../../libs/spotify-live-wrapped-uri');

function setWindowedPlaylistShowTracklistCell(cell) {
  windowedPlaylistShowTracklistCell = cell;
}

function play(contextUri, options, opt_callback) {
  checkIfPlaylistsToShowsContext(contextUri).then(function (includeEpisodes) {
    var resolverUrl = playlistData.getCorePlaylistUrl(contextUri, {
      includeEpisodes: includeEpisodes,
      type: 'play'
    }, windowedPlaylistShowTracklistCell);

    var postObject = { url: resolverUrl };
    if (options) {
      postObject.body = options;
    }

    cosmos.post(postObject, opt_callback);
  });
}

function checkIfPlaylistsToShowsContext(contextUri) {
  return new Promise(function (resolve) {
    abba.get('ab-p2s-on-desktop', function (error, cell) {
      var abTestMember = cell === 'Enabled';
      if (!abTestMember) {
        return resolve(false);
      }

      var parsedUri = wrappedUri.parse(contextUri);
      var originUri = parsedUri ? parsedUri.originUri : contextUri;
      live(originUri).query('formatListType', function (error, _ref) {
        var formatListType = _ref.formatListType;

        resolve(formatListType === 'format-shows');
      });
    });
  });
}

},{"../../../libs/abba":49,"../../../libs/playlist-utils/playlist-data":219,"../../../libs/spotify-live":512,"../../../libs/spotify-live-wrapped-uri":511,"../util/cosmos":508}],487:[function(require,module,exports){
/**
 * @module spotify-live-models/player/updates
 * @private
 */
'use strict';

var lastRowsList;
var lastRowsListUri;
var lastRowsListHandler;
var lastRowsListReferrer;
var playerRowKey;
var playerKeys;

/**
 * Listen for updates on a rows list and update the player when
 * changes happen.
 *
 * @param {LiveList} rowsList A live list of rows.
 * @param {Object} options Object with options and data of what to play.
 * @param {Function} handler A handler function that gets called whenever
 *     the list is updated. Gets called with one argument: an options object.
 */
function listen(rowsList, options, handler) {
  if (lastRowsList) {
    removeRowsListener();
  }

  lastRowsList = rowsList;
  lastRowsListUri = options.context;
  lastRowsListReferrer = options.contextPlayerReferrer;

  lastRowsListHandler = function lastRowsListHandler() {
    // Todo: Only add this for TPM.
    options.index = getPlayingAndUpdateIndicesInList(rowsList).update;
    handler(options);
  };

  rowsList.on('update', lastRowsListHandler);
}

/**
 * Check if the last added rows listener is still valid for the current
 * player state, and clean up the update handler if it's not valid.
 *
 * @param {LiveObject} model The player live object.
 */
function clean(model) {
  if (!lastRowsListHandler) return;

  var context = model.get('variant');

  // Remove listener if the player context is no longer the same
  if ((context && context.uri) !== lastRowsListUri) {
    removeRowsListener();

    // Remove listener if the player referrer is no longer the same
  } else {
    var origin = model.get('playOrigin');
    var playerReferrer = origin && origin.get('referrerIdentifier');

    if (playerReferrer !== lastRowsListReferrer && !model.get('contextUpdatedCrossFrame')) {
      removeRowsListener();
    }
  }
}

/**
 * Save which item is currently playing.
 *
 * @param {number} index The index for the playing row.
 */
function setPlayingIndex(index, optRowsList) {
  if (!lastRowsList && !optRowsList) {
    return;
  }

  // If the index is out of bounds (e.g. is -1 because the track is not found),
  // then just keep the old playerRowKey.
  if (index < 0) {
    return;
  }

  var list = optRowsList || lastRowsList;

  playerRowKey = list.keys[index] || null;
  playerKeys = list.keys.slice();
}

/**
 * Remove the saved rows listener data.
 */
function removeRowsListener() {
  if (lastRowsList) {
    lastRowsList.off('update', lastRowsListHandler);
  }

  lastRowsList = null;
  lastRowsListUri = '';
  lastRowsListHandler = null;
  lastRowsListReferrer = '';
}

/**
 * Get the index of the playing row in the provided list.
 *
 * @param {LiveList} rowsList A live list of rows.
 *
 * @return {number} The index of the playing row, or -1 if not found.
 */
function getPlayingAndUpdateIndicesInList(rowsList) {
  if (!playerRowKey) return { update: -1, playing: -1 };

  // Find the currently playing row in the new list
  var playingIndexInNewList = rowsList.keys.indexOf(playerRowKey);
  var updateIndex = playingIndexInNewList;

  // If the playing row was not found in the new list, loop through the row
  // keys of the list that the player is currently playing from, and try to
  // find the next row key that exist both in the currently playing list and
  // the new list.
  if (playingIndexInNewList === -1) {
    var indexInPlayerList = playerKeys.indexOf(playerRowKey);
    for (var i = indexInPlayerList, l = playerKeys.length; i < l; i++) {
      updateIndex = rowsList.keys.indexOf(playerKeys[i]);
      if (updateIndex > -1) {

        // Index must be -1 since we've moved down several rows. The cosmos
        // player wants the index of the next row, so before passing it to
        // cosmos, the index will be incremented again.
        updateIndex--;

        break;
      }
    }
  }

  return {
    update: updateIndex,
    playing: playingIndexInNewList
  };
}

/**
 * Check if the player is currently playing from a rows list.
 *
 * @param {string} opt_uri Context URI. If passed, it checks for that specific URI.
 *
 * @return {boolean} True if it is playing from a rows list, false otherwise.
 */
function isPlayingFromRowsContext(opt_uri) {
  if (opt_uri) return lastRowsListUri === opt_uri;

  return !!lastRowsList;
}

exports.setPlayingIndex = setPlayingIndex;
exports.listen = listen;
exports.clean = clean;
exports.getPlayingAndUpdateIndicesInList = getPlayingAndUpdateIndicesInList;
exports.isPlayingFromRowsContext = isPlayingFromRowsContext;

},{}],488:[function(require,module,exports){
(function (global){
'use strict';

var _spotifyLive = require('../spotify-live');

var _spotifyLive2 = _interopRequireDefault(_spotifyLive);

var _offlineStatus = require('../playlist-utils/offline-status');

var _spotifyBridgeRequest = require('../spotify-bridge-request');

var _playlistUtils = require('../playlist-utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function onBroadcast(error, body) {
  if (error) {
    if (global.console) console.error(error);
    return;
  }

  (0, _spotifyLive2.default)(body.uri).update(body);
}

function onWait(model, properties) {
  var policy = {};
  if (properties.includes('name')) policy.name = true;
  if (properties.includes('description')) policy.description = true;
  if (properties.includes('image') || properties.includes('annotatedImage')) policy.picture = true;
  if (properties.includes('added')) policy.followed = true;
  if (properties.includes('formatListType')) policy.formatListType = true;
  if (properties.includes('annotatedImage')) policy.pictureFromAnnotate = true;
  if (properties.includes('owner')) policy.owner = { link: true, username: true, name: true };
  if (Object.keys(policy).length === 0) return;

  (0, _playlistUtils.subscribeToMetadata)(model.uri, policy, function (error, data) {
    if (error) {
      console.error(error);
      return;
    }

    if ('picture' in data) {
      data.image = data.picture;
      delete data.picture;
    }

    if ('pictureFromAnnotate' in data) {
      data.annotatedImage = data.pictureFromAnnotate && data.image || null;
      delete data.pictureFromAnnotate;
    }

    if ('offline' in data) {
      data.offlineStatus = data.offline;
      data.shouldBeOffline = (0, _offlineStatus.shouldBeOffline)(data.offline);
      delete data.offline;
    }

    if (properties.includes('formatListType')) {
      data.formatListType = data.formatListType || 'playlist';
    }

    model.update(data);
  });
}

var matches = exports.matches = /^spotify:user:(.*):playlist/;

var broadcastSubscriptionCancel = void 0;
var registered = void 0;
exports.register = function () {
  if (registered) return;
  registered = true;

  _spotifyLive2.default.subscribe(matches, 'wait', onWait);

  broadcastSubscriptionCancel = (0, _spotifyBridgeRequest.cosmosJSON)({ method: 'SUB', uri: 'sp://messages/v1/playliststate' }, onBroadcast);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  _spotifyLive2.default.unsubscribe(matches, 'wait', onWait);

  broadcastSubscriptionCancel();
  broadcastSubscriptionCancel = null;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../playlist-utils":216,"../playlist-utils/offline-status":217,"../spotify-bridge-request":225,"../spotify-live":512}],489:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/session-storage
 */
'use strict';

var forOwn = require('mout/object/forOwn');
var combine = require('mout/array/combine');
var remove = require('mout/array/remove');
var contains = require('mout/array/contains');

var URI = 'spotify:session-storage';
var live = require('../spotify-live');
var cosmos = require('./util/cosmos');
var endpoints = {
  broadcast: 'sp://messages/v1/session-storage'
};

var waiting = [];

function onInit(model) {
  // Set a flag for showing that the model has been implemented and
  // registered. This is so that we can check this in player without
  // making a breaking change.
  model.update({ implemented: true });
}

function onWait(model, properties) {
  // Ask the top frame to broadcast the properties.
  // Values will be null when they weren't stored.
  waiting = combine(waiting, properties);
  global.top.postMessage({
    type: 'session_storage',
    name: 'broadcast_session_storage',
    data: properties
  }, '*');
}

function onPublish(model, properties) {
  // Tell the top frame to persist and broadcast
  global.top.postMessage({
    type: 'session_storage',
    name: 'set_session_storage',
    data: properties
  }, '*');

  // Optimistic update
  model.update(properties);
}

function onBroadcast(error, event) {
  var update = {};
  var model = live(URI);

  forOwn(event.body, function (value, key) {

    // Update model if this instance of storage knows that the model waits for it
    var isWaiting = contains(waiting, key);

    // Or if the model has a potentially outdated value in the live cache
    var hasKey = model.get(key) !== undefined;

    if (isWaiting || hasKey) update[key] = value;
    if (isWaiting) remove(waiting, key);
  });
  model.update(update);
}

var broadcastSubscription;
var regExp = exports.matches = new RegExp('^' + URI + '$');
var registered;

exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'init', onInit);
  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'publish', onPublish);
  broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, onBroadcast);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'init', onInit);
  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'publish', onPublish);

  if (broadcastSubscription) {
    broadcastSubscription.cancel();
    broadcastSubscription = null;
  }
  waiting.length = 0;
};

exports._endpoints = endpoints;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":512,"./util/cosmos":508,"mout/array/combine":651,"mout/array/contains":652,"mout/array/remove":663,"mout/object/forOwn":689}],490:[function(require,module,exports){
"use strict";

/**
 * This module splits up a list into many chunks.
 *
 * @module spotify-live-models/sorting/chunker
 * @private
 */

/**
 * Splits up an array of data into smaller chunks.
 *
 * @param {Array} list The array to be split up.
 * @param {number=} opt_size Optional size of each chunk.
 *
 * @return {Array} Array of chunks, where each chunk is an array of data.
 */
module.exports = function (list, opt_size) {

  function split(array, segments) {
    segments = segments || 2;
    var results = [];
    if (array == null) {
      return results;
    }

    var minLength = Math.floor(array.length / segments);
    var remainder = array.length % segments;
    var i = 0;
    var len = array.length;
    var segmentIndex = 0;
    var segmentLength;

    while (i < len) {
      segmentLength = minLength;
      if (segmentIndex < remainder) {
        segmentLength++;
      }

      results.push(array.slice(i, i + segmentLength));

      segmentIndex++;
      i += segmentLength;
    }

    return results;
  }

  var size = opt_size || 50;
  var chunkCount = Math.ceil(list.length / size);
  var chunks = split(list, chunkCount);

  return chunks;
};

},{}],491:[function(require,module,exports){
/**
 * This file contains transformations from legacy sort queries to new sort
 * queries. We need this because when a user sorts by a certain column, we store
 * the full URI for that list and the sort query is part of the URI. Whenever
 * we change the sort query of a column, we will break sorting for users who
 * have a stored sort state with the old query. That's why we need to maintain
 * this conversion from old to new to make the right list load for all users.
 *
 * When to remove a conversion needs to be weighed case by case I guess. If a
 * user sorts by a certain column and doesn't launch the client for three months
 * and we change the query during that time, it's expected to still work for
 * that user when logging in the next time.
 *
 * History of this file is in the play-desktop app,
 * https://ghe.spotify.net/zelda/client-zelda-js/blob/master/apps/playlist-desktop/src/legacy-sort-uris.js
 */
'use strict';

exports.legacyQueries = {
  // Change date: 2015-03-16
  'track(album(name))': 'track(album(name),disc,number)',
  // Change date: 2015-03-16
  'track(artists(name))': 'track(artists[0:1](name),album(name),disc,number)',
  // Change date: 2015-03-17, value changed 2015-07-14 because we introduced the conversion below.
  'track(addedBy)': 'addedBy(name)',
  // Change date: 2015-07-14
  'track(addedBy(name))': 'addedBy(name)',
  // Change date: 2015-06-26
  'timeSinceAdded': 'timeSinceAdded,track(album(name),disc,number)'
};

},{}],492:[function(require,module,exports){
'use strict';

/**
 * This module helps posting chunked data to/from a worker.
 *
 * @module spotify-live-models/sorting/poster
 * @private
 */

/**
 * Posts data from/to a worker.
 *
 * @param {Object} worker A web worker.
 * @param {Array} chunks Array of split up data.
 * @param {number} index Index of the current chunk to post. Initiate the
 *     poster with 0, and it posts all data sequentially until all data
 *     is posted.
 * @param {string} id An ID for the full payload.
 */
module.exports = function poster(worker, chunks, index, id) {
  'use strict';

  var data = {
    items: chunks[index],
    id: id
  };

  if (index === chunks.length - 1) {
    data.last = true;
  }

  worker.postMessage(data);

  if (!data.last) {
    poster(worker, chunks, index + 1, id);
  }
};

},{}],493:[function(require,module,exports){
(function (global){
'use strict';

/**
 * This module sorts an array of data in the best possible way.
 * If Web Workers are supported, it will spawn new workers and
 * sort on different threads to speed it up.
 *
 * @module spotify-live-models/sorting/sort
 * @private
 */

var chunker = require('./chunker');
var poster = require('./poster');
var sorter = require('./sorter');
var sortWorker = require('./sortworker');
var defer = require('../../../libs/prime/defer');

var workerFile;
var workers = {};
var callbacks = {};
var waitingForReset = {};

// A generated ID will be stored here for each sorted list. Whenever a sorted
// list is asked to resort, a new ID will be generated and set here for that
// list. That allows us to cancel a previous sort if a newer one has started
// before the old one finished.
var idCounter = 0;
var lastIds = {};

/**
 * The local sorter that sorts on the main thread.
 *
 * @param {string} sortUri URI of the sorted list.
 * @param {Array.<Object>} items Array of items to sort. Each item is
 *     an object with the properties `data` and `key`. The `data`
 *     property is an array of values to sort on. The `key` property
 *     is a string for the row ID.
 * @param {Function} callback Async callback where the data is the array of
 *     sorted items.
*/
function localSorter(sortUri, items, callback) {
  items = sorter(items);

  // Saving the callback as the latest callback for this sorted list
  // will allow us to only respond with the latest sorted values (if
  // multiple sort calls were made at the same time).
  callbacks[sortUri] = callback;

  // Make the callback async
  defer.immediate(function () {

    // Only allow the latest callback to run
    if (callback === callbacks[sortUri]) {
      delete callbacks[sortUri];

      callback(null, items);
    }
  });
}

/**
 * The Web Worker sorter.
 *
 * @param {string} sortUri URI of the sorted list.
 * @param {Array.<Object>} items Array of items to sort. Each item is
 *     an object with the properties `data` and `key`. The `data`
 *     property is an array of values to sort on. The `key` property
 *     is a string for the row ID.
 * @param {Function} callback Async callback where the data is the array of
 *     sorted items.
 */
function workerSorter(sortUri, items, callback) {
  var worker = workers[sortUri];

  // If we already have a worker for this sorted list, reset that worker
  // and tell it to sort the new data. By saving the callback we make sure
  // that the original worker event handler will run the latest callback
  // when the sorting is done.
  if (worker) {
    callbacks[sortUri] = callback;
    waitingForReset[sortUri] = (waitingForReset[sortUri] || 0) + 1;
    var id = (++idCounter).toString(36);
    lastIds[sortUri] = id;
    worker.postMessage({ reset: true, newId: id });
    sendItemsToWorker(items, worker, id);
    return;
  }

  worker = new Worker(workerFile);
  workers[sortUri] = worker;
  callbacks[sortUri] = callback;

  var id = (++idCounter).toString(36);
  lastIds[sortUri] = id;
  sendItemsToWorker(items, worker, id);

  var result = { items: [] };

  worker.addEventListener('message', function (event) {
    onWorkerMessage(event, result, sortUri);
  }, false);
}

/**
 * Event handler for receiving a message from a worker.
 * This will handle collecting all chunks of data and post it to the latest
 * callback when all chunks have been received.
 *
 * @param {Event} event An event object from the worker 'message' event.
 * @param {Object} result An object with a property `items` for the sorted items.
 * @param {string} sortUri The sort URI for the current sort.
 */
function onWorkerMessage(event, result, sortUri) {

  // When the main thread tells the worker to reset, the worker will respond with
  // a message to reset the array of already sorted items.
  if (event.data.reset) {
    waitingForReset[sortUri]--;
    result.items.length = 0;
    return;
  }

  // Skip messages that don't belong to the latest sort
  if (event.data.id !== lastIds[sortUri]) {
    return;
  }

  // If we are still waiting for reset messages, don't continue to add more items
  // to the list of sorted items.
  if (waitingForReset[sortUri]) {
    return;
  }

  // If we are not waiting for any resets, just save the chunk of sorted items.
  result.items = result.items.concat(event.data.items);

  // When all data has been passed over from the worker, kill the worker and run
  // the latest registered callback for this sorted list.
  if (event.data.last) {
    workers[sortUri].terminate();

    var callback = callbacks[sortUri];
    delete callbacks[sortUri];
    delete workers[sortUri];

    callback(null, result.items);
  }
}

/**
 * Create the Web Worker file path.
 * Since the worker can't share objects with the main thead, we can't share
 * dependencies. To solve this, we convert the dependencies to strings and pass
 * them as arguments to the worker file.
 * To circumvent the need of a separate file for the worker, we make the worker
 * itself and the passed dependencies a single string and make a blob out of it.
 * From the blob we can get a URL that we can pass to the worker constructor.
 *
 * @return {string} Blob URL that can be passed to the worker.
 */
function createWorkerFile() {
  var workerStr = sortWorker.toString();
  var sortStr = sorter.toString();
  var chunkerStr = chunker.toString();
  var posterStr = poster.toString();
  var argsStr = [sortStr, chunkerStr, posterStr].join(', ');
  var stringWorker = '(' + workerStr + ')(' + argsStr + ')';

  var blob = new Blob([stringWorker], { type: 'text/javascript' });
  var url = URL.createObjectURL(blob);

  return url;
}

/**
 * Send the provided items to the provided worker. It will do this by splitting
 * the items into chunks and sending the chunks.
 *
 * @param {Array} items An array of items.
 * @param {Worker} worker A worker instance.
 * @param {string} id The ID for the payload.
 */
function sendItemsToWorker(data, worker, id) {
  var chunks = chunker(data);
  poster(worker, chunks, 0, id);
}

/**
 * Get the sort function to use.
 * If Web Workers are supported, it will use that, otherwise it will use the
 * default sorter on the main thread.
 * Having the code in a function allows for testing where worker support can
 * be removed and added while running the tests.
 *
 * @return {Function} The sorter function.
 */
function getSorter() {
  if (global.Worker && global.Blob && global.URL) {
    if (!workerFile) {
      workerFile = createWorkerFile();
    }
    return workerSorter;
  } else {
    return localSorter;
  }
}

/**
 * Sort the data using the best supported method.
 *
 * @param {string} sortUri URI of the sorted list.
 * @param {Array.<Object>} items Array of items to sort. Each item is
 *     an object with the properties `data` and `key`. The `data`
 *     property is an array of values to sort on. The `key` property
 *     is a string for the row ID.
 * @param {Function} callback Async callback where the data is the array of
 *     sorted items.
 */
module.exports = function (sortUri, items, callback) {
  var sort = getSorter();
  sort(sortUri, items, callback);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../libs/prime/defer":220,"./chunker":490,"./poster":492,"./sorter":494,"./sortworker":495}],494:[function(require,module,exports){
'use strict';

/**
 * This module sorts an array of data.
 *
 * @module spotify-live-models/sorting/sorter
 * @private
 */

/**
 * Sorts an array of data. Supports multiple levels of values
 * (if two items are the same, it tests the values in the next level).
 *
 * @param {Array.<Object>} data Array of items to sort. Each item is
 *     an object with the properties `data` and `key`. The `data`
 *     property is an array of values to sort on. The `key` property
 *     is a string for the row ID.
 *
 * @return {Array.<Object>} A new array of the same objects that were
 *     passed in, but sorted.
 */
module.exports = function (data) {
  'use strict';

  data.sort(function (a, b) {

    var length = a.data.length;

    for (var i = 0; i < length; i++) {
      var aValue = a.data[i];
      var bValue = b.data[i];

      var aNumber = parseInt(aValue, 10);
      var bNumber = parseInt(bValue, 10);

      var aStartsWithNumber = !isNaN(aNumber);
      var bStartsWithNumber = !isNaN(bNumber);

      if (aStartsWithNumber && bStartsWithNumber) {
        if (aNumber < bNumber) return -1;
        if (aNumber > bNumber) return 1;
      } else if (aStartsWithNumber) {
        return -1;
      } else if (bStartsWithNumber) {
        return 1;
      }

      if (aValue.localeCompare) {
        var value = aValue.localeCompare(bValue);
        if (value !== 0) return value;
      } else {
        if (aValue < bValue) return -1;
        if (aValue > bValue) return 1;
      }
    }
  });

  return data;
};

},{}],495:[function(require,module,exports){
'use strict';

/**
 * This is the Web Worker file that sorts the data and passes it back again.
 * The file cannot be passed directly to new Worker(), as it needs some
 * dependencies. These dependencies are required before creating the worker,
 * and then serialized together with this file into a single blob, which is
 * used to create the worker.
 *
 * @module spotify-live-models/sorting/sortworker
 * @private
 */

/**
 * Sort worker.
 *
 * @param {Function} sort Function that sorts an array of data based on a
 *     property.
 * @param {Function} chunk Function that splits up data into chunks.
 * @param {Function} post Function that posts chunks of data back to main
 *     thread.
 * @param {Object} opt_worker Optional worker instance (mainly for testability).
 */
module.exports = function (sort, chunk, post, opt_worker) {
  'use strict';

  var worker = opt_worker || self;

  var itemsToSort = [];
  var id = null;

  worker.addEventListener('message', function (event) {

    // When the main thread tells the worker to reset, the worker will respond with
    // a message to reset the array of already sorted items.
    if (event.data.reset) {
      itemsToSort.length = 0;
      id = event.data.newId;
      worker.postMessage({ reset: true, newId: id });
      return;
    }

    // Only set the stored id for the first message
    if (id === null) {
      id = event.data.id;
    }

    // If the event id does not match the stored id, don't do anything.
    // This allows a sort to be aborted in the middle.
    if (id !== event.data.id) {
      return;
    }

    itemsToSort = itemsToSort.concat(event.data.items);

    if (event.data.last) {
      var sortedItems = sort(itemsToSort);
      var chunks = chunk(sortedItems);
      post(worker, chunks, 0, id);
    }
  }, false);
};

},{}],496:[function(require,module,exports){
'use strict';

/**
 * Get the row values used for sorting.
 *
 * @module spotify-live-models/sorting/values
 * @private
 */

/**
 * Get the values from the row based on the passed mask.
 * String values will be sanitized (lowercase, removing articles like 'the' etc).
 * The values can then be used for sorting.
 *
 * @param {Object} mask A mask object from the query parser.
 * @param {Object} row Row data object.
 *
 * @return {Array>} Array of values to sort on.
 *
 * @example
 * var parse = require('../../spotify-live/util/parser');
 * var mask = parse('track(name), track(artists(name))').mask;
 * var row = {track: {name: 'Track', artists: [{name: 'Artist'}]}};
 * var values = getValues(mask, row);
 * console.log(values);
 * // ['track', 'artist']
 */
function getValues(mask, row) {
  var result = [];
  mask.forEach(function (m) {
    var k = m.key;
    var value = row[k];

    // If the value is an array, we will concatenate all the
    // values with a comma in between, so that sorting takes
    // all values into account. An example is sorting tracks
    // based on 'artists(name)', where there can be many
    // artists for a track. We will in that case concatenate
    // all artists with comma in between and use a string with
    // all the artists when we compare in the sort function.
    if (Array.isArray(value)) {
      if (m.mask) {
        var values = [];
        for (var i = 0, l = value.length; i < l; i++) {
          values = values.concat(getValues(m.mask, value[i]));
        }
        result.push(values.join(', '));
      } else {
        result.push(value.join(', '));
      }
    } else {
      if (m.mask) result.push.apply(result, getValues(m.mask, value));else result.push(value);
    }
  });

  result = sanitizeStrings(result);

  return result;
}

/**
 * Sanitize string values. This includes trimming whitespace, converting
 * the string to lower case and removing common articles like 'the'.
 *
 * @param {Array} values Array of values.
 *
 * @return {Array} A new array of sanitized values.
 */
function sanitizeStrings(values) {
  var numberRe = /\b[0-9]+\b/g;
  var pad = '000000';

  return values.map(function (value) {
    if (typeof value !== 'string') return value;

    value = value.toLowerCase();

    // Remove the first article
    var articles = ['the ', '(the) '];
    for (var i = 0, article; article = articles[i]; i++) {
      if (value.indexOf(article) === 0) {
        value = value.replace(article, '');
        break;
      }
    }

    // Zero-pad numbers for natural numeric sorting (i.e. 2 before 10)
    value = value.replace(numberRe, function (match) {
      if (match.length >= pad.length) return match;
      return pad.substr(0, pad.length - match.length) + match;
    });

    return value.trim();
  });
}

module.exports = getValues;

},{}],497:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/sortlist
 */
'use strict';

var live = require('../spotify-live');
var mixIn = require('mout/object/mixIn');

var Range = require('../spotify-range2');
var diff = require('../spotify-live/util/diff');
var parse = require('../spotify-live/util/parser');
var sortUriUtils = require('../spotify-live-sort-uri');
var listOperations = require('../spotify-live-list-operations');

var sort = require('./sorting/sort');
var getValues = require('./sorting/values');

// A generated ID will be stored here for each sorted list. Whenever a sorted
// list is asked to resort, a new ID will be generated and set here for that
// list. That allows us to cancel a previous sort if a newer one has started
// before the old one finished.
var idCounter = 0;
var lastIds = {};

/**
 * Event handler for the live 'init' event on sorted models. Keeps sorted model
 * and tracking model in sync (properties, not rows).
 *
 * This will set up an update listener for the tracking model, so that any
 * changes to the tracking model are also applied to the sort model.
 *
 * This also sets up a publish listener for the sorted model, so that anything
 * that is published on the sorted model gets published on the tracking model,
 * which can then update backend with the data and then update the tracking
 * model with the correct data, which will then trickle back down to the
 * sorted model.
 *
 * @param {LiveObject} sortModel The sorted live model.
 */
function onInit(sortModel) {
  var trackingModel = getTrackingModel(sortModel.uri);

  lastIds[sortModel.uri] = (++idCounter).toString(36);

  // Update the sorted model when any property on the tracking model changes (except rows)
  trackingModel.on('update', function (properties) {
    var updateObject = mixIn({}, properties);
    delete updateObject.rows;
    sortModel.update(updateObject);
  });

  // Update the tracking model when any property on the sort model changes (except rows)
  sortModel.on('publish', function (properties) {
    var updateObject = mixIn({}, properties);
    delete updateObject.rows;
    trackingModel.publish(updateObject);
  });
}

/**
 * Event handler for the live 'wait' event on sorted models.
 * This will fetch any requested property from the tracking model, or if
 * rows are requested, it will perform a sort of the rows from the tracking
 * model.
 *
 * It will also listen for changes. If a change is published on the sorted list,
 * it will be republished on the tracking list. When the tracking list is updated
 * with the new data (maybe after a save on the backend), the sorted list will be
 * updated and resorted if needed.
 *
 * @param {LiveObject} sortModel The sorted live model.
 * @param {Array} properties Array of properties that the model is waiting for.
 */
function onWait(sortModel, properties) {
  var trackingModel = getTrackingModel(sortModel.uri);

  properties.forEach(function (key) {

    // Requesting rows will create a live list of rows, perform sorting,
    // fill the list with the sorted items and also start to listen for changes.
    if (key === 'rows') {
      setRowsProperty(sortModel, trackingModel);

      // Requesting any other property than rows will just get that property from
      // the tracking model.
    } else {
      trackingModel.get(key, function (error, value) {
        if (error) {
          if (global.console) console.error(error);
          return;
        }
        var obj = {};
        obj[key] = value;
        sortModel.update(obj);
      });
    }
  });
}

/**
 * Set the `rows` property on the sort model. It will create a new live list
 * and perform sorting based on the rows of the tracking model. It will also
 * set up listeners for any changes to the lists to automatically keep
 * everything in sync.
 *
 * @param {LiveObject} sortModel The live object for the sorted list.
 * @param {LiveObject} trackingModel The live object for the list the sorted
 *     list is tracking.
 */
function setRowsProperty(sortModel, trackingModel) {
  var sortParams = sortUriUtils.parse(sortModel.uri);
  var direction = sortParams.direction;
  var query = sortParams.query;

  // Start the first sort
  performRowSorting(trackingModel, sortModel, query, direction);

  // Whenever a publish call happens on the sorted list, publish it to the
  // tracking list.
  sortModel.get('rows', function (error, sortList) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    sortList.on('publish', function (operations) {
      var trackingList = trackingModel.get('rows');
      if (!trackingList) return;
      syncRows(trackingList, operations, 'publish');
    });
  });

  // We need to get the rows list of the tracking model to be able to know the
  // length of the list, so that we can create the rows list for the sorted list.
  trackingModel.get('rows', function (error, trackingList) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    // Listen for updates on the tracking list and apply the changes (and
    // maybe resort if needed) on the sorted list.
    trackingList.on('update', function (operations) {
      var sortList = sortModel.get('rows');
      if (!sortList) return;
      var mustSort = syncRows(sortList, operations, 'update');
      if (mustSort) performRowSorting(trackingModel, sortModel, query, direction);
    });
  });
}

/**
 * Get the tracking model for a sort URI.
 * For an ascending sort URI, the tracking model would be the original list.
 * For a descending sort URI, the tracking model would be the ascending sort list.
 *
 * @param {string} sortUri The sort URI.
 *
 * @return {LiveObject} The live object for the tracking model.
 */
function getTrackingModel(sortUri) {
  var parsed = sortUriUtils.parse(sortUri);
  var direction = parsed.direction;
  var originUri = parsed.originUri;
  var query = parsed.query;

  // We can use the sorting from the ascending list when requesting the
  // descending list, by just depending on the ascending list. Asking for
  // data from the ascending list will make that list ask for the data
  // from the original list and then sort it, and then the descending list
  // will reverse that.
  if (direction === 'desc') {
    return live(sortUriUtils.create(originUri, 'asc', query));
  } else {
    return live(originUri);
  }
}

/**
 * Get data that is needed for performing a sort.
 *
 * @param {Array.<Object>} rows Array of objects of metadata about the rows.
 * @param {Object} mask A mask object from the query parser.
 * @param {LiveList} trackingList The live list for the list the sorted
 *     list is tracking.
 *
 * @return {Array.<Object>} A new array of items used for sorting. Each item is
 *     an object with the properties `data` and `key`. The `data`
 *     property is an array of values to sort on. The `key` property
 *     is a string for the row ID.
 *
 * @example
 * {
 *   data: ['Name of Song', 'Whatever', 100, 0],
 *   key: '0'
 * }
 */
function getSortData(rows, mask, trackingList) {
  return rows.map(function (row, i) {
    var array = getValues(mask, row);
    array.push(i);
    return { data: array, key: trackingList.keys[i] };
  });
}

/**
 * Perform sorting of all rows in a list.
 *
 * @param {LiveObject} trackingModel The model that the sort model is tracking.
 *     For ascending lists, this is the original model. For descending lists,
 *     this is the ascending sort model.
 * @param {LiveObject} sortModel The model to perform the sort on.
 * @param {string} sortQuery The sort query (live compatible query).
 * @param {string} sortDirection The sort direction ('asc' or 'desc').
 */
function performRowSorting(trackingModel, sortModel, sortQuery, sortDirection) {
  lastIds[sortModel.uri] = (++idCounter).toString(36);
  var sortId = lastIds[sortModel.uri];

  // Querying the rows of the tracking model might perform a sort. An example is when
  // getting the sort for a descending list, it will query the rows from the ascending
  // list, which will in turn query the rows from the original list and then perform a
  // sort. When the ascending sort is done, the query will be done and the descending
  // list can just use the ascending list and reverse it.
  trackingModel.get('rows', function (error, rows) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    // Create a list of loaded rows. This allows partial loading of a list,
    // and the sorted version will only contain the loaded rows.
    var rowsToSort = [];
    var keys = [];
    for (var i = 0, l = rows.length; i < l; i++) {
      if (rows.get(i)) {
        rowsToSort.push(rows.get(i));
        keys.push(rows.keys[i]);
      }
    }

    // Empty lists won't sort anyway, so quit here, but empty the sorted list
    // to make it up to date.
    if (rowsToSort.length === 0) {
      var sortList = sortModel.get('rows');
      if (sortList) {
        sortList.update([{
          type: 'remove',
          index: 0,
          length: sortList.length
        }]);
      } else {
        sortModel.update({ rows: [] });
      }
      return;
    }

    var partialTrackingList = live([]);

    partialTrackingList.update([{
      type: 'insert',
      index: 0,
      values: rowsToSort,
      keys: keys
    }]);

    // Now we have a list containing only the loaded rows
    partialTrackingList.query(sortQuery, function (error, rows) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }

      // If direction is descending, the tracking model is ascending. Simply reverse that.
      if (sortDirection === 'desc') {
        updateListWithReversedData(sortModel, partialTrackingList);

        // For an ascending sort, perform a real sort.
      } else {

        var mask = parse(sortQuery).mask;
        var sortData = getSortData(rows, mask, partialTrackingList);

        sort(sortModel.uri, sortData, function (error, sortedData) {
          if (error) {
            if (global.console) console.error(error);
            return;
          }
          if (lastIds[sortModel.uri] !== sortId) return;
          updateListWithSortedData(sortModel, partialTrackingList, sortedData);
        });
      }
    });
  });
}

/**
 * Update the sorted live list with the right data after a sort.
 *
 * @param {LiveObject} sortModel The live object for the sorted list.
 * @param {LiveList} trackingList The live list for the list the sorted
 *     list is tracking.
 * @param {Array.<Object>} sortedItems Array of sorted items. Each item is
 *     an object with a property `key`, which is a string for the row ID.
 */
function updateListWithSortedData(sortModel, trackingList, sortedItems) {
  var sortList = sortModel.get('rows');

  // Copy the rows from the list that the sorted list is tracking,
  // if the sorted list has no tracks yet. Only for the first time.
  if (!sortList) {
    sortList = new live.List();
    sortModel.update({ rows: sortList });
  }

  var length = sortedItems.length;
  var keys = new Array(length);
  var values = new Array(length);

  for (var i = 0, l = sortedItems.length; i < l; i++) {
    keys[i] = sortedItems[i].key;
    values[i] = trackingList.valueOf(keys[i]);
  }

  sortList.update([{
    type: 'remove',
    index: 0,
    length: sortList.length
  }, {
    type: 'insert',
    index: 0,
    keys: keys,
    values: values
  }]);
}

/**
 * Update the sorted live list with the data of the list it is tracking,
 * but reversed.
 *
 * @param {LiveObject} sortModel The live object for the sorted list.
 * @param {LiveList} trackingList The live list for the list the sorted
 *     list is tracking.
 */
function updateListWithReversedData(sortModel, trackingList) {
  var sortList = sortModel.get('rows');

  if (!sortList) {
    sortList = new live.List();
    sortModel.update({ rows: sortList });
  }

  sortList.update([{
    type: 'remove',
    index: 0,
    length: sortList.length
  }, {
    type: 'insert',
    index: 0,
    length: trackingList.length,
    values: trackingList.values.slice().reverse(),
    keys: trackingList.keys.slice().reverse()
  }]);
}

/**
 * Converting the passed in operations to be relative to the list that was
 * passed in. Passing operations for a sorted list can convert the operations
 * to be used for the original list. This also updates (or publishes) the list
 * with the converted operations.
 *
 * @param {LiveList} rows The list to sync operations to.
 * @param {Array.<Object>} operations Array of operation objects.
 * @param {string} mode The mode for updates. 'update' or 'publish'.
 *
 * @return {boolean} True if a resort must happen after applying the operations.
 */
function syncRows(rows, operations, mode) {
  var mustSort = false;

  operations.forEach(function (operation) {
    var newOperations = [];

    switch (operation.type) {

      // If rows are removed from the tracking list, we can "simply" remove
      // the same rows from the sorted model.
      case 'remove':
        newOperations = convertRemoveOperationForList(rows, operation);
        break;

      // If rows are inserted in the tracking list, we must add the rows to
      // the sorted list and resort. Where we insert doesn't matter as we will
      // perform a new sort anyway.
      case 'insert':
        newOperations = [{
          type: 'insert', index: 0,
          values: operation.values, keys: operation.keys
        }];
        mustSort = true;
        break;

      // If rows are moved in the tracking list, we don't need to perform any
      // new moves directly, but we will need to perform a resort, as sorting
      // uses stable sort (falls back on index in original list if compared
      // values are the same).
      case 'move':
        mustSort = true;
        break;
    }

    if (mode === 'publish') {
      rows.publish(newOperations);
    } else if (mode === 'update') {
      rows.update(newOperations);
    }
  });

  return mustSort;
}

/**
 * Convert a remove operation from one list to an operation that can
 * be used in another list. An example is when we have an operation that
 * happened in the original list, we need to convert that to operations
 * that can be applied to the sorted list.
 *
 * @param {LiveList} list The live list to create the operations for.
 * @param {Object} operation The input 'remove' operation.
 *
 * @return {Array.<Object>} Array of remove operation objects.
 */
function convertRemoveOperationForList(list, operation) {
  var indices = [];
  var operationKeys = operation.keys;

  list.keys.forEach(function (key, i) {
    if (operationKeys.indexOf(key) > -1) indices.push(i);
  });

  return listOperations.getRemoveOperations(indices);
}

var regExp = exports.matches = /^spotify:internal:sortlist:(asc|desc):([^:]*):(.*)$/;

var registered = false;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'init', onInit);
  live.subscribe(regExp, 'wait', onWait);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'init', onInit);
  live.unsubscribe(regExp, 'wait', onWait);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":512,"../spotify-live-list-operations":461,"../spotify-live-sort-uri":510,"../spotify-live/util/diff":513,"../spotify-live/util/parser":515,"../spotify-range2":551,"./sorting/sort":493,"./sorting/values":496,"mout/object/mixIn":692}],498:[function(require,module,exports){
'use strict';

var _messageProxy = require('../../libs/message-proxy');

/**
 * @module spotify-live-models/station
 */

var live = require('../spotify-live');

// Utilities
var trackToRow = require('./station/track-to-row');
var contains = require('mout/array/contains');
var spotifyURI = require('spotify-liburi');
var thumbActions = require('./station/thumb-actions');

var appUri; // The app where this live model is being used.

var URI = exports.URI = 'spotify:station:';
var regExp = exports.matches = new RegExp('^' + URI + '(' + '((artist:|album:|track:)[a-zA-Z0-9]{22})' + '|' + '(user:[^:]+:' + '(playlist:[a-zA-Z0-9]{22}|top:tracks|toplist))' + '|' + '(user:[^:]+:cluster:[a-zA-Z0-9]{22})' + '|' + '(genre:[a-zA-Z0-9]*)' + ')');
exports.isStationUri = regExp.test.bind(regExp);

var clusterRegExp = new RegExp('^' + URI + '(' + '(user:[^:]+:cluster:[a-zA-Z0-9]{22})' + ')');
exports.isClusterStationUri = regExp.test.bind(clusterRegExp);

var DEFAULT_FETCH_COUNT = 15;

// Station Types
var PLAYLIST = 'playlist';
var TRACK = 'track';
var ALBUM = 'album';
var ARTIST = 'artist';
var GENRE = 'genre';
var CLUSTER = 'cluster';
var UNKNOWN = 'unknown';

var registered = false;
var metadataUpdateUnsubscribe;

var trackingRows = []; // A list of stations that need row updates.
var trackingMetadata = []; // A list of stations that need metadata updates.


/**
 * Get the station's base seed from the live model uri
 * @param {Object} model
 * @return {String}
 */
function getBaseSeedFromUri(model) {
  var seed = model.uri.replace(/^spotify:station:/, 'spotify:');
  return decodeURIComponent(seed);
}

/**
 * Get the station type
 * @param {String} seed
 * @return {String}
 */
function getType(seed) {
  var uri = spotifyURI.from(seed);
  if (!uri) {
    return UNKNOWN;
  }
  var contextType = uri.type;
  if (contextType === spotifyURI.Type.PLAYLIST) {
    return PLAYLIST;
  } else if (contextType === spotifyURI.Type.ARTIST) {
    return ARTIST;
  } else if (contextType === spotifyURI.Type.ALBUM) {
    return ALBUM;
  } else if (contextType === spotifyURI.Type.TRACK) {
    return TRACK;
  } else if (seed.indexOf('spotify:genre:') === 0) {
    return GENRE;
  } else if (seed.indexOf(':cluster:') > 0) {
    return CLUSTER;
  } else {
    return UNKNOWN;
  }
}

/**
 * Thumb up a track
 * @param {Object} model
 * @param {String} trackUID
 */
function onThumbUp(model, trackUri) {
  (0, _messageProxy.messageProxy)({
    method: 'POST',
    uri: 'station-thumb',
    body: {
      'stationUri': model.get('uri'),
      'trackUri': trackUri,
      'thumb': thumbActions.UP
    }
  });
}

/**
 * Thumb down a track
 * @param {Object} model
 * @param {String} trackUID
 */
function onThumbDown(model, trackUri) {
  (0, _messageProxy.messageProxy)({
    method: 'POST',
    uri: 'station-thumb',
    body: {
      'stationUri': model.get('uri'),
      'trackUri': trackUri,
      'thumb': thumbActions.DOWN
    }
  });
}

/**
 * Heart a track
 * @param {Object} model
 * @param {String} trackUID
 */
function onHeart(model, trackUri) {
  (0, _messageProxy.messageProxy)({
    method: 'POST',
    uri: 'station-heart',
    body: {
      'stationUri': model.get('uri'),
      'trackUri': trackUri
    }
  });
}

/**
 * Post a request for data from the container (station-manager in zlink).
 * @param {Object} model
 * @param {Array} properties
 * @param {Boolean} needsRows
 * @param {Integer} fetchCount
 */
function requestStationData(model, properties, needsRows, fetchCount) {
  var count = needsRows ? fetchCount || model.get('fetchCount') : false;
  (0, _messageProxy.messageProxy)({
    method: 'GET',
    uri: 'station',
    target: 'top',
    body: {
      'stationUri': model.get('uri'),
      'metadata': properties,
      'trackCount': count
    }
  }, function onStationGet(err, opts) {
    if (err) {
      (0, _messageProxy.messageProxy)({ method: 'POST', uri: 'station-error',
        body: { stationUri: model.get('uri'), message: err }
      });
      return;
    }
    var stationUri = opts.stationUri;
    var station = opts.station;
    if (station.hasOwnProperty('tracks')) {
      if (trackingRows.indexOf(stationUri) !== -1) {
        var timeStamp = new Date().getTime();
        station.rows = station.tracks.map(trackToRow.bind(null, timeStamp));
      }
      // Never keep a tracks object in the station (needs to be rows).
      delete station.tracks;
    }
    live(stationUri).update(station);
  });
}

/**
 * Get the appURI to compare against the referrerIdentifier from the player
 */
function getAppUri() {
  live('spotify:application').query('appURI', function (error, data) {
    if (!error) {
      appUri = data.appURI;
    }
  });
}

/**
 * Callback for rows wait event.
 * @param {Object} model
 * @param {Array} ranges
 */
function onRowsWait(model, ranges) {
  if (ranges && ranges.length > 0) {
    var fetchCount = 0;
    var largestTrack = 0;
    ranges.forEach(function (a) {
      if (a.end > largestTrack) {
        largestTrack = a.end;
      }
    });
    fetchCount = largestTrack - model.get('rows').length;
    requestStationData(model, [], true, fetchCount);
  }
}

/**
 * Subscriber for updateMetadata messages
 * @param {Object} opts
 */
function onUpdateMetadata(opts) {
  var stationUri = opts.stationUri;
  var metadata = opts.metadata;
  if (trackingMetadata.indexOf(stationUri) === -1) {
    return;
  }
  if (metadata.hasOwnProperty('tracks')) {
    if (trackingRows.indexOf(stationUri) !== -1) {
      var timeStamp = new Date().getTime();
      metadata.rows = metadata.tracks.map(trackToRow.bind(null, timeStamp));
    }
    // Never keep a tracks object in the station (needs to be rows).
    delete metadata.tracks;
  }
  live(stationUri).update(metadata);
}

/**
 * When the model intializes
 * @param {Object} model
 */
function onInit(model) {
  var baseSeed = getBaseSeedFromUri(model);
  if (!baseSeed) {
    return;
  }
  model.update({
    baseSeed: baseSeed,
    type: getType(baseSeed),
    added: false, // set this by default
    fetchCount: DEFAULT_FETCH_COUNT
  });
  model.on('update', function onModelUpdate(properties) {
    if (properties.hasOwnProperty('rows')) {
      model.get('rows').on('wait', onRowsWait.bind(null, model));
      model.off('update', onModelUpdate);
    }
  });
  trackingMetadata.push(model.get('uri'));
}

/**
 * Model publish listener
 * @param {Object} model station
 * @param {Object} properties
 */
function onPublish(model, properties) {
  if (properties.hasOwnProperty('added')) {
    var added = properties.added;
    if (typeof added === 'boolean') {
      model.update({ added: added });
      (0, _messageProxy.messageProxy)({
        method: 'POST',
        uri: 'station-add',
        body: {
          'stationUri': model.get('uri'),
          'add': added
        }
      });
    } else {
      console.error('Added can only be a boolean');
    }
  }
}

/**
 * Unset props listener
 * @param {Object} model station
 * @param {Object} properties
 */
function onWait(model, properties) {
  var rowsIndex = -1;
  var needsMetadata;
  var metaFields = ['name', 'subtitle', 'relatedArtists', 'image', 'nextPageUrl'];

  properties.forEach(function (key, index) {
    if (key === 'rows') {
      rowsIndex = index;
    }
    if (!needsMetadata && contains(metaFields, key)) {
      needsMetadata = true;
    }
  });

  if (rowsIndex !== -1) {
    trackingRows.push(model.get('uri'));
    properties.splice(rowsIndex, 1);
    requestStationData(model, properties, true);
  } else if (needsMetadata) {
    requestStationData(model, properties);
  }
}

exports.register = function () {
  if (registered) {
    return;
  }
  registered = true;

  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'init', onInit);
  live.subscribe(regExp, 'thumb-up', onThumbUp);
  live.subscribe(regExp, 'thumb-down', onThumbDown);
  live.subscribe(regExp, 'heart', onHeart);
  live.subscribe(regExp, 'publish', onPublish);
  metadataUpdateUnsubscribe = (0, _messageProxy.messageProxy)({
    method: 'SUB',
    uri: 'station-metadata'
  }, onUpdateMetadata);
  getAppUri();
};

exports.unregister = function () {
  if (!registered) {
    return;
  }
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'init', onInit);
  live.unsubscribe(regExp, 'thumb-up', onThumbUp);
  live.unsubscribe(regExp, 'thumb-down', onThumbDown);
  live.unsubscribe(regExp, 'heart', onHeart);
  live.unsubscribe(regExp, 'publish', onPublish);
  metadataUpdateUnsubscribe();
  trackingRows = [];
  trackingMetadata = [];
};

},{"../../libs/message-proxy":214,"../spotify-live":512,"./station/thumb-actions":502,"./station/track-to-row":503,"mout/array/contains":652,"spotify-liburi":899}],499:[function(require,module,exports){
'use strict';

var rowToPlayerTrack = require('./row-to-player-track');

var PLAYER_RESTRICTIONS = {
  'disallow_toggling_repeat_context_reasons': ['disallow-radio'],
  'disallow_toggling_repeat_track_reasons': ['disallow-radio'],
  'disallow_toggling_shuffle_reasons': ['disallow-radio']
};

/**
 * Create an array of tracks formatted for the context player
 * @param {Object} model
 * @return {Array} tracks array
 */
function createPlayerTracks(model) {
  var rows = model.get('rows');
  if (!rows) {
    return [];
  }
  return rows.values.map(rowToPlayerTrack);
}

/**
 * Construct a context object for context-player
 * @param {Object} model station live model
 * @return {Object} context
 */
module.exports = function createPlayContext(model) {
  return {
    'entity_uri': model.get('uri'),
    'pages': [{
      'tracks': createPlayerTracks(model),
      'next_page_url': model.get('nextPageUrl')
    }],
    'metadata': {
      'context_description': model.get('name')
    },
    'restrictions': PLAYER_RESTRICTIONS
  };
};

},{"./row-to-player-track":501}],500:[function(require,module,exports){
'use strict';

var PLAYER_OPTIONS = {
  'shuffling_context': false,
  'repeating_context': false,
  'repeating_track': false
};

/**
 * This is neccesary because you dont get pages back from the context-player.
 * So if you want to resume a station with a set of rows (not pages)
 * you have to know the index of the last played row,
 * which you can get by comparing currentTrackUid with the row's Uid.
 * @param {Object} model station live model
 * @return {Int} index
 */
function getLastIndex(model) {
  var rows = model.get('rows');
  var currentTrackUid = model.get('currentTrackUid');

  if (!rows || !currentTrackUid) {
    return 0;
  }

  var currentIndex;

  var foundRow = rows.values.some(function (row, index) {
    if (row.get('uid') === currentTrackUid) {
      currentIndex = index;
      return true;
    }
  });

  return foundRow ? currentIndex : 0;
};

/**
 * Creates the context-player options for a station context
 * @param {Object} model station model
 * @param {Object} options optional
 * @return {Object} playOptions
 */
module.exports = function createPlayOptions(model, options) {
  if (options && (options.index || options.index === 0)) {
    var trackIndex = options.index;
  } else {
    var trackIndex = getLastIndex(model);
  }
  var playOptions = {
    'skip_to_index': {
      'page': 0,
      'track': trackIndex
    },
    'player_options_override': PLAYER_OPTIONS
  };
  if (options && options.uid) {
    playOptions.uid = options.uid;
  }
  return playOptions;
};

},{}],501:[function(require,module,exports){
'use strict';

/**
 * Converts a station row into a track for the context-player
 * @param {Object} row station row
 * @return {Object} track
 */

module.exports = function rowToPlayerTrack(row) {
  return {
    'uid': row.get('uid'),
    'uri': row.get('track').get('uri'),
    'album_uri': row.get('track').get('albumUri'),
    'artist_uri': row.get('track').get('artistUri'),
    'metadata': {
      'image_url': row.get('track').get('image'),
      'radio.thumb': row.get('thumb')
    }
  };
};

},{}],502:[function(require,module,exports){
'use strict';

module.exports = {
  UP: 'ups',
  DOWN: 'downs'
};

},{}],503:[function(require,module,exports){
'use strict';

/**
 * Convert track objects coming from station-manager into a row.
 * @param {Object} track
 * @return {Object} row
 */

module.exports = function trackToRow(timeStamp, track, index) {
  var metadata = track.metadata || {};
  var artistUri = track.artist_uri || metadata.artist_uri;
  var albumUri = track.album_uri || metadata.album_uri;
  var uid = track.uid;

  if (!track.uid) {
    var id = track.uri.replace('spotify:track:', '');
    uid = timeStamp + id + index;
  }

  return {
    uid: uid,
    uri: uid,
    thumb: metadata['radio.thumb'] || '',
    track: {
      uri: track.uri,
      name: metadata.title,
      image: metadata.image_url,
      artistUri: artistUri,
      albumUri: albumUri,
      artists: [{ name: metadata.artist_name, uri: artistUri }],
      album: { name: metadata.album_title, uri: albumUri }
    }
  };
};

},{}],504:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/track
 */
'use strict';

var live = require('../spotify-live');
var liburi = require('spotify-liburi');
var intersection = require('mout/array/intersection');
var contains = require('mout/array/contains');
var bridge = require('./util/bridge').request;
var cosmos = require('./util/cosmos');
var util = require('./util/common');

var BACKOFF = 100;
var localFilesRequest = null;

var metaFields = ['album', 'artists', 'availability', 'disc', 'duration', 'explicit', 'image', 'local', 'name', 'number', 'placeholder', 'playable', 'popularity', 'linkedTrack'];

function onWait(model, properties) {
  // Set the 'unavailable' property based on the 'playable' property
  if (contains(properties, 'unavailable')) {
    model.get('playable', function (error, playable) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }
      model.update({ unavailable: !playable });
    });
  }

  var hasMetadata = !!intersection(properties, metaFields).length;

  if (hasMetadata) updateMetadata(model);

  var needsShouldBeOffline = contains(properties, 'shouldBeOffline');
  var needsOfflineProgress = contains(properties, 'offlineProgress');
  if (needsShouldBeOffline || needsOfflineProgress) {
    updateOffline(model);
  }
}

function updateMetadata(model) {
  bridge('track_metadata', [model.uri], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    util.setLocalProperties(payload);
    payload.image = largestImage(payload);

    // The linkedTrack is not available everywhere, so do fallback
    if (payload.linkedTrack) {
      payload.linkedTrack = { uri: payload.linkedTrack };
    } else {
      payload.linkedTrack = null;
    }

    model.update(payload);
  });
}

function largestImage(trackMetadata) {
  var imageURI = trackMetadata.image;
  var largestSize;

  if (trackMetadata.images) {
    for (var i = 0; i < trackMetadata.images.length; i++) {
      var currentImage = trackMetadata.images[i];
      if (!largestSize || currentImage[0] > largestSize) {
        largestSize = currentImage[0];
        imageURI = currentImage[1];
      }
    }
  }

  return imageURI;
}

function updateOffline(model) {

  // Local tracks are available offline if they are playable
  if (liburi.fromString(model.uri).type === liburi.Type.LOCAL) {
    model.get('playable', function (error, playable) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }
      model.update({
        shouldBeOffline: playable,
        offlineProgress: playable ? 1 : 0
      });
    });
    return;
  }

  cosmos.subscribe({ url: 'sp://offline/v1/resources?uri=' + model.uri }, function (error, response) {

    if (!error) {
      var resource = response.body.resources;
      updateModelWithOfflineData(model, resource);
    } else {
      // Status -104 (or 404 in web player) means 'No endpoint resolver that could handle the request was found'.
      // If that's the case, we handle it like the client doesn't support offline.
      var statusCode = error.response && error.response.getStatusCode();
      if (statusCode === -104 || statusCode === 404) {
        updateModelWithOfflineData(model, { offline_availability: 'no' });
      } else {
        if (global.console) console.error(error);
        return;
      }
    }
  });
}

function updateModelWithOfflineData(model, resource) {
  var shouldBeOffline = false;
  var offlineProgress = 0;

  switch (resource.offline_availability) {
    case 'waiting':
      shouldBeOffline = true;offlineProgress = 0;break;
    case 'downloading':
      shouldBeOffline = true;offlineProgress = 0.5;break;
    case 'yes':
      shouldBeOffline = true;offlineProgress = 1;break;
  }

  model.update({
    shouldBeOffline: shouldBeOffline,
    offlineProgress: offlineProgress
  });
}

function waitForLocalFilesChange() {
  localFilesRequest = cosmos.subscribe({ url: 'sp://local-files/v1/changes' }, function (error, response) {
    if (!registered) return;

    if (error) {
      // Status -104 (or 404 in web player) means 'No endpoint resolver that could handle the request was found'.
      // If that's the case, we bail out and don't do anything.
      var statusCode = error.response && error.response.getStatusCode();
      if (statusCode === -104 || statusCode === 404) {
        return;
      }
      if (global.console) console.error(error);
      return;
    }

    var event = response.body;
    var data = event.data;
    var type = event.type;
    var isAdded = type === 'added';
    var isRemoved = type === 'removed';

    if (isAdded || isRemoved) {
      data.tracks.forEach(function (track) {
        live(track.uri).update({
          shouldBeOffline: isAdded,
          offlineProgress: isAdded ? 1 : 0,
          playable: isAdded
        });
      });
    }
  });
}

function waitForTrackChange() {
  bridge('track_event_wait_any', [], function (error, event) {
    if (!registered) return;

    if (error) {
      setTimeout(function () {
        waitForTrackChange();
      }, BACKOFF);
      if (global.console) console.error(error);
      return;
    }

    waitForTrackChange();

    if (event.type === 'change') {
      if (event.data.playable !== undefined) {
        event.data.unavailable = !event.data.playable;
      }
      live(event.data.uri).update(event.data);
    }
  });
}

var regExp = exports.matches = /^spotify:track:|^spotify:local:[^:]*:[^:]*:[^:]*:\d*$/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);

  waitForLocalFilesChange();

  // Only desktop has support for track relinking
  if (global._getSpotifyModule) {
    waitForTrackChange();
  }
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);

  if (localFilesRequest) {
    localFilesRequest.cancel();
    localFilesRequest = null;
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":512,"./util/bridge":506,"./util/common":507,"./util/cosmos":508,"mout/array/contains":652,"mout/array/intersection":661,"spotify-liburi":899}],505:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/user
 */
'use strict';

var live = require('../spotify-live');
var liburi = require('spotify-liburi');
var contains = require('mout/array/contains');
var intersection = require('mout/array/intersection');
var bridge = require('./util/bridge').request;

function updateMetadata(model) {
  bridge('user_metadata', [model.uri], function (error, payload) {
    if (error && global.console) console.error(error);

    if (!payload) payload = {};

    payload.username = payload.username || liburi.from(model.uri).username;
    payload.name = payload.name || payload.username;
    payload.image = payload.image || '';
    payload.images = payload.images || [];

    if (payload.subscribed == null) {
      payload.subscribed = false;
    }

    if (payload.currentUser == null) {
      live('spotify:client').query('currentUser(uri)', function (error, data) {
        if (error) {
          if (global.console) console.error(error);
          return;
        }
        model.update({ currentUser: model.uri === data.currentUser.uri });
      });
    }

    model.update(payload);
  });
}

function updateArtist(model) {
  bridge('user_associated_artist', [model.uri], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    var artist = payload.artist ? { uri: payload.artist } : null;
    model.update({ artist: artist });
  });
}

function onWait(model, properties) {
  var hasArtist = contains(properties, 'artist');
  var metaFields = ['currentUser', 'name', 'username', 'image', 'images', 'subscribed'];
  var hasMetadata = !!intersection(properties, metaFields).length;

  if (hasMetadata) updateMetadata(model);
  if (hasArtist) updateArtist(model);
}

var regExp = exports.matches = /^spotify:user:[^:]+$/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":512,"./util/bridge":506,"mout/array/contains":652,"mout/array/intersection":661,"spotify-liburi":899}],506:[function(require,module,exports){
/**
 * @module spotify-live-models/util/bridge
 * @private
 */

'use strict';

var bridge = require('../../spotify-bridge-request');

module.exports = {
  request: bridge.request
};

},{"../../spotify-bridge-request":225}],507:[function(require,module,exports){
'use strict';

var liburi = require('spotify-liburi');

function setLocalProperties(track) {
  if (track.album && track.album.uri) {
    var albumType = liburi.from(track.album.uri).type;
    track.album.local = albumType === liburi.Type.LOCAL_ALBUM;
  }
  if (track.artists) {
    for (var i = 0, l = track.artists.length; i < l; i++) {
      var artist = track.artists[i];
      if (artist.uri) {
        var artistType = liburi.from(artist.uri).type;
        artist.local = artistType === liburi.Type.LOCAL_ARTIST;
      }
    }
  }
}

module.exports = {
  setLocalProperties: setLocalProperties
};

},{"spotify-liburi":899}],508:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/util/cosmos
 * @private
 */

'use strict';

var cosmos = require('spotify-cosmos-api');

function DELETE(options, opt_callback) {
  options.method = exports.cosmos.Action.DELETE;
  return request(options, opt_callback);
}

function GET(options, opt_callback) {
  options.method = exports.cosmos.Action.GET;
  return request(options, opt_callback);
}

function SUB(options, opt_callback) {
  options.method = exports.cosmos.Action.SUB;
  return request(options, opt_callback);
}

function POST(options, opt_callback) {
  options.method = exports.cosmos.Action.POST;
  return request(options, opt_callback);
}

function PUT(options, opt_callback) {
  options.method = exports.cosmos.Action.PUT;
  return request(options, opt_callback);
}

function HEAD(options, opt_callback) {
  options.method = exports.cosmos.Action.HEAD;
  return request(options, opt_callback);
}

function request(options, opt_callback) {
  var method = options.method;
  delete options.method;

  var subscription, canceled;

  sanitizeURL(options.url, function (error, url) {
    if (error) return opt_callback && opt_callback(error);

    // if you cancel before the userName is replaced.
    if (canceled) return;

    var request = new exports.cosmos.Request(method || exports.cosmos.Action.GET, url, options.headers, options.body);
    subscription = exports.cosmos.resolver.resolve(request, function (error, response) {
      if (!opt_callback) return;
      if (error) return opt_callback(error);
      try {
        opt_callback(null, {
          body: JSON.parse(response.getBody() || '{}'),
          headers: response.getHeaders(),
          status: response.getStatusCode()
        });
      } catch (parseError) {
        parseError.response = response;
        opt_callback(parseError);
      }
    });
  });

  return {
    cancel: function cancel() {
      if (subscription && subscription.cancel) {
        // we already subscribed, cancel it.
        subscription.cancel();
        subscription = null;
      } else if (!canceled) {
        // not subscribed yet, don't even subscribe.
        canceled = true;
      }
      return null;
    }
  };
}

function sanitizeURL(url, callback) {
  if (url.indexOf('@') > -1) {
    callback(null, url.replace('@', encodeURIComponent(global.__spotify.username)));
  } else {
    callback(null, url);
  }
}

exports.request = request;
exports.get = GET;
exports.post = POST;
exports.subscribe = SUB;
exports.delete = DELETE;
exports.put = PUT;
exports.head = HEAD;
exports.cosmos = cosmos;

exports.sanitizeURL = sanitizeURL;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"spotify-cosmos-api":890}],509:[function(require,module,exports){
'use strict';

var Preferences = require('../../spotify-preferences');

var preferences = null;
var showUnplayableTracks = null;

var isInitialized = false;
var initCallbacks = [];

/**
 * Initialize the module and start listening for preference updates.
 */

function init(callback) {

  initCallbacks.push(callback);
  if (initCallbacks.length > 1) {
    // We already kicked of the subscription
    return;
  }

  subscribe(function (error, value) {
    if (!error) {
      showUnplayableTracks = !!value;
    }
    isInitialized = true;

    var cb;
    while (cb = initCallbacks.pop()) {
      cb(showUnplayableTracks);
    }
  });
}

/**
 * Subscribe for changes of the 'Show Unplayable Tracks' preference.
 *
 * @param {Function} callback Callback function that gets called for
 *                            each change.
 *
 * @return {Object} An object with a `cancel` method.
 */
function subscribe(callback) {
  var preferences = new Preferences('ui');

  return preferences.subscribe('show_unplayable_tracks', function (error, value) {
    if (error) return callback(error);
    callback(null, !!value);
  });
}

exports.subscribe = subscribe;

},{"../../spotify-preferences":550}],510:[function(require,module,exports){
'use strict';

var base = 'spotify:internal:sortlist';
var regExp = /^spotify:internal:sortlist:(asc|desc):([^:]*):(.*)$/;

/**
 * Create a URI representing a sorted variant of a list.
 *
 * @param {string} originUri The original list URI.
 * @param {string} direction The direction of the sorted list ('asc' or 'desc').
 * @param {string} query The query string (compatible with spotify-live). Sorting
 *     implementations might not look at all values. The list of produced values
 *     from the query will be tried in order from left to right. If two items have
 *     the same value, it will look at the next produced value from this query.
 *     Any spaces in the query will be removed.
 *
 * @return {string} URI of the sorted variant of the list. The URI will have
 *     the query string URL encoded.
 */
exports.create = function (originUri, direction, query) {
  originUri = originUri.replace(/^spotify:/, '');

  query = encodeURIComponent(query);
  query = query.replace(/%20/g, '');

  return [base, direction, query, originUri].join(':');
};

/**
 * Get the direction of the sorted list.
 *
 * @param {string} sortUri The URI of the sorted list.
 *
 * @return {string} The direction of the sort ('asc' or 'desc'). If URI is
 *     invalid, this returns an empty string.
 */
exports.getDirection = function (sortUri) {
  var matches = sortUri.match(regExp);
  if (!matches) return '';

  return matches[1];
};

/**
 * Get the query string from a sort URI.
 *
 * @param {string} sortUri The URI of the sorted list.
 *
 * @return {string} The query string, URL decoded. If URI is
 *     invalid, this returns an empty string.
 */
exports.getQuery = function (sortUri) {
  var matches = sortUri.match(regExp);
  if (!matches) return '';

  return decodeURIComponent(matches[2]);
};

/**
 * Get the URI of the original list.
 *
 * @param {string} sortUri The URI of the sorted list.
 *
 * @return {string} The URI of the original list. If the sort URI is invalid,
 *     this returns an empty string.
 */
exports.getOriginUri = function (sortUri) {
  var matches = sortUri.match(regExp);
  if (!matches) return '';

  return 'spotify:' + matches[3];
};

/**
 * Parse and return all parts of the sort URI.
 *
 * @param {string} sortUri The URI of the sorted list.
 *
 * @return {Object?} An object with properties `direction`, `query` and `originUri`,
 *     or null if the URI is not valid.
 */
exports.parse = function (sortUri) {
  var matches = sortUri.match(regExp);
  if (!matches) return null;

  return {
    direction: matches[1],
    query: decodeURIComponent(matches[2]),
    originUri: 'spotify:' + matches[3]
  };
};

/**
 * Test if the provided URI is a valid sort URI.
 *
 * @param {string} sortUri The URI of the sorted list.
 *
 * @return {boolean} True if it's valid, false otherwise.
 */
exports.isValid = function (sortUri) {
  return regExp.test(sortUri);
};

/**
 * The regular expression that matches sort URIs.
 */
exports.regExp = regExp;

},{}],511:[function(require,module,exports){
'use strict';

var sortUriUtils = require('../spotify-live-sort-uri');
var filterUriUtils = require('../spotify-live-filter-uri');

/**
 * Create a URI representing a wrapped variant of a list.
 *
 * @param {object} opts The options.
 * @param {string} opts.originUri The origin uri.
 * @param {object?} opts.filter The filter, if any
 * @param {object?} opts.sort The sorting, if any
 *
 * @return {string} URI of the wrapped variant of the list.
 */
exports.create = function (opts) {
  var uri = opts.originUri;
  if (opts.filter) {
    uri = filterUriUtils.create(uri, opts.filter.query);
  }
  if (opts.sort) {
    uri = sortUriUtils.create(uri, opts.sort.direction, opts.sort.query);
  }
  return uri;
};

/**
 * Get the URI of the original list.
 *
 * @param {string} sortUri The URI of the wrapped list.
 *
 * @return {string} The URI of the original list. If the wrapped URI is invalid,
 *     this returns an empty string.
 */
exports.getOriginUri = function (wrappedUri) {
  var parsed = exports.parse(wrappedUri);
  return parsed && parsed.originUri || '';
};

/**
 * Parse and return all parts of the wrapped URI.
 *
 * @param {string} wrappedUri The URI of the wrapped list.
 *
 * @return {object} An object with properties `originUri`, `sort` and `filter`.
 */
exports.parse = function (wrappedUri) {
  var sort = sortUriUtils.parse(wrappedUri);
  var filter = filterUriUtils.parse(sort && sort.originUri || wrappedUri);
  if (!(sort || filter)) return null;

  return {
    originUri: filter && filter.originUri || sort && sort.originUri,
    sort: sort,
    filter: filter
  };
};

/**
 * Test if the provided URI is a valid wrapped URI.
 *
 * @param {string} wrappedUri The URI of the wrapped list.
 *
 * @return {boolean} True if it's valid, false otherwise.
 */
exports.isValid = function (wrappedUri) {
  return !!exports.parse(wrappedUri);
};

},{"../spotify-live-filter-uri":460,"../spotify-live-sort-uri":510}],512:[function(require,module,exports){
(function (global){
/**
 * @module live
 */'use strict';

// prime

var prime = require('../../libs/prime');
var defer = require('../../libs/prime/defer');
var Emitter = require('../../libs/prime/emitter');

// mout
var isPlainObject = require('mout/lang/isPlainObject');
var isRegExp = require('mout/lang/isRegExp');
var isNumber = function isNumber(n) {
  return typeof n === 'number';
};
var isString = function isString(s) {
  return typeof s === 'string';
};

var escapeRegExp = require('mout/string/escapeRegExp');

var _difference = require('mout/array/difference');
var filter = require('mout/array/filter');
var combine = require('mout/array/combine');
var map = require('mout/array/map');

var deepMixIn = require('mout/object/deepMixIn');
var pick = require('mout/object/pick');

function parallel(tasks, cb) {
  var results = [];
  var pending = tasks.length;

  if (!pending) cb(null, results);else {
    tasks.forEach(function (task, i) {
      task(function (err, result) {
        results[i] = result;
        if (--pending === 0 || err) cb(err, results);
      });
    });
  }
}

// util
var OrderedSet = require('./util/ordered-set');
var Range = require('../spotify-range2');
var parse = require('./util/parser');
var throttle = require('./util/throttle');

// debugging
var debug = require('debug')('spotify-live');

// methods

var isLiveList = function isLiveList(item) {
  return item instanceof LiveList;
};

var isLiveObject = function isLiveObject(item) {
  return item instanceof LiveObject;
};

// Simple, stupid and fast.
// Shallow, not checking hasOwnProperty.
var simpleClone = function simpleClone(object) {
  var clone = {};
  for (var key in object) {
    clone[key] = object[key];
  }
  return clone;
};

var difference = function difference(a, b) {
  return a.length === 0 ? [] : _difference.apply(this, arguments);
};

var values = function values(object, keys) {
  var values = [];
  var key;
  for (var i = 0, len = keys.length; i < len; i++) {
    key = keys[i];
    if (key in object) values.push(object[key]);else values.length++;
  }
  return values;
};

// subtract ranges2 from ranges1
var rdifference = function rdifference(ranges1, ranges2) {
  if (!ranges1.length) return [];

  var resultingRanges = [];

  for (var i = 0, len = ranges1.length; i < len; i++) {
    var range = ranges1[i];
    resultingRanges = resultingRanges.concat(range.subtract(ranges2));
  }

  // Make sure we don't have overlapping ranges
  resultingRanges = new Range(0, 0).merge(resultingRanges);

  // Remove any empty ranges
  resultingRanges = filter(resultingRanges, function (range) {
    return !!range.length;
  });

  return resultingRanges;
};

// merge ranges1 into ranges2
var rcombine = function rcombine(ranges1, ranges2) {
  for (var i = 0, len = ranges1.length; i < len; i++) {
    var range = ranges1[i];
    ranges2 = range.merge(ranges2);
  }
  return ranges2;
};

// util
var IDX = 0;

var slice_ = Array.prototype.slice;

var transform = function transform(item, method) {

  if (isPlainObject(item)) {
    // plain objects need to be liveified
    if ('operations' in item) return new LiveList().update(item.operations);
    return live(item.uri)._update(item, method);
  }

  if (Array.isArray(item)) {
    // arrays need to be liveified
    return new LiveList()._update([{
      type: 'insert',
      index: 0,
      length: item.length,
      values: item
    }], method);
  }
  return item;
};

// Creates a callback with a timeout.
function createTimedCallback(callback, timeout) {
  var called;
  var timeoutId = setTimeout(function () {
    called = true;
    callback(new Error('Timeout Expired: ' + timeout + ' milliseconds'));
  }, timeout);
  return function () {
    if (!called) {
      clearTimeout(timeoutId);
      callback.apply(this, arguments);
    }
  };
};

var LiveList = prime( /** @lends LiveList.prototype */{

  mixin: Emitter,

  /**
   * A representation of an array which may be observed for changes
   * @constructs
   * @mixes Emitter
   * @param {Number} [length] - A number representing the length of the liveList.
   */
  constructor: function LiveList(length) {
    this._data = new OrderedSet(length);
    this._mergeThrottled = throttle(this._merge, this);
    this._waiting = [];

    var self = this;
    var lastWait = '';

    if (live.debug) setInterval(function () {
      var thisWait = self._waiting.toString();
      if (lastWait === thisWait) return;
      lastWait = thisWait;

      if (self._waiting.length) {
        debug(self, 'waiting for', self._waiting);
      } else {
        debug(self, 'all done');
      }
    }, 2000);
  },

  get index() {
    return this._data.index;
  },

  get length() {
    return this._data.length;
  },

  get keys() {
    return this._data.keys;
  },

  get values() {
    return this._data.values;
  },

  indexOf: function indexOf(key) {
    return this._data.indexOf(key);
  },

  indexOfMany: function indexOfMany(keys) {
    return this._data.indexOfMany(keys);
  },

  valueOf: function valueOf(key) {
    return this._data.valueOf(key);
  },

  hasKey: function hasKey(key) {
    return this._data.hasKey(key);
  },

  forEach: function forEach(fn, ctx) {
    this._data.forEach(fn, ctx);
    return this;
  },

  map: function map(fn, ctx) {
    return this._data.map(fn, ctx);
  },

  _merge: function _merge() {
    var data = this._data; // actual data
    var publish = this._publish; // new items on top of a copy of data || null
    var before = this._before; // an old copy of data || null

    if (publish) {
      delete this._publish;
      if (this._listeners && this._listeners.publish) {
        var publishDiff = data.diff(publish);
        if (publishDiff.length) this.emit('publish', publishDiff, EMIT_SYNC);
      }
    } else if (before) {
      delete this._before;
      if (this._listeners && this._listeners.update) {
        var updateDiff = before.diff(data);
        if (updateDiff.length) this.emit('update', updateDiff, EMIT_SYNC);
      }
    }
    return this;
  },

  _update: function _update(operations, method) {

    var branch;
    if (method === PUBLISH) {
      // it was receiving, cannot publish.
      if (this._before) return this;
      branch = this._publish || (this._publish = this._data.clone());
    } else if (method === UPDATE) {
      // it was publishing, delete it.
      if (this._publish) delete this._publish;
      if (!this._before) this._before = this._data.clone();
      branch = this._data;
    }

    var op;
    for (var opIndex = 0, opLen = operations.length; opIndex < opLen; opIndex++) {
      op = operations[opIndex];
      switch (op.type) {
        case 'length':
          branch.length = op.length;break;
        case 'sort':
          branch.sort(op.compareFunction);break;
        case 'move':
          branch.move(op.from, op.to, op.length);break;
        case 'remove':
          branch.remove(op.index, op.length);break;
        case 'insert':
          var values = [];
          var keys = op.keys || [];
          for (var i = 0, len = op.values.length; i < len; i++) {
            if (!op.keys || !op.keys[i]) keys[i] = (IDX++).toString(36);
            values[i] = transform(op.values[i], method);
          }
          branch.insert(op.index, keys, values);
          break;
      }
    }

    if (method === UPDATE) this._waiting = rdifference(this._waiting, this.index);

    this._mergeThrottled();
    return this;
  },

  publish: function publish(operations) {
    return this._update(operations, PUBLISH);
  },

  update: function update(operations) {
    return this._update(operations, UPDATE);
  },

  /**
   * Serialize the data in this list into a plain object.
   *
   * @param {number=} limit Optional limit parameter. Controls how many levels
   *     deep to serialize.
   *
   * @return {Array} The data array.
   */
  serialize: function serialize(limit) {
    if (limit === 0) return [];

    var array = [];
    var nextLimit = limit === undefined ? undefined : limit - 1;

    for (var i = 0; i < this.length; i++) {
      var value = this.values[i];
      var serializedValue = value;
      if (value && value.serialize) {
        serializedValue = value.serialize(nextLimit);
      }
      array.push(serializedValue);
    }

    return array;
  },

  _getDataFromMask: function _getDataFromMask(mask) {
    var items = [];

    if (mask.length > 0) {
      // The provided mask to a list is the mask for each list item, so we need
      // to loop through all the items and get the data from each item based on
      // the mask.
      for (var i = 0, l = this.length; i < l; i++) {
        var item = this.get(i);
        var parsedItem;
        var isObjectOrList = item && item._getDataFromMask;
        if (isObjectOrList) {
          parsedItem = item._getDataFromMask(mask);
        }
        items.push(parsedItem);
      }
    }

    return items;
  },

  _query: function _query(selector, callback, mode) {
    var self = this;

    var query = function query() {
      queryList(self, selector, function (error, data, wasSync) {
        if (error) return callback(error);

        if (!wasSync) {
          self._query(selector, callback, mode);
        } else {
          callback(null, data);
        }
      });
    };

    if (mode === ASYNC) defer.immediate(query);else query();
  },

  /**
   * Query properties in this list.
   * This can be called in two different ways: with a callback or without. When
   * calling it with a callback, it will wait for any missing data and always
   * return the data you queried for. When calling it without a callback, it
   * will return an array structure with only the data that was found in the
   * object at the moment. It will not kick off any events for waiting for
   * properties.
   *
   * @param {String} selector - The query selector. Only selectors without
   *     filters are supported when not providing a callback.
   * @param {Array} params - The query replace parameters.
   * @param {LiveList~queryCallback} callback - The callback that handles the response.
   * @param {Object} [mode] live.SYNC: Force sync, 2: live.ASAP: Don't force async
   * @param {Number} timeout - optional timeout in milliseconds
   *
   * @return {LiveList|Array} If no callback is passed it returns an array with
   *                             the data matching the query, that was found at
   *                             the moment in the list.
   *                             If a callback is passed it returns the instance.
   */
  query: function query(selector, params, callback, mode, timeout) {
    /**
     * @callback LiveList~queryCallback
     * @param {Error|Null} error - An error that you can throw, or null.
     * @param {Array} [data] - The response as an array.
     */
    if (typeof params === 'function') {
      // shift for empty params
      timeout = mode;
      mode = callback;
      callback = params;
      params = [];
    }

    if (!callback) {
      return this._getDataFromMask(parse(selector, params).mask);
    }

    if (!mode) {
      mode = ASYNC;
    } else if (isNumber(mode)) {
      // shift once again
      timeout = mode;
      mode = ASYNC;
    }

    if (timeout) {
      callback = createTimedCallback(callback, timeout);
    }

    this._query(parse(selector, params), callback, mode);
    return this;
  },

  _wait: function _wait(ranges) {
    if (!this._required) {
      // if _required is set, it was deferred already
      this._required = [];
      defer.immediate(function () {
        var missingFromIndex = this.missing(this._required);
        var missingFromWaiting = rdifference(missingFromIndex, this._waiting);
        this._waiting = rcombine(this._waiting, missingFromWaiting);
        delete this._required;
        if (missingFromWaiting.length) this.emit('wait', missingFromWaiting, EMIT_SYNC);
      }, this);
    }
    this._required = rcombine(this._required, ranges);
  },

  missing: function missing(ranges) {
    return rdifference(ranges, this.index);
  },

  // the raw, unbeautified get
  // this can callback sync or async
  _get: function _get(ranges, callback) {
    if (this.missing(ranges).length) {
      // has missing stuff (no matter what)
      this._wait(ranges);

      var check = function check() {
        var needed = this.missing(ranges);
        if (!needed.length) {
          this.off('update', check);
          callback.call(this);
        }
      };

      this.on('update', check);
    } else {
      // the callback is called with 'true' when syncronous.
      callback.call(this, null, true);
    }
  },

  /**
   * Checks if the range has been set with values in the list.
   *
   * @param {number} fromIndex The index to start from.
   * @param {number=} toIndex Optional index to stop at (non-inclusive). If no
   *     toIndex is specified, it will default to the index after fromIndex, to
   *     check for the single item at fromIndex.
   *
   * @return {Boolean} True if the range has been set.
   */
  has: function has(fromIndex, toIndex) {
    var hasToIndex = toIndex !== undefined;
    if (!hasToIndex) toIndex = fromIndex + 1;

    var range = new Range(fromIndex, toIndex);

    return range.contained(this.index);
  },

  /**
   * Gets items from the list between the specified indices.
   * @param {Number} what - The index to start from.
   * @param {Number} [toIndex=fromIndex + 1] - The index to stop at (non-inclusive).
   * @param {LiveList~getCallback} [callback] - Optional callback function. If no toIndex
   *     is specified, the callback can be placed as the second argument.
   * @param {Object} [mode] live.SYNC: Force sync, 2: live.ASAP: Don't force async
   * @param {Number} timeout - optional timeout in milliseconds
   * @return {LiveList|Array} If no callback is specified, returns the requested items in an array.
   *                          If a callback is specified, the method returns the instance.
   */
  get: function get(fromIndex, toIndex) {
    /**
     * @callback LiveList~getCallback
     * @param {Error|Null} error - An error that you can throw, or null.
     * @param {Array|*} [data] - The response as an array.
     *                           If toIndex is not specified a single item on the list is passed.
     */

    // fast, get one
    if (arguments.length === 1) {
      if (isNumber(fromIndex)) return this.values[fromIndex];
      if (isString(fromIndex)) return this.valueOf(fromIndex);
    }

    var self = this;

    var args = slice_.call(arguments);
    var callback, mode, requested;

    for (var i = 0, len = args.length; i < len; i++) {
      var arg = args[i];
      if (typeof arg === 'function') {
        var split = args.splice(i, 3);
        len = args.length;
        callback = split[0];
        if (split[1]) {
          if (split[1] === SYNC || split[1] === ASYNC || split[1] === ASAP) {
            mode = split[1];
          } else {
            // assume this arg is a timeout
            mode = ASYNC;
            callback = createTimedCallback(callback, split[1]);
            break;
          }
          // is there a timeout ?
          if (split[2] && mode !== SYNC) {
            callback = createTimedCallback(callback, split[2]);
          }
        } else {
          mode = ASYNC;
        }
        break;
      }
    }

    var asArray = false;
    var asSingleValue = false;

    if (fromIndex instanceof Range) {
      // one range
      requested = args;
      asArray = !callback && requested.length > 1;
    } else if (Array.isArray(fromIndex)) {
      // array of ranges
      asArray = true;
      requested = fromIndex;
    } else {
      // numbers ?
      var hasToIndex = !isNaN(toIndex);
      if (!hasToIndex) toIndex = fromIndex + 1;
      asSingleValue = !hasToIndex;
      requested = [new Range(fromIndex, toIndex)];
    }

    var result = function result() {
      return map(requested, function (range) {
        return self.values.slice(range.start, range.end);
      });
    };

    var done = function done() {
      if (asArray) callback.call(self, null, result());else if (asSingleValue) callback.call(self, null, self.values[fromIndex]);else callback.apply(self, [null].concat(result()));
    };

    if (!callback) {
      if (asArray) return result();
      return result()[0];
    } else if (mode === SYNC) {
      done();
    } else {
      if (mode === ASYNC && !this.missing(requested).length) {
        // it has all the data but needs to be ASYNC
        defer.immediate(function () {
          this._get(requested, done);
        }, this);
      } else {
        this._get(requested, done);
      }
    }
    return this;
  }

});

var LiveObject = prime( /** @lends LiveObject.prototype */{

  mixin: Emitter,

  /**
   * A representation of an object which may be observed for changes
   * @constructs
   * @mixes Emitter
   */
  constructor: function LiveObject(_uri) {
    this.uri = _uri;
    this._data = { uri: _uri };
    this._mergeThrottled = throttle(this._merge, this);
    this.index = [];
    this._waiting = [];
    this.emit('init', EMIT_SYNC);

    var self = this;
    var lastWait = '';

    if (live.debug) setInterval(function () {
      var thisWait = self._waiting.toString();
      if (lastWait === thisWait) return;
      lastWait = thisWait;

      if (self._waiting.length) {
        debug(self, self._waiting);
      } else {
        debug(self, 'all done');
      }
    }, 2000);
  },

  emit: function emit() {
    var uri = this.uri;
    if (uri) {
      var keys = emitters.keys;
      var values = emitters.values;
      var key;
      var args;

      for (var i = 0, len = keys.length; i < len; i++) {
        key = keys[i];
        if (uri.match(key)) {
          if (!args) {
            args = new Array(arguments.length);
            for (var j = 0; j < arguments.length; ++j) {
              args[j] = arguments[j];
            }
            args.splice(1, 0, this);
          }
          var emitter = values[i];
          emitter.emit.apply(emitter, args);
        }
      }
    }

    Emitter.prototype.emit.apply(this, arguments);
  },

  _merge: function _merge() {
    var data = this._data; // the data
    var before = this._before; // an old copy of data
    var publish = this._publish; // published data
    var value;
    var key;

    // published changes
    if (publish) {
      delete this._publish;

      // emit change events if the object has a uri that can be subscribed too,
      // or the object in itself has listeners
      if (this.uri || this._listeners && this._listeners.publish) {
        var publishEvent = {};

        for (key in publish) {
          value = publish[key];
          if (data[key] !== value) publishEvent[key] = value;
        }

        if (Object.keys(publishEvent).length) {
          this.emit('publish', publishEvent, EMIT_SYNC);
        }
      }
    }

    // if there are changes
    if (before) {
      delete this._before;

      var updateEvent = {};

      // emit change events if the object has a uri that can be subscribed too,
      // or the object in itself has listeners
      if (this.uri || this._listeners && this._listeners.update) {
        // check changed and added keys
        for (key in data) {
          value = data[key];
          // there was no key, or value is different
          if (!(key in before) || before[key] !== value) updateEvent[key] = value;
        }

        // check deleted keys
        for (key in before) {
          value = before[key];
          // there is no key so it was deleted
          if (!(key in data)) updateEvent[key] = undefined;
        }

        if (Object.keys(updateEvent).length) {
          this.emit('update', updateEvent, EMIT_SYNC);
        }
      }
    }

    return this;
  },

  _update: function _update(object, method) {
    var branch;

    if (method === PUBLISH) {
      branch = this._publish || (this._publish = simpleClone(this._data));
    } else if (method === UPDATE) {
      if (!this._before) this._before = simpleClone(this._data);
      branch = this._data;
    }

    var value;
    for (var key in object) {
      value = object[key];
      var previous = !(key in branch) ? undefined : branch[key];

      if (isLiveList(previous)) {
        // updating lists with an array will keep the reference but replace every item.
        if (Array.isArray(value)) {

          previous._update([{
            type: 'remove',
            index: 0,
            length: previous.length
          }, {
            type: 'insert',
            index: 0,
            values: value
          }], method);
          continue;
        } else if (isPlainObject(value) && 'operations' in value) {
          previous._update(value.operations, method);
          continue;
        }
      }

      if (method === UPDATE && value === undefined) delete branch[key];else branch[key] = transform(value, method);
    }

    if (method === UPDATE) {
      this.index = Object.keys(branch);
      this._waiting = difference(this._waiting, this.index);
    }

    this._mergeThrottled();
    return this;
  },

  delete: function _delete(key) {
    var object = {};
    object[key] = undefined;
    return this.update(object);
  },

  update: function update(object) {
    return this._update(object, UPDATE);
  },

  publish: function publish(object) {
    return this._update(object, PUBLISH);
  },

  /**
   * Serialize the data in this object into a plain object.
   *
   * @param {number=} limit Optional limit parameter. Controls how many levels
   *     deep to serialize.
   *
   * @return {Object} The data object.
   */
  serialize: function serialize(limit) {
    if (limit === 0) return {};

    var object = {};
    var data = this._data;
    var nextLimit = limit === undefined ? undefined : limit - 1;

    for (var key in data) {
      var value = data[key];
      if (value === undefined) continue;
      var serializedValue = value;
      if (value && value.serialize) {
        serializedValue = value.serialize(nextLimit);
      }
      object[key] = serializedValue;
    }

    return object;
  },

  _getDataFromMask: function _getDataFromMask(mask) {
    var data = {};

    for (var i = 0, l = mask.length; i < l; i++) {
      var thisMask = mask[i];
      var nextMask = thisMask.mask;
      var key = thisMask.key;

      var realValue = this.get(key);
      var value = realValue;

      // Set the value to an empty object or array, and then it will be filled
      // in with the found data in the next step.
      if (isLiveObject(realValue)) value = {};
      if (isLiveList(realValue)) value = [];

      if (nextMask) {
        if (isLiveObject(realValue)) {
          var innerData = realValue._getDataFromMask(nextMask);
          deepMixIn(value, innerData);
        } else if (isLiveList(realValue)) {
          value = realValue._getDataFromMask(nextMask);
        }
      }

      data[key] = value;
    }

    return data;
  },

  _query: function _query(selector, callback, mode) {
    var self = this;

    var query = function query() {
      queryObject(self, selector, function (error, data, wasSync) {
        if (error) return callback.call(this, error);

        if (!wasSync) {
          self._query(selector, callback, mode);
        } else {
          callback.call(this, null, data);
        }
      });
    };

    if (mode === ASYNC) defer.immediate(query);else query();
  },

  /**
   * Query properties in this object.
   * This can be called in two different ways: with a callback or without. When
   * calling it with a callback, it will wait for any missing properties and
   * always return the data you queried for. When calling it without a callback,
   * it will return an object structure with only the data that was found in the
   * object at the moment. It will not kick off any events for waiting for
   * properties.
   *
   * @param {String} selector - The query selector. Only selectors without
   *     filters are supported when not providing a callback.
   * @param {Array} params - The query replace parameters. Optional.
   * @param {LiveObject~queryCallback} callback - The callback function.
   * @param {Object} [mode] live.SYNC: Force sync, 2: live.ASAP: Don't force async
   * @param {Number} timeout - optional timeout in milliseconds
   *
   * @return {LiveObject|Object} If no callback is passed it returns an object
   *                             with the data matching the query, that was found
   *                             at the moment in the object.
   *                             If a callback is passed it returns the instance.
   */
  query: function query(selector, params, callback, mode, timeout) {
    /**
     * @callback LiveObject~queryCallback
     * @param {Error|Null} error - An error that you can throw, or null.
     * @param {LiveObject} [data] - The response as a plain object.
     */
    if (typeof params === 'function') {
      // shift for empty params
      timeout = mode;
      mode = callback;
      callback = params;
      params = [];
    }

    if (!callback) {
      return this._getDataFromMask(parse(selector, params).mask);
    }

    if (!mode) {
      mode = ASYNC;
    } else if (isNumber(mode)) {
      // shift once again
      timeout = mode;
      mode = ASYNC;
    }

    if (timeout) {
      callback = createTimedCallback(callback, timeout);
    }

    this._query(parse(selector, params), callback, mode);
    return this;
  },

  _wait: function _wait(keys) {
    if (!this._required) {
      // if _required is set, it was deferred already
      this._required = [];
      defer.immediate(function () {
        var missingFromIndex = this.missing(this._required);
        var missingFromWaiting = difference(missingFromIndex, this._waiting);
        this._waiting = combine(this._waiting, missingFromWaiting);
        delete this._required;
        if (missingFromWaiting.length) this.emit('wait', missingFromWaiting, EMIT_SYNC);
      }, this);
    }
    this._required = combine(this._required, keys);
  },

  missing: function missing(keys) {
    return difference(keys, this.index);
  },

  /**
   * Checks if the key has been set in the object.
   *
   * @param {string} key The name of the key.
   *
   * @return {Boolean} True if the key has been set.
   */
  has: function has(key) {
    return this.index.indexOf(key) > -1;
  },

  // the raw, unbeautified get
  // this can callback sync or async
  _get: function _get(keys, callback) {
    if (this.missing(keys).length) {
      this._wait(keys);

      var check = function check() {
        var needed = this.missing(keys);
        if (!needed.length) {
          this.off('update', check);
          callback.call(this);
        }
      };
      this.on('update', check);
    } else {
      // the callback is called with 'true' when syncronous.
      callback.call(this, null, true);
    }
  },

  /**
   * Gets values from the object.
   * @param {...String|Array} keys - An array of strings as arguments.
   * @param {LiveObject~getCallback} [callback] - Optional callback function.
   * @param {Object} [mode] live.SYNC: Force sync, 2: live.ASAP: Don't force async
   * @param {Number} timeout - optional timeout in milliseconds
   * @return {LiveObject|Array|*} If no callback is passed and keys is either an array or multiple arguments
   *                             returns the values in an array.
   *                             If no callback is passed and keys is a single parameter it
   *                             returns the requested value (any type).
   *                             If a callback is passed it returns the instance.
   */
  get: function get(key) {
    /**
     * @callback LiveObject~getCallback
     * @param {Error|Null} error - An error that you can throw, or null.
     * @param {Array|...*} [data] - If keys are requested as arguments (any #)
     *                              it will return many results as arguments.
     *                              If keys are requested as an array (any #), it will return data as an array
     * @param {Number} [mode] 1: FORCE SYNC, 2: DON'T FORCE ASYNC
     */

    // fast, get one
    var data = this._data;
    if (arguments.length === 1 && isString(key)) return data[key];

    var self = this;

    var args = slice_.call(arguments);
    var callback, mode, keys;

    for (var i = 0, len = args.length; i < len; i++) {
      var arg = args[i];
      if (typeof arg === 'function') {
        var split = args.splice(i, 3);
        len = args.length;
        callback = split[0];
        if (split[1]) {
          if (split[1] === SYNC || split[1] === ASYNC || split[1] === ASAP) {
            mode = split[1];
          } else {
            // assume this arg is a timeout
            mode = ASYNC;
            callback = createTimedCallback(callback, split[1]);
            break;
          }
          // is there a timeout ?
          if (split[2] && mode !== SYNC) {
            callback = createTimedCallback(callback, split[2]);
          }
        } else {
          mode = ASYNC;
        }
        break;
      }
    }

    var asArray = false;

    if (Array.isArray(key)) {
      keys = key;
      asArray = true;
    } else {
      keys = args;
    }

    var done = function done() {
      var vals = values(data, keys);
      if (asArray) {
        callback.call(self, null, vals);
      } else {
        vals.unshift(null); // unshift no error
        callback.apply(self, vals);
      }
    };

    if (!callback) {
      return values(data, keys);
    } else if (mode === SYNC) {
      done();
    } else {
      if (mode === ASYNC && !this.missing(keys).length) {
        // it has all the data but needs to be ASYNC
        defer.immediate(function () {
          self._get(keys, done);
        });
      } else {
        this._get(keys, done);
      }
    }

    return this;
  }

});

var queryAny = function queryAny(object, selector, callback) {
  if (isPlainObject(object) || isLiveObject(object)) return queryObject(object, selector, callback);else if (Array.isArray(object) || isLiveList(object)) return queryList(object, selector, callback);else return callback(null, object, true);
};

var queryObject = function queryObject(object, selector, callback) {
  var data = {};
  var isSync = true;

  if (!selector) callback(null, data, isSync);

  var keys = map(selector.mask, 'key');

  var done = function done(values) {
    parallel(values.map(function (objectValue, i) {
      return function (callback) {
        queryAny(objectValue, selector.mask[i], function (error, dataValue, wasSync) {
          if (error) {
            callback(error);
            return;
          }
          if (!wasSync) {
            isSync = false;
          }
          if (data[keys[i]]) {
            deepMixIn(data[keys[i]], dataValue);
          } else {
            data[keys[i]] = dataValue;
          }
          callback();
        });
      };
    }), function (error) {
      callback(error, data, isSync);
    });
  };

  if (isLiveObject(object)) {
    object._get(keys, function (error, wasSync) {
      if (error) return callback(error);
      if (!wasSync) isSync = false;
      var values = map(keys, function (key) {
        return object._data[key];
      });
      done(values);
    });
  } else {
    var values = pick(object, keys);
    done(values);
  }
};

var satisfies = function satisfies(value, op, right) {
  if (!op) return !!value;
  if (isRegExp(right)) return right.test(value);

  if (op === '=') return value === right;
  if (op === '!=') return value !== right;

  if (isNumber(right)) {
    if (op === '>') return value > right;
    if (op === '>=') return value >= right;
    if (op === '<') return value < right;
    if (op === '<=') return value <= right;
  }

  if (isString(right)) {
    var escapedRight = escapeRegExp(right);
    // starts with
    if (op === '^=') return new RegExp('^' + escapedRight).test(value);
    // ends with
    if (op === '$=') return new RegExp(escapedRight + '$').test(value);
    // contains separated by space e.g. 'list of things to look for' ~= 'list'
    if (op === '~=') return new RegExp('(^|\\s)' + escapedRight + '(\\s|$)').test(value);
    // contains separated by - e.g. 'list-of-things-to-look-for' ~= 'things'
    if (op === '|=') return new RegExp('^' + escapedRight + '(-|$)').test(value);
    // contains e.g. 'listofthingstolookfor' ~= 'look'
    if (op === ' *=') return value.toString().indexOf(right) !== -1;
  }

  return false;
};

var filterArray = function filterArray(array, left, op, right, callback) {
  var isSync = true;
  var filtered = [];

  var todo = array.length;
  var failed = false;
  function done(error) {
    if (error) {
      if (!failed) {
        failed = true;
        callback(error);
      }
      return;
    }
    if (failed || --todo > 0) {
      return;
    }
    var clean = [];
    for (var i = 0; i < filtered.length; i++) {
      if (i in filtered) {
        clean.push(filtered[i]);
      }
    }
    callback(null, clean, isSync);
  }

  for (var i = 0; i < array.length; i++) {
    var item = array[i];

    if (isLiveObject(item)) {
      /* eslint-disable */
      item._get([left], function (error, wasSync) {
        if (error) {
          done(error);
          return;
        }
        if (!wasSync) {
          isSync = false;
        }
        var value = item._data[left];
        if (satisfies(value, op, right)) {
          filtered[i] = item;
        }
        done();
      });
      /* eslint-enable */
    } else {
      if (isPlainObject(item)) {
        // filter objects only
        if (satisfies(item[left], op, right)) {
          filtered[i] = item;
        }
      }
      done();
    }
  }
};

// default filter that filters the whole list.
var defaultFilters = [[{
  left: 0,
  op: ':'
}]];

function runSeriallyOnArray(array, startAtIndex, asyncFn, callback) {
  if (startAtIndex >= array.length) {
    callback();
    return;
  }
  asyncFn(array[startAtIndex], function (error) {
    if (error) {
      callback(error);
      return;
    }
    runSeriallyOnArray(array, startAtIndex + 1, asyncFn, callback);
  });
}

var queryList = function queryList(list, selector, callback) {
  var isSync = true;
  // if there are no filters we need to query the full length
  if (!selector.filters) selector.filters = defaultFilters;

  function processConditions(conditions, serialTaskCallback) {
    var ref = [];

    function processCondition(condition, parallelTaskCallback) {
      var left = condition.left;
      var right = condition.right;
      var op = condition.op;

      if ('left' in condition && !('right' in condition) && isNumber(left)) {
        if (!op) right = left + 1;else if (op === ':') right = list.length;
        op = ':';
      }

      if ('right' in condition && !('left' in condition) && isNumber(right) && op === ':') {
        left = 0;
      }

      // filter by range.
      if (isNumber(left) && isNumber(right) && op === ':') {
        // if the list is an array it means it has already been filtered.
        if (Array.isArray(list)) {
          var filtered = slice_.call(list, left, right);
          ref = ref.concat(filtered);
          parallelTaskCallback();
        } else {
          list._get([new Range(left, right)], function (error, wasSync) {
            if (error) return parallelTaskCallback(error);

            for (var i = left; i < right; i++) {
              ref.push(list.values[i]);
            }if (!wasSync) isSync = false;
            parallelTaskCallback();
          });
        }
      } else {
        var done = function done(array) {
          filterArray(array, left, op, right, function (error, filtered, wasSync) {
            if (error) return parallelTaskCallback(error);

            if (!wasSync) isSync = false;
            ref = ref.concat(filtered);
            parallelTaskCallback();
          });
        };

        if (Array.isArray(list)) {
          done(list);
        } else {
          // the list is not an array, never been filtered.
          // assume full length.
          // call a function that filters an array once you arraify it.
          list._get([new Range(0, list.length)], function (error, wasSync) {
            if (error) return parallelTaskCallback(error);

            var array = [];
            for (var i = 0; i < list.length; i++) {
              array.push(list.values[i]);
            }if (!wasSync) isSync = false;
            done(array);
          });
        }
      }
    }

    // list of conditions in a single filter.
    // can be parallel.
    parallel(conditions.map(function (condition) {
      return function (parallelTaskCallback) {
        processCondition(condition, parallelTaskCallback);
      };
    }), function (error) {
      if (error) {
        serialTaskCallback(error);
        return;
      }
      list = ref;
      serialTaskCallback();
    });
  }

  // single filter.
  // must be sequential.
  runSeriallyOnArray(selector.filters, 0, processConditions, function (error) {
    if (error) return callback(error);

    var data = [];

    parallel(list.map(function (item, i) {
      return function (parallelTaskCallback) {
        queryAny(item, selector, function (err, res, wasSync) {
          if (!wasSync) isSync = false;
          if (data[i]) deepMixIn(data[i], res);else data[i] = res;
          parallelTaskCallback(err);
        });
      };
    }), function (err) {
      callback(err, data, isSync);
    });
  });
};

var cache = {};

/**
 * Create a new instance of a object, based on an unique identifier.
 * @function
 * @static
 * @param {String|LiveObject} item - An object with an uri property, or an uri as a string.
 * @return {LiveObject|LiveList} An instance of LiveObject or LiveList.
 */
var live = function live(item) {
  if (Array.isArray(item)) {
    return new LiveList().update([{
      type: 'insert',
      index: 0,
      length: item.length,
      values: item
    }]);
  } else if (isNumber(item)) {
    return new LiveList(item);
  } else if (isString(item)) {
    return cache[item] || (cache[item] = new LiveObject(item));
  } else if (isPlainObject(item)) {
    return live(item.uri).update(item);
  } else if (isLiveList(item) || isLiveObject(item)) {
    return item;
  }

  return new LiveObject();
};

// Allow localStorage.debug to also control live.debug.
if (global.localStorage && global.localStorage.debug && (global.localStorage.debug.indexOf('spotify-live') > -1 || global.localStorage.debug.indexOf('*') > -1)) {
  live.debug = true;
}

var emitters = {
  keys: [],
  values: []
};

/**
 * Subscribe to the specific event of objects matching the pattern.
 * @function
 * @static
 * @param {RegExp} match - Regular expression for matching uris.
 * @param {String} name - The name of the event to listen for.
 * @param {Function} handle - The event handle.
 * @return {Function} The live function.
 */
live.subscribe = function (match, name, handle) {
  if (match.matches) match = match.matches;

  var string = match.toString();

  var keys = emitters.keys;
  var values = emitters.values;

  var emitter;
  for (var i = 0, len = keys.length; i < len; i++) {
    var key = keys[i];
    if (key.toString() === string) {
      emitter = values[i];
      if (emitter) break;
    }
  }

  if (!emitter) {
    keys.push(match);
    values.push(emitter = new Emitter());
  }

  emitter.on(name, handle);

  return this;
};

/**
 * Unsubscribe to the specific event of objects matching the pattern.
 * @function
 * @static
 * @param {RegExp} match - Regular expression for matching uris.
 * @param {String} name - The name of the event to unsubscribe from.
 * @param {Function} handle - The event handle.
 * @return {Function} The live function.
 */
live.unsubscribe = function (match, name, handle) {
  if (match.matches) match = match.matches;

  var string = match.toString();

  var keys = emitters.keys;
  var values = emitters.values;

  var emitter;
  for (var i = 0, len = keys.length; i < len; i++) {
    var key = keys[i];
    if (key.toString() === string) {
      emitter = values[i];
      if (emitter) break;
    }
  }

  if (emitter) emitter.off(name, handle);

  return this;
};

/**
 * Delete a model from the live cache.
 *
 * @param {string} uri A uri.
 *
 * @return {Function} The live function.
 */
live.delete = function (uri) {
  delete cache[uri];
  return this;
};

/**
 * Purge the entire cache.
 *
 * @return {Function} The live function.
 */
live.purge = function () {
  cache = {};
  return this;
};

/**
 * Check if live has an object for the URI in the cache.
 *
 * @param {string} uri A uri.
 *
 * @return {Boolean} True if the object is in the cache.
 */
live.has = function (uri) {
  return !!cache[uri];
};

var EMIT_SYNC = live.EMIT_SYNC = Emitter.EMIT_SYNC;

var ASYNC = live.ASYNC = 'ASYNC';
var SYNC = live.SYNC = 'SYNC';
var ASAP = live.ASAP = 'ASAP';

var PUBLISH = 3;
var UPDATE = 4;

/**
 * @static
 * @see LiveObject
 */
live.Object = LiveObject;

/**
 * @static
 * @see LiveList
 */
live.List = LiveList;

module.exports = live;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../libs/prime":222,"../../libs/prime/defer":220,"../../libs/prime/emitter":221,"../spotify-range2":551,"./util/ordered-set":514,"./util/parser":515,"./util/throttle":516,"debug":582,"mout/array/combine":651,"mout/array/difference":653,"mout/array/filter":656,"mout/array/map":662,"mout/lang/isPlainObject":679,"mout/lang/isRegExp":680,"mout/object/deepMixIn":685,"mout/object/pick":693,"mout/string/escapeRegExp":695}],513:[function(require,module,exports){
/**
 * @module spotify-live/diff
 */
'use strict';

// Original code from: https://github.com/codeparty/arraydiff
// License: MIT
// This has been forked to allow for optimizations and patching operations.

// Based on some rough benchmarking, this algorithm is about O(n^2) worst case,
// and it can compute diffs on random arrays of length 1024 in about 34ms,
// though just a few changes on an array of length 1024 takes about 0.5ms

var splice_ = Array.prototype.splice;
var slice_ = Array.prototype.slice;

var annotate = function annotate(before, after) {
  // Find all items in both the before and after array, and represent them
  // as moves. Many of these "moves" may end up being discarded in the last
  // pass if they are from an index to the same index, but we don't know this
  // up front, since we haven't yet offset the indices.
  //
  // Also keep a map of all the indicies accounted for in the before and after
  // arrays. These maps are used next to create insert and remove diffs.
  var beforeLength = before.length;
  var afterLength = after.length;
  var moves = [];
  var beforeMarked = {};
  var afterMarked = {};
  for (var beforeIndex = 0; beforeIndex < beforeLength; beforeIndex++) {
    var beforeItem = before[beforeIndex];
    for (var afterIndex = 0; afterIndex < afterLength; afterIndex++) {
      if (afterMarked[afterIndex]) continue;
      if (beforeItem !== after[afterIndex]) continue;
      var from = beforeIndex;
      var to = afterIndex;
      var length = 0;
      do {
        beforeMarked[beforeIndex++] = afterMarked[afterIndex++] = true;
        length++;
      } while (beforeIndex < beforeLength && afterIndex < afterLength && before[beforeIndex] === after[afterIndex] && !afterMarked[afterIndex]);
      var moveDiff = {
        type: 'move',
        from: from,
        to: to,
        length: length
      };
      moves.push(moveDiff);
      beforeIndex--;
      break;
    }
  }

  // Create a remove for all of the items in the before array that were
  // not marked as being matched in the after array as well
  var removes = [];
  for (beforeIndex = 0; beforeIndex < beforeLength;) {
    if (beforeMarked[beforeIndex]) {
      beforeIndex++;
      continue;
    }
    var index = beforeIndex;
    var length = 0;
    while (beforeIndex < beforeLength && !beforeMarked[beforeIndex++]) {
      length++;
    }
    var removeDiff = {
      type: 'remove',
      index: index,
      length: length,
      values: slice_.call(before, index, index + length)
    };
    removes.push(removeDiff);
  }

  // Create an insert for all of the items in the after array that were
  // not marked as being matched in the before array as well
  var inserts = [];
  for (afterIndex = 0; afterIndex < afterLength;) {
    if (afterMarked[afterIndex]) {
      afterIndex++;
      continue;
    }
    var index = afterIndex;
    var length = 0;
    while (afterIndex < afterLength && !afterMarked[afterIndex++]) {
      length++;
    }
    var values = slice_.call(after, index, index + length);
    inserts.push({ type: 'insert', index: index, length: length, values: values });
  }

  return [removes, moves, inserts];
};

var offset = function offset(removes, moves, inserts) {

  var insertsLength = inserts.length;
  var removesLength = removes.length;
  var movesLength = moves.length;
  var i, j;

  // Offset subsequent removes and moves by removes
  var count = 0;
  for (i = 0; i < removesLength; i++) {
    var remove = removes[i];
    remove.index -= count;
    count += remove.length;
    for (j = 0; j < movesLength; j++) {
      var move = moves[j];
      if (move.from >= remove.index) move.from -= remove.length;
    }
  }

  // Offset moves by inserts
  for (i = insertsLength; i--;) {
    var insert = inserts[i];
    var length = insert.length;
    for (j = movesLength; j--;) {
      var move = moves[j];
      if (move.to >= insert.index) move.to -= length;
    }
  }

  // Offset the to of moves by later moves
  for (i = movesLength; i-- > 1;) {
    var move = moves[i];
    if (move.to === move.from) continue;
    for (j = i; j--;) {
      var earlier = moves[j];
      if (earlier.to >= move.to) earlier.to -= move.length;
      if (earlier.to >= move.from) earlier.to += move.length;
    }
  }

  // Only output moves that end up having an effect after offsetting
  var outputMoves = [];

  // Offset the from of moves by earlier moves
  for (i = 0; i < movesLength; i++) {
    var move = moves[i];
    if (move.to === move.from) continue;
    outputMoves.push(move);
    for (j = i + 1; j < movesLength; j++) {
      var later = moves[j];
      if (later.from >= move.from) later.from -= move.length;
      if (later.from >= move.to) later.from += move.length;
    }
  }

  // try to reduce the number of move events
  reduceMoves(outputMoves);

  return removes.concat(outputMoves, inserts);
};

var reduceMoves = function reduceMoves(moves) {
  for (var i = 0; i < moves.length; i++) {

    // if we detect a move operation of a lots of items to a near position, we
    // can swap it by a move operation of less items to a farther position
    // (which is going to be much more performant).
    //
    // Example:
    // [1, 2, 3, 4, 5, 6, 7] => [2, 3, 4, 5, 6, 7, 1]
    // We could move [2, 3, 4, 5, 6, 7] one position ahead, but it's better to
    // move [1] six positions behind.
    if (moves[i].length > Math.abs(moves[i].to - moves[i].from)) {
      var from = moves[i].from;
      var to = moves[i].to;
      var length = moves[i].length;

      moves[i].length = Math.abs(moves[i].to - moves[i].from);
      moves[i].from = to;
      moves[i].to = to + length;
    }
  }
};

var insert = function insert(array, index, values) {
  for (var i = 0; i < values.length; i++) {
    if (i in values) {
      var idx = index + i;
      if (array.length < idx) array.length = idx;
      array.splice(idx, 0, values[i]);
    }
  }
  return values;
};

var remove = function remove(array, index, length) {
  return splice_.call(array, index, length);
};

var move = function move(array, from, to, length) {
  var moved = remove(array, from, length);
  insert(array, to, moved);
  return moved;
};

var patch = function patch(array, operations) {
  for (var i = 0; i < operations.length; i++) {
    var operation = operations[i];
    switch (operation.type) {
      case 'move':
        move(array, operation.from, operation.to, operation.length);break;
      case 'remove':
        remove(array, operation.index, operation.length);break;
      case 'insert':
        insert(array, operation.index, operation.values);break;
    }
  }
  return array;
};

var diff = function diff(before, after) {
  var operations = annotate(before, after);
  return offset.apply(this, operations);
};

diff.annotate = annotate;
diff.offset = offset;

diff.remove = remove;
diff.insert = insert;
diff.move = move;
diff.patch = patch;

module.exports = diff;

},{}],514:[function(require,module,exports){
/**
 * @module spotify-live/util/ordered-set
 * @private
 */
'use strict';

// prime

var prime = require('../../../libs/prime');

// mout
var forEach = require('mout/array/forEach');

var Range = require('../../spotify-range2');
var _diff = require('./diff');

var OrderedSet = prime({

  constructor: function constructor(length) {
    if (!length) length = 0;
    this.index = [];
    this.keys = new Array(length);
    this.values = new Array(length);
    this.objectStorage = {};
  },

  get length() {
    return this.keys.length;
  },

  set length(value) {
    this.keys.length = value;
    this.values.length = value;
  },

  forEach: function forEach(fn, ctx) {
    var index = this.index;
    main: for (var k = 0; k < index.length; k++) {
      var range = index[k];
      for (var i = range.start; i < range.end; i++) {
        if (fn.call(ctx, this.values[i], i, this.keys[i], this) === false) break main;
      }
    }
    return this;
  },

  map: function map(fn, ctx) {
    var values = new Array(this.length);
    this.forEach(function (value, index, key) {
      values[index] = fn.call(ctx, value, index, key, this);
    }, this);
    return values;
  },

  copy: function copy(set) {
    this.index = set.index.slice();
    this.keys = set.keys.slice();
    this.values = set.values.slice();
    var length = this.keys.length;
    this.objectStorage = {};
    for (var i = 0; i < length; i++) {
      this.objectStorage[this.keys[i]] = this.values[i];
    }
    return this;
  },

  clone: function clone() {
    return new OrderedSet().copy(this);
  },

  indexOf: function indexOf(key) {
    var index = -1;
    this.forEach(function (v, i, k) {
      if (key === k) {
        index = i;
        return false;
      }
    });
    return index;
  },

  indexOfMany: function indexOfMany(keys) {
    var indexedKeys = {};
    var found = 0;
    var output = [];

    // create a hash with the keys that are going to be searched, so we can
    // access them really fast later
    for (var i = 0; i < keys.length; i++) {
      indexedKeys[keys[i]] = -1;
    }

    this.forEach(function (v, i, k) {
      // If the element one that is being searched, add its position
      // to the output array
      if (k in indexedKeys) {
        indexedKeys[k] = i;
        found++;

        // when we have found all the search keys, we do not need to iterate
        // any more
        if (found >= keys.length) {
          return false;
        }
      }
    });

    for (i = 0; i < keys.length; i++) {
      output[i] = indexedKeys[keys[i]];
    }

    return output;
  },

  valueOf: function valueOf(key) {
    return this.objectStorage[key] || null;
  },

  hasKey: function hasKey(key) {
    return this.objectStorage.hasOwnProperty(key);
  },

  sort: function sort(fn) {
    var keys = this.keys;
    var values = this.values;
    var operations = _diff(values.slice(), values.sort(fn));

    forEach(operations, function (op) {
      // unless something is broken, a sort only produces moves.
      _diff.move(keys, op.from, op.to, op.length);
    });

    return this;
  },

  move: function move(from, to, length) {
    if (from > this.length) return [];
    if (from + length > this.length) length = from - this.length;
    if (to > this.length) to = this.length;
    if (from === to) return [];

    _diff.move(this.keys, from, to, length);
    _diff.move(this.values, from, to, length);

    return this;
  },

  insert: function insert(index, keys, values) {
    if (keys.length !== values.length) throw new Error('length mismatch');

    var range = new Range(index, index + keys.length);
    this.index = range.insert(this.index);

    _diff.insert(this.keys, index, keys);
    _diff.insert(this.values, index, values);

    for (var i = 0, length = keys.length; i < length; i++) {
      this.objectStorage[keys[i]] = values[i];
    }

    return this;
  },

  remove: function remove(index, length) {
    if (index >= this.length) return [];
    if (index + length > this.length) length = this.length;
    var range = new Range(index, index + length);
    this.index = range.extract(this.index);

    for (var i = 0; i < length; i++) {
      delete this.objectStorage[this.keys[i + index]];
    }
    _diff.remove(this.keys, index, length);
    _diff.remove(this.values, index, length);

    return this;
  },

  diff: function diff(target) {
    var operations = _diff.annotate(this.keys, target.keys);

    forEach(operations[0], function (op) {
      // remove
      op.keys = op.values;
      op.values = this.values.slice(op.index, op.index + op.length);
    }, this);

    forEach(operations[1], function (op) {
      // move
      op.keys = op.values;
      op.values = this.values.slice(op.from, op.from + op.length);
    }, this);

    forEach(operations[2], function (op) {
      // insert
      op.keys = op.values;
      op.values = target.values.slice(op.index, op.index + op.length);
    });

    return _diff.offset.apply(_diff, operations);
  },

  patch: function patch(operations) {
    forEach(operations, function (op) {
      switch (op.type) {
        case 'move':
          this.move(op.from, op.to, op.length);break;
        case 'remove':
          this.remove(op.index, op.length);break;
        case 'insert':
          this.insert(op.index, op.keys, op.values);break;
      }
    }, this);
    return this;
  }

});

module.exports = OrderedSet;

},{"../../../libs/prime":222,"../../spotify-range2":551,"./diff":513,"mout/array/forEach":659}],515:[function(require,module,exports){
/**
 * @module spotify-live/util/parser
 */
'use strict';

var normalize = function normalize(value) {
  if (value !== '' && !isNaN(value)) return +value;else if (value === 'true') return true;else if (value === 'false') return false;else if (value === 'null') return null;else if (value === 'undefined') return undefined;
  return value;
};

function escapeForRegExp(str) {
  return str.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
};

var COMMA = ',';
var BMASK = '(';
var EMASK = ')';
var BFILTER = '[';
var EFILTER = ']';
var EQUALS = '=';
var WHITESPACE = '\\s';

var operators = ['=', '!=', '>=', '<=', '>', '<', '^=', '$=', '~=', '|=', '*='];

var keyBlacklist = COMMA + BMASK + EMASK + escapeForRegExp(BFILTER) + escapeForRegExp(EFILTER) + EQUALS + WHITESPACE;
var keyBlacklistCharacterClass = '[^' + keyBlacklist + ']';

var KEY_CHARACTER_REG_EXP = new RegExp(keyBlacklistCharacterClass);
var EXACT_KEY_REG_EXP = new RegExp('^' + keyBlacklistCharacterClass + '+$');

var OPERATORS_REG_EXP = new RegExp(operators.map(escapeForRegExp).join('|'));
var REPLACE_REG_EXP = /\$([\d]+)/;
var RANGE_FILTER_REG_EXP = /^(\d*):(\d*)$/;

var parse = function parse(string, params) {
  if (!params) params = [];

  var selector = { mask: [] };
  var history = [selector];

  var key = '';
  var filter;

  var filterStr = '';
  var left = '';
  var right = '';
  var op = '';

  for (var i = 0; i < string.length + 1; i++) {
    var c = string.charAt(i);

    if (filter) {
      // parse the filter
      filterStr = filterStr.trim();
      if (c === COMMA || c === EFILTER) {
        var matches;
        if (matches = filterStr.match(RANGE_FILTER_REG_EXP)) {
          left = matches[1];
          op = ':';
          right = matches[2];
        } else if (matches = filterStr.match(OPERATORS_REG_EXP)) {
          left = filterStr.substring(0, matches.index);
          op = matches[0];
          right = filterStr.substring(matches.index + op.length);
        } else if (matches = filterStr.match(EXACT_KEY_REG_EXP)) {
          left = matches[0];
        } else {
          throw new SyntaxError('syntax error: `' + filterStr + '` contains characters not valid in a filter');
        }

        filterStr = '';

        var condition = {};

        if (left) {
          var leftMatch = left.match(REPLACE_REG_EXP);
          left = leftMatch ? params[+leftMatch[1]] : normalize(left);
          condition.left = left;
        }

        if (op) condition.op = op;

        if (right) {
          var rightMatch = right.match(REPLACE_REG_EXP);
          right = rightMatch ? params[+rightMatch[1]] : normalize(right);
          condition.right = right;
        }

        if ('left' in condition || 'right' in condition) filter.push(condition);

        right = '';
        left = '';
        op = '';

        if (c === EFILTER) {
          if (filter.length) {
            var filters = selector.filters || (selector.filters = []);
            filters.push(filter);
          }

          filter = null;
        }
        continue;
      }

      filterStr += c;
    } else {
      // parse the key

      if (c && KEY_CHARACTER_REG_EXP.test(c)) {
        // key
        key += c;
      } else if (key && (!c || c === COMMA || c === BMASK || c === BFILTER || c === EMASK)) {
        // end key
        // end word is "a!" or "b(a!)" or "a!,c" or "a!(" or "a!["
        var keyMatch = key.match(REPLACE_REG_EXP);
        // begin a new selector
        history[0].mask.push(selector = { key: keyMatch ? params[+keyMatch[1]] : normalize(key) });
        key = '';
      } else if (c && key) {
        throw new SyntaxError('syntax error: `' + c + '` is not a valid character in a key');
      }

      if (c === BMASK) {
        selector.mask = [];
        history.unshift(selector);
      } else if (c === EMASK) {
        history.shift();
      }

      if (c === BFILTER) {
        filter = [];
      }
    }
  }

  if (history.length !== 1) throw new SyntaxError('syntax error');

  return history[0];
};

/** exports */
module.exports = parse;

},{}],516:[function(require,module,exports){
/**
 * @module spotify-live/util/throttle
 * @private
 */
'use strict';

var defer = require('../../../libs/prime/defer');
var isInteger = function isInteger(n) {
  return typeof n === 'number' && n % 1 === 0;
};

var slice = Array.prototype.slice;

var _throttle = function _throttle(fn, method, context) {
  var queued, args, cancel;

  return function () {
    args = arguments;
    if (!queued) {
      queued = true;
      cancel = method(function (time) {
        queued = false;
        fn.apply(context, slice.call(args).concat(time));
      });
    }
    return cancel;
  };
};

var throttle = function throttle(callback, argument, context) {
  if (isInteger(argument)) return throttle.timeout(callback, argument, context);else return throttle.immediate(callback, argument);
};

throttle.timeout = function (callback, ms, context) {
  return _throttle(callback, function (run) {
    return defer.timeout(run, ms, context);
  }, context);
};

throttle.immediate = function (callback, context) {
  return _throttle(callback, function (run) {
    return defer.immediate(run, context);
  }, context);
};

module.exports = throttle;

},{"../../../libs/prime/defer":220}],517:[function(require,module,exports){
(function (global){
'use strict';

var namespace = void 0;

function getNamespace() {
  if (!namespace) {
    namespace = global.__spotify.app_uri.split(':')[2] + ':' + encodeURIComponent(global.__spotify.username) + ':';
  }
  return namespace;
}

function set(key, value) {
  return global.localStorage.setItem(getNamespace() + key, value);
}

function get(key) {
  return global.localStorage.getItem(getNamespace() + key);
}

function remove(key) {
  return global.localStorage.removeItem(getNamespace() + key);
}

function clear() {
  var namespace = getNamespace();
  Object.keys(global.localStorage).forEach(function (key) {
    if (key.startsWith(namespace)) {
      delete global.localStorage[key];
    }
  });
}

function _setNamespace(value) {
  namespace = value;
}

var storage = {
  set: set,
  get: get,
  remove: remove,
  clear: clear,
  _setNamespace: _setNamespace
};

module.exports = storage;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],518:[function(require,module,exports){
'use strict';

var languages = require('./languages.json');

function lookup(language, to) {
  var lang = languages[language];
  if (lang && lang[to]) {
    return lang[to];
  } else {
    return language;
  }
}

module.exports = lookup;
module.exports.all = function () {
  return Object.keys(languages);
};

},{"./languages.json":519}],519:[function(require,module,exports){
module.exports={
  "cs": {
    "smartling": "cs-CZ"
  },
  "de": {
    "smartling": "de-DE"
  },
  "el": {
    "smartling": "el-GR"
  },
  "en": {
    "smartling": "en-GB"
  },
  "es": {
    "smartling": "es-ES"
  },
  "es-419": {
    "moment": "es",
    "smartling": "es-LA"
  },
  "fi": {
    "smartling": "fi-FI"
  },
  "fr": {
    "smartling": "fr-FR"
  },
  "fr-CA": {
    "smartling": "fr-CA",
    "moment": "fr-ca"
  },
  "hu": {
    "smartling": "hu-HU"
  },
  "id": {
    "smartling": "id-ID"
  },
  "it": {
    "smartling": "it-IT"
  },
  "ja": {
    "smartling": "ja-JP"
  },
  "nl": {
    "smartling": "nl-NL"
  },
  "pl": {
    "smartling": "pl-PL"
  },
  "pt-BR": {
    "moment": "pt-br",
    "smartling": "pt-BR"
  },
  "sv": {
    "smartling": "sv-SE"
  },
  "tr": {
    "smartling": "tr-TR"
  },
  "zh-Hant": {
    "moment": "zh-tw",
    "smartling": "zh-TW"
  },
  "zsm": {
    "moment": "ms-my",
    "smartling": "ms-MY",
    "spotify-numeral": "ms-MY"
  }
}

},{}],520:[function(require,module,exports){
'use strict';

var schemer = require('./schemer');
var cosmos = require('spotify-cosmos-api');
var debug = require('debug');

var id = 0;

module.exports = function log(schema, data) {
  var body = schemer(schema, Object.assign({}, {
    message_name: schema.name,
    message_version: schema.schema_version
  }, data));

  // Logging cosmos endpoint requires all values to be strings.
  body.fields = body.fields.map(function (f) {
    if (typeof f === 'string') return f;
    if (f == null) return '';
    return JSON.stringify(f);
  });

  var qualifiedName = schema.name + schema.schema_version;

  var messageDebug = debug('spotify-logger:' + qualifiedName);
  var requestId = ++id;

  messageDebug('REQ %s#%s %s', qualifiedName, requestId, JSON.stringify(body));

  cosmos.resolver.post({
    url: 'sp://logging/v1/log',
    body: body
  }, function (error, response) {
    if (error) return console.error(error, body);
    messageDebug('RES %s#%s %d', qualifiedName, requestId, response.getStatusCode());
  });
};

},{"./schemer":522,"debug":582,"spotify-cosmos-api":890}],521:[function(require,module,exports){
'use strict';

var schemer = require('./schemer');
var cosmos = require('spotify-cosmos-api');
var debug = require('debug');

var id = 0;

function schemeBody(schema, data) {
  var body = schemer(schema, Object.assign({}, {
    message_name: schema.name,
    message_version: schema.schema_version
  }, data));

  // Logging cosmos endpoint requires all values to be strings.
  body.fields = body.fields.map(function (f) {
    if (typeof f === 'string') return f;
    if (f == null) return '';
    return JSON.stringify(f);
  });

  return body;
}

module.exports.create = function create(schema, callback) {
  var body = {
    message_name: schema.name,
    version: schema.schema_version
  };
  /*eslint-enable camelcase */
  cosmos.resolver.post({
    url: 'sp://logging/v1/create_pending_message',
    body: body
  }, function (error, response) {

    if (error) {
      callback(error, null);
      return;
    }
    var reply = response.getJSONBody();
    if (!reply.hasOwnProperty('message_id')) {
      callback(new Error('pendingLog: message_id not present', reply), null);
      return;
    }
    callback(null, reply.message_id);
  });
};

module.exports.update = function update(schema, messageId, data, callback) {
  var body = schemeBody(schema, data);
  body.message_id = messageId;
  /*eslint-enable camelcase */

  cosmos.resolver.post({
    url: 'sp://logging/v1/update_pending_message',
    body: body
  }, function (error, response) {
    if (error) return callback(error);

    callback(null);
  });
};

module.exports.send = function send(schema, messageId) {

  var body = {
    message_id: messageId,
    message_name: schema.name
  };
  // Logging cosmos endpoint requires all values to be strings.
  var qualifiedName = schema.name + schema.schema_version;
  cosmos.resolver.post({
    url: 'sp://logging/v1/send_pending_message',
    body: body
  }, function (error, response) {
    if (error) return console.error(error, body);
  });
};

},{"./schemer":522,"debug":582,"spotify-cosmos-api":890}],522:[function(require,module,exports){
'use strict';

var validation = require('../../avro-validator');
var debug = require('debug')(require('../package.json').name + ':');

module.exports = function (schema, data) {

  debug(schema.name);

  var name = data.message_name;
  var version = data.message_version;
  var copy = Object.assign({}, data);

  if (version !== schema.schema_version) throw new Error('' + 'Invalid message version: received Message with message_version ' + version + ' but the Schema requires version ' + schema.schema_version);

  // Create positional array of field values as required by cosmos and
  // log-parser, and also create an avro Field for each value to allow
  // validation.
  var fields = schema.fields.map(function (f) {
    var type = f.type;
    var value = copy[f.name];

    // If field is a union, attempt to infer the type by grabbing the first
    // non-null type from the schema.
    if (Array.isArray(f.type)) {
      copy[f.name] = {};
      var firstNoneNullType = type.filter(function (t) {
        return t !== 'null';
      })[0];
      copy[f.name][firstNoneNullType] = value;
      debug('union `%s` (%s) : `%s`', f.name, firstNoneNullType, value);
    } else {
      copy[f.name] = value;
      debug('field `%s` : `%s`', f.name, value);
    }
    return value === undefined ? f.default : value;
  })
  // remove name, version
  .slice(2);

  validation.Validator.validate(schema, copy);

  return {
    message: name,
    version: version,
    fields: fields
  };
};

module.exports.Validator = validation.Validator;
module.exports.ProtocolValidator = validation.ProtocolValidator;

},{"../../avro-validator":123,"../package.json":532,"debug":582}],523:[function(require,module,exports){
'use strict';

var schema = require('../schemas/AdControlEvent1.json');
var log = require('../lib/log');

module.exports = {
  schema: schema,
  log: log.bind(null, schema),
  Reason: {
    USER_POLICY: 'user-policy',
    IN_FOCUS: 'in-focus',
    OUT_OF_FOCUS: 'out-of-focus',
    NOT_STARTED: 'not-started',
    URI_BLACKLISTED: 'uri-blacklisted',
    AUDIO_AD_ACTIVE: 'audio-ad-active',
    VIDEO_AD_ACTIVE: 'video-ad-active',
    BILLBOARD_AD_ACTIVE: 'billboard-ad-active',
    CLIENT_ACTIVE: 'client-active',
    VIDEO_NOT_SUPPORTED: 'video-not-supported'
  },
  Event: {
    ENABLE: 'enable',
    ENABLE_REFRESH: 'enable-refresh',
    DISABLE: 'disable',
    DISABLE_REFRESH: 'disable-refresh',
    TRIGGER_WAIT: 'trigger-wait',
    DISCARD: 'discard'
  },
  Slot: {
    LEADERBOARD: 'leaderboard',
    BILLBOARD: 'billboard'
  }
};

},{"../lib/log":520,"../schemas/AdControlEvent1.json":534}],524:[function(require,module,exports){
'use strict';

var schema = require('../schemas/AdError2.json');
var log = require('../lib/log');

module.exports = {
  schema: schema,
  log: log.bind(null, schema)
};

},{"../lib/log":520,"../schemas/AdError2.json":535}],525:[function(require,module,exports){
'use strict';

var schema = require('../schemas/AdEvent4.json');
var log = require('../lib/log');

module.exports = {
  schema: schema,
  log: log.bind(null, schema)
};

},{"../lib/log":520,"../schemas/AdEvent4.json":536}],526:[function(require,module,exports){
'use strict';

var schema = require('../schemas/AddToPlaylist3.json');
var log = require('../lib/log');

module.exports = {
  schema: schema,
  log: log.bind(null, schema)
};

},{"../lib/log":520,"../schemas/AddToPlaylist3.json":537}],527:[function(require,module,exports){
'use strict';

var schema = require('../schemas/ClientEvent3.json');
var log = require('../lib/log');

module.exports = {
  schema: schema,
  log: log.bind(null, schema)
};

},{"../lib/log":520,"../schemas/ClientEvent3.json":538}],528:[function(require,module,exports){
'use strict';

var schema = require('../schemas/UIImpression5.json');
var log = require('../lib/log');

module.exports = {
  schema: schema,
  log: log.bind(null, schema)
};

},{"../lib/log":520,"../schemas/UIImpression5.json":540}],529:[function(require,module,exports){
'use strict';

var schema = require('../schemas/UIInteraction5.json');
var log = require('../lib/log');

module.exports = {
  schema: schema,
  log: log.bind(null, schema)
};

},{"../lib/log":520,"../schemas/UIInteraction5.json":541}],530:[function(require,module,exports){
'use strict';

var schema = require('../schemas/UserDragAndDropInteraction1.json');
var log = require('../lib/log');

module.exports = {
  schema: schema,
  log: log.bind(null, schema)
};

},{"../lib/log":520,"../schemas/UserDragAndDropInteraction1.json":542}],531:[function(require,module,exports){
'use strict';

var schema = require('../schemas/VideoPlayerErrorKM1.json');
var log = require('../lib/log');

module.exports = {
  schema: schema,
  log: log.bind(null, schema)
};

},{"../lib/log":520,"../schemas/VideoPlayerErrorKM1.json":543}],532:[function(require,module,exports){
module.exports={
  "name": "spotify-logger",
  "version": "1.0.0",
  "description": "Generate / consume log-parser schemas in JS",
  "bin": {
    "spotify-logger-schemas-generator": "bin/schemas-generator",
    "spotify-logger-messages-generator": "bin/messages-generator"
  },
  "main": "lib/log.js",
  "dependencies": {},
  "devDependencies": {},
  "scripts": {
    "dev": "echo App scripts have been removed. Please see docs/app-development.md for more information. && exit 1",
    "prod": "echo App scripts have been removed. Please see docs/app-development.md for more information. && exit 1",
    "spa": "echo App scripts have been removed. Please see docs/app-development.md for more information. && exit 1",
    "enable": "echo App scripts have been removed. Please see docs/app-development.md for more information. && exit 1"
  },
  "author": "Drew Petersen <drewp@spotify.com>",
  "license": "UNLICENSED",
  "private": true
}
},{}],533:[function(require,module,exports){
'use strict';

var schema = require('../schemas/EndVideo9.json');
var pendingLog = require('../lib/pendingLog');

module.exports = {
  schema: schema,
  create: pendingLog.create.bind(null, schema),
  update: pendingLog.update.bind(null, schema),
  send: pendingLog.send.bind(null, schema)
};

},{"../lib/pendingLog":521,"../schemas/EndVideo9.json":539}],534:[function(require,module,exports){
module.exports={
  "type": "record",
  "name": "AdControlEvent",
  "namespace": "com.spotify.Message",
  "doc": "Event for ad controls, such as disabling/enabling ad units",
  "fields": [
    {
      "name": "message_name",
      "type": "string"
    },
    {
      "name": "message_version",
      "type": "int"
    },
    {
      "name": "event",
      "type": [
        "null",
        "string"
      ],
      "doc": "Type of event: disable, enable, enable-refresh, disable-refresh, trigger-wait, trigger",
      "default": null
    },
    {
      "name": "reason",
      "type": [
        "null",
        "string"
      ],
      "doc": "Reason code for event, such as: audio-ad, no-focus.  Blank if not applicable.",
      "default": null
    },
    {
      "name": "slot",
      "type": [
        "null",
        "string"
      ],
      "doc": "Slot name, such as: leaderboard, billboard, stream.  Blank if not applicable.",
      "default": null
    },
    {
      "name": "uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "Current app uri in view, if available, otherwise blank.",
      "default": null
    },
    {
      "name": "in_focus",
      "type": [
        "null",
        "string"
      ],
      "doc": "Set to \"true\" if in focus, \"false\" if not in focus, blank if not known by the emitter.",
      "default": null
    },
    {
      "name": "wait_ms",
      "type": [
        "null",
        "long"
      ],
      "doc": "Number of ms of wait time, relevant for trigger-wait.  Set to zero if not applicable.",
      "default": null
    }
  ],
  "schema_version": 1
}
},{}],535:[function(require,module,exports){
module.exports={
  "type": "record",
  "name": "AdError",
  "namespace": "com.spotify.Message",
  "doc": "Error logging for DFP integration",
  "fields": [
    {
      "name": "message_name",
      "type": "string"
    },
    {
      "name": "message_version",
      "type": "int"
    },
    {
      "name": "request_type",
      "type": [
        "null",
        "string"
      ],
      "doc": "Type of event: VAST, Lasertag, Tracking, Parsing",
      "default": null
    },
    {
      "name": "error_message",
      "type": [
        "null",
        "string"
      ],
      "doc": "Error message",
      "default": null
    },
    {
      "name": "http_error_code",
      "type": [
        "null",
        "long"
      ],
      "doc": "HTTP error code",
      "default": null
    },
    {
      "name": "request_url",
      "type": [
        "null",
        "string"
      ],
      "doc": "Request that was made to the ad server",
      "default": null
    },
    {
      "name": "companion_ad",
      "type": [
        "null",
        "string"
      ],
      "doc": "Companion ad that was returned and caused a VAST parsing error",
      "default": null
    },
    {
      "name": "tracking_event",
      "type": [
        "null",
        "string"
      ],
      "doc": "The type of tracking event that errored for a Tracking error",
      "default": null
    }
  ],
  "schema_version": 2
}
},{}],536:[function(require,module,exports){
module.exports={
  "type": "record",
  "name": "AdEvent",
  "namespace": "com.spotify.Message",
  "doc": "Ad-Specific Event",
  "fields": [
    {
      "name": "message_name",
      "type": "string"
    },
    {
      "name": "message_version",
      "type": "int"
    },
    {
      "name": "ad_playback_id",
      "type": [
        "null",
        "string"
      ],
      "doc": "Identifies each ad serving which can be used to tie together related ad events",
      "default": null
    },
    {
      "name": "app_startup_id",
      "type": [
        "null",
        "string"
      ],
      "doc": "Identifies a users app session as defined by each time the app is restarted",
      "default": null
    },
    {
      "name": "ad_id",
      "type": [
        "null",
        "string"
      ],
      "doc": "id of the Ad for this event.  In most cases, this maps to creative id",
      "default": null
    },
    {
      "name": "lineitem_id",
      "type": [
        "null",
        "string"
      ],
      "doc": "id of DFP line item",
      "default": null
    },
    {
      "name": "creative_id",
      "type": [
        "null",
        "string"
      ],
      "doc": "id of DFP creative asset",
      "default": null
    },
    {
      "name": "ad_format",
      "type": [
        "null",
        "string"
      ],
      "doc": "format of ad this event occurred during",
      "default": null
    },
    {
      "name": "source",
      "type": [
        "null",
        "string"
      ],
      "doc": "Source which generated the event, will mostly be set to the App-ID",
      "default": null
    },
    {
      "name": "context",
      "type": [
        "null",
        "string"
      ],
      "doc": "Context and targeting parameters, same set as passed in ad requests",
      "default": null
    },
    {
      "name": "event",
      "type": [
        "null",
        "string"
      ],
      "doc": "Event name",
      "default": null
    },
    {
      "name": "event_version",
      "type": [
        "null",
        "string"
      ],
      "doc": "Optional event version, can be used as a version or sub-type",
      "default": null
    },
    {
      "name": "jsondata",
      "type": [
        "null",
        "string"
      ],
      "doc": "json encoded map which is specific to the event being sent",
      "default": null
    },
    {
      "name": "source_version",
      "type": [
        "null",
        "string"
      ],
      "doc": "Source stitch app version",
      "default": null
    },
    {
      "name": "slot",
      "type": [
        "null",
        "string"
      ],
      "doc": "Ad slot identifier",
      "default": null
    },
    {
      "name": "ms_from_start",
      "type": [
        "null",
        "long"
      ],
      "doc": "Time elapsed since the ad started playback, with ms precision",
      "default": null
    },
    {
      "name": "in_focus",
      "type": [
        "null",
        "boolean"
      ],
      "doc": "Indicates whether the app was in focus when the AdEvent was fired",
      "default": null
    }
  ],
  "schema_version": 4
}
},{}],537:[function(require,module,exports){
module.exports={
  "namespace": "com.spotify.Message",
  "type": "record",
  "name": "AddToPlaylist",
  "fields": [
    {
      "type": "string",
      "name": "message_name"
    },
    {
      "type": "int",
      "name": "message_version"
    },
    {
      "default": null,
      "doc": "Create playlist, save to collection, save to existing playlist etc.",
      "type": [
        "null",
        "string"
      ],
      "name": "intent"
    },
    {
      "default": null,
      "doc": "URI of item that was added and only the first if multiple.",
      "type": [
        "null",
        "string"
      ],
      "name": "item_uri"
    },
    {
      "default": null,
      "doc": "Number of items added.",
      "type": [
        "null",
        "string"
      ],
      "name": "number_items"
    },
    {
      "default": null,
      "doc": "What section the item where added from.",
      "type": [
        "null",
        "string"
      ],
      "name": "section"
    },
    {
      "default": null,
      "doc": "The view uri which led to add to playlist.",
      "type": [
        "null",
        "string"
      ],
      "name": "source"
    },
    {
      "default": null,
      "doc": "The action which led to add to playlist.",
      "type": [
        "null",
        "string"
      ],
      "name": "source_action"
    },
    {
      "default": null,
      "doc": "The position of playlist added to or null.",
      "type": [
        "null",
        "int"
      ],
      "name": "playlist_index"
    },
    {
      "default": null,
      "doc": "The uri of playlist added to or null.",
      "type": [
        "null",
        "string"
      ],
      "name": "playlist_uri"
    },
    {
      "default": null,
      "doc": "The total number of items displayed.",
      "type": [
        "null",
        "int"
      ],
      "name": "total_number_playlists"
    },
    {
      "default": null,
      "doc": "Unix timestamp",
      "type": [
        "null",
        "long"
      ],
      "name": "time"
    }
  ],
  "doc": "User interacted with add to playlist.",
  "schema_version": 3
}
},{}],538:[function(require,module,exports){
module.exports={
  "type": "record",
  "name": "ClientEvent",
  "namespace": "com.spotify.Message",
  "doc": "A generic client event primarily used by Stitch Apps",
  "fields": [
    {
      "name": "message_name",
      "type": "string"
    },
    {
      "name": "message_version",
      "type": "int"
    },
    {
      "name": "source",
      "type": [
        "null",
        "string"
      ],
      "doc": "Source which generated the event, will mostly be set to the App-ID",
      "default": null
    },
    {
      "name": "context",
      "type": [
        "null",
        "string"
      ],
      "doc": "Optional context within the app",
      "default": null
    },
    {
      "name": "event",
      "type": [
        "null",
        "string"
      ],
      "doc": "Event name",
      "default": null
    },
    {
      "name": "event_version",
      "type": [
        "null",
        "string"
      ],
      "doc": "Optional event version, can be used as a version or sub-type",
      "default": null
    },
    {
      "name": "test_version",
      "type": [
        "null",
        "string"
      ],
      "doc": "Optional test case if A/B testing",
      "default": null
    },
    {
      "name": "source_version",
      "type": [
        "null",
        "string"
      ],
      "doc": "The version of the app",
      "default": null
    },
    {
      "name": "source_vendor",
      "type": [
        "null",
        "string"
      ],
      "doc": "The app vendor",
      "default": null
    },
    {
      "name": "json_data",
      "type": [
        "null",
        "string"
      ],
      "doc": "Additional JSON data specific to the event being sent",
      "default": null
    }
  ],
  "schema_version": 3
}
},{}],539:[function(require,module,exports){
module.exports={
  "type": "record",
  "name": "EndVideo",
  "namespace": "com.spotify.Message",
  "doc": "Information about a video played by the client",
  "fields": [
    {
      "name": "message_name",
      "type": "string"
    },
    {
      "name": "message_version",
      "type": "int"
    },
    {
      "name": "sequence_number",
      "type": [
        "null",
        "long"
      ],
      "doc": "Sequence number of message",
      "default": null
    },
    {
      "name": "file_id",
      "type": [
        "null",
        "bytes"
      ],
      "doc": "ID of the video manifest",
      "default": null
    },
    {
      "name": "playback_id",
      "type": [
        "null",
        "bytes"
      ],
      "doc": "ID of the unique playback",
      "default": null
    },
    {
      "name": "feature_identifier",
      "type": [
        "null",
        "string"
      ],
      "doc": "The identifier of the feature that started playback",
      "default": null
    },
    {
      "name": "feature_version",
      "type": [
        "null",
        "string"
      ],
      "doc": "The version of the feature that started playback",
      "default": null
    },
    {
      "name": "view_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "The URI of the view that started playback",
      "default": null
    },
    {
      "name": "reason_start",
      "type": [
        "null",
        "string"
      ],
      "doc": "Why the video was started",
      "default": null
    },
    {
      "name": "reason_end",
      "type": [
        "null",
        "string"
      ],
      "doc": "Why the video ended (trackdone, trackerror, etc.)",
      "default": null
    },
    {
      "name": "ms_played",
      "type": [
        "null",
        "long"
      ],
      "doc": "Total milliseconds played, including overlapping time ranges",
      "default": null
    },
    {
      "name": "ms_total_est",
      "type": [
        "null",
        "long"
      ],
      "doc": "Duration of the video in milliseconds (constant if VOD, variable if live)",
      "default": null
    },
    {
      "name": "live",
      "type": [
        "null",
        "boolean"
      ],
      "doc": "Is the video being streamed live?",
      "default": null
    },
    {
      "name": "ms_manifest_latency",
      "type": [
        "null",
        "long"
      ],
      "doc": "The time it took to fetch the manifest in milliseconds (may be 0 if cached or prefetched)",
      "default": null
    },
    {
      "name": "n_seekback",
      "type": [
        "null",
        "long"
      ],
      "doc": "Number of times user seeked backwards",
      "default": null
    },
    {
      "name": "ms_seekback",
      "type": [
        "null",
        "long"
      ],
      "doc": "The total amount of milliseconds jumped when performing seekbacks throughout playback.",
      "default": null
    },
    {
      "name": "n_seekfwd",
      "type": [
        "null",
        "long"
      ],
      "doc": "Number of times user seeked forwards",
      "default": null
    },
    {
      "name": "ms_seekfwd",
      "type": [
        "null",
        "long"
      ],
      "doc": "The total amount of milliseconds jumped when performing seek forwards throughout playback.",
      "default": null
    },
    {
      "name": "ms_latency",
      "type": [
        "null",
        "long"
      ],
      "doc": "Time from initiating video playback to first frame ready to play in milliseconds",
      "default": null
    },
    {
      "name": "ui_latency",
      "type": [
        "null",
        "long"
      ],
      "doc": "Time from UI interaction to first frame ready to play in milliseconds (may be -1 if not user-initiated)",
      "default": null
    },
    {
      "name": "start_offset_ms",
      "type": [
        "null",
        "long"
      ],
      "doc": "The offset at which the video started playing in milliseconds",
      "default": null
    },
    {
      "name": "ms_initial_buffering",
      "type": [
        "null",
        "long"
      ],
      "doc": "Time between first segment load and first frame ready to play in milliseconds",
      "default": null
    },
    {
      "name": "ms_seek_rebuffering",
      "type": [
        "null",
        "long"
      ],
      "doc": "Total time spent re-buffering from a seek in milliseconds",
      "default": null
    },
    {
      "name": "ms_stalled",
      "type": [
        "null",
        "long"
      ],
      "doc": "Total time where playback stalled in milliseconds (excluding initial buffering and seek rebuffering)",
      "default": null
    },
    {
      "name": "max_ms_seek_rebuffering",
      "type": [
        "null",
        "long"
      ],
      "doc": "Maximum time spent re-buffering from a single seek",
      "default": null
    },
    {
      "name": "max_ms_stalled",
      "type": [
        "null",
        "long"
      ],
      "doc": "Maximum time stalled from a single stall",
      "default": null
    },
    {
      "name": "n_stalls",
      "type": [
        "null",
        "long"
      ],
      "doc": "Number of times playback was stopped because of empty buffer (excluding initial buffering and seek rebuffering)",
      "default": null
    },
    {
      "name": "shuffle",
      "type": [
        "null",
        "boolean"
      ],
      "doc": "If playback was initiated while in shuffle mode",
      "default": null
    },
    {
      "name": "max_continous",
      "type": [
        "null",
        "long"
      ],
      "doc": "Maximum continuous time range played in milliseconds",
      "default": null
    },
    {
      "name": "union_played",
      "type": [
        "null",
        "long"
      ],
      "doc": "Union of all played time ranges in milliseconds (cannot exceed duration)",
      "default": null
    },
    {
      "name": "play_context",
      "type": [
        "null",
        "string"
      ],
      "doc": "The context from which this track was played (spotify URI)",
      "default": null
    },
    {
      "name": "audiocodec",
      "type": [
        "null",
        "string"
      ],
      "doc": "The primarily played audio codec (in RFC6381 notation)",
      "default": null
    },
    {
      "name": "videocodec",
      "type": [
        "null",
        "string"
      ],
      "doc": "The primarily played video codec (in RFC6381 notation)",
      "default": null
    },
    {
      "name": "play_track",
      "type": [
        "null",
        "string"
      ],
      "doc": "Spotify URI for the track (ex. spotify:episode:abc)",
      "default": null
    },
    {
      "name": "incognito_mode",
      "type": [
        "null",
        "boolean"
      ],
      "doc": "Whether playback was initiated in incognito mode",
      "default": null
    },
    {
      "name": "provider",
      "type": [
        "null",
        "string"
      ],
      "doc": "The playback rule that provided the video, e.g., \"mft/inject_random_track\" or \"queue\"",
      "default": null
    },
    {
      "name": "referrer",
      "type": [
        "null",
        "string"
      ],
      "doc": "Either a remote site or a spotify app which initiated the request",
      "default": null
    },
    {
      "name": "referrer_version",
      "type": [
        "null",
        "string"
      ],
      "doc": "The version of the referrer, where applicable",
      "default": null
    },
    {
      "name": "referrer_vendor",
      "type": [
        "null",
        "string"
      ],
      "doc": "The vendor of the referrer, where applicable",
      "default": null
    },
    {
      "name": "streaming_rule",
      "type": [
        "null",
        "string"
      ],
      "doc": "The streaming rule in effect for this track",
      "default": null
    },
    {
      "name": "gaia_dev_id",
      "type": [
        "null",
        "string"
      ],
      "doc": "Remote control that started the playback. Same as \"dev-id\" in \"Gaia\" messages sent by that device. \"none\" if non-Gaia playback.",
      "default": null
    },
    {
      "name": "start_bitrate",
      "type": [
        "null",
        "long"
      ],
      "doc": "Bitrate at which playback started (bits/s)",
      "default": null
    },
    {
      "name": "full_screen",
      "type": [
        "null",
        "long"
      ],
      "doc": "Milliseconds played while video is in a modal or fullscreen state",
      "default": null
    },
    {
      "name": "time_weighted_bitrate",
      "type": [
        "null",
        "long"
      ],
      "doc": "Average bitrate weighted by the amount of time video played at each bitrate",
      "default": null
    },
    {
      "name": "prefetched_bytes",
      "type": [
        "null",
        "long"
      ],
      "doc": "Total number of bytes prefetched for the selected content",
      "default": null
    },
    {
      "name": "prefetched_bytes_loaded",
      "type": [
        "null",
        "long"
      ],
      "doc": "Total number of prefetched bytes played back",
      "default": null
    },
    {
      "name": "key_system",
      "type": [
        "null",
        "string"
      ],
      "doc": "The DRM key system",
      "default": null
    },
    {
      "name": "ms_key_latency",
      "type": [
        "null",
        "long"
      ],
      "doc": "The time it took to fetch and install the DRM key in milliseconds.",
      "default": null
    },
    {
      "name": "total_bytes",
      "type": [
        "null",
        "long"
      ],
      "doc": "The total segment bytes downloaded",
      "default": null
    },
    {
      "name": "local_time_ms",
      "type": [
        "null",
        "long"
      ],
      "doc": "The local time at which playback was initiated (Unix timestamp in milliseconds)",
      "default": null
    },
    {
      "name": "connection_type_start",
      "type": [
        "null",
        "string"
      ],
      "doc": "connection type (i.e. wifi, 3G) at the start of the stream",
      "default": null
    },
    {
      "name": "connection_type_end",
      "type": [
        "null",
        "string"
      ],
      "doc": "connection type (i.e. wifi, 3G) at the end of the stream",
      "default": null
    },
    {
      "name": "ms_played_background",
      "type": [
        "null",
        "long"
      ],
      "doc": "Milliseconds played in background (audio-only). Always subset of ms-played.",
      "default": null
    }
  ],
  "schema_version": 9
}

},{}],540:[function(require,module,exports){
module.exports={
  "type": "record",
  "name": "UIImpression",
  "namespace": "com.spotify.Message",
  "doc": "A UI impression log",
  "fields": [
    {
      "name": "message_name",
      "type": "string"
    },
    {
      "name": "message_version",
      "type": "int"
    },
    {
      "name": "request_id",
      "type": [
        "null",
        "string"
      ],
      "doc": "Request ID from Spaces Log",
      "default": null
    },
    {
      "name": "feature_id",
      "type": [
        "null",
        "string"
      ],
      "doc": "A name for a feature (e.g., browse-new-releases, collection, etc.)",
      "default": null
    },
    {
      "name": "pageuri",
      "type": [
        "null",
        "string"
      ],
      "doc": "Uri of the page within the feature (e.g., spotify:hub:music, etc.)",
      "default": null
    },
    {
      "name": "section_id",
      "type": [
        "null",
        "string"
      ],
      "doc": "Section of the page (e.g., Early Morning)",
      "default": null
    },
    {
      "name": "item_index",
      "type": [
        "null",
        "int"
      ],
      "doc": "Index of item in block",
      "default": null
    },
    {
      "name": "target_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "URI of item impressed (nullable for page and block impressions)",
      "default": null
    },
    {
      "name": "impression_type",
      "type": [
        "null",
        "string"
      ],
      "doc": "Page, block, or item",
      "default": null
    },
    {
      "name": "render_type",
      "type": [
        "null",
        "string"
      ],
      "doc": "Block container ceramic type (e.g. carousel, list, tile)",
      "default": null
    },
    {
      "name": "timestamp",
      "type": [
        "null",
        "double"
      ],
      "doc": "Unix timestamp of event",
      "default": null
    }
  ],
  "schema_version": 5
}
},{}],541:[function(require,module,exports){
module.exports={
  "type": "record",
  "name": "UIInteraction",
  "namespace": "com.spotify.Message",
  "doc": "A UI interaction log",
  "fields": [
    {
      "name": "message_name",
      "type": "string"
    },
    {
      "name": "message_version",
      "type": "int"
    },
    {
      "name": "request_id",
      "type": [
        "null",
        "string"
      ],
      "doc": "Request ID from Spaces Log",
      "default": null
    },
    {
      "name": "feature_id",
      "type": [
        "null",
        "string"
      ],
      "doc": "A name for a feature (e.g., browse-new-releases, collection, etc.)",
      "default": null
    },
    {
      "name": "pageuri",
      "type": [
        "null",
        "string"
      ],
      "doc": "Uri of the page within the feature (e.g., spotify:hub:music, etc.)",
      "default": null
    },
    {
      "name": "section_id",
      "type": [
        "null",
        "string"
      ],
      "doc": "Section or block of the page (e.g., Early Morning)",
      "default": null
    },
    {
      "name": "item_index",
      "type": [
        "null",
        "int"
      ],
      "doc": "Index of item in block",
      "default": null
    },
    {
      "name": "target_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "Destination of interaction",
      "default": null
    },
    {
      "name": "interaction_type",
      "type": [
        "null",
        "string"
      ],
      "doc": "Type of interaction (e.g., hit, swipe, hold, hover, etc.)",
      "default": null
    },
    {
      "name": "user_intent",
      "type": [
        "null",
        "string"
      ],
      "doc": "Grouping of interactions based on user intent (e.g., play, navigate-forward, navigate-back)",
      "default": null
    },
    {
      "name": "timestamp",
      "type": [
        "null",
        "double"
      ],
      "doc": "Unix timestamp of event",
      "default": null
    }
  ],
  "schema_version": 5
}
},{}],542:[function(require,module,exports){
module.exports={
  "type": "record",
  "name": "UserDragAndDropInteraction",
  "namespace": "com.spotify.Message",
  "doc": "Logged whenever a user drags and drops (currently desktop only) an item in the client. Only completed drag and drops are logged and not canceled/failed ones.",
  "fields": [
    {
      "name": "message_name",
      "type": "string"
    },
    {
      "name": "message_version",
      "type": "int"
    },
    {
      "name": "item_type",
      "type": [
        "null",
        "string"
      ],
      "doc": "Type of item, eg \"track\".",
      "default": null
    },
    {
      "name": "item_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "Uri of item that was dropped and only the first if multiple.",
      "default": null
    },
    {
      "name": "number_items",
      "type": [
        "null",
        "long"
      ],
      "doc": "Number of items dropped.",
      "default": null
    },
    {
      "name": "source_view_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "View uri from where the drag started, eg \"spotify:app:playlist-desktop\".",
      "default": null
    },
    {
      "name": "source_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "Uri of the context from where the drag started, eg: \"spotify:user:spotify:playlist:1m6DKwKNM1YLcm3OX6RzJg\".",
      "default": null
    },
    {
      "name": "source_index",
      "type": [
        "null",
        "long"
      ],
      "doc": "Index of the item from where the drag started.",
      "default": null
    },
    {
      "name": "source_component",
      "type": [
        "null",
        "string"
      ],
      "doc": "Id of the component from where the drag started, eg: \"header/title\" if the user dragged a playlist via the playlist title in the header.",
      "default": null
    },
    {
      "name": "target_view_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "View uri where the drop ended, eg \"spotify:app:zlink\".",
      "default": null
    },
    {
      "name": "target_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "Uri of the context where the drop ended, \"spotify:user:spotify:rootlist\".",
      "default": null
    },
    {
      "name": "target_index",
      "type": [
        "null",
        "long"
      ],
      "doc": "Index where dropped.",
      "default": null
    },
    {
      "name": "target_component",
      "type": [
        "null",
        "string"
      ],
      "doc": "Id of the component where the drop ended, eg: \"player/queue\" if dropped on the Queue button in the player component.",
      "default": null
    },
    {
      "name": "ms_duration",
      "type": [
        "null",
        "long"
      ],
      "doc": "The duration in milliseconds from the start of the drag until the end of the drop.",
      "default": null
    }
  ],
  "schema_version": 1
}
},{}],543:[function(require,module,exports){
module.exports={
  "type": "record",
  "name": "VideoPlayerErrorKM",
  "namespace": "com.spotify.Message",
  "doc": "Log a raw KM error for the video player in the video player stack",
  "fields": [
    {
      "name": "message_name",
      "type": "string"
    },
    {
      "name": "message_version",
      "type": "int"
    },
    {
      "name": "file_id",
      "type": [
        "null",
        "bytes"
      ],
      "doc": "The ID of the file being played back",
      "default": null
    },
    {
      "name": "uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "The URI of the item being played back",
      "default": null
    },
    {
      "name": "playback_id",
      "type": [
        "null",
        "bytes"
      ],
      "doc": "The ID of the playback session for the track",
      "default": null
    },
    {
      "name": "local_time",
      "type": [
        "null",
        "long"
      ],
      "doc": "The time of the clock on the devices went the event was logged",
      "default": null
    },
    {
      "name": "name",
      "type": [
        "null",
        "string"
      ],
      "doc": "A name representing the error",
      "default": null
    },
    {
      "name": "message",
      "type": [
        "null",
        "string"
      ],
      "doc": "A detailed message of the error, might be a JSON struct",
      "default": null
    }
  ],
  "schema_version": 1
}
},{}],544:[function(require,module,exports){
'use strict';

var _pageIdentifiers = require('./page-identifiers.js');

var _pageIdentifiers2 = require('./page-identifiers.json');

var _pageIdentifiers3 = _interopRequireDefault(_pageIdentifiers2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var UUID = require('uuid-js');

/**
 * Object representing state of an app.
 *
 * @param {String} uri Spotify URI of app.
 * @constructor
 */
function AppState(uri) {
  /**
   * Spotify URI.
   *
   * @type {String}
   */
  this._uri = undefined;

  if (uri !== undefined) {
    this.setURI(uri);
  }

  /**
   *  Unique ID of this Application.
   *
   *  @type {String}
   */
  this._uuid = UUID.create().toString();
}

/**
 * Create new instance of AppState based on JSON string.
 *
 * @param {String} json Serialized representation of AppState object.
 * @return {AppState} Instance of AppState.
 */
AppState.unserialize = function (json) {
  var s = JSON.parse(json);
  var a = new AppState();
  a.setURI(s.uri);
  return a;
};

/**
 * Test if another object is considered equal to this.
 *
 * @param {AppState} state AppState instance to compare.
 */
AppState.prototype.equals = function (state) {
  return typeof this._uri === 'string' && state instanceof AppState && this._uri === state._uri;
};

/**
 * Test if another app state is for the same app.
 *
 * @param {AppState} state AppState instance to compare.
 */
AppState.prototype.equalsApp = function (state) {
  var id = this.getAppId();
  return state && id && state.getAppId() === id || false;
};

/**
 * Get App identifier.
 *
 * @return {String} Id of app contained in URI.
 */
AppState.prototype.getAppId = function () {
  var uri = this.getURI();
  var parts = uri.split(':');
  if (parts.length < 3) {
    return undefined;
  }
  if (parts[1] !== 'app') {
    return undefined;
  }
  if (parts[2] === '') {
    return undefined;
  }
  return parts[2];
};

/**
 * Get App URI without arguments.
 *
 * @return {String} URI of app without arguments.
 */
AppState.prototype.getAppURI = function () {
  return this.getURI().split(':').slice(0, 3).join(':');
};

/**
 * Get App arguments
 *
 * @return {Array} List of app arguments.
 */
AppState.prototype.getArgs = function () {
  return this.getURI().split(':').slice(3).map(function (a) {
    return decodeURIComponent(a);
  });
};

/**
 * Get URI value.
 *
 * @return {String} URI as string.
 */
AppState.prototype.getURI = function () {
  if (this._uri === undefined) {
    throw new Error('URI not set');
  }
  return this._uri;
};

/**
 * Create serialized representation of this instance.
 *
 * @return {String} Serialized representation of AppState object.
 */
AppState.prototype.serialize = function () {
  return JSON.stringify({
    uri: this.getURI()
  });
};

/**
 * Set arguments for state.
 *
 * @param {Array} args Arguments as array.
 */
AppState.prototype.setArgs = function (args) {
  if (!Array.isArray(args)) {
    throw new TypeError('Args must be array');
  }

  this._uri = this.getAppURI().split(':').concat(args.map(function (a) {
    return encodeURIComponent(a);
  })).join(':');
};

/**
 * Set URI value.
 *
 * @param {String} uri Spotify URI for app.
 */
AppState.prototype.setURI = function (uri) {
  if (typeof uri !== 'string') {
    throw new TypeError('URI must be string');
  }
  this._uri = uri;
};

/**
 * Get UUID value.
 *
 * @return {String} UUID as string.
 */
AppState.prototype.getUUID = function () {
  return this._uuid;
};

/**
 * Get Page ID.
 *
 * @return {String} Page ID as string.
 */
AppState.prototype.getPageID = function () {
  return (0, _pageIdentifiers.getPageIdFromUri)(this.getAppId(), this.getURI());
};

/**
 * Check if page is covered
 *
 * @return {Boolean} True if page ID is known.
 */
AppState.prototype.isPageCovered = function () {
  return this.getPageID() !== _pageIdentifiers3.default.unknownUncovered;
};

module.exports = AppState;

},{"./page-identifiers.js":548,"./page-identifiers.json":547,"uuid-js":908}],545:[function(require,module,exports){
'use strict';

module.exports = {
  AppState: require('./app-state'),
  Navigator: require('./navigator')
};

},{"./app-state":544,"./navigator":546}],546:[function(require,module,exports){
(function (global){
'use strict';

var inherit = require('spotify-inheritance/inherit');
var EventEmitter = require('spotify-eventemitter');
var AppState = require('./app-state');

/**
 * Class containing methods for navigating.
 *
 * @constructor
 */
function Navigator() {
  this._global = global.top || global;

  EventEmitter.call(this);

  /**
   * Locally bound handler function for message event on global.
   *
   * @type {Function}
   */
  this._messageHandler = this._messageHandler.bind(this);
}

inherit(Navigator, EventEmitter);

/**
 * Maps constants to string values of supported events.
 */
Navigator.prototype.EVENTS = Navigator.EVENTS = {
  REQUEST_STATE: 'navigation_request_state'
};

/**
 * Maps constants to string values of supported methods.
 */
Navigator.prototype.METHOD = Navigator.METHOD = {
  OPEN: 'open',
  TOGGLE: 'toggle'
};

/**
 * Identify posted message and trigger relevant callbacks
 * based on the message contents.
 *
 * @param {Object} message Message object caused by postMessage.
 */
Navigator.prototype._messageHandler = function (message) {
  if (!message.data.type) {
    return;
  }
  var type = message.data.type;
  if (type === Navigator.EVENTS.REQUEST_STATE) {
    var appState = AppState.unserialize(message.data.state);
    this.emitSync(type, { state: appState, method: message.data.method });
  }
};

/**
 * Start listening to messages.
 */
Navigator.prototype.attachListener = function () {
  this._global.addEventListener('message', this._messageHandler);
};

/**
 * Stop listening to messages.
 */
Navigator.prototype.detachListener = function () {
  this._global.removeEventListener('message', this._messageHandler);
};

/**
 * Short hand method for requesting open AppState with URI only.
 *
 * @param {string} uri URI to open.
 */
Navigator.prototype.openURI = function (uri) {
  this.requestOpenState(new AppState(uri));
};

/**
 * Short hand method for requesting toggle of AppState with URI only.
 *
 * @param {string} uri URI to open.
 */
Navigator.prototype.toggleURI = function (uri) {
  this.requestToggleState(new AppState(uri));
};

/**
 * Send an open request message.
 *
 * @param {AppState} state AppState instance to base open action on.
 */
Navigator.prototype.requestOpenState = function (state) {
  this.requestState(state, this.METHOD.OPEN);
};

/**
 * Send a toggle request message.
 *
 * @param {AppState} state AppState instance to base open action on.
 */
Navigator.prototype.requestToggleState = function (state) {
  this.requestState(state, this.METHOD.TOGGLE);
};

/**
 * Send an request for an app state.
 *
 * @param {AppState} state AppState object representing state to request.
 * @param {string} method Method to use.
 */
Navigator.prototype.requestState = function (state, method) {
  if (!state) {
    throw new TypeError('AppState not set');
  }
  if (!method) {
    throw new TypeError('Method not set');
  }
  this._global.postMessage({
    type: this.EVENTS.REQUEST_STATE,
    method: method,
    state: state.serialize()
  }, '*');
};

module.exports = Navigator;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./app-state":544,"spotify-eventemitter":895,"spotify-inheritance/inherit":898}],547:[function(require,module,exports){
module.exports={
  "album": "album",

  "artist": "artist",
  "artistAbout": "artist/about",
  "artistAlbums": "artist/albums",
  "artistBio": "artist/bio",
  "artistGallery": "artist/gallery",
  "artistPlaylists": "artist/playlists",
  "artistRelated": "artist/related",
  "artistConcerts": "artist/concerts",

  "browse": "browse",
  "browseDiscover": "browse/discover",
  "browseNewReleases": "browse/newreleases",
  "browseCharts": "browse/charts",
  "browseGenres": "browse/genres",

  "charts": "charts",
  "chartsChart": "charts/chart",
  "chartsRegional": "charts/regional",
  "chartsSocial": "charts/social",
  "chartsViral": "charts/viral",

  "collection": "collection",
  "collectionAlbums": "collection/albums",
  "collectionAlbumsAlbum": "collection/albums/album",
  "collectionArtists": "collection/artists",
  "collectionArtistsArtist": "collection/artists/artist",
  "radioDailyMixes": "radio/daily-mixes",
  "collectionPlaylists": "collection/playlists",
  "collectionRadio": "collection/radio",
  "collectionShows": "collection/shows",
  "collectionSongs": "collection/songs",

  "concerts": "concerts",
  "concertsCitysearch": "concerts/citysearch",
  "concertsConcert": "concerts/concert",

  "inbox": "inbox",

  "lyrics": "lyrics",

  "moments": "moments",
  "momentsCategory": "moments/category",

  "music": "music",
  "musicCategory": "music/category",

  "now": "now",

  "nowplaying": "nowplaying",
  "nowplayingDevicepicker": "nowplaying/devicepicker",
  "nowplayingQueue": "nowplaying/queue",
  "nowplayingHistory": "nowplaying/history",

  "party": "party",
  "partyAddFriends": "party/add-friends",
  "partyEnableBluetooth": "party/enable-bluetooth",
  "partyEnableNearby": "party/enable-nearby",
  "partyPreset": "party/preset",
  "partyQueue": "party/queue",

  "playlist": "playlist",
  "playlistFolder": "playlist/folder",

  "profile": "profile",
  "profileActivity": "profile/activity",
  "profileArtists": "profile/artists",
  "profileFollowers": "profile/followers",
  "profileFollowing": "profile/following",
  "profilePlaylists": "profile/playlists",


  "radio": "radio",
  "radioStation": "radio/station",

  "running": "running",
  "runningCategory": "running/category",
  "runningSetup": "running/setup",

  "search": "search",
  "searchAlbums": "search/albums",
  "searchArtists": "search/artists",
  "searchGenres": "search/genres",
  "searchPlaylists": "search/playlists",
  "searchProfiles": "search/profiles",
  "searchRadio": "search/radio",
  "searchShows": "search/shows",
  "searchSongs": "search/songs",
  "searchVideos": "search/videos",

  "settings": "settings",

  "shows": "shows",
  "showsAudio": "shows/audio",
  "showsCategory": "shows/category",
  "showsNetwork": "shows/network",
  "showsVideo": "shows/video",

  "unknown": "unknown",
  "unknownUncovered": "unknown/uncovered",
  "debug": "debug"
}

},{}],548:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPageIdFromUri = getPageIdFromUri;
exports.getPageIdFromAppArguments = getPageIdFromAppArguments;

var _pageIdentifiers = require('./page-identifiers.json');

var _pageIdentifiers2 = _interopRequireDefault(_pageIdentifiers);

var _spotifyLiburi = require('spotify-liburi');

var _spotifyLiburi2 = _interopRequireDefault(_spotifyLiburi);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var extractArg = function extractArg(argNumber) {
  return function (args) {
    return args.length > argNumber && args[argNumber] || null;
  };
};
var extractHubArg = function extractHubArg(uri) {
  if (extractArg(0)(uri) === 'charts') {
    // For charts uris: spotify:app:hub:*charts*:*viral*
    return 'charts-' + extractArg(1)(uri);
  }

  // Everything else can be treated as genre
  return 'genre';
};

/**
 * Maps the name of the app with the name of the identifier that has to be used
 * for logging the page view.
 */
var PAGE_LOGGER_MAP = {
  'album': 'album',
  'app-manager': 'debug',
  'artist': 'artist',
  'artist-overview': 'artist',
  'artist-concerts': 'concerts',
  'artist-creator-about': 'artistAbout',
  'artist-related': 'artistRelated',
  'boilerplate': 'debug',
  'browse': 'browse',
  'browse-home': 'browse',
  'browse-charts': 'charts',
  'browse-discover': 'browseDiscover',
  'browse-genres': 'browseGenres',
  'browse-releases': 'browseNewReleases',
  'chart': 'chartsChart',
  'charts': 'charts',
  'collection': 'collection',
  'collection-songs': 'collectionSongs',
  'collection-albums': 'collectionAlbums',
  'collection-album': 'collectionAlbumsAlbum',
  'collection-artists': 'collectionArtists',
  'collection-artist': 'collectionArtistsArtist',
  'concerts': 'concerts',
  'daily-mix-hub': 'radioDailyMixes',
  'diag': 'debug',
  'discover': 'browseDiscover',
  'genre': 'browseGenres',
  'glue-header-demo': 'debug',
  'glue-reference': 'debug',
  'hub-charts-regional': 'chartsRegional',
  'hub-charts-viral': 'chartsViral',
  'hub-genre': 'browseGenres',
  'lyrics': 'lyrics',
  'messages': 'inbox',
  'playlist-desktop': 'playlist',
  'playlist-folder': 'playlistFolder',
  'profile': 'profile',
  'profile-overview': 'profile',
  'profile-public-playlists': 'profilePlaylists',
  'profile-followers': 'profileFollowers',
  'profile-following': 'profileFollowing',
  'profile-recently-played-artists': 'profileArtists',
  'radio': 'radio',
  'radio-hub': 'radio',
  'search': 'search',
  'search-albums': 'searchAlbums',
  'search-artists': 'searchArtists',
  'search-genres': 'searchGenres',
  'search-playlists': 'searchPlaylists',
  'search-profiles': 'searchProfiles',
  'search-tracks': 'searchSongs',
  'settings': 'settings',
  'station': 'radioStation',
  'stations': 'collectionRadio',
  'video-debug': 'debug',
  'zlink-queue': 'nowplayingQueue',
  'zlink-queue-queue': 'nowplayingQueue',
  'zlink-queue-history': 'nowplayingHistory'
};

var EXTRACT_SECTION = {
  // Browse section is the first app argument (i.e.: spotify:app:browse:*releases*)
  'browse': extractArg(0),
  // Artist and profile have the argument after the id (i.e.: spotify:user:spotify:*followers*)
  'artist': extractArg(1),
  'profile': extractArg(1),
  // Queue (spotify:app:zlink-queue and spotify:app:zlink-queue:history)
  'zlink-queue': extractArg(0),
  // Search section is the argument after the search query (spotify:app:search:<query>:*albums*)
  'search': extractArg(1),
  // Hub (spotify:app:hub:*charts*:*viral* or spotify:app:hub:*special*:*thebeatles*)
  'hub': extractHubArg,
  // Collection (spotify:app:collection for albums and artists)
  'collection': extractArg(0)
};

function getPageIdFromUri(appId, inputUri) {
  if (appId in EXTRACT_SECTION) {
    var uri = _spotifyLiburi2.default.from(inputUri);
    var section = EXTRACT_SECTION[appId](uri.args);
    return getPageIdFromAppIdAndSection(appId, section);
  }
  return getPageIdFromAppIdAndSection(appId);
}

function getPageIdFromAppArguments(appId, appArguments) {
  if (appId in EXTRACT_SECTION) {
    var section = EXTRACT_SECTION[appId](appArguments);
    return getPageIdFromAppIdAndSection(appId, section);
  }
  return getPageIdFromAppIdAndSection(appId);
}

function getPageIdFromAppIdAndSection(inputAppId, section) {
  var appId = inputAppId;
  if (section) {
    // The appId of an app with sections should be APP-SECTION,
    // such as 'browse-genres'
    appId = appId + '-' + section;
  }
  var normalizedAppId = PAGE_LOGGER_MAP[appId];
  return _pageIdentifiers2.default[normalizedAppId] || _pageIdentifiers2.default.unknownUncovered;
}

},{"./page-identifiers.json":547,"spotify-liburi":899}],549:[function(require,module,exports){
'use strict';

var _spotifyLocales = require('../spotify-locales');

var _spotifyLocales2 = _interopRequireDefault(_spotifyLocales);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function getOrdinalFunction(currentLanguage) {
  switch (currentLanguage) {
    case 'cs':
    case 'de':
    case 'el':
    case 'fi':
    case 'hu':
    case 'ja':
    case 'pl':
    case 'sv':
    case 'zsm':
      return function (n) {
        return n + '.';
      };

    case 'it':
    case 'pt-BR':
      return function (n) {
        return n + '\xBA';
      };

    case 'fr':
    case 'fr-CA':
      return function (n) {
        return '' + n + (n === 1 ? 'er' : 'e');
      };

    case 'es':
    case 'es-419':
      return function (n) {
        var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : n % 10;
        return '' + n + (b === 1 || b === 3 ? 'er' : b === 2 ? 'do' : b === 7 || b === 0 ? 'mo' : b === 8 ? 'vo' : b === 9 ? 'no' : 'to');
      };

    case 'id':
      // According to Spotify's internal Indonesian specialist,
      // there is no ordinal symbol in Indonesian (like st, nd, th, º, ª),
      // they just use the word (equivalent to writing: first, second,
      // third, instead of 1st, 2nd, 3rd). And as we don't have such
      // capability to translate all numbers to words, this function
      // returns the cardinal number as a string.
      return function (n) {
        return '' + n;
      };

    case 'nl':
      return function (n) {
        var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : n % 100;
        return '' + n + (n !== 0 && b <= 1 || b === 8 || b >= 20 ? 'ste' : 'de');
      };

    case 'tr':
      return function (n) {
        if (n === 0) {
          // special case for zero
          return n + '\'\u0131nc\u0131';
        }
        var suffixes = {
          1: '\'inci',
          5: '\'inci',
          8: '\'inci',
          70: '\'inci',
          80: '\'inci',

          2: '\'nci',
          7: '\'nci',
          20: '\'nci',
          50: '\'nci',

          3: '\'üncü',
          4: '\'üncü',
          100: '\'üncü',

          6: '\'ncı',

          9: '\'uncu',
          10: '\'uncu',
          30: '\'uncu',

          60: '\'ıncı',
          90: '\'ıncı'
        };
        var a = n % 10;
        var b = n % 100 - a;
        var c = n >= 100 ? 100 : null;

        return '' + n + (suffixes[a] || suffixes[b] || suffixes[c]);
      };

    case 'zh-Hant':
      return function (n) {
        return '\u7B2C' + n;
      };

    case 'en':
      return function (n) {
        var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : n % 10;
        return '' + n + (~~(n % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th');
      };

    default:
      console.warn('No explicit ordinal formatter specified for "' + currentLanguage + '" locale \u2013 please add to spotify-numeral');
      return function (n) {
        return n + '.';
      };
  }
}

module.exports = function (currentLanguage) {
  var getOrdinal = getOrdinalFunction(currentLanguage);
  var numberFormat = new Intl.NumberFormat((0, _spotifyLocales2.default)(currentLanguage, 'spotify-numeral'));

  var getFormattedNumber = function getFormattedNumber(number) {
    var format = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '0,0';

    if (format === '0,0') return numberFormat.format(number);else if (format === '0o') return getOrdinal(number);else throw new Error('Unsupported format ' + format);
  };

  return function (number) {
    return {
      format: function format(_format) {
        return getFormattedNumber(number, _format);
      }
    };
  };
};

},{"../spotify-locales":518}],550:[function(require,module,exports){

'use strict';

/**
 * Module dependencies
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var extend = require('extend'),
    bridge = require('../spotify-bridge-request'),
    batch = require('spotify-batch');

/**
 * Bridge methods
 */

var PREF_ALL = 'preferences_all';
var PREF_GET = 'preferences_get';
var PREF_SET = 'preferences_set';
var PREF_SUB = 'preferences_event_wait';

/**
 * Converts a string with dot notation into
 * a nested object where the last key is
 * set to value
 *
 *  eg: f('foo.bar', 123) = {foo: {bar: 123}}
 *
 * @api private
 * @param {String} string
 * @param {Mixed} value
 * @param {String} delimiter - optional
 */

function TransformStringIntoObjectAndSetValue(string, value, delimiter) {
  var object = {};
  string.split(delimiter || '.').reduce(function (o, c, i, a) {
    if (i < a.length - 1) {
      o[c] = {};
    } else {
      o[c] = value;
    }

    return o[c];
  }, object);

  return object;
}

/**
 * Converts an object with nest objects into a flat object
 *
 *  eg: f({foo: {bar: 123}}) = {'foo.bar': 123}
 *
 * @api private
 * @param {String} string
 * @param {String} delimiter - optional
 */

function TransformObjectIntoFlatObject(object, delimiter) {
  var flattened = {};
  delimiter = delimiter || '.';
  function traverse(o, key) {
    var tmp = null;
    for (var p in o) {
      if ('object' == _typeof(o[p])) {
        key = key ? [key, p].join(delimiter) : p;
        traverse(o[p], key);
      } else {
        tmp = key ? [key, p].join(delimiter) : p;
        flattened[tmp] = o[p];
      }
    }
  }

  traverse(object);
  return flattened;
}

/**
 * Normalizes data from bridge responses
 *
 * @api private
 * @param {String} key
 * @param {Object} data
 * @param {Boolean} preserve - optional (Default: false)
 */

function NormalizeData(key, data, preserve) {
  var out = {};
  var regex = '*' == key ? null : RegExp('^' + key);
  var targets = null;

  if ('object' != (typeof data === 'undefined' ? 'undefined' : _typeof(data))) {
    return data;
  }

  targets = Object.keys(data).map(function (key) {
    if (null == regex || regex.test(key)) {
      return [key, data[key]];
    }
  }).filter(Boolean).reduce(function (t, c) {
    t[c[0]] = c[1];
    return t;
  }, {});

  Object.keys(targets).forEach(function (key) {
    // extend output object with transformed properties
    extend(true, out, TransformStringIntoObjectAndSetValue(key, targets[key]));
  });

  if ('*' == key || true === preserve) {
    return out;
  } else {
    return key.split('.').reduce(function (o, k) {
      return o[k];
    }, out);
  }
}

/**
 * Subscribes to a key.
 *
 * @api private
 * @param {Function} rpc The RPC to use.
 * @param {String} key The key (including path).
 * @param {*} lastValue The last value of the key (used for comparing).
 * @param {Function} fn Subscribe handler.
 * @param {Object=} sub Subscription object, optional.
 */

function SubscribeToKey(rpc, key, lastValue, fn, sub) {
  sub = sub || {
    isCancelled: false,
    cancel: function cancel() {
      this.isCancelled = true;
    }
  };

  rpc(PREF_SUB, [], function (err, res) {
    if (sub.isCancelled) return;

    var didValueChange = false;

    if (res) {
      var value = NormalizeData(key, res);
      if (value !== lastValue) {
        lastValue = value;
        didValueChange = true;
      }
    }

    // Resubscribe since one subscription is only for one response
    SubscribeToKey(rpc, key, lastValue, fn, sub);

    if (didValueChange) {
      fn(null, lastValue);
    }
  });

  return sub;
}

/**
 * `Preferences' constructor
 *
 * @api public
 * @param {String} path - optional (Default: '*')
 * @param {Function} rpc - optional
 */

module.exports = Preferences;
function Preferences(path, rpc) {
  if (!(this instanceof Preferences)) {
    return new Preferences(path, rpc);
  }

  this.path = path || '*';
  this.rpc = rpc || bridge.request.bind(bridge);
}

/**
 * Retrieves all preferences at path.
 * If path is '*' then all preferences
 * are retrieved.
 *
 * @api public
 * @param {Function} fn
 */

Preferences.prototype.all = function (fn) {
  var self = this;
  var path = this.path;

  this.rpc(PREF_ALL, [], function (err, res) {
    if (err) {
      return fn(err);
    } else if ('*' == path) {
      fn(null, res);
    } else {
      fn(null, NormalizeData(path, res, true));
    }
  });

  return this;
};

/**
 * Sets a preference at key at path
 * with value
 *
 * @api public
 * @param {String} key
 * @param {Mixed} value
 * @param {Function} fn
 */

Preferences.prototype.set = function (key, value, fn) {
  var self = this;
  var path = this.path;
  var tmp = null;
  var map = null;
  var jobs = null;

  // handle batch jobs to extend bridge preferences
  if ('object' == (typeof key === 'undefined' ? 'undefined' : _typeof(key))) {
    fn = value;

    map = TransformObjectIntoFlatObject(key);
    jobs = batch().concurrency(1);
    Object.keys(map).forEach(function (k) {
      jobs.push(function (next) {
        self.set(k, map[k], next);
      });
    });

    jobs.run(fn);
  } else {
    key = '*' == path ? key : [path, key].join('.');
    this.rpc(PREF_SET, [key, value], fn);
  }
  return this;
};

/**
 * Sets a preference bitflag at path, based on the inputs.
 *
 * @api public
 * @param {String} key
 * @param {Array} flagBoolPairs
 * @param {Function} fn
 */

Preferences.prototype.setAtomicFlags = function (key, flagBoolPairs, fn) {
  var self = this;

  self.get(key, function (err, value) {
    if (err) return fn(err);

    flagBoolPairs.forEach(function (pair) {
      var flag = pair[0];
      var bool = pair[1];
      if (bool === undefined || bool === null) return;
      if (bool) value |= flag;else value &= ~flag;
    });

    self.set(key, value, fn);
  });
};

/**
 * Gets a preference at key at path
 *
 * @api public
 * @param {String} key
 * @param {Function} fn
 */

Preferences.prototype.get = function (key, fn) {
  var self = this;
  key = '*' == this.path ? key : [this.path, key].join('.');

  // try to get property first
  this.rpc(PREF_GET, [key], function (err, res) {
    var value = res ? NormalizeData(key, res) : null;
    if (null == value) {
      self.rpc(PREF_ALL, [], function (err, res) {
        if (err) {
          return fn(err);
        } else {
          fn(null, NormalizeData(key, res));
        }
      });
    } else {
      fn(null, NormalizeData(key, res));
    }
  });
  return this;
};

/**
 * Subscribes to a preference at key at path
 *
 * @api public
 * @param {String} key
 * @param {Function} fn
 */

Preferences.prototype.subscribe = function (key, fn) {
  var self = this;
  var sub = null;
  var cancelled = false;

  // Get initial value and then subscribe for changes
  this.get(key, function (err, res) {
    if (cancelled) return;
    var keyWithPath = '*' == self.path ? key : [self.path, key].join('.');
    sub = SubscribeToKey(self.rpc, keyWithPath, res, fn);

    // Respond to the GET (initial value for SUB)
    fn(err, res);
  });

  return {
    cancel: function cancel() {
      cancelled = true;
      if (sub) {
        sub.cancel();
      }
    }
  };
};

},{"../spotify-bridge-request":225,"extend":585,"spotify-batch":884}],551:[function(require,module,exports){
/**
 * @module spotify-range2
 */
'use strict';

var prime = require('../../libs/prime');

var map = require('mout/array/map');

var push_ = Array.prototype.push;
var slice_ = Array.prototype.slice;

var Range = prime( /** @lends Range.prototype */{

  /**
   * The representation of a range
   * @constructs
   * @param {Number} start The start of the range.
   * @param {Number} end The end of the range.
   */
  constructor: function Range(start, end) {
    this.update(start, end);
  },

  /** Update a range. */
  update: function update(start, end) {
    if (start !== null) this.start = start;
    if (end !== null) this.end = end;
    if (this.start === null || this.end === null) throw new Error('invalid range');
    if (this.start > this.end) throw new Error('invalid range');
    this.length = this.end - this.start;
    return this;
  },

  /** Copy a range. */
  copy: function copy() {
    return new Range(this.start, this.end);
  },

  /** Range is above range. */
  above: function above(range) {
    if (!range) return false;
    return this.start >= range.end;
  },

  /** Range is below range. */
  below: function below(range) {
    if (!range) return false;
    return this.end <= range.start;
  },

  adjacent: function adjacent(range) {
    if (!range) return false;
    return this.end === range.start || this.start === range.end;
  },

  /** Range intersects range. */
  intersects: function intersects(range) {
    if (!range) return false;
    return !this.above(range) && !this.below(range);
  },

  /** Range contains range. */
  contains: function contains(range) {
    if (!range) return false;
    return this.start <= range.start && this.end >= range.end;
  },

  /** Range is contained by ranges. */
  contained: function contained(range) {
    var ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;
    if (!ranges) return false;

    for (var i = 0; ranges[i] !== undefined; i++) {
      var r = ranges[i];
      if (r.start <= this.start && r.end >= this.end) {
        return true;
      }
    }
    return false;
  },

  /** Range fits two ranges. */
  fits: function fits(prev, next) {
    if (!prev && !next) return true;
    if (!prev) return this.end <= next.start;
    if (!next) return this.start >= prev.end;
    return this.start >= prev.end && this.end <= next.start;
  },

  // get the section of this range contained between two ranges
  // [0, 20] » [0, 8], [16, 20] » [8, 16]

  /** portion of a range between two ranges. */
  between: function between(prev, next) {
    if (!prev && !next) return this.copy();
    if (!prev) return this.start >= next.start ? null : new Range(this.start, Math.min(this.end, next.start));
    if (!next) return this.end <= prev.end ? null : new Range(Math.max(prev.end, this.start), this.end);

    return this.end > prev.end && this.start < next.start ? new Range(Math.max(prev.end, this.start), Math.min(next.start, this.end)) : null;
  },

  // [0, 8] » [0, 2], [4, 5] = [0, 2], [4, 5]
  // [3, 6] » [5, 7] = [5, 6]
  // [6, 9] » [5, 7] = [6, 7]

  /** intersection of a range with many ranges */
  intersection: function intersection(range) {
    var intersected = [];
    var ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;
    for (var k = 0; k < ranges.length; k++) {
      var r = ranges[k];
      if (this.below(r)) break;

      if (r.intersects(this)) intersected.push(new Range(Math.max(this.start, r.start), Math.min(this.end, r.end)));
    }
    return intersected;
  },

  // subtract ranges from this range
  // [0, 8] » [0, 2], [4, 5] = [2, 4], [5, 8]

  /** subtract many ranges from the range. */
  subtract: function subtract(range) {
    var subtracted = [];
    var ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;
    for (var k = -1; k < ranges.length; k++) {
      var prev = ranges[k];
      var next = ranges[k + 1];
      var between = this.between(prev, next);
      if (between) subtracted.push(between);
    }
    return subtracted;
  },

  // extract this range from ranges
  // [0, 8] » [0, 2], [5, 8] = []
  // [8, 20] » [0, 2], [5, 8] = [0, 2], [5, 8]
  // [0, 10] » [5, 10], [15, 20] = [5, 10]
  // [10, 20] » [5, 80], [90, 100] = [5, 70] [80, 90]
  // [10, 20] » [0, 10], [20, 30] = [0, 20]

  /** extract the range from many ranges. */
  extract: function extract(range) {
    var ranges = range instanceof Range ? slice_.call(arguments) : range.slice();

    for (var k = 0; k < ranges.length; k++) {
      var prev = ranges[k - 1];
      var next = ranges[k];

      var newRange = null;

      if (this.below(next)) {
        newRange = new Range(next.start - this.length, next.end - this.length);
      } else if (this.intersects(next)) {
        var subtracted = next.subtract(this);
        if (subtracted.length === 2) {
          // is contained
          newRange = new Range(subtracted[0].start, subtracted[1].end - this.length);
        } else if (subtracted.length === 1) {
          if (next.end > this.end) {
            // second segment kept
            newRange = new Range(subtracted[0].start - this.length, subtracted[0].end - this.length);
          } else if (this.start > next.start) {
            // first segment kept
            newRange = new Range(subtracted[0].start, subtracted[0].end);
          }
        } else {
          // gets eaten
          ranges.splice(k--, 1); // decrease k
        }
      } else {
        ranges.splice(k, 1, next.copy());
      }

      if (newRange) {
        if (prev && prev.end === newRange.start) {
          // touches previous
          ranges.splice(k-- - 1, 2, new Range(prev.start, newRange.end)); // decrease k due to splicing
        } else {
          ranges.splice(k, 1, newRange);
        }
      }
    }

    return ranges;
  },

  // [2,3] » [0,1], [2,3] = [0,1], [2,4]
  // [1,2] » [0,6] = [0,7]
  // [0,1] » [0,1], [5,6] = [0,2], [6,7]
  // [4,6] » [0,1], [5,6] = [0,1], [4,6], [7,8]

  // TODO: this can be slightly better. merging can be done in one loop.

  /** insert the range in many ranges. */
  insert: function insert(range) {
    var ranges = range instanceof Range ? slice_.call(arguments) : range.slice();

    for (var k = 0; k < ranges.length; k++) {
      var next = ranges[k];

      if (this.start >= next.end) {
        ranges.splice(k, 1, next.copy());
      } else if (this.start > next.start && this.start < next.end) {
        ranges.splice(k, 1, new Range(next.start, this.start), new Range(this.start, next.end));
      } else {
        ranges.splice(k, 1, new Range(next.start + this.length, next.end + this.length));
      }
    }

    return this.merge(ranges);
  },

  // merge this range in ranges
  // [0, 8] » [0, 2], [5, 8] = [0, 8]
  // [8, 20] » [0, 2], [5, 8] = [0, 2], [5, 20]
  // [0, 10] » [5, 10], [15, 20] = [0, 10], [15, 20]

  /** merge many ranges to the range. */
  merge: function merge(range) {
    var ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;

    ranges = map(ranges, function (r) {
      return r.copy();
    });

    if (!ranges.length) return [this.copy()];

    var k;
    var l;

    for (k = -1, l = ranges.length; k < l; k++) {
      var prev = ranges[k];
      var next = ranges[k + 1];
      var between = this.between(prev, next);

      if (between) {
        if (!prev && next) {
          if (between.end === next.start) {
            next.update(between.start, next.end);
          } else {
            k++; // increase k since we had a push
            ranges.unshift(between);
          }
        } else if (prev && next) {
          if (prev.end === between.start && between.end === next.start) {
            prev.update(prev.start, next.end);
            ranges.splice(k-- + 1, 1); // remove the next, decrease k since we had a splice
          } else if (prev.end === between.start) {
            prev.update(prev.start, between.end);
          } else if (between.end === next.start) {
            next.update(between.start, next.end);
          } else {
            ranges.splice(k + 1, 0, between);
          }
        } else if (prev && !next) {
          if (prev.end === between.start) {
            prev.update(prev.start, between.end);
          } else {
            k++; // increase k since we had a push
            ranges.push(between);
          }
        }
      }
    }

    return ranges;
  },

  /** Remove range from many ranges
      - The range(s) you pass is what you remove from */
  remove: function remove(range) {
    var ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;
    var result = [];
    for (var i = 0; i < ranges.length; i++) {
      var remaining = ranges[i].subtract(this);
      if (remaining.length) push_.apply(result, remaining);
    }
    return result;
  },

  /** Range to an array of indices */
  toIndices: function toIndices() {
    var indices = [];
    for (var i = this.start; i < this.end; i++) {
      indices.push(i);
    }return indices;
  },

  /** Range to a string */
  toString: function toString() {
    return [this.start, this.end] + '';
  }

});

/**
 * Range from a string
 * @memberof Range
 * @static
 * @param {String} string - The string.
 * @return {Range} The range.
 */
Range.fromString = function (string) {
  var parts = string.split(',');
  return new Range(+parts[0], +parts[1]);
};

/**
 * Ranges from an array of indices
 * @memberof Range
 * @static
 * @param {Array} indices - An array of indices.
 * @return {Array} An array of Ranges.
 */
Range.fromIndices = function (indices) {
  indices.sort(function (a, b) {
    return a > b ? 1 : -1;
  });

  var ranges = [];
  var rstart;
  var rend;

  for (var i = 0; i < indices.length; i++) {
    rstart = indices[i];
    rend = rstart;
    while (indices[i + 1] - indices[i] === 1) {
      rend = indices[i + 1]; // increment the index if the numbers sequential
      i++;
    }
    ranges.push(new Range(rstart, rend + 1));
  }

  return ranges;
};

/**
 * A function that returns a range.
 * @function
 * @see Range
 * @param {Number} start The start of the range.
 * @param {Number} end The end of the range.
 */
module.exports = Range;

},{"../../libs/prime":222,"mout/array/map":662}],552:[function(require,module,exports){
'use strict';

module.exports = require('./src/SPVideoManager');

},{"./src/SPVideoManager":553}],553:[function(require,module,exports){
'use strict';

var UUID = require('uuid-js');
var EventEmitter = require('events').EventEmitter;
var util = require('util');
var _ = require('./utils');
var SPVideoPlayer = require('./SPVideoPlayer');
var SPVideoPlayerTracker = require('./SPVideoPlayerTracker');

var SPVideoManager, activeId;
var videos = {};

// CONSTANTS
var CHANGE_EVENT = 'change';

function getVideo(id) {
  var vid = null;
  if (typeof id === 'undefined') {
    vid = videos[activeId];
  } else {
    vid = videos[id];
  }

  console.assert(vid, 'Video unavailable ', vid);
  return vid;
}

function generateId() {
  var uuid = UUID.create();
  return uuid.toString();
}

var _state = {
  'isPlaying': false,
  'activeVideo': null,
  'activeVideoState': {},
  'volume': 1
};

var _onChange = function _onChange(err, p, c) {
  SPVideoManager.set({
    'activeVideoState': c
  });
};

/**
 * @module SPVideoManager
 */
SPVideoManager = {

  /**
   * @param {String} [key]
   * @return {*} - value at key or shallow clone of state
   */
  get: function get(key) {
    return arguments.length ? _state[key] : _.clone(_state);
  },

  /**
   * @param {String|Object} key - key or hash of key:value pairs to be updated
   * @param {*} [val]
   * @param {Boolean} [silent] - if true then no change event is fired
   * @return {SPVideoPlayer} this
   */
  set: function set(key, val, silent) {
    var oldState = this.get();

    if (arguments.length < 3 && util.isObject(key)) {
      silent = val;
      _.extend(_state, key);
    } else {
      _state[key] = val;
    }

    if (!silent) {
      this.emitter.emit(CHANGE_EVENT, null, oldState, this.get());
    }

    return this;
  },

  /**
   * @param {HTMLVideoElement} node
   * @param {Object} config
   * @return {String} videoId
   */
  createVideo: function createVideo(node, config) {
    var videoId = generateId();
    videos[videoId] = new SPVideoPlayer(node, config);
    return videoId;
  },

  getActiveVideo: function getActiveVideo() {
    return videos[activeId];
  },

  getVideo: function getVideo(videoId) {
    return videos[videoId];
  },

  /**
   * @param {Number} [videoId]
   * @return {SPVideoManager}
   */
  play: function play(videoId) {
    getVideo(videoId).play();
    return SPVideoManager;
  },

  /**
   * @param {Number} [videoId]
   * @return {SPVideoManager}
   */
  pause: function pause(videoId) {
    getVideo(videoId).pause();
    return SPVideoManager;
  },

  /**
   * @param {Number} [videoId]
   * @param {Number} [timeInSeconds]
   * @return {SPVideoManager}
   */
  seekTo: function seekTo(videoId, timeInSeconds) {
    getVideo(videoId).seekTo(timeInSeconds);
    return SPVideoManager;
  },

  /**
   * @param {Number} n
   * @return {SPVideoManager}
   */
  setPlayerVolume: function setPlayerVolume(videoId, volume) {
    if (videoId === activeId) {
      SPVideoManager.setVolume(volume);
    } else {
      getVideo(videoId).setVolume(volume);
    }
    return SPVideoManager;
  },

  /**
   * @param {Number} n
   * @return {SPVideoManager}
   */
  setVolume: function setVolume(n) {
    this.set('volume', n);

    // Apply to active video
    if (getVideo()) {
      getVideo().setVolume(n);
    }
    return SPVideoManager;
  },

  /**
   * @param {Number} [videoId]
   * @return {SPVideoManager}
   */
  destroy: function destroy(videoId, destroyNode, reason) {
    if (videoId) {
      var video = getVideo(videoId);
      if (video) {
        if (destroyNode) {
          video.getNode().remove();
        }
        video.unload(reason);
        delete videos[videoId];
      }
    }

    return SPVideoManager;
  },

  /**
   * @param {String} videoId
   * @return {SPVideoManager}
   */
  setActiveVideo: function setActiveVideo(videoId) {
    activeId = videoId;

    for (var v in videos) {
      if (!videos.hasOwnProperty(v)) continue;

      videos[v].set({
        'isActive': false,
        'endReason': getVideo(videoId).get('startReason')
      });
    }

    getVideo(videoId).setVolume(this.get('volume')).unmute().set({
      'isActive': true
    }).subscribe(_onChange);

    // Notify listeners that video is playing
    this.set({
      'isPlaying': true,
      'activeVideo': activeId,
      'activeVideoState': getVideo(videoId).get()
    });

    return SPVideoManager;
  },

  /**
   * @return {SPVideoManager}
   */
  clearActiveVideo: function clearActiveVideo() {
    getVideo().unsubscribe(_onChange).mute().set({
      'isActive': false
    });

    // Notify listeners that video is not playing
    this.set({
      'isPlaying': false,
      'activeVideo': null,
      'activeVideoState': {}
    });

    activeId = null;

    return SPVideoManager;
  },

  /**
   * @param {Number} [videoId]
   * @param {Function} cb
   * @return {SPVideoManager}
   */
  subscribe: function subscribe(videoId, cb) {
    if (videoId) {
      getVideo(videoId).addListener(CHANGE_EVENT, cb);
    } else {
      // Sub to the active video
      this.emitter.addListener('change', cb);
    }
    return SPVideoManager;
  },

  /**
   * @param {Number} [videoId]
   * @param {Function} [cb]
   * @return {SPVideoManager}
   */
  unsubscribe: function unsubscribe(videoId, cb) {
    if (videoId) {
      getVideo(videoId).removeListener(CHANGE_EVENT, cb);
    } else {
      // Unsub from active video
      this.emitter.removeListener('change', cb);
    }
    return SPVideoManager;
  },

  createEndVideoTracker: function createEndVideoTracker(player, options) {
    return new SPVideoPlayerTracker(player, options);
  },

  emitter: new EventEmitter()
};

module.exports = SPVideoManager;

},{"./SPVideoPlayer":554,"./SPVideoPlayerTracker":555,"./utils":557,"events":584,"util":907,"uuid-js":908}],554:[function(require,module,exports){
'use strict';
/**
 * @external EventEmitter
 * @see {@link https://nodejs.org/api/events.html|EventEmitter}
 */

var _VideoPlayerErrorKM = require('../../spotify-logger/messages/VideoPlayerErrorKM1');

var _VideoPlayerErrorKM2 = _interopRequireDefault(_VideoPlayerErrorKM);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var EventEmitter = require('events').EventEmitter;
var util = require('util');
var shaka = require('./shaka');
var _ = require('./utils');


var abrManager = new shaka.abr.SimpleAbrManager();

// CONSTANTS
var DEFAULT_BANDWIDTH_ESTIMATE = 1000 * 1000 * 8; // 8 Mbps
var CHANGE_EVENT = 'change';
var BUFFERING_INTERVAL = 500;
var UPDATE_INTERVAL = 15000;

function isDashyURL(url) {
  return (/(\.mpd$)|(\/dash\/)/.test(url)
  );
}

function optionsFromConfig(config) {
  return !config ? {} : {
    'url': config.url || null,
    'type': config.type || null,
    'isDash': config.type === 'dash' || isDashyURL(config.url),
    'volume': typeof config.volume === 'number' ? config.volume : 1,
    'startPaused': config.startPaused || false,
    'isAd': config.isAd || false,
    'nativeControls': config.nativeControls || false,
    'preseekPosition': config.position || 0,
    'networkCallback': config.networkCallback,
    'licenseServerUrl': config.licenseServerUrl,
    'playbackID': config.playbackID,
    'fileId': config.fileId || null,
    'playOrigin': config.playOrigin || {},
    'track_uri': config.track_uri || '',
    'provider': config.provider || '',
    'startReason': config.startReason || 'unknown',
    'play_context': config.play_context || '',
    'streamingRule': config.streamingRule || ''
  };
}

/**
 * @class SPVideoPlayer
 * @extends external:EventEmitter
 * @param {HTMLVideoElement} node
 * @param {Object} config
 */
var SPVideoPlayer = function SPVideoPlayer(node, config) {
  EventEmitter.call(this);
  this._options = optionsFromConfig(config);

  // set up video node
  _.bindAll(this);
  this._node = node;
  this._node.controls = this._options.nativeControls;
  this._node.setAttribute('preload', 'auto');

  // defaults
  this._firstTimeUpdate = false;
  this._playerBufferInterval = null;
  this._playerTimeUpdateInterval = null;
  this._state = this._getDefaultState();

  this.setVolume(this._options.volume);

  // add a tracker
  if (config.videoTrackerFactory) {
    config.videoTrackerFactory(this, this._options);
  }

  if (this._options.isDash) {
    this._player = new shaka.Player(node);

    this._player.configure({
      drm: {
        servers: {
          'com.widevine.alpha': this._options.licenseServerUrl
        },
        advanced: {
          'com.widevine.alpha': {
            videoRobustness: 'SW_SECURE_DECODE'
          }
        }
      },
      abr: {
        manager: abrManager,
        defaultBandwidthEstimate: DEFAULT_BANDWIDTH_ESTIMATE
      }
    });

    this._player.getNetworkingEngine().registerRequestFilter(function (type, request) {
      if (type !== shaka.net.NetworkingEngine.RequestType.LICENSE && type !== shaka.net.NetworkingEngine.RequestType.MANIFEST) {
        return;
      }

      if (this._options.networkCallback) {
        if (request.uris && request.uris.length > 0) {
          for (var i = 0; i < request.uris.length; i++) {
            this._options.networkCallback(request.uris[i], request.headers);
          }
        } else if (request.uri) {
          this._options.networkCallback(request.uri, request.headers);
        }
      }
    }.bind(this));

    this._playerLoadPromise = this._player.load(this._options.url, this._options.preseekPosition);
    this._playerLoadPromise.then(function () {
      this.set({
        'isLoaded': true,
        'keySystem': this._player.keySystem()
      });
    }.bind(this));
    this._playerLoadPromise.catch(function (e) {
      this._handleError('player-load', { 'type': 'error', 'detail': e });
    }.bind(this));
  } else {
    this._node.src = this._options.url;
    this.set({ 'isLoaded': true });
  }

  this._startListening();

  this.setPaused(this._options.startPaused);
};

util.inherits(SPVideoPlayer, EventEmitter);

SPVideoPlayer.prototype._getDefaultState = function () {
  return {
    'time': new Date().getTime(),
    'isAd': this._options.isAd,
    'isEnded': false,
    'isPlaying': false,
    'isPaused': this._options.startPaused,
    'isError': false,
    'isBuffering': false,
    'isInitiallyBuffered': false,
    'isLoaded': false,
    'canPlay': false,
    'isSeeking': false,
    'timeBuffering': 0,
    'readyTimeBuffering': 0,
    'isMuted': this._node.muted || this._node.volume === 0,
    'duration': this._node.duration || -1,
    'currentTime': this._node.currentTime || this._options.preseekPosition,
    'progress': this._node.currentTime / this._node.duration || 0,
    'volume': this._node.muted ? 0 : this._node.volume,
    'bitrate': 0,
    'stalls': 0,
    'stats': {},
    'endReason': 'unknown'
  };
};

SPVideoPlayer.BUFFER_EVENTS = {
  REBUFFER: 'rebuffer',
  SEEK: 'seek'
};

SPVideoPlayer.prototype._licensePreProcessor = function (req) {
  if (this._options.networkCallback) {
    this._options.networkCallback(req.url, req.headers);
  }
};

SPVideoPlayer.prototype._handleEnded = function () {
  this._disablePlayTimers();

  this.set({
    isEnded: true,
    endReason: 'trackdone',
    stats: this._getStats()
  });
};

SPVideoPlayer.prototype._handleDurationchange = function (e) {
  this.set({
    duration: e.target.duration,
    progress: e.target.currentTime / e.target.duration,
    stats: this._getStats()
  });
};

SPVideoPlayer.prototype._handleTimeUpdate = function (e) {
  // if seeking, pretend we're at the last seek time
  var time = this._lastSeekTime || e.target.currentTime || 0;
  this.set({
    currentTime: time,
    progress: time / e.target.duration,
    stats: this._getStats()
  }, true);

  if (this._state.isSeeking) {
    this.set({ isSeeking: false });
    this._lastSeekTime = null;
  }
};

SPVideoPlayer.prototype._handlePlaying = function () {
  this.set({
    isPlaying: true,
    isEnded: false,
    stats: this._getStats()
  });
};

SPVideoPlayer.prototype._handlePause = function () {
  this.set({
    isPlaying: false,
    stats: this._getStats()
  });
};

SPVideoPlayer.prototype._handleVolumechange = function (e) {
  this.set({
    isMuted: e.target.muted || e.target.volume === 0,
    volume: e.target.muted ? 0 : e.target.volume
  });
};

SPVideoPlayer.prototype._handleShakaError = function (e) {
  this._handleError('shaka-event', e);
};

SPVideoPlayer.prototype._handleError = function (kind, e) {
  _VideoPlayerErrorKM2.default.log({
    'file_id': this._options.fileId,
    'uri': this._options.track_uri,
    'playback_id': this._options.playbackID,
    'local_time': new Date().getTime(),
    'name': kind,
    'message': JSON.stringify(e)
  });

  var oldState = this.get();
  var stats = this._getStats();
  var errorData = {
    'type': '' + e.type,
    'error_code': e.detail.code,
    'play_time': '' + stats.playTime,
    'buffering_time': '' + stats.bufferingTime,
    'dropped_frames': '' + stats.droppedFrames,
    'playback_latency': '' + stats.playbackLatency
  };

  var xhr = e.detail.xhr;
  if (xhr) {
    errorData.httpStatus = xhr.status;
    errorData.responseText = xhr.responseText;
  }

  this.set({
    isEnded: true,
    isError: true,
    stats: stats,
    endReason: 'trackerror'
  }, true);

  this.emit(CHANGE_EVENT, errorData, oldState, this.get());
};

SPVideoPlayer.prototype._handleAdaptation = function (e) {
  if (e.type !== 'adaptation') {
    return;
  }

  var activeTrack = this._player.getTracks().find(function (t) {
    return t.active;
  });
  if (!activeTrack) {
    return;
  }

  var stateChange = { bitrate: activeTrack.bandwidth };
  // Once Shaka is bumped, consider using current time from shaka instead
  if (this._node.readyState > 0) {
    stateChange.currentTime = this._node.currentTime;
  }
  this.set(stateChange);
};

SPVideoPlayer.prototype._onBufferingStateChange = function (event) {
  var oldState = this.get();

  if (event.buffering) {
    this.set({
      isBuffering: event.buffering,
      bufferCause: oldState.isSeeking ? SPVideoPlayer.BUFFER_EVENTS.SEEK : SPVideoPlayer.BUFFER_EVENTS.REBUFFER,
      lastBufferStart: new Date().getTime()
    });
  } else {
    this.set({
      isBuffering: event.buffering,
      isSeeking: false,
      isInitiallyBuffered: true,
      bufferCause: ''
    });
  }
};

SPVideoPlayer.prototype._handleSeeked = function () {
  if (!this._state.isSeeking) {
    return;
  }
  this.set({
    isSeeking: false
  });
};

SPVideoPlayer.prototype._handleCanplay = function () {
  this.set({
    canPlay: true
  });
};

SPVideoPlayer.prototype._videoEvents = {
  'ended': '_handleEnded',
  'durationchange': '_handleDurationchange',
  'timeupdate': '_handleTimeUpdate',
  'volumechange': '_handleVolumechange',
  'playing': '_handlePlaying',
  'pause': '_handlePause',
  //  'seeked': '_handleSeeked',
  'canplay': '_handleCanplay'
};

SPVideoPlayer.prototype._startListening = function () {
  // video node events
  for (var x in this._videoEvents) {
    if (this._videoEvents.hasOwnProperty(x)) {
      this._node.addEventListener(x, this[this._videoEvents[x]]);
    }
  }

  // shaka player events
  if (this._player !== undefined) {
    this._player.addEventListener('error', this._handleShakaError);
    this._player.addEventListener('adaptation', this._handleAdaptation);
    this._player.addEventListener('buffering', this._onBufferingStateChange);
  }
};

SPVideoPlayer.prototype._stopListening = function () {
  // video node events
  for (var x in this._videoEvents) {
    if (this._videoEvents.hasOwnProperty(x)) {
      this._node.removeEventListener(x, this[this._videoEvents[x]]);
    }
  }

  // shaka player events
  if (this._player !== undefined) {
    this._player.removeEventListener('error', this._handleShakaError);
    this._player.removeEventListener('adaptation', this._handleAdaptation);
    this._player.removeEventListener('buffering', this._onBufferingStateChange);
  }
};

SPVideoPlayer.prototype._enablePlayTimers = function () {
  if (this._playerBufferInterval) {
    return;
  }

  var lastProgress = 0;
  var lastCheckDate = new Date().getTime();
  var timerUpdate = function () {
    this.set({ timeUpdate: true });
    this.set({ timeUpdate: false }, true);
  }.bind(this);
  var bufferPoll = function () {
    var currentProgress = this.get('progress');
    var currentTime = new Date().getTime();
    var oldBuffering = this.get('isBuffering');

    if (this.get('isPlaying') === true) {
      if (!this._firstTimeUpdate) {
        timerUpdate();
        this._firstTimeUpdate = true;
      }
      if (currentProgress > lastProgress) {
        if (this.get('isBuffering') === true) {
          this.set({
            isBuffering: false,
            timeBuffering: 0
          });
        }
      } else {
        var stalls = this._state.stalls;
        if (!oldBuffering) {
          stalls++;
        }
        this.set({
          isBuffering: true,
          stalls: stalls,
          timeBuffering: this.get('timeBuffering') + currentTime - lastCheckDate
        }, oldBuffering); // only send update on first update
      }
    }

    lastProgress = currentProgress;
    lastCheckDate = currentTime;
  }.bind(this);
  this._playerTimeUpdateInterval = setInterval(timerUpdate, UPDATE_INTERVAL);
  this._playerBufferInterval = setInterval(bufferPoll, BUFFERING_INTERVAL);
};

SPVideoPlayer.prototype._disablePlayTimers = function () {
  clearInterval(this._playerBufferInterval);
  clearInterval(this._playerTimeUpdateInterval);
  this._playerBufferInterval = null;
  this._playerTimeUpdateInterval = null;
  this.set('isBuffering', false);
  this.set('timeBuffering', 0);
};

SPVideoPlayer.prototype._getStats = function () {
  return this._player !== undefined ? this._player.getStats() : {};
};

/**
 * @param {String} [key]
 * @return {*} - value at key or shallow clone of state
 */
SPVideoPlayer.prototype.get = function (key) {
  return arguments.length ? this._state[key] : _.clone(this._state);
};

/**
 * @param {String|Object} key - key or hash of key:value pairs to be updated
 * @param {*} [val]
 * @param {Boolean} [silent] - if true then no change event is fired
 * @return {SPVideoPlayer} this
 */
SPVideoPlayer.prototype.set = function (key, val, silent) {
  var oldState = this.get();

  if (arguments.length < 3 && util.isObject(key)) {
    silent = val;
    _.extend(this._state, key);
  } else {
    this._state[key] = val;
  }

  this._state.time = new Date().getTime();

  if (!silent) {
    this.emit(CHANGE_EVENT, undefined, oldState, this.get());
  }

  return this;
};

/**
 * @param {Number} n
 * @return {SPVideoPlayer} this
 */
SPVideoPlayer.prototype.setPaused = function (p) {
  p = !!p;
  if (p) {
    this._node.pause();
    this._disablePlayTimers();
  } else {
    this._node.play();
    this._enablePlayTimers();
  }
  this._node.autoplay = !p;
  this.set({ 'isPaused': p });
  return this;
};

/**
 * @return {SPVideoPlayer} this
 */
SPVideoPlayer.prototype.pause = function () {
  return this.setPaused(true);
};

/**
 * @return {SPVideoPlayer} this
 */
SPVideoPlayer.prototype.play = function () {
  return this.setPaused(false);
};

/**
 * @param {Number} n
 * @return {SPVideoPlayer} this
 */
SPVideoPlayer.prototype.setVolume = function (n) {
  this.set('volume', n);
  this._node.volume = n;
  return this;
};

/**
 * @return {SPVideoPlayer} this
 */
SPVideoPlayer.prototype.seekTo = function (timeInSeconds) {
  if (timeInSeconds < 0) {
    timeInSeconds = 0;
  }
  var duration = this._node.duration || 0;
  if (timeInSeconds > duration) {
    timeInSeconds = duration;
  }
  // Some content doesn't actually start on 0, if we
  // seek to before the start time, shaka player just
  // freezes there.
  if (timeInSeconds < 0.1) {
    timeInSeconds = 0.1;
  }

  this._lastSeekTime = timeInSeconds;
  // Update the current time, and then emit the event, so the
  // states will hold the seek diff, and let the first update be silent
  this.set({ currentTime: this._node.currentTime }, true);
  this.set({ isSeeking: true, currentTime: timeInSeconds });
  this._node.currentTime = timeInSeconds;

  return this;
};

/**
 * @return {SPVideoPlayer} this
 */
SPVideoPlayer.prototype.mute = function () {
  this._node.muted = true;
  return this;
};

/**
 * @return {SPVideoPlayer} this
 */
SPVideoPlayer.prototype.unmute = function () {
  this._node.muted = false;
  return this;
};

/**
 * @return {SPVideoPlayer} this
 */
SPVideoPlayer.prototype.unload = function (reason) {
  this._disablePlayTimers();
  this.set({
    isEnded: true,
    endReason: reason,
    stats: this._getStats()
  });
  this._stopListening();
  if (this._player !== undefined) {
    this._playerLoadPromise.then(function () {
      this._player.unload();
    }.bind(this));
  }
};

/**
 * @param {String} [prop]
 * @param {Function} fn
 * @return {SPVideoPlayer} this
 */
SPVideoPlayer.prototype.subscribe = function (prop, fn) {
  if (typeof prop === 'string') {
    this.addListener(CHANGE_EVENT + ':' + prop, fn);
  } else {
    this.addListener(CHANGE_EVENT, prop);
  }

  return this;
};

/**
 * @param {String} [prop]
 * @param {Function} fn
 * @return {SPVideoPlayer} this
 */
SPVideoPlayer.prototype.unsubscribe = function (prop, fn) {
  if (typeof prop === 'string') {
    this.removeListener(CHANGE_EVENT + ':' + prop, fn);
  } else {
    this.removeListener(CHANGE_EVENT, prop);
  }

  return this;
};

/**
 * @return {node} node
 */
SPVideoPlayer.prototype.getNode = function () {
  return this._node;
};

module.exports = SPVideoPlayer;

},{"../../spotify-logger/messages/VideoPlayerErrorKM1":531,"./shaka":556,"./utils":557,"events":584,"util":907}],555:[function(require,module,exports){
'use strict';

var _ = require('./utils');
var live = require('../../spotify-live');
var EndVideo9 = require('../../spotify-logger/pending-messages/EndVideo9');

var BUFFER_EVENTS = require('./SPVideoPlayer').BUFFER_EVENTS;
require('../../spotify-live-models/client').register();

var SPVideoPlayerTracker = function SPVideoPlayerTracker(player, options) {
  var _this = this;

  this._nSeekfwd = 0;
  this._msSeekfwd = 0;
  this._nSeekback = 0;
  this._msSeekback = 0;
  this._nStalls = 0;
  this._msInitialBuffering = -1;
  this._msStalled = 0;
  this._maxMsStalled = 0;
  this._msSeekRebuffering = 0;
  this._maxMsSeekRebuffering = 0;
  this._startBitrate = 0;
  this._oldBitrate = 0;
  this._initTime = new Date().getTime();
  this._latency = 0;
  this._bitrates = [];
  this._options = options;
  this._logged = false;
  this._endVideoSent = false;
  this._shouldSendEndVideo = false;
  this._endReason = 'unknown';
  this._duration = 0;
  this._connection_type_current = 'unknown';
  this._connection_type_start = 'unknown';
  this._incognito = false;
  this._keySystem = '';
  this._playRanges = { lastPosition: options.preseekPosition, ranges: [] };
  _.bindAll(this);

  var client = live('spotify:client');
  client.query('session(connection, incognito)', function (error, data) {
    if (error) {
      console.error('Failed to load client connection:', error);
      return;
    }
    _this._connection_type_start = data.session.connection;
    _this._connection_type_current = data.session.connection;
    _this._incognito = data.session.incognito;
    client.get('session').on('update', function (properties) {
      if ('connection' in properties) {
        _this._connection_type_current = properties.connection;
      }
      if ('incognito' in properties) {
        _this._incognito = properties.incognito;
      }
    });
  });

  player.subscribe(this._onChange);
};

SPVideoPlayerTracker.prototype._onChange = function (errorData, oldState, newState) {

  if (oldState.isLoaded !== newState.isLoaded) {
    this._keySystem = this._parseKeySystem(newState.keySystem);
  }
  if (this._latency === 0 && newState.currentTime >= 0) {
    this._latency = new Date().getTime() - this._initTime;
  }

  if (!oldState.isSeeking && newState.isSeeking) {
    this._seekTo(oldState, newState);
  }
  if (this._duration === 0 && newState.duration >= 0) {
    this._duration = newState.duration;
  }

  if (this._endReason !== newState.endReason) {
    this._endReason = newState.endReason;
  }
  if (newState.bitrate !== this._oldBitrate) {
    this._updatePlayedSegment(newState.currentTime, oldState.bitrate, newState.currentTime, false);
  }

  var bufferStateChanged = oldState.isBuffering !== newState.isBuffering;
  var playbackEndedWhileBuffering = newState.isEnded && newState.isBuffering;
  var initialBufferComplete = newState.isInitiallyBuffered !== oldState.isInitiallyBuffered;
  var bufferingStarted = newState.isBuffering && !newState.isEnded;

  if (initialBufferComplete) {
    this._msInitialBuffering = newState.time - newState.lastBufferStart;
  } else if (bufferStateChanged || playbackEndedWhileBuffering) {
    if (bufferingStarted) {
      this._nStalls += newState.bufferCause === BUFFER_EVENTS.REBUFFER ? 1 : 0;
    } else if (oldState.bufferCause === BUFFER_EVENTS.SEEK) {
      this._msSeekRebuffering += newState.time - newState.lastBufferStart;
      this._maxMsSeekRebuffering = Math.max(this._maxMsSeekRebuffering, newState.time - newState.lastBufferStart);
    } else {
      // Caused by a stall/stutter
      this._msStalled += newState.time - newState.lastBufferStart;
      this._maxMsStalled = Math.max(this._maxMsStalled, newState.time - newState.lastBufferStart);
    }
  }

  this._oldBitrate = newState.bitrate;
  if (this._startBitrate === 0) {
    this._startBitrate = newState.bitrate;
  }
  var reason = null;
  if (newState.timeUpdate) {
    reason = 'unexpected-exit';
  } else if (!oldState.isPaused && newState.isPaused) {
    reason = 'unexpected-exit-while-paused';
  }

  if (reason) {
    this._updatePlayedSegment(newState.currentTime, oldState.bitrate, newState.currentTime, false);
    this._updateEndVideo(reason);
  }

  if (newState.isEnded && !this._logged) {
    this._updatePlayedSegment(newState.currentTime, oldState.bitrate, newState.currentTime, true);

    var first = this._bitrates.length > 0 ? this._bitrates[0].timeDiff : 0;
    var short = this._bitrates.length <= 1 && first < 0.1;
    var appload = this._options.startReason === 'appload';
    if (!(appload && short)) {
      this._logEndVideo(this._endReason);
    }
    this._logged = true;
  }
};

SPVideoPlayerTracker.prototype._seekTo = function (oldState, newState) {
  this._updatePlayedSegment(oldState.currentTime, oldState.bitrate, newState.currentTime, true);

  var relativeSeek = newState.currentTime - oldState.currentTime;
  if (relativeSeek > 0) {
    this._nSeekfwd++;
    this._msSeekfwd += relativeSeek;
  } else {
    this._nSeekback++;
    this._msSeekback -= relativeSeek;
  }
};

SPVideoPlayerTracker.prototype._updatePlayedSegment = function (currentTime, bitrate, newTime, endSegment) {
  if (currentTime >= 0) {
    this._playRanges.ranges.push({
      position: this._playRanges.lastPosition,
      length: currentTime - this._playRanges.lastPosition
    });
    this._playRanges.lastPosition = newTime;
  }
  if (this._segmentStartTime !== undefined) {
    var diff = currentTime - this._segmentStartTime;
    if (diff > 0.01) {
      this._bitrates.push({
        timeDiff: diff,
        endSegment: endSegment,
        bitrate: bitrate
      });
    }
  }

  if (currentTime >= 0.0) {
    this._segmentStartTime = newTime;
  }
};

SPVideoPlayerTracker.prototype._calculatePlayTimesAndBitrates = function () {
  var msPlayed = 0;
  var unionPlayed = 0;
  var maxContinuous = 0;
  var curContinuous = 0;
  var bitrateLength = {};
  var lastRangeEndedAt = 0;

  var sortedPlayRanges = this._playRanges.ranges.sort(function (lhs, rhs) {
    if (lhs.position < rhs.position) {
      return -1;
    } else if (lhs.position === rhs.position) {
      return 0;
    }
    return 1;
  });
  var end = 0;
  for (var j = 0; j < sortedPlayRanges.length; j++) {
    var start = sortedPlayRanges[j].position;
    var length = sortedPlayRanges[j].length;
    msPlayed += length;

    if (start >= end) {
      unionPlayed += length;
      end = start + length;
    } else {
      unionPlayed += Math.max(0, start + length - end);
      end = Math.max(end, start + length);
    }
    if (lastRangeEndedAt === start) {
      curContinuous += length;
    } else {
      maxContinuous = Math.max(maxContinuous, curContinuous);
      curContinuous = length;
    }
    lastRangeEndedAt = start + length;
  }
  maxContinuous = Math.max(maxContinuous, curContinuous);

  for (var i in this._bitrates) {
    if (!this._bitrates.hasOwnProperty(i)) {
      continue;
    }
    var ent = this._bitrates[i];

    if (bitrateLength.hasOwnProperty(ent.bitrate)) {
      bitrateLength[ent.bitrate] += ent.timeDiff;
    } else {
      bitrateLength[ent.bitrate] = ent.timeDiff;
    }
  }

  var timeWeightedBitrate = 0;
  for (var bitrate in bitrateLength) {
    if (bitrateLength.hasOwnProperty(bitrate)) {
      timeWeightedBitrate += bitrate * bitrateLength[bitrate] / msPlayed;
    }
  }

  return {
    msPlayed: Math.round(msPlayed * 1000),
    unionPlayed: Math.round(unionPlayed * 1000),
    maxContinuous: Math.round(maxContinuous * 1000),
    timeWeightedBitrate: Math.round(timeWeightedBitrate)
  };
};

SPVideoPlayerTracker.prototype._parseKeySystem = function (keySystem) {
  switch (keySystem) {
    case 'com.widevine.alpha':
      return 'widevine';
    default:
      return keySystem || '';
  }
};

SPVideoPlayerTracker.prototype._createMessage = function (reason) {

  var calc = this._calculatePlayTimesAndBitrates();
  return {
    'sequence_number': this._messageId,
    'file_id': this._options.fileId,
    'playback_id': this._options.playbackID,
    'feature_identifier': this._options.playOrigin.feature_identifier,
    'feature_version': this._options.playOrigin.feature_version,
    'view_uri': this._options.playOrigin.view_uri,
    'reason_start': this._options.startReason,
    'reason_end': reason,
    'ms_played': calc.msPlayed,
    'ms_total_est': Math.round(this._duration * 1000),
    'live': false,
    'ms_manifest_latency': -1,
    'n_seekback': this._nSeekback,
    'ms_seekback': Math.round(this._msSeekback * 1000),
    'n_seekfwd': this._nSeekfwd,
    'ms_seekfwd': Math.round(this._msSeekfwd * 1000),
    'ms_latency': Math.round(this._latency),
    'ui_latency': -1,
    'start_offset_ms': Math.round(this._options.preseekPosition * 1000),
    'ms_initial_buffering': this._msInitialBuffering,
    'ms_seek_rebuffering': this._msSeekRebuffering,
    'ms_stalled': this._msStalled,
    'max_ms_seek_rebuffering': this._maxMsSeekRebuffering,
    'max_ms_stalled': this._maxMsStalled,
    'n_stalls': this._nStalls,
    'shuffle': false,
    'max_continous': calc.maxContinuous,
    'union_played': calc.unionPlayed,
    'play_context': this._options.play_context,
    'audiocodec': 'mp4a.40.5',
    'videocodec': 'vp9',
    'play_track': this._options.track_uri,
    'incognito_mode': this._incognito,
    'provider': this._options.provider,
    'referrer': this._options.playOrigin.external_referrer,
    'referrer_version': this._options.playOrigin.feature_version,
    'referrer_vendor': 'com.spotify',
    'streaming_rule': this._options.streamingRule,
    'gaia_dev_id': this._options.playOrigin.device_identifier,
    'start_bitrate': this._startBitrate,
    'full_screen': 0,
    'time_weighted_bitrate': calc.timeWeightedBitrate,
    'prefetched_bytes': 0,
    'prefetched_bytes_loaded': -1,
    'key_system': this._keySystem,
    'ms_key_latency': -1,
    'total_bytes': Math.round(calc.timeWeightedBitrate * calc.msPlayed / 1000 / 8),
    'local_time_ms': Math.round(this._initTime),
    'connection_type_start': this._connection_type_start,
    'connection_type_end': this._connection_type_current,
    'ms_played_background': 0
  };
};

SPVideoPlayerTracker.prototype._updateEndVideoInternal = function (reason) {
  var logMessage = this._createMessage(reason);
  EndVideo9.update(this._messageId, logMessage, function (error) {
    if (error) {
      console.error('logEndVideo, failed update:', error);
      return;
    }
    if (this._shouldSendEndVideo) {
      EndVideo9.send(this._messageId);
    }
  }.bind(this));
};

SPVideoPlayerTracker.prototype._updateEndVideo = function (reason) {
  if (this._endVideoSent) {
    return;
  }

  if (this._messageId === undefined) {
    this._messageId = -1;

    EndVideo9.create(function (error, messageId) {
      if (error) {
        this._messageId = undefined;
        return;
      }
      this._messageId = messageId;
      this._updateEndVideoInternal(reason);
    }.bind(this));
    return;
  } else if (this._messageId === -1) {
    // if we are waiting for an 'add' just bail, this is a rare case
    // but just bail here since it's probably good enough
    return;
  }
  // Do a final update and sene the EndVideo
  this._updateEndVideoInternal(reason);
};

SPVideoPlayerTracker.prototype._logEndVideo = function (reason) {
  if (this._endVideoSent) {
    return;
  }
  this._shouldSendEndVideo = true;
  this._updateEndVideo(reason);
  this._endVideoSent = true;
};

module.exports = SPVideoPlayerTracker;

},{"../../spotify-live":512,"../../spotify-live-models/client":475,"../../spotify-logger/pending-messages/EndVideo9":533,"./SPVideoPlayer":554,"./utils":557}],556:[function(require,module,exports){
'use strict';
/*
How to run shaka in debug mode:

Add this to apps/zlink/index.html
<script src="http://127.0.0.1:8000/third_party/closure/goog/base.js"></script>
<script src="http://127.0.0.1:8000/dist/deps.js"></script>
<script src="http://127.0.0.1:8000/shaka-player.uncompiled.js"></script>

In node_modules/shaka-player run "devd ."

Change "var shaka = require('shaka-player');" to "var shaka = window.shaka;"
*/

var shaka = require('shaka-player');

if (typeof document !== 'undefined' && typeof Document !== 'undefined') {
  shaka.polyfill.installAll();
}

module.exports = shaka;

},{"shaka-player":880}],557:[function(require,module,exports){
'use strict';

module.exports = {
  extend: function extend() {
    return Object.assign.apply(Object, arguments);
  },

  clone: function clone(obj) {
    return Object.assign({}, obj);
  },

  bindAll: function bindAll(obj, keys) {
    var key;

    if (arguments.length === 1) {
      for (key in obj) {
        if (typeof obj[key] === 'function') {
          obj[key] = obj[key].bind(obj);
        }
      }
    } else {
      for (key in keys) {
        if (typeof obj[keys[key]] === 'function') {
          obj[keys[key]] = obj[keys[key]].bind(obj);
        }
      }
    }

    return obj;
  }
};

},{}],558:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = kernel;

var _spotifyLiburi = require('spotify-liburi');

var _spotifyLiburi2 = _interopRequireDefault(_spotifyLiburi);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function kernel(_ref) {
  var bridge = _ref.bridge,
      live = _ref.live;

  var COMPLETE_QBE_TASK = 'complete_qbe_task';
  var SONG_ADDED_TO_PLAYLIST = 'song_added_to_playlist';
  var OPEN_APP = 'open_app';
  var OPEN_PLAYLIST = 'open_playlist';
  var ADD_URI = 'add_uri'; // add/follow an URI
  var SHOW_MODAL = 'show_modal';
  var SHOW_QBE = 'show_qbe';
  var TRIAL_ACTIVATED = 'trial_activated';
  var SESSION_ONLINE_STATUS_CHANGE = 'session_online_status_change';

  function sendMessages(messages) {
    bridge.cosmosJSON({
      method: 'POST',
      uri: 'sp://messages/v1/surround',
      body: messages
    });
  }

  // The seconds parameter passed to `callback` is an array of messages that may
  // contain 1 or more messages.
  function subscribeToMessages(callback) {
    bridge.cosmosJSON({
      method: 'SUB',
      uri: 'sp://messages/v1/surround'
    }, callback);
  }

  function dispatchCompleteTask(id) {
    if (!id) {
      return;
    }

    sendMessages([{
      action: COMPLETE_QBE_TASK,
      id: id
    }]);
  }

  function dispatchNewPlaylist() {
    dispatchCompleteTask('create_playlist');
  }

  function dispatchSongAddedToPlaylist(amount) {
    sendMessages([{
      action: SONG_ADDED_TO_PLAYLIST,
      amount: amount
    }]);
  }

  function dispatchAppOpened(appId, appArguments) {
    var messages = [{
      action: OPEN_APP,
      appId: appId
    }];

    switch (appId) {
      case 'playlist-desktop':
      case 'chart':
        var openPlaylistMessage = function createOpenPlaylistMessageFromAppArguments() {
          // args are the arguments passed to the playlist-desktop app and chart app.
          var args = appArguments;
          var playlistUri = null;

          if (args.length === 1 && args[0] === 'local-files') {
            playlistUri = 'spotify:internal:local-files';
          } else if (args.length >= 2) {
            playlistUri = _spotifyLiburi2.default.playlistURI(args[0], args[1]).toString();
          }

          if (playlistUri) {
            return { action: OPEN_PLAYLIST, playlistUri: playlistUri };
          }
          return null;
        }();

        if (openPlaylistMessage) {
          messages.push(openPlaylistMessage);
        }
        break;
      default:
        break;
    }

    sendMessages(messages);
  }

  function dispatchUriAdded(uri, data) {
    if (!data.added) {
      return;
    }

    sendMessages([{
      action: ADD_URI,
      uri: uri
    }]);
  }

  function dispatchShowModal(title, content) {
    sendMessages([{
      action: SHOW_MODAL,
      modal: { title: title, content: content }
    }]);
  }

  function dispatchShowQBE() {
    sendMessages([{
      action: SHOW_QBE
    }]);
  }

  function activateTrial(_ref2) {
    var device_id = _ref2.device_id,
        trial = _ref2.trial,
        country = _ref2.country;

    bridge.cosmosJSON({
      method: 'POST',
      uri: 'hm://login-trial/start_trial',
      body: {
        device_id: device_id,
        trial: trial,
        country: country
      }
    }, function (err, result) {
      if (err) {
        console.error(err);
      }

      var success = !err && result && result.premium === true;

      sendMessages([{
        action: TRIAL_ACTIVATED,
        success: success
      }]);
    });
  }

  function watchSessionChange() {
    function subscribe() {
      live('spotify:client').get('session').on('update', function (data) {
        if ('online' in data) {
          sendMessages([{
            action: SESSION_ONLINE_STATUS_CHANGE,
            online: data.online
          }]);
        }
      });
    }
    live('spotify:client').query('session(online)', function (error, data) {
      sendMessages([{
        action: SESSION_ONLINE_STATUS_CHANGE,
        online: data.session.online
      }]);
      subscribe();
    });
  }

  return {
    COMPLETE_QBE_TASK: COMPLETE_QBE_TASK,
    SONG_ADDED_TO_PLAYLIST: SONG_ADDED_TO_PLAYLIST,
    OPEN_APP: OPEN_APP,
    OPEN_PLAYLIST: OPEN_PLAYLIST,
    ADD_URI: ADD_URI,
    SHOW_MODAL: SHOW_MODAL,
    SHOW_QBE: SHOW_QBE,
    TRIAL_ACTIVATED: TRIAL_ACTIVATED,
    SESSION_ONLINE_STATUS_CHANGE: SESSION_ONLINE_STATUS_CHANGE,

    sendMessages: sendMessages,
    subscribeToMessages: subscribeToMessages,
    dispatchCompleteTask: dispatchCompleteTask,
    dispatchNewPlaylist: dispatchNewPlaylist,
    dispatchSongAddedToPlaylist: dispatchSongAddedToPlaylist,
    dispatchAppOpened: dispatchAppOpened,
    dispatchUriAdded: dispatchUriAdded,
    dispatchShowModal: dispatchShowModal,
    dispatchShowQBE: dispatchShowQBE,
    activateTrial: activateTrial,
    watchSessionChange: watchSessionChange
  };
}

},{"spotify-liburi":899}],559:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.watchSessionChange = exports.activateTrial = exports.dispatchShowQBE = exports.dispatchShowModal = exports.dispatchUriAdded = exports.dispatchAppOpened = exports.dispatchSongAddedToPlaylist = exports.dispatchNewPlaylist = exports.dispatchCompleteTask = exports.subscribeToMessages = exports.sendMessages = exports.SESSION_ONLINE_STATUS_CHANGE = exports.TRIAL_ACTIVATED = exports.COMPLETE_QBE = exports.SHOW_QBE = exports.SHOW_MODAL = exports.ADD_URI = exports.OPEN_PLAYLIST = exports.OPEN_APP = exports.SONG_ADDED_TO_PLAYLIST = exports.COMPLETE_QBE_TASK = undefined;

var _spotifyBridgeRequest = require('../../libs/spotify-bridge-request');

var _spotifyBridgeRequest2 = _interopRequireDefault(_spotifyBridgeRequest);

var _spotifyLive = require('../../libs/spotify-live');

var _spotifyLive2 = _interopRequireDefault(_spotifyLive);

var _kernel = require('./kernel');

var _kernel2 = _interopRequireDefault(_kernel);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var sideEffects = {
  bridge: _spotifyBridgeRequest2.default,
  live: _spotifyLive2.default
};
var shell = (0, _kernel2.default)(sideEffects);

var COMPLETE_QBE_TASK = shell.COMPLETE_QBE_TASK,
    SONG_ADDED_TO_PLAYLIST = shell.SONG_ADDED_TO_PLAYLIST,
    OPEN_APP = shell.OPEN_APP,
    OPEN_PLAYLIST = shell.OPEN_PLAYLIST,
    ADD_URI = shell.ADD_URI,
    SHOW_MODAL = shell.SHOW_MODAL,
    SHOW_QBE = shell.SHOW_QBE,
    COMPLETE_QBE = shell.COMPLETE_QBE,
    TRIAL_ACTIVATED = shell.TRIAL_ACTIVATED,
    SESSION_ONLINE_STATUS_CHANGE = shell.SESSION_ONLINE_STATUS_CHANGE,
    sendMessages = shell.sendMessages,
    subscribeToMessages = shell.subscribeToMessages,
    dispatchCompleteTask = shell.dispatchCompleteTask,
    dispatchNewPlaylist = shell.dispatchNewPlaylist,
    dispatchSongAddedToPlaylist = shell.dispatchSongAddedToPlaylist,
    dispatchAppOpened = shell.dispatchAppOpened,
    dispatchUriAdded = shell.dispatchUriAdded,
    dispatchShowModal = shell.dispatchShowModal,
    dispatchShowQBE = shell.dispatchShowQBE,
    activateTrial = shell.activateTrial,
    watchSessionChange = shell.watchSessionChange;
exports.COMPLETE_QBE_TASK = COMPLETE_QBE_TASK;
exports.SONG_ADDED_TO_PLAYLIST = SONG_ADDED_TO_PLAYLIST;
exports.OPEN_APP = OPEN_APP;
exports.OPEN_PLAYLIST = OPEN_PLAYLIST;
exports.ADD_URI = ADD_URI;
exports.SHOW_MODAL = SHOW_MODAL;
exports.SHOW_QBE = SHOW_QBE;
exports.COMPLETE_QBE = COMPLETE_QBE;
exports.TRIAL_ACTIVATED = TRIAL_ACTIVATED;
exports.SESSION_ONLINE_STATUS_CHANGE = SESSION_ONLINE_STATUS_CHANGE;
exports.sendMessages = sendMessages;
exports.subscribeToMessages = subscribeToMessages;
exports.dispatchCompleteTask = dispatchCompleteTask;
exports.dispatchNewPlaylist = dispatchNewPlaylist;
exports.dispatchSongAddedToPlaylist = dispatchSongAddedToPlaylist;
exports.dispatchAppOpened = dispatchAppOpened;
exports.dispatchUriAdded = dispatchUriAdded;
exports.dispatchShowModal = dispatchShowModal;
exports.dispatchShowQBE = dispatchShowQBE;
exports.activateTrial = activateTrial;
exports.watchSessionChange = watchSessionChange;

},{"../../libs/spotify-bridge-request":225,"../../libs/spotify-live":512,"./kernel":558}],560:[function(require,module,exports){
(function (global){
var check = require('./check.js');
var compare = require('./compare.js');

/**
 * Throws an Error if there are differences between the two given instances. The
 * error message will contain the difference summary. Compares arrays, booleans,
 * numbers, objects and strings as well as null and undefined by value and other
 * types by reference.
 */
var assert = function (one, two) {
  var summary;

  summary = compare(one, two, '');

  if (summary !== null) {
    throw new global.Error(summary);
  }
};

/**
 * Throws an Error if the given method does not throw when called with the given
 * args for the given instance.
 */
assert.throws = function (instance, method, args) {
  var unexpected;

  check.function(method);
  check.array(args);

  unexpected = new Error('Expected an error to be thrown!');

  try {
    method.apply(instance, args);

    throw unexpected;
  } catch (error) {
    if (error === unexpected) {
      throw unexpected;
    }
  }
};

module.exports = assert;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./check.js":561,"./compare.js":563}],561:[function(require,module,exports){
(function (global){
var is = require('./is.js');

/**
 * Throws a TypeError if the given instance is not an array.
 */
exports.array = function (instance) {
  if (!is.array(instance)) {
    throw new global.TypeError('Expected array!');
  }
};

/**
 * Throws a TypeError if the given instance is not a boolean.
 */
exports.boolean = function (instance) {
  if (!is.boolean(instance)) {
    throw new global.TypeError('Expected boolean!');
  }
};

/**
 * Throws a TypeError if the given instance is not a function.
 */
exports.function = function (instance) {
  if (!is.function(instance)) {
    throw new global.TypeError('Expected function!');
  }
};

/**
 * Throws a TypeError if the given instance is not null.
 */
exports.null = function (instance) {
  if (!is.null(instance)) {
    throw new global.TypeError('Expected null!');
  }
};

/**
 * Throws a TypeError if the given instance is not a number.
 */
exports.number = function (instance) {
  if (!is.number(instance)) {
    throw new global.TypeError('Expected number!');
  }
};

/**
 * Throws a TypeError if the given instance is not an object.
 */
exports.object = function (instance) {
  if (!is.object(instance)) {
    throw new global.TypeError('Expected object!');
  }
};

/**
 * Throws a TypeError if the given instance is not a string.
 */
exports.string = function (instance) {
  if (!is.string(instance)) {
    throw new global.TypeError('Expected string!');
  }
};

/**
 * Throws a TypeError if the given instance does not descend from the given
 * constructor.
 */
exports.type = function (instance, constructor) {
  if (!is.type(instance, constructor)) {
    throw new global.TypeError('Expected type!');
  }
};

/**
 * Throws a TypeError if the given instance is not undefined.
 */
exports.undefined = function (instance) {
  if (!is.undefined(instance)) {
    throw new global.TypeError('Expected undefined!');
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./is.js":571}],562:[function(require,module,exports){
(function (global){
var is = require('./is.js');
var name = require('./name.js');

/**
 * Attemps to clone the given instance. Only arrays, booleans, numbers, objects
 * and strings as well as null and undefined are accepted. If any other type is
 * encountered, a TypeError is thrown.
 */
var clone = function (instance) {
  var array;
  var i;
  var k;
  var l;
  var object;

  if (is.array(instance)) {
    array = [];

    for (i = 0, l = instance.length; i < l; i++) {
      array[i] = clone(instance[i]);
    }

    return array;
  }

  if (is.boolean(instance)) {
    return instance;
  }

  if (is.null(instance)) {
    return instance;
  }

  if (is.number(instance)) {
    return instance;
  }

  if (is.object(instance)) {
    object = {};

    for (k in instance) {
      object[k] = clone(instance[k]);
    }

    return object;
  }

  if (is.string(instance)) {
    return instance;
  }

  if (is.undefined(instance)) {
    return instance;
  }

  throw new global.TypeError('Unexpected type "' + name(instance) + '"!');
};

module.exports = clone;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./is.js":571,"./name.js":573}],563:[function(require,module,exports){
var is = require('./is.js');
var name = require('./name.js');

/**
 * Creates a difference summary between the two given instances. Compares
 * arrays, booleans, numbers, objects and strings as well as null and undefined
 * by value and other types by reference. Returns null if the two given
 * instances are identical.
 */
var compare = function (one, two, prefix) {
  var i;
  var k;
  var l;
  var m;
  var result;
  var summary;

  result = '\n';

  if (!is.string(prefix)) {
    prefix = '';
  }

  if (is.array(one)) {
    if (!is.array(two)) {
      return 'expected type "' + name(one) + '" but found type "' + name(two) + '"\n';
    }

    for (i = 0, l = one.length, m = two.length; i < l && i < m; i++) {
      summary = compare(one[i], two[i], prefix + '    ');

      if (summary !== null) {
        result += prefix + '"' + i + '": ' + summary;
      }
    }

    for (; i < l; i++) {
      result += prefix + '"' + i + '": the item is missing\n';
    }

    for (; i < m; i++) {
      result += prefix + '"' + i + '": the item was not expected\n';
    }

    return result !== '\n' ? result : null;
  }

  if (is.boolean(one)) {
    if (!is.boolean(two)) {
      return 'expected type "' + name(one) + '" but found type "' + name(two) + '"\n';
    }

    if (one.valueOf() !== two.valueOf()) {
      return 'expected ' + one.valueOf() + ' but found ' + two.valueOf() + '\n';
    }

    return null;
  }

  if (is.null(one)) {
    if (!is.null(two)) {
      return 'expected type "' + name(one) + '" but found type "' + name(two) + '"\n';
    }

    return null;
  }

  if (is.number(one)) {
    if (!is.number(two)) {
      return 'expected type "' + name(one) + '" but found type "' + name(two) + '"\n';
    }

    if (one.valueOf() !== two.valueOf()) {
      return 'expected ' + one.valueOf() + ' but found ' + two.valueOf() + '\n';
    }

    return null;
  }

  if (is.object(one)) {
    if (!is.object(two)) {
      return 'expected type "' + name(one) + '" but found type "' + name(two) + '"\n';
    }

    for (k in one) {
      if (!(k in two)) {
        result += prefix + '"' + k + '": the item is missing\n';
      } else {
        summary = compare(one[k], two[k], prefix + '    ');

        if (summary !== null) {
          result += prefix + '"' + k + '": ' + summary;
        }
      }
    }

    for (k in two) {
      if (!(k in one)) {
        result += prefix + '"' + k + '": the item was not expected\n';
      }
    }

    return result !== '\n' ? result : null;
  }

  if (is.string(one)) {
    if (!is.string(two)) {
      return 'expected type "' + name(one) + '" but found type "' + name(two) + '"\n';
    }

    if (one.valueOf() !== two.valueOf()) {
      return 'expected "' + one.valueOf() + '" but found "' + two.valueOf() + '"\n';
    }

    return null;
  }

  if (is.undefined(one)) {
    if (!is.undefined(two)) {
      return 'expected type "' + name(one) + '" but found type "' + name(two) + '"\n';
    }

    return null;
  }

  if (two == null || two.constructor !== one.constructor) {
    return 'expected an instance of type "' + name(one) + '"\n';
  } else {
    if (one !== two) {
      return 'expected a different instance of type "' + name(one) + '"\n';
    }
  }

  return null;
};

module.exports = compare;

},{"./is.js":571,"./name.js":573}],564:[function(require,module,exports){
var is = require('./is.js');

/**
 * Checks whether the given actual json conforms to the given schema. This
 * asserts that all required fields are present and have the correct types. It
 * also asserts that all optional fields either are present and have the correct
 * types or are missing in the given actual json.
 */
var conforms = function (actual, schema, verbose, path) {
  var i;
  var l;
  var result;
  var k;
  var parts;

  if (!is.boolean(verbose)) {
    verbose = false;
  }

  if (!is.string(path)) {
    path = 'root';
  }

  if (is.array(schema)) {
    if (is.array(actual)) {
      if (schema.length === 0) {
        return true;
      }

      if (schema.length !== 1) {
        if (verbose) {
          console.warn(path + ': expected an array with exactly one element in the schema but found ' + schema.length + ' elements');
        }

        return false;
      }

      result = true;

      for (i = 0, l = actual.length; i < l; i++) {
        if (!conforms(actual[i], schema[0], verbose, path + '[' + i + ']')) {
          result = false;
        }
      }

      return result;
    } else {
      if (verbose) {
        console.warn(path + ': expected an array but found', actual);
      }

      return false;
    }
  }

  if (is.boolean(schema)) {
    if (is.boolean(actual)) {
      return true;
    } else {
      if (verbose) {
        console.warn(path + ': expected a boolean but found', actual);
      }

      return false;
    }
  }

  if (is.number(schema)) {
    if (is.number(actual)) {
      return true;
    } else {
      if (verbose) {
        console.warn(path + ': expected a number but found', actual);
      }

      return false;
    }
  }

  if (is.object(schema)) {
    if (is.object(actual)) {
      result = true;

      for (k in schema) {
        parts = /^([^?]+)\?$/.exec(k);

        if (parts === null) {
          if (!conforms(actual[k], schema[k], verbose, path + '.' + k)) {
            result = false;
          }
        } else {
          if (actual[parts[1]] != null) {
            if (!conforms(actual[parts[1]], schema[k], verbose, path + '.' + k)) {
              result = false;
            }
          }
        }
      }

      return result;
    } else {
      if (verbose) {
        console.warn(path + ': expected an object but found', actual);
      }

      return false;
    }
  }

  if (is.string(schema)) {
    if (is.string(actual)) {
      return true;
    } else {
      if (verbose) {
        console.warn(path + ': expected a string but found', actual);
      }

      return false;
    }
  }

  if (verbose) {
    console.warn(path + ': expected a supported type in the schema but found', schema);
  }

  return false;
};

module.exports = conforms;

},{"./is.js":571}],565:[function(require,module,exports){
(function (global){
var check = require('./check.js');

/**
 * Makes base a pure class.
 */
var define = function (base) {
  check.function(base);

  base.prototype = global.Object.create(null);
  base.prototype.constructor = base;
};

module.exports = define;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./check.js":561}],566:[function(require,module,exports){
var is = require('./is.js');
var name = require('./name.js');

/**
 * Determines if the two given instances are identical. Compares arrays,
 * booleans, numbers, objects and strings as well as null and undefined by value
 * and other types by reference.
 */
var equals = function (one, two) {
  var i;
  var k;
  var l;

  if (is.array(one)) {
    if (!is.array(two)) {
      return false;
    }

    if (one.length !== two.length) {
      return false;
    }

    for (i = 0, l = one.length; i < l; i++) {
      if (!equals(one[i], two[i])) {
        return false;
      }
    }

    return true;
  }

  if (is.boolean(one)) {
    if (!is.boolean(two)) {
      return false;
    }

    if (one.valueOf() !== two.valueOf()) {
      return false;
    }

    return true;
  }

  if (is.null(one)) {
    if (!is.null(two)) {
      return false;
    }

    return true;
  }

  if (is.number(one)) {
    if (!is.number(two)) {
      return false;
    }

    if (one.valueOf() !== two.valueOf()) {
      return false;
    }

    return true;
  }

  if (is.object(one)) {
    if (!is.object(two)) {
      return false;
    }

    for (k in one) {
      if (!(k in two)) {
        return false;
      }

      if (!equals(one[k], two[k])) {
        return false;
      }
    }

    for (k in two) {
      if (!(k in one)) {
        return false;
      }
    }

    return true;
  }

  if (is.string(one)) {
    if (!is.string(two)) {
      return false;
    }

    if (one.valueOf() !== two.valueOf()) {
      return false;
    }

    return true;
  }

  if (is.undefined(one)) {
    if (!is.undefined(two)) {
      return false;
    }

    return true;
  }

  return one === two;
};

module.exports = equals;

},{"./is.js":571,"./name.js":573}],567:[function(require,module,exports){
(function (global){
var check = require('./check.js');

/**
 * Makes derived extend base.
 */
var extend = function (derived, base) {
  check.function(derived);
  check.function(base);

  derived.prototype = global.Object.create(base.prototype);
  derived.prototype.constructor = derived;
};

module.exports = extend;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./check.js":561}],568:[function(require,module,exports){
var is = require('./is.js');

/**
 * Returns the given fallback if the given instance is not an array.
 */
exports.array = function (instance, fallback) {
  return is.array(instance) ? instance : fallback;
};

/**
 * Returns the given fallback if the given instance is not a boolean.
 */
exports.boolean = function (instance, fallback) {
  return is.boolean(instance) ? instance : fallback;
};

/**
 * Returns the given fallback if the given instance is not a function.
 */
exports.function = function (instance, fallback) {
  return is.function(instance) ? instance : fallback;
};

/**
 * Returns the given fallback if the given instance is not null.
 */
exports.null = function (instance, fallback) {
  return is.null(instance) ? instance : fallback;
};

/**
 * Returns the given fallback if the given instance is not a number.
 */
exports.number = function (instance, fallback) {
  return is.number(instance) ? instance : fallback;
};

/**
 * Returns the given fallback if the given instance is not an object.
 */
exports.object = function (instance, fallback) {
  return is.object(instance) ? instance : fallback;
};

/**
 * Returns the given fallback if the given instance is not a string.
 */
exports.string = function (instance, fallback) {
  return is.string(instance) ? instance : fallback;
};

/**
 * Returns the given fallback if the given instance does not descend from the
 * given constructor.
 */
exports.type = function (instance, constructor, fallback) {
  return is.type(instance, constructor) ? instance : fallback;
};

/**
 * Returns the given fallback if the given instance is not undefined.
 */
exports.undefined = function (instance, fallback) {
  return is.undefined(instance) ? instance : fallback;
};

},{"./is.js":571}],569:[function(require,module,exports){
/**
 * Creates a function wrapper that always returns the given value.
 */
var fixture = function (value) {
  return function () {
    return value;
  };
};

module.exports = fixture;

},{}],570:[function(require,module,exports){
exports.assert = require('./assert.js');
exports.check = require('./check.js');
exports.clone = require('./clone.js');
exports.compare = require('./compare.js');
exports.conforms = require('./conforms.js');
exports.define = require('./define.js');
exports.equals = require('./equals.js');
exports.extend = require('./extend.js');
exports.fallback = require('./fallback.js');
exports.fixture = require('./fixture.js');
exports.is = require('./is.js');
exports.mock = require('./mock.js');
exports.name = require('./name.js');
exports.spy = require('./spy.js');
exports.stub = require('./stub.js');

},{"./assert.js":560,"./check.js":561,"./clone.js":562,"./compare.js":563,"./conforms.js":564,"./define.js":565,"./equals.js":566,"./extend.js":567,"./fallback.js":568,"./fixture.js":569,"./is.js":571,"./mock.js":572,"./name.js":573,"./spy.js":574,"./stub.js":575}],571:[function(require,module,exports){
(function (global){
/**
 * Determines if the given instance is an array.
 */
exports.array = function (instance) {
  return instance != null && instance.constructor === global.Array;
};

/**
 * Determines if the given instance is a boolean.
 */
exports.boolean = function (instance) {
  return instance != null && instance.constructor === global.Boolean;
};

/**
 * Determines if the given instance is a function.
 */
exports.function = function (instance) {
  return instance != null && instance.constructor === global.Function;
};

/**
 * Determines if the given instance is null.
 */
exports.null = function (instance) {
  return instance === null;
};

/**
 * Determines if the given instance is a number.
 */
exports.number = function (instance) {
  return instance != null && instance.constructor === global.Number;
};

/**
 * Determines if the given instance is an object.
 */
exports.object = function (instance) {
  return instance != null && instance.constructor === global.Object;
};

/**
 * Determines if the given instance is a string.
 */
exports.string = function (instance) {
  return instance != null && instance.constructor === global.String;
};

/**
 * Determines if the given instance descends from the given constructor.
 */
exports.type = function (instance, constructor) {
  return instance != null && constructor != null && instance instanceof constructor;
};

/**
 * Determines if the given instance is undefined.
 */
exports.undefined = function (instance) {
  return instance === global.undefined;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],572:[function(require,module,exports){
(function (global){
var check = require('./check.js');
var extend = require('./extend.js');
var is = require('./is.js');

/**
 * Creates a mock for the given base class with the given implementation that
 * can be used for unit testing. The methods defined on implementation will be
 * used instead of the methods defined on the base class.
 */
var mock = function (base, implementation) {
  var derived;
  var keys;
  var i;
  var key;

  check.function(base);

  derived = function () {
    base.apply(this, arguments);
  };

  extend(derived, base);

  derived.create = function () {
    var that;

    that = global.Object.create(derived.prototype);

    derived.apply(that, arguments);

    return that;
  };

  if (implementation != null) {
    check.object(implementation);

    keys = global.Object.getOwnPropertyNames(implementation);

    for (i = 0; i < keys.length; i++) {
      key = keys[i];

      if (key !== 'constructor' && is.function(implementation[key])) {
        if (is.function(base.prototype[key])) {
          derived.prototype[key] = implementation[key];
        } else {
          throw new global.Error('Method "' + key + '" doesn\'t override any method defined on the base class!');
        }
      }
    }
  }

  return derived;
};

module.exports = mock;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./check.js":561,"./extend.js":567,"./is.js":571}],573:[function(require,module,exports){
var is = require('./is.js');

/**
 * Attempts to read the type name for the given instance.
 */
var name = function (instance) {
  if (is.null(instance)) {
    return 'Null';
  }

  if (is.undefined(instance)) {
    return 'Undefined';
  }

  if (is.function(instance.constructor) && is.string(instance.constructor.name)) {
    return instance.constructor.name;
  }

  return '';
};

module.exports = name;

},{"./is.js":571}],574:[function(require,module,exports){
(function (global){
var check = require('./check.js');

/**
 * Creates a spy function that records all function calls into the given calls
 * array.
 */
var spy = function (calls) {
  check.array(calls);

  return function () {
    calls.push({ 'caller' : this, 'arguments' : global.Array.prototype.slice.call(arguments) });
  };
};

module.exports = spy;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./check.js":561}],575:[function(require,module,exports){
(function (global){
var check = require('./check.js');
var extend = require('./extend.js');
var is = require('./is.js');

/**
 * Creates a stub for the given base class with the given implementation that
 * can be used for unit testing.
 */
var stub = function (base, implementation) {
  var derived;
  var prototype;
  var keys;
  var i;
  var key;

  check.function(base);
  check.object(implementation);

  derived = function () {
    var key;

    for (key in implementation) {
      this[key] = implementation[key];
    }
  };

  extend(derived, base);

  derived.create = function () {
    var that;

    that = global.Object.create(derived.prototype);

    derived.apply(that, arguments);

    return that;
  };

  prototype = base.prototype;

  while (prototype != null && prototype !== global.Object.prototype) {
    keys = global.Object.getOwnPropertyNames(prototype);

    for (i = 0; i < keys.length; i++) {
      key = keys[i];

      if (key !== 'constructor' && is.function(prototype[key])) {
        if (is.function(implementation[key])) {
          derived.prototype[key] = implementation[key];
        } else {
          derived.prototype[key] = (function (key) {
            return function () {
              throw new global.Error('Method stub "' + key + '" called!');
            };
          })(key);
        }
      }
    }

    prototype = global.Object.getPrototypeOf(prototype);
  }

  return derived;
};

module.exports = stub;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./check.js":561,"./extend.js":567,"./is.js":571}],576:[function(require,module,exports){
/*!
  Copyright (c) 2016 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames () {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				classes.push(classNames.apply(null, arg));
			} else if (argType === 'object') {
				for (var key in arg) {
					if (hasOwn.call(arg, key) && arg[key]) {
						classes.push(key);
					}
				}
			}
		}

		return classes.join(' ');
	}

	if (typeof module !== 'undefined' && module.exports) {
		module.exports = classNames;
	} else if (typeof define === 'function' && typeof define.amd === 'object' && define.amd) {
		// register as 'classnames', consistent with npm package name
		define('classnames', [], function () {
			return classNames;
		});
	} else {
		window.classNames = classNames;
	}
}());

},{}],577:[function(require,module,exports){
'use strict';

exports.message = require('./src/message');
exports.request = require('./src/request');
exports.response = require('./src/response');
exports.playerstate = require('./src/player_state');

},{"./src/message":578,"./src/player_state":579,"./src/request":580,"./src/response":581}],578:[function(require,module,exports){
/**
 * A set of Message headers.
 *
 * @name exports.Headers
 * @typedef {Object.<string, string>}
 */
exports.Headers;

/**
 * A body of a Request-Response.
 *
 * @name exports.Body
 * @typedef {*}
 */
exports.Body;

/**
 * A serialized Message object.
 *
 * @name Spotify.Cosmos.SerializedMessage
 * @typedef {{
 *   uri: Spotify.Cosmos.URI,
 *   headers: Spotify.Cosmos.Headers,
 *   body: Spotify.Cosmos.Body
 * }}
 */
exports.SerializedMessage;

/**
 * Encapsulates a message.
 *
 * A message is an entity that has a URI, headers and a body.
 *
 * @constructs Spotify.Cosmos.Message
 * @param {Spotify.Cosmos.URI} uri The URI of the message
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     message.
 * @param {Spotify.Cosmos.Body=} opt_body The optional body of the message.
 */
function Message(uri, opt_headers, opt_body) {
  if (uri == null)
    throw new TypeError('Invalid `uri` argument for Message.');

  /**
   * The URI of the Message.
   *
   * @type {Spotify.Cosmos.URI}
   * @protected
   */
  this._uri = uri;

  /**
   * The headers of the Message.
   *
   * @type {Spotify.Cosmos.Headers}
   * @protected
   */
  this._headers = {};

  /**
   * The body of the Message.
   *
   * @type {Spotify.Cosmos.Body}
   * @protected
   */
  this._body = this._encodeBody(opt_body || '');

  if (opt_headers) this._setHeaders(opt_headers);
}
exports.Message = Message;

/**
 * Creates a new Message from a SerializedMessage object.
 *
 * @param {Spotify.Cosmos.SerializedMessage} object The serialized request.
 * @return {Spotify.Cosmos.Message|null} The new Message object or null.
 */
Message.fromObject = function(object) {
  return (object && object.uri) ?
    new Message(
        object.uri,
        object.headers,
        object.body
    ) : null;
};

/**
 * Encodes a message body to a string.
 *
 * @param {*} body The value for the body.
 * @return {string} The body encoded as a string.
 */
Message.prototype._encodeBody = function(body) {
  if (typeof body != 'string') {
    body = JSON.stringify(body);
  }
  return body;
};

/**
 * Returns the URI of the message.
 *
 * @return {Spotify.Cosmos.URI} The URI of the message.
 */
Message.prototype.getURI = function() {
  return this._uri;
};

/**
 * Returns the mimetype of the message.
 *
 * @return {Spotify.Cosmos.MimeType} The mimetype of the message.
 */
Message.prototype.getMimeType = function() {
  return this._headers['accept'];
};

/**
 * Returns the value of a message's headers.
 *
 * @param {string} name The name of the header.
 * @return {string|null} The header value or null if the header wasn't set.
 */
Message.prototype.getHeader = function(name) {
  return this._headers[name.toLowerCase()] || null;
};

/**
 * Returns the headers of the message.
 *
 * @return {Spotify.Cosmos.Headers} The headers of the message.
 */
Message.prototype.getHeaders = function() {
  var _headers = this._headers;
  var headers = {};
  for (var name in _headers) {
    if (!_headers.hasOwnProperty(name)) continue;
    headers[name] = _headers[name];
  }
  return headers;
};

/**
 * Sets a bunch of headers to the message's headers.
 *
 * @param {Spotify.Cosmos.Headers} headers The headers to set to the message.
 * @protected
 */
Message.prototype._setHeaders = function(headers) {
  var _headers = this._headers;
  for (var name in headers) {
    if (!headers.hasOwnProperty(name)) continue;
    _headers[name.toLowerCase()] = headers[name];
  }
  return this;
};

/**
 * Returns the body of the message.
 *
 * @return {Spotify.Cosmos.Body} The body of the message.
 */
Message.prototype.getBody = function() {
  return this._body;
};

/**
 * Returns the body as a JSON object.
 *
 * @return {Object|null} The body of the message parsed as a JSON value. Can
 *     be null if the body is not a proper JSON string.
 */
Message.prototype.getJSONBody = function() {
  try {
    return JSON.parse(this._body);
  } catch(e) {
    return null;
  }
};

/**
 * Creates a new Message instance with data copied from the current instance.
 *
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     message.
 * @param {Spotify.Cosmos.Body=} opt_body The optional body of the message.
 */
Message.prototype.copy = function(opt_headers, opt_body) {
  return new Message(
      this._uri,
      this._copyHeaders(opt_headers),
      typeof opt_body != 'undefined' ? opt_body : this._body
  );
};

/**
 * Copies the headers of the message.
 *
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     message.
 * @return {Spotify.Cosmos.Headers} The headers of the message.
 */
Message.prototype._copyHeaders = function(opt_headers) {
  var headers;
  if (opt_headers) {
    var _headers = this._headers;
    var name;
    headers = {};
    for (name in _headers) {
      if (!_headers.hasOwnProperty(name)) continue;
      headers[name] = _headers[name];
    }
    for (name in opt_headers) {
      if (!opt_headers.hasOwnProperty(name)) continue;
      headers[name.toLowerCase()] = opt_headers[name];
    }
  } else {
    headers = this._headers;
  }
  return headers;
};

/**
 * Serializes the message into a plain object.
 *
 * @return {Spotify.Cosmos.SerializedMessage} The serialized object.
 */
Message.prototype.serialize = function() {
  return this.toJSON();
};

/**
 * Returns a JSON-object representation of the message.
 *
 * @return {Object} The JSON representation of the message.
 */
Message.prototype.toJSON = function() {
  return {
    uri: this._uri,
    headers: this._headers,
    body: this._body
  };
};

},{}],579:[function(require,module,exports){
var inherit = require('spotify-inheritance').inherit;

/**
 * PlayerState is used for two distinct purposes: Pushing new state to the
 * player (this is done when you request to play a completely new context with
 * 'play' method) and retrieving player state updates.
 *
 * Changing properties on PlayerState objects will not change the state of
 * the player unless you pass it to the 'play' method.
 *
 * @param {Object} stateData the data for the playerState.
 */
function PlayerState(stateData) {
  Serializable.call(this, [
    'action',
    'context',
    'tracks',
    'index',
    'playing',
    'loading',
    'track',
    'position',
    'duration',
    'volume',
    'options',
    'play_origin',
    'next_page_url',
    'prev_page_url'
  ]);

  stateData = stateData || {};
  /**
   * What kind of the action player should perform.
   * It's set directly before sending the request.
   * @type {String}
   */
  this.action = stateData.action;

  /**
   * Spotify uri describing the context that
   * will be played e.g playlist, album or artist.
   * Example: spotify:artist:4XaUmUGjidSklcDHxv3XWf,
   * spotify:user:daftpunkofficial:playlist:5nrg0D90OlFyveVfrQD0zE,
   * spotify:album:2nXJkqkS1tIKIyhBcFMmwz
   *
   * @type {String}
   */
  this.context = stateData.context;

  /**
   * The list of tracks uris to play in the given context.
   * Example: [
   *    spotify:track:0bXpmJyHHYPk6QBFj25bYF,
   *    spotify:track:6DXFVsLcEvOTSrkG9G1Cb1,
   *    spotify:track:6rxEjkoar48SssZePbtb2x
   * ]
   *
   * @type {Array.<String>}
   */
  this.tracks = stateData.tracks;

  /**
   * Which element on the this.tracks list should
   * be played.
   *
   * @type {Number}
   */
  this.index = stateData.index;

  /**
   * Is the player currently playing
   */
  this.playing = stateData.playing;
  this.loading = stateData.loading;

  /**
   * Current track URI
   * @type {String}
   */
  this.track = stateData.track;


  this.position = stateData.position;

  this.volume = stateData.volume;

  /**
   * Current track duration in miliseconds?
   * @type {Number}
   */
  this.duration = stateData.duration;

  /**
   * See PlayOptions description
   * @type {cosmos-bindings-js/scripts/player_state~PlayOptions}
   */
  this.options = new PlayOptions(stateData.options);

  /**
   * See PlayOrigin description
   * @type {cosmos-bindings-js/scripts/player_state~PlayOrigin}
   */
  this.play_origin = new PlayOrigin(stateData.play_origin);

  /**
   * Before the list of tracks that are to be played ends, a request will be sent
   * to this URL, which is supposed to return a list of tracks. That list of
   * tracks will then be appended to the list of tracks in the context.
   *
   * The response payload of the next_page_url should look like this:
   *
   * {
   *   "tracks": [
   *     { "track": "spotify:track:$TRACK-ID1", "context": "spotify:album:$ALBUM-ID1" },
   *     { "track": "spotify:track:$TRACK-ID2", "context": "spotify:album:$ALBUM-ID1" },
   *     { "track": "spotify:track:$TRACK-ID3", "context": "spotify:album:$ALBUM-ID1" },
   *   ],
   *   "next_page_url": "...", // Optional
   *   "prev_page_url": "..." // Optional
   * }
   *
   * May be null, which is the same as a URL that would return an empty list
   * of tracks (but with null, no network request is made).
   */
  this.next_page_url = stateData.next_page_url;

  /**
   * Like `next_page_url`, but for going backwards in the context.
   */
  this.prev_page_url = stateData.prev_page_url;
}
inherit(PlayerState, Serializable);

/**
 * Ovverides prototype method.
 * Converts play options and origin to
 * serializable to make sure only correct data
 * is returned.
 * @return {Object} Data associated with player state.
 */
PlayerState.prototype.serialize = function() {
  if (this.options && !(this.options instanceof PlayOptions)) {
    this.options = new PlayOptions(this.options);
  }

  if (this.play_origin && !(this.play_origin instanceof PlayOrigin)) {
    this.play_origin = new PlayOrigin(this.play_origin);
  }

  return this.constructor.prototype.serialize.call(this);
};

/**
 * Possible player actions.
 */
PlayerState.ACTIONS = {
  UNKNOWN: 'unknown',
  PLAY: 'play',
  UPDATE: 'update',
  STOP: 'stop',
  RESUME: 'resume',
  PAUSE: 'pause',
  SKIP_PREV: 'skip_prev',
  SKIP_NEXT: 'skip_next'
};

function PlayOrigin(data) {
  Serializable.call(this, [
    'source',
    'source_context',
    'reason',
    'referrer',
    'referrer_version',
    'referrer_vendor'
  ]);

  data = data || {};

  /**
   * What kind of playlist did we play from?
   *
   * The default value of this property is "unknown". Must have a value.
   *
   * Valid values include 'album', 'artist', 'extlink', 'playlist', 'playqueue',
   * 'radio', 'search', 'unknown'.
   *
   * For an up to date list of valid values, see `PLAY_SOURCES` in
   * https://git.spotify.net/cgit.cgi/log-parser.git/tree/spotify/log_parser/messages_specs.py
   */
  this.source = data.source || 'unknown';

  /**
   * The uri of the view that initiated the playback.
   */
  this.source_context = data.source_context || 'unknown';

  /**
   * Why was the song started?
   *
   * The default value of this property is "unknown". Must have a value.
   *
   * A list of valid values that might be used by features:
   *
   * unknown    = Client doesn't know
   * clickrow   = A row in the song list was clicked/opened
   * playbtn    = The play button was pressed
   * urlopen    = A Url was opened
   *
   * For a complete and up to date list of valid values, see `PLAY_REASONS` in
   * https://git.spotify.net/cgit.cgi/log-parser.git/tree/spotify/log_parser/messages_specs.py
   */
  this.reason = data.reason || 'unknown';

  /**
   * Either a remote site or a spotify app which initiated the request.
   *
   * NOTE: This normally should be a readonly property and not be set
   * explicitly in the PlayerState as the Player will overwrite it when sending the request.
   */
  this.referrer = data.referrer || 'unknown';

  /**
   * The version of the referrer, where applicable. It usually makes sense to
   * set this value to the version of the JS app version, for instance "0.7.5".
   *
   * NOTE: This normally should be a readonly property and not be set
   * explicitly in the PlayerState as the Player will overwrite it when sending the request.
   */
  this.referrer_version = data.referrer_version || 'unknown';

  /**
   * The vendor of the referrer, where applicable.
   * For example com.soundrop, com.spotify.
   *
   * NOTE: This normally should be a readonly property and not be set
   * explicitly in the PlayerState as the Player will overwrite it when sending the request.
   */
  this.referrer_vendor = data.referrer_vendor || 'unknown';
}
inherit(PlayOrigin, Serializable);

/**
 * What kind of options user has
 * with the player. By default
 * all 'can_*' properties are set to true.
 * You might want to restrict some of them
 * in the special cases like ads (no skipping)
 * or radio no skipping prev.
 * @constructor
 * @param {Object} options The options data.
 */
function PlayOptions(options) {
  Serializable.call(this, [
    'repeat',
    'shuffle',
    'can_repeat',
    'can_shuffle',
    'can_skip_prev',
    'can_skip_next',
    'can_seek',
    'use_dmca_rules'
  ]);
  options = options || {};

  /**
   * True if repeat (repeat all, not single track repeat) is (or is to be) enabled.
   *
   * Default value is false
   */
  this.repeat = options.repeat !== undefined ? options.repeat : false;

  /**
   * True if shuffle is (or is to be) enabled.
   *
   * Default value is false
   */
  this.shuffle = options.shuffle !== undefined ? options.shuffle : false;

  /**
   * True if this context can be repeated. This would be false for instance in the
   * case of radio.
   *
   * Default value is true.
   */
  this.can_repeat = options.can_repeat !== undefined ? options.can_repeat : true;

  /**
   * True if this context can be shuffled. This would be false for instance in the
   * case of radio.
   *
   * Default value is true.
   */
  this.can_shuffle = options.can_shuffle !== undefined ? options.can_shuffle : true;

  /**
   * True if the user is (or should be) allowed to skip to the previous track.
   *
   * Default value is true.
   */
  this.can_skip_prev = options.can_skip_prev !== undefined ? options.can_skip_prev : true;

  /**
   * True if the user is (or should be) allowed to skip to the next track.
   *
   * Default value is true.
   */
  this.can_skip_next = options.can_skip_next !== undefined ? options.can_skip_next : true;

  /**
   * True if the user is (or should be) allowed to seek to a certain time in the
   * currently playing track.
   *
   * Default value is true.
   */
  this.can_seek = options.can_seek !== undefined ? options.can_seek : true;

  /**
   * True if the track player should automatically apply DMCA rules when playing.
   * DMCA rules should be enabled for users that have free radio in the US, and
   * controls how many tracks the user are allowed to skip etc.
   *
   * Default value is false.
   */
  this.use_dmca_rules = options.use_dmca_rules !== undefined ? options.use_dmca_rules : false;
}
inherit(PlayOptions, Serializable);

/**
 * The object accepting only defined properties.
 * To make sure only valid properties are passed
 * always use 'serialize()' when object value needed.
 * @constructor
 * @param {Array.<string>} allowedProps The list of the properties
 * that are supported for the object.
 */
function Serializable(allowedProps) {
  this._props = allowedProps || [];
}

/**
 * The JSON representation of the object.
 * @return {Object} Data associated with current player state.
 */
Serializable.prototype.serialize = function() {
  var data = {};
  var prop;

  for (var i = 0, l = this._props.length; i < l; i++) {
    prop = this._props[i];
    if (this[prop] !== undefined) {
      if (this[prop] instanceof Serializable) {
        data[prop] = this[prop].serialize();
      } else {
        data[prop] = this[prop];
      }
    }
  }

  return data;
};

exports.PlayerState = PlayerState;

},{"spotify-inheritance":897}],580:[function(require,module,exports){
var inherit = require('spotify-inheritance').inherit;

var Message = require('./message').Message;

/**
 * Request actions.
 *
 * @name exports.Action
 * @enum {string}
 */
exports.Action = {
  DELETE: 'DELETE',
  GET: 'GET',
  HEAD: 'HEAD',
  POST: 'POST',
  PUT: 'PUT',
  SUB: 'SUB',
  PATCH: 'PATCH'
};

/**
 * A serialized Request object.
 *
 * @name Spotify.Cosmos.SerializedRequest
 * @typedef {{
 *   uri: Spotify.Cosmos.URI,
 *   headers: Spotify.Cosmos.Headers,
 *   body: Spotify.Cosmos.Body
 * }}
 */
exports.SerializedRequest;

/**
 * Encapsulates a request to the handlers.
 *
 * Instances of this class are "immutable" and should not be changed.
 *
 * @constructs Spotify.Cosmos.Request
 * @extends Spotify.Cosmos.Message
 * @param {Spotify.Cosmos.Action} action The action of the request.
 * @param {Spotify.Cosmos.URI} uri The URI of the request
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     request.
 * @param {Spotify.Cosmos.Body=} opt_body The optional body of the request.
 */
function Request(action, uri, opt_headers, opt_body) {
  if (!(this instanceof Request))
    return new Request(action, uri, opt_headers, opt_body);
  if (!action)
    throw new TypeError('Invalid `action` argument for Request.');
  Message.call(this, uri, opt_headers, opt_body);

  /**
   * The action of the request.
   *
   * @type {Spotify.Cosmos.Action}
   * @protected
   */
  this._action = action;
}
inherit(Request, Message);
exports.Request = Request;

/**
 * Creates a new Request from a SerializedRequest object.
 *
 * @param {Spotify.Cosmos.SerializedRequest} object The serialized request.
 * @return {Spotify.Cosmos.Request|null} The new Request object or null.
 */
Request.fromObject = function(object) {
  return (object && object.action && object.uri) ?
    new Request(
        object.action,
        object.uri,
        object.headers,
        object.body
    ) : null;
};

/**
 * Returns the action of the request.
 *
 * @return {Spotify.Cosmos.Action} The action of the request.
 */
Request.prototype.getAction = function() {
  return this._action;
};

/**
 * @inheritDoc
 */
Request.prototype.copy = function(opt_headers, opt_body) {
  return new Request(
      this._action,
      this._uri,
      this._copyHeaders(opt_headers),
      typeof opt_body != 'undefined' ? opt_body : this._body
  );
};

/**
 * @inheritDoc
 */
Request.prototype.toJSON = function() {
  return {
    action: this._action,
    uri: this._uri,
    headers: this._headers,
    body: this._body
  };
};



},{"./message":578,"spotify-inheritance":897}],581:[function(require,module,exports){
var inherit = require('spotify-inheritance').inherit;

var Message = require('./message').Message;

/**
 * Statuscode.
 * The statuses with negative numbers are reserved for
 * errors that originate within the cosmos library.
 *
 * @name exports.StatusCode
 * @enum {number}
 */
exports.StatusCode = {
  OK: 200,
  CREATED: 201,
  ACCEPTED: 202,
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  FORBIDDEN: 403,
  NOT_FOUND: 404,
  METHOD_NOT_ALLOWED: 405,
  TIMED_OUT: 408,
  CONFLICT: 409,
  GONE: 410,
  INTERNAL_SERVER_ERROR: 500,
  NOT_IMPLEMENTED: 501,
  BAD_GATEWAY: 502,
  SERVICE_UNAVAILABLE: 503,

  /** Something went wrong, but the exact reason is not known. */
  ERROR_UNKNOWN: -100,

  /** A resource allocation required to complete the request failed. */
  ERROR_ALLOCATION_FAILED: -101,

  /** The body could not be decoded because it does
   not conform to the encoding header field. */
  ERROR_INVALID_ENCODING: -102,

  /** The router detected an infinite loop while processing the request. */
  ERROR_INFINITE_LOOP: -103,

  /** No endpoint resolver that could handle the request was found. */
  ERROR_RESOLVER_NOT_FOUND: -104
};

/**
 * A serialized Response object.
 *
 * @name Spotify.Cosmos.SerializedResponse
 * @typedef {{
 *   uri: Spotify.Cosmos.URI,
 *   status: Spotify.Cosmos.StatusCode,
 *   headers: Spotify.Cosmos.Headers,
 *   body: Spotify.Cosmos.Body
 * }}
 */
exports.SerializedResponse;

/**
 * Encapsulates a response from the handlers.
 *
 * @constructs Spotify.Cosmos.Response
 * @extends Spotify.Cosmos.Message
 * @param {Spotify.Cosmos.URI} uri The URI of the response
 * @param {Spotify.Cosmos.StatusCode} status The status of the response.
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     response.
 * @param {Spotify.Cosmos.Body=} opt_body The optional body of the response.
 */
function Response(uri, status, opt_headers, opt_body) {
  if (!(this instanceof Response))
    return new Response(uri, status, opt_headers, opt_body, opt_requestURI);
  if (typeof status == 'undefined' || status == null)
    throw new TypeError('Invalid `status` argument for Response.');

  Message.call(this, uri, opt_headers, opt_body);

  /**
   * The Status of the Response.
   *
   * @type {Spotify.Cosmos.StatusCode}
   * @protected
   */
  this._status = status;
}
inherit(Response, Message);
exports.Response = Response;

/**
 * Creates a new Response from a SerializedResponse object.
 *
 * @param {Spotify.Cosmos.SerializedResponse} object The serialized response.
 * @return {Spotify.Cosmos.Response|null} The new Response object or null.
 */
Response.fromObject = function(object) {
  return (object && object.uri && object.status) ?
    new Response(
        object.uri,
        object.status,
        object.headers,
        object.body
    ) : null;
};

/**
 * @inheritDoc
 */
Response.prototype.getMimeType = function() {
  return this._headers['content-type'];
};

/**
 * Returns the status code of the Response.
 *
 * @return {Spotify.Cosmos.StatusCode} The status code of the response.
 */
Response.prototype.getStatusCode = function() {
  return this._status;
};

/**
 * @inheritDoc
 */
Response.prototype.copy = function(opt_headers, opt_body) {
  return new Response(
      this._uri,
      this._status,
      this._copyHeaders(opt_headers),
      typeof opt_body != 'undefined' ? opt_body : this._body
  );
};

/**
 * @inheritDoc
 */
Response.prototype.toJSON = function() {
  return {
    uri: this._uri,
    status: this._status,
    headers: this._headers,
    body: this._body
  };
};


},{"./message":578,"spotify-inheritance":897}],582:[function(require,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
  return (typeof document !== 'undefined' && 'WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage(){
  try {
    return window.localStorage;
  } catch (e) {}
}

},{"./debug":583}],583:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug.debug = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/[\\^$+?.()|[\]{}]/g, '\\$&').replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":700}],584:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],585:[function(require,module,exports){
var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var undefined;

var isArray = function isArray(arr) {
	if (typeof Array.isArray === 'function') {
		return Array.isArray(arr);
	}

	return toStr.call(arr) === '[object Array]';
};

var isPlainObject = function isPlainObject(obj) {
	'use strict';
	if (!obj || toStr.call(obj) !== '[object Object]') {
		return false;
	}

	var has_own_constructor = hasOwn.call(obj, 'constructor');
	var has_is_property_of_method = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
	// Not own constructor property must be Object
	if (obj.constructor && !has_own_constructor && !has_is_property_of_method) {
		return false;
	}

	// Own properties are enumerated firstly, so to speed up,
	// if last one is own, then all properties are own.
	var key;
	for (key in obj) {}

	return key === undefined || hasOwn.call(obj, key);
};

module.exports = function extend() {
	'use strict';
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0],
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if (typeof target === 'boolean') {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	} else if ((typeof target !== 'object' && typeof target !== 'function') || target == null) {
		target = {};
	}

	for (; i < length; ++i) {
		options = arguments[i];
		// Only deal with non-null/undefined values
		if (options != null) {
			// Extend the base object
			for (name in options) {
				src = target[name];
				copy = options[name];

				// Prevent never-ending loop
				if (target === copy) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
					if (copyIsArray) {
						copyIsArray = false;
						clone = src && isArray(src) ? src : [];
					} else {
						clone = src && isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[name] = extend(deep, clone, copy);

				// Don't bring in undefined values
				} else if (copy !== undefined) {
					target[name] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};


},{}],586:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var invariant = require('./invariant');

/**
 * The CSSCore module specifies the API (and implements most of the methods)
 * that should be used when dealing with the display of elements (via their
 * CSS classes and visibility on screen. It is an API focused on mutating the
 * display and not reading it as no logical state should be encoded in the
 * display of elements.
 */

/* Slow implementation for browsers that don't natively support .matches() */
function matchesSelector_SLOW(element, selector) {
  var root = element;
  while (root.parentNode) {
    root = root.parentNode;
  }

  var all = root.querySelectorAll(selector);
  return Array.prototype.indexOf.call(all, element) !== -1;
}

var CSSCore = {

  /**
   * Adds the class passed in to the element if it doesn't already have it.
   *
   * @param {DOMElement} element the element to set the class on
   * @param {string} className the CSS className
   * @return {DOMElement} the element passed in
   */
  addClass: function addClass(element, className) {
    !!/\s/.test(className) ? invariant(false) : void 0;

    if (className) {
      if (element.classList) {
        element.classList.add(className);
      } else if (!CSSCore.hasClass(element, className)) {
        element.className = element.className + ' ' + className;
      }
    }
    return element;
  },

  /**
   * Removes the class passed in from the element
   *
   * @param {DOMElement} element the element to set the class on
   * @param {string} className the CSS className
   * @return {DOMElement} the element passed in
   */
  removeClass: function removeClass(element, className) {
    !!/\s/.test(className) ? invariant(false) : void 0;

    if (className) {
      if (element.classList) {
        element.classList.remove(className);
      } else if (CSSCore.hasClass(element, className)) {
        element.className = element.className.replace(new RegExp('(^|\\s)' + className + '(?:\\s|$)', 'g'), '$1').replace(/\s+/g, ' ') // multiple spaces to one
        .replace(/^\s*|\s*$/g, ''); // trim the ends
      }
    }
    return element;
  },

  /**
   * Helper to add or remove a class from an element based on a condition.
   *
   * @param {DOMElement} element the element to set the class on
   * @param {string} className the CSS className
   * @param {*} bool condition to whether to add or remove the class
   * @return {DOMElement} the element passed in
   */
  conditionClass: function conditionClass(element, className, bool) {
    return (bool ? CSSCore.addClass : CSSCore.removeClass)(element, className);
  },

  /**
   * Tests whether the element has the class specified.
   *
   * @param {DOMNode|DOMWindow} element the element to check the class on
   * @param {string} className the CSS className
   * @return {boolean} true if the element has the class, false if not
   */
  hasClass: function hasClass(element, className) {
    !!/\s/.test(className) ? invariant(false) : void 0;
    if (element.classList) {
      return !!className && element.classList.contains(className);
    }
    return (' ' + element.className + ' ').indexOf(' ' + className + ' ') > -1;
  },

  /**
   * Tests whether the element matches the selector specified
   *
   * @param {DOMNode|DOMWindow} element the element that we are querying
   * @param {string} selector the CSS selector
   * @return {boolean} true if the element matches the selector, false if not
   */
  matchesSelector: function matchesSelector(element, selector) {
    var matchesImpl = element.matches || element.webkitMatchesSelector || element.mozMatchesSelector || element.msMatchesSelector || function (s) {
      return matchesSelector_SLOW(element, s);
    };
    return matchesImpl.call(element, selector);
  }

};

module.exports = CSSCore;
},{"./invariant":602}],587:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @typechecks
 */

var emptyFunction = require('./emptyFunction');

/**
 * Upstream version of event listener. Does not take into account specific
 * nature of platform.
 */
var EventListener = {
  /**
   * Listen to DOM events during the bubble phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  listen: function listen(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, false);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, false);
        }
      };
    } else if (target.attachEvent) {
      target.attachEvent('on' + eventType, callback);
      return {
        remove: function remove() {
          target.detachEvent('on' + eventType, callback);
        }
      };
    }
  },

  /**
   * Listen to DOM events during the capture phase.
   *
   * @param {DOMEventTarget} target DOM element to register listener on.
   * @param {string} eventType Event type, e.g. 'click' or 'mouseover'.
   * @param {function} callback Callback function.
   * @return {object} Object with a `remove` method.
   */
  capture: function capture(target, eventType, callback) {
    if (target.addEventListener) {
      target.addEventListener(eventType, callback, true);
      return {
        remove: function remove() {
          target.removeEventListener(eventType, callback, true);
        }
      };
    } else {
      return {
        remove: emptyFunction
      };
    }
  },

  registerDefault: function registerDefault() {}
};

module.exports = EventListener;
},{"./emptyFunction":594}],588:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);

/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */
var ExecutionEnvironment = {

  canUseDOM: canUseDOM,

  canUseWorkers: typeof Worker !== 'undefined',

  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),

  canUseViewport: canUseDOM && !!window.screen,

  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};

module.exports = ExecutionEnvironment;
},{}],589:[function(require,module,exports){
"use strict";

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var _hyphenPattern = /-(.)/g;

/**
 * Camelcases a hyphenated string, for example:
 *
 *   > camelize('background-color')
 *   < "backgroundColor"
 *
 * @param {string} string
 * @return {string}
 */
function camelize(string) {
  return string.replace(_hyphenPattern, function (_, character) {
    return character.toUpperCase();
  });
}

module.exports = camelize;
},{}],590:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

'use strict';

var camelize = require('./camelize');

var msPattern = /^-ms-/;

/**
 * Camelcases a hyphenated CSS property name, for example:
 *
 *   > camelizeStyleName('background-color')
 *   < "backgroundColor"
 *   > camelizeStyleName('-moz-transition')
 *   < "MozTransition"
 *   > camelizeStyleName('-ms-transition')
 *   < "msTransition"
 *
 * As Andi Smith suggests
 * (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
 * is converted to lowercase `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function camelizeStyleName(string) {
  return camelize(string.replace(msPattern, 'ms-'));
}

module.exports = camelizeStyleName;
},{"./camelize":589}],591:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

var isTextNode = require('./isTextNode');

/*eslint-disable no-bitwise */

/**
 * Checks if a given DOM node contains or is another DOM node.
 */
function containsNode(outerNode, innerNode) {
  if (!outerNode || !innerNode) {
    return false;
  } else if (outerNode === innerNode) {
    return true;
  } else if (isTextNode(outerNode)) {
    return false;
  } else if (isTextNode(innerNode)) {
    return containsNode(outerNode, innerNode.parentNode);
  } else if ('contains' in outerNode) {
    return outerNode.contains(innerNode);
  } else if (outerNode.compareDocumentPosition) {
    return !!(outerNode.compareDocumentPosition(innerNode) & 16);
  } else {
    return false;
  }
}

module.exports = containsNode;
},{"./isTextNode":604}],592:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var invariant = require('./invariant');

/**
 * Convert array-like objects to arrays.
 *
 * This API assumes the caller knows the contents of the data type. For less
 * well defined inputs use createArrayFromMixed.
 *
 * @param {object|function|filelist} obj
 * @return {array}
 */
function toArray(obj) {
  var length = obj.length;

  // Some browsers builtin objects can report typeof 'function' (e.g. NodeList
  // in old versions of Safari).
  !(!Array.isArray(obj) && (typeof obj === 'object' || typeof obj === 'function')) ? invariant(false) : void 0;

  !(typeof length === 'number') ? invariant(false) : void 0;

  !(length === 0 || length - 1 in obj) ? invariant(false) : void 0;

  !(typeof obj.callee !== 'function') ? invariant(false) : void 0;

  // Old IE doesn't give collections access to hasOwnProperty. Assume inputs
  // without method will throw during the slice call and skip straight to the
  // fallback.
  if (obj.hasOwnProperty) {
    try {
      return Array.prototype.slice.call(obj);
    } catch (e) {
      // IE < 9 does not support Array#slice on collections objects
    }
  }

  // Fall back to copying key by key. This assumes all keys have a value,
  // so will not preserve sparsely populated inputs.
  var ret = Array(length);
  for (var ii = 0; ii < length; ii++) {
    ret[ii] = obj[ii];
  }
  return ret;
}

/**
 * Perform a heuristic test to determine if an object is "array-like".
 *
 *   A monk asked Joshu, a Zen master, "Has a dog Buddha nature?"
 *   Joshu replied: "Mu."
 *
 * This function determines if its argument has "array nature": it returns
 * true if the argument is an actual array, an `arguments' object, or an
 * HTMLCollection (e.g. node.childNodes or node.getElementsByTagName()).
 *
 * It will return false for other array-like objects like Filelist.
 *
 * @param {*} obj
 * @return {boolean}
 */
function hasArrayNature(obj) {
  return (
    // not null/false
    !!obj && (
    // arrays are objects, NodeLists are functions in Safari
    (typeof obj == 'object' || typeof obj == 'function')) &&
    // quacks like an array
    'length' in obj &&
    // not window
    !('setInterval' in obj) &&
    // no DOM node should be considered an array-like
    // a 'select' element has 'length' and 'item' properties on IE8
    typeof obj.nodeType != 'number' && (
    // a real array
    (Array.isArray(obj) ||
    // arguments
    'callee' in obj || // HTMLCollection/NodeList
    'item' in obj))
  );
}

/**
 * Ensure that the argument is an array by wrapping it in an array if it is not.
 * Creates a copy of the argument if it is already an array.
 *
 * This is mostly useful idiomatically:
 *
 *   var createArrayFromMixed = require('createArrayFromMixed');
 *
 *   function takesOneOrMoreThings(things) {
 *     things = createArrayFromMixed(things);
 *     ...
 *   }
 *
 * This allows you to treat `things' as an array, but accept scalars in the API.
 *
 * If you need to convert an array-like object, like `arguments`, into an array
 * use toArray instead.
 *
 * @param {*} obj
 * @return {array}
 */
function createArrayFromMixed(obj) {
  if (!hasArrayNature(obj)) {
    return [obj];
  } else if (Array.isArray(obj)) {
    return obj.slice();
  } else {
    return toArray(obj);
  }
}

module.exports = createArrayFromMixed;
},{"./invariant":602}],593:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

/*eslint-disable fb-www/unsafe-html*/

var ExecutionEnvironment = require('./ExecutionEnvironment');

var createArrayFromMixed = require('./createArrayFromMixed');
var getMarkupWrap = require('./getMarkupWrap');
var invariant = require('./invariant');

/**
 * Dummy container used to render all markup.
 */
var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

/**
 * Pattern used by `getNodeName`.
 */
var nodeNamePattern = /^\s*<(\w+)/;

/**
 * Extracts the `nodeName` of the first element in a string of markup.
 *
 * @param {string} markup String of markup.
 * @return {?string} Node name of the supplied markup.
 */
function getNodeName(markup) {
  var nodeNameMatch = markup.match(nodeNamePattern);
  return nodeNameMatch && nodeNameMatch[1].toLowerCase();
}

/**
 * Creates an array containing the nodes rendered from the supplied markup. The
 * optionally supplied `handleScript` function will be invoked once for each
 * <script> element that is rendered. If no `handleScript` function is supplied,
 * an exception is thrown if any <script> elements are rendered.
 *
 * @param {string} markup A string of valid HTML markup.
 * @param {?function} handleScript Invoked once for each rendered <script>.
 * @return {array<DOMElement|DOMTextNode>} An array of rendered nodes.
 */
function createNodesFromMarkup(markup, handleScript) {
  var node = dummyNode;
  !!!dummyNode ? invariant(false) : void 0;
  var nodeName = getNodeName(markup);

  var wrap = nodeName && getMarkupWrap(nodeName);
  if (wrap) {
    node.innerHTML = wrap[1] + markup + wrap[2];

    var wrapDepth = wrap[0];
    while (wrapDepth--) {
      node = node.lastChild;
    }
  } else {
    node.innerHTML = markup;
  }

  var scripts = node.getElementsByTagName('script');
  if (scripts.length) {
    !handleScript ? invariant(false) : void 0;
    createArrayFromMixed(scripts).forEach(handleScript);
  }

  var nodes = Array.from(node.childNodes);
  while (node.lastChild) {
    node.removeChild(node.lastChild);
  }
  return nodes;
}

module.exports = createNodesFromMarkup;
},{"./ExecutionEnvironment":588,"./createArrayFromMixed":592,"./getMarkupWrap":598,"./invariant":602}],594:[function(require,module,exports){
"use strict";

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;
},{}],595:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var emptyObject = {};

module.exports = emptyObject;
},{}],596:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

/**
 * @param {DOMElement} node input/textarea to focus
 */

function focusNode(node) {
  // IE8 can throw "Can't move focus to the control because it is invisible,
  // not enabled, or of a type that does not accept the focus." for all kinds of
  // reasons that are too expensive and fragile to test.
  try {
    node.focus();
  } catch (e) {}
}

module.exports = focusNode;
},{}],597:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

/* eslint-disable fb-www/typeof-undefined */

/**
 * Same as document.activeElement but wraps in a try-catch block. In IE it is
 * not safe to call document.activeElement if there is nothing focused.
 *
 * The activeElement will be null only if the document or document body is not
 * yet defined.
 */
function getActiveElement() /*?DOMElement*/{
  if (typeof document === 'undefined') {
    return null;
  }
  try {
    return document.activeElement || document.body;
  } catch (e) {
    return document.body;
  }
}

module.exports = getActiveElement;
},{}],598:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/*eslint-disable fb-www/unsafe-html */

var ExecutionEnvironment = require('./ExecutionEnvironment');

var invariant = require('./invariant');

/**
 * Dummy container used to detect which wraps are necessary.
 */
var dummyNode = ExecutionEnvironment.canUseDOM ? document.createElement('div') : null;

/**
 * Some browsers cannot use `innerHTML` to render certain elements standalone,
 * so we wrap them, render the wrapped nodes, then extract the desired node.
 *
 * In IE8, certain elements cannot render alone, so wrap all elements ('*').
 */

var shouldWrap = {};

var selectWrap = [1, '<select multiple="true">', '</select>'];
var tableWrap = [1, '<table>', '</table>'];
var trWrap = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

var svgWrap = [1, '<svg xmlns="http://www.w3.org/2000/svg">', '</svg>'];

var markupWrap = {
  '*': [1, '?<div>', '</div>'],

  'area': [1, '<map>', '</map>'],
  'col': [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
  'legend': [1, '<fieldset>', '</fieldset>'],
  'param': [1, '<object>', '</object>'],
  'tr': [2, '<table><tbody>', '</tbody></table>'],

  'optgroup': selectWrap,
  'option': selectWrap,

  'caption': tableWrap,
  'colgroup': tableWrap,
  'tbody': tableWrap,
  'tfoot': tableWrap,
  'thead': tableWrap,

  'td': trWrap,
  'th': trWrap
};

// Initialize the SVG elements since we know they'll always need to be wrapped
// consistently. If they are created inside a <div> they will be initialized in
// the wrong namespace (and will not display).
var svgElements = ['circle', 'clipPath', 'defs', 'ellipse', 'g', 'image', 'line', 'linearGradient', 'mask', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'stop', 'text', 'tspan'];
svgElements.forEach(function (nodeName) {
  markupWrap[nodeName] = svgWrap;
  shouldWrap[nodeName] = true;
});

/**
 * Gets the markup wrap configuration for the supplied `nodeName`.
 *
 * NOTE: This lazily detects which wraps are necessary for the current browser.
 *
 * @param {string} nodeName Lowercase `nodeName`.
 * @return {?array} Markup wrap configuration, if applicable.
 */
function getMarkupWrap(nodeName) {
  !!!dummyNode ? invariant(false) : void 0;
  if (!markupWrap.hasOwnProperty(nodeName)) {
    nodeName = '*';
  }
  if (!shouldWrap.hasOwnProperty(nodeName)) {
    if (nodeName === '*') {
      dummyNode.innerHTML = '<link />';
    } else {
      dummyNode.innerHTML = '<' + nodeName + '></' + nodeName + '>';
    }
    shouldWrap[nodeName] = !dummyNode.firstChild;
  }
  return shouldWrap[nodeName] ? markupWrap[nodeName] : null;
}

module.exports = getMarkupWrap;
},{"./ExecutionEnvironment":588,"./invariant":602}],599:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

'use strict';

/**
 * Gets the scroll position of the supplied element or window.
 *
 * The return values are unbounded, unlike `getScrollPosition`. This means they
 * may be negative or exceed the element boundaries (which is possible using
 * inertial scrolling).
 *
 * @param {DOMWindow|DOMElement} scrollable
 * @return {object} Map with `x` and `y` keys.
 */

function getUnboundedScrollPosition(scrollable) {
  if (scrollable === window) {
    return {
      x: window.pageXOffset || document.documentElement.scrollLeft,
      y: window.pageYOffset || document.documentElement.scrollTop
    };
  }
  return {
    x: scrollable.scrollLeft,
    y: scrollable.scrollTop
  };
}

module.exports = getUnboundedScrollPosition;
},{}],600:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var _uppercasePattern = /([A-Z])/g;

/**
 * Hyphenates a camelcased string, for example:
 *
 *   > hyphenate('backgroundColor')
 *   < "background-color"
 *
 * For CSS style names, use `hyphenateStyleName` instead which works properly
 * with all vendor prefixes, including `ms`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenate(string) {
  return string.replace(_uppercasePattern, '-$1').toLowerCase();
}

module.exports = hyphenate;
},{}],601:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

'use strict';

var hyphenate = require('./hyphenate');

var msPattern = /^ms-/;

/**
 * Hyphenates a camelcased CSS property name, for example:
 *
 *   > hyphenateStyleName('backgroundColor')
 *   < "background-color"
 *   > hyphenateStyleName('MozTransition')
 *   < "-moz-transition"
 *   > hyphenateStyleName('msTransition')
 *   < "-ms-transition"
 *
 * As Modernizr suggests (http://modernizr.com/docs/#prefixed), an `ms` prefix
 * is converted to `-ms-`.
 *
 * @param {string} string
 * @return {string}
 */
function hyphenateStyleName(string) {
  return hyphenate(string).replace(msPattern, '-ms-');
}

module.exports = hyphenateStyleName;
},{"./hyphenate":600}],602:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

function invariant(condition, format, a, b, c, d, e, f) {
  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;
},{}],603:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM node.
 */
function isNode(object) {
  return !!(object && (typeof Node === 'function' ? object instanceof Node : typeof object === 'object' && typeof object.nodeType === 'number' && typeof object.nodeName === 'string'));
}

module.exports = isNode;
},{}],604:[function(require,module,exports){
'use strict';

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 */

var isNode = require('./isNode');

/**
 * @param {*} object The object to check.
 * @return {boolean} Whether or not the object is a DOM text node.
 */
function isTextNode(object) {
  return isNode(object) && object.nodeType == 3;
}

module.exports = isTextNode;
},{"./isNode":603}],605:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 * @typechecks static-only
 */

'use strict';

/**
 * Memoizes the return value of a function that accepts one string argument.
 */

function memoizeStringOnly(callback) {
  var cache = {};
  return function (string) {
    if (!cache.hasOwnProperty(string)) {
      cache[string] = callback.call(this, string);
    }
    return cache[string];
  };
}

module.exports = memoizeStringOnly;
},{}],606:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @typechecks
 * 
 */

/*eslint-disable no-self-compare */

'use strict';

var hasOwnProperty = Object.prototype.hasOwnProperty;

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
function is(x, y) {
  // SameValue algorithm
  if (x === y) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    // Added the nonzero y check to make Flow happy, but it is redundant
    return x !== 0 || y !== 0 || 1 / x === 1 / y;
  } else {
    // Step 6.a: NaN == NaN
    return x !== x && y !== y;
  }
}

/**
 * Performs equality by iterating through keys on an object and returning false
 * when any key has values which are not strictly equal between the arguments.
 * Returns true when the values of all keys are strictly equal.
 */
function shallowEqual(objA, objB) {
  if (is(objA, objB)) {
    return true;
  }

  if (typeof objA !== 'object' || objA === null || typeof objB !== 'object' || objB === null) {
    return false;
  }

  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);

  if (keysA.length !== keysB.length) {
    return false;
  }

  // Test for A's keys different from B.
  for (var i = 0; i < keysA.length; i++) {
    if (!hasOwnProperty.call(objB, keysA[i]) || !is(objA[keysA[i]], objB[keysA[i]])) {
      return false;
    }
  }

  return true;
}

module.exports = shallowEqual;
},{}],607:[function(require,module,exports){
/**
 * Copyright 2014-2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var emptyFunction = require('./emptyFunction');

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

module.exports = warning;
},{"./emptyFunction":594}],608:[function(require,module,exports){
"use strict";
/*globals Handlebars: true */
var base = require("./handlebars/base");

// Each of these augment the Handlebars object. No need to setup here.
// (This is done to easily share code between commonjs and browse envs)
var SafeString = require("./handlebars/safe-string")["default"];
var Exception = require("./handlebars/exception")["default"];
var Utils = require("./handlebars/utils");
var runtime = require("./handlebars/runtime");

// For compatibility and usage outside of module systems, make the Handlebars object a namespace
var create = function() {
  var hb = new base.HandlebarsEnvironment();

  Utils.extend(hb, base);
  hb.SafeString = SafeString;
  hb.Exception = Exception;
  hb.Utils = Utils;

  hb.VM = runtime;
  hb.template = function(spec) {
    return runtime.template(spec, hb);
  };

  return hb;
};

var Handlebars = create();
Handlebars.create = create;

exports["default"] = Handlebars;
},{"./handlebars/base":609,"./handlebars/exception":610,"./handlebars/runtime":611,"./handlebars/safe-string":612,"./handlebars/utils":613}],609:[function(require,module,exports){
"use strict";
var Utils = require("./utils");
var Exception = require("./exception")["default"];

var VERSION = "1.3.0";
exports.VERSION = VERSION;var COMPILER_REVISION = 4;
exports.COMPILER_REVISION = COMPILER_REVISION;
var REVISION_CHANGES = {
  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
  2: '== 1.0.0-rc.3',
  3: '== 1.0.0-rc.4',
  4: '>= 1.0.0'
};
exports.REVISION_CHANGES = REVISION_CHANGES;
var isArray = Utils.isArray,
    isFunction = Utils.isFunction,
    toString = Utils.toString,
    objectType = '[object Object]';

function HandlebarsEnvironment(helpers, partials) {
  this.helpers = helpers || {};
  this.partials = partials || {};

  registerDefaultHelpers(this);
}

exports.HandlebarsEnvironment = HandlebarsEnvironment;HandlebarsEnvironment.prototype = {
  constructor: HandlebarsEnvironment,

  logger: logger,
  log: log,

  registerHelper: function(name, fn, inverse) {
    if (toString.call(name) === objectType) {
      if (inverse || fn) { throw new Exception('Arg not supported with multiple helpers'); }
      Utils.extend(this.helpers, name);
    } else {
      if (inverse) { fn.not = inverse; }
      this.helpers[name] = fn;
    }
  },

  registerPartial: function(name, str) {
    if (toString.call(name) === objectType) {
      Utils.extend(this.partials,  name);
    } else {
      this.partials[name] = str;
    }
  }
};

function registerDefaultHelpers(instance) {
  instance.registerHelper('helperMissing', function(arg) {
    if(arguments.length === 2) {
      return undefined;
    } else {
      throw new Exception("Missing helper: '" + arg + "'");
    }
  });

  instance.registerHelper('blockHelperMissing', function(context, options) {
    var inverse = options.inverse || function() {}, fn = options.fn;

    if (isFunction(context)) { context = context.call(this); }

    if(context === true) {
      return fn(this);
    } else if(context === false || context == null) {
      return inverse(this);
    } else if (isArray(context)) {
      if(context.length > 0) {
        return instance.helpers.each(context, options);
      } else {
        return inverse(this);
      }
    } else {
      return fn(context);
    }
  });

  instance.registerHelper('each', function(context, options) {
    var fn = options.fn, inverse = options.inverse;
    var i = 0, ret = "", data;

    if (isFunction(context)) { context = context.call(this); }

    if (options.data) {
      data = createFrame(options.data);
    }

    if(context && typeof context === 'object') {
      if (isArray(context)) {
        for(var j = context.length; i<j; i++) {
          if (data) {
            data.index = i;
            data.first = (i === 0);
            data.last  = (i === (context.length-1));
          }
          ret = ret + fn(context[i], { data: data });
        }
      } else {
        for(var key in context) {
          if(context.hasOwnProperty(key)) {
            if(data) { 
              data.key = key; 
              data.index = i;
              data.first = (i === 0);
            }
            ret = ret + fn(context[key], {data: data});
            i++;
          }
        }
      }
    }

    if(i === 0){
      ret = inverse(this);
    }

    return ret;
  });

  instance.registerHelper('if', function(conditional, options) {
    if (isFunction(conditional)) { conditional = conditional.call(this); }

    // Default behavior is to render the positive path if the value is truthy and not empty.
    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
    if ((!options.hash.includeZero && !conditional) || Utils.isEmpty(conditional)) {
      return options.inverse(this);
    } else {
      return options.fn(this);
    }
  });

  instance.registerHelper('unless', function(conditional, options) {
    return instance.helpers['if'].call(this, conditional, {fn: options.inverse, inverse: options.fn, hash: options.hash});
  });

  instance.registerHelper('with', function(context, options) {
    if (isFunction(context)) { context = context.call(this); }

    if (!Utils.isEmpty(context)) return options.fn(context);
  });

  instance.registerHelper('log', function(context, options) {
    var level = options.data && options.data.level != null ? parseInt(options.data.level, 10) : 1;
    instance.log(level, context);
  });
}

var logger = {
  methodMap: { 0: 'debug', 1: 'info', 2: 'warn', 3: 'error' },

  // State enum
  DEBUG: 0,
  INFO: 1,
  WARN: 2,
  ERROR: 3,
  level: 3,

  // can be overridden in the host environment
  log: function(level, obj) {
    if (logger.level <= level) {
      var method = logger.methodMap[level];
      if (typeof console !== 'undefined' && console[method]) {
        console[method].call(console, obj);
      }
    }
  }
};
exports.logger = logger;
function log(level, obj) { logger.log(level, obj); }

exports.log = log;var createFrame = function(object) {
  var obj = {};
  Utils.extend(obj, object);
  return obj;
};
exports.createFrame = createFrame;
},{"./exception":610,"./utils":613}],610:[function(require,module,exports){
"use strict";

var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

function Exception(message, node) {
  var line;
  if (node && node.firstLine) {
    line = node.firstLine;

    message += ' - ' + line + ':' + node.firstColumn;
  }

  var tmp = Error.prototype.constructor.call(this, message);

  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
  for (var idx = 0; idx < errorProps.length; idx++) {
    this[errorProps[idx]] = tmp[errorProps[idx]];
  }

  if (line) {
    this.lineNumber = line;
    this.column = node.firstColumn;
  }
}

Exception.prototype = new Error();

exports["default"] = Exception;
},{}],611:[function(require,module,exports){
"use strict";
var Utils = require("./utils");
var Exception = require("./exception")["default"];
var COMPILER_REVISION = require("./base").COMPILER_REVISION;
var REVISION_CHANGES = require("./base").REVISION_CHANGES;

function checkRevision(compilerInfo) {
  var compilerRevision = compilerInfo && compilerInfo[0] || 1,
      currentRevision = COMPILER_REVISION;

  if (compilerRevision !== currentRevision) {
    if (compilerRevision < currentRevision) {
      var runtimeVersions = REVISION_CHANGES[currentRevision],
          compilerVersions = REVISION_CHANGES[compilerRevision];
      throw new Exception("Template was precompiled with an older version of Handlebars than the current runtime. "+
            "Please update your precompiler to a newer version ("+runtimeVersions+") or downgrade your runtime to an older version ("+compilerVersions+").");
    } else {
      // Use the embedded version info since the runtime doesn't know about this revision yet
      throw new Exception("Template was precompiled with a newer version of Handlebars than the current runtime. "+
            "Please update your runtime to a newer version ("+compilerInfo[1]+").");
    }
  }
}

exports.checkRevision = checkRevision;// TODO: Remove this line and break up compilePartial

function template(templateSpec, env) {
  if (!env) {
    throw new Exception("No environment passed to template");
  }

  // Note: Using env.VM references rather than local var references throughout this section to allow
  // for external users to override these as psuedo-supported APIs.
  var invokePartialWrapper = function(partial, name, context, helpers, partials, data) {
    var result = env.VM.invokePartial.apply(this, arguments);
    if (result != null) { return result; }

    if (env.compile) {
      var options = { helpers: helpers, partials: partials, data: data };
      partials[name] = env.compile(partial, { data: data !== undefined }, env);
      return partials[name](context, options);
    } else {
      throw new Exception("The partial " + name + " could not be compiled when running in runtime-only mode");
    }
  };

  // Just add water
  var container = {
    escapeExpression: Utils.escapeExpression,
    invokePartial: invokePartialWrapper,
    programs: [],
    program: function(i, fn, data) {
      var programWrapper = this.programs[i];
      if(data) {
        programWrapper = program(i, fn, data);
      } else if (!programWrapper) {
        programWrapper = this.programs[i] = program(i, fn);
      }
      return programWrapper;
    },
    merge: function(param, common) {
      var ret = param || common;

      if (param && common && (param !== common)) {
        ret = {};
        Utils.extend(ret, common);
        Utils.extend(ret, param);
      }
      return ret;
    },
    programWithDepth: env.VM.programWithDepth,
    noop: env.VM.noop,
    compilerInfo: null
  };

  return function(context, options) {
    options = options || {};
    var namespace = options.partial ? options : env,
        helpers,
        partials;

    if (!options.partial) {
      helpers = options.helpers;
      partials = options.partials;
    }
    var result = templateSpec.call(
          container,
          namespace, context,
          helpers,
          partials,
          options.data);

    if (!options.partial) {
      env.VM.checkRevision(container.compilerInfo);
    }

    return result;
  };
}

exports.template = template;function programWithDepth(i, fn, data /*, $depth */) {
  var args = Array.prototype.slice.call(arguments, 3);

  var prog = function(context, options) {
    options = options || {};

    return fn.apply(this, [context, options.data || data].concat(args));
  };
  prog.program = i;
  prog.depth = args.length;
  return prog;
}

exports.programWithDepth = programWithDepth;function program(i, fn, data) {
  var prog = function(context, options) {
    options = options || {};

    return fn(context, options.data || data);
  };
  prog.program = i;
  prog.depth = 0;
  return prog;
}

exports.program = program;function invokePartial(partial, name, context, helpers, partials, data) {
  var options = { partial: true, helpers: helpers, partials: partials, data: data };

  if(partial === undefined) {
    throw new Exception("The partial " + name + " could not be found");
  } else if(partial instanceof Function) {
    return partial(context, options);
  }
}

exports.invokePartial = invokePartial;function noop() { return ""; }

exports.noop = noop;
},{"./base":609,"./exception":610,"./utils":613}],612:[function(require,module,exports){
"use strict";
// Build out our basic SafeString type
function SafeString(string) {
  this.string = string;
}

SafeString.prototype.toString = function() {
  return "" + this.string;
};

exports["default"] = SafeString;
},{}],613:[function(require,module,exports){
"use strict";
/*jshint -W004 */
var SafeString = require("./safe-string")["default"];

var escape = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#x27;",
  "`": "&#x60;"
};

var badChars = /[&<>"'`]/g;
var possible = /[&<>"'`]/;

function escapeChar(chr) {
  return escape[chr] || "&amp;";
}

function extend(obj, value) {
  for(var key in value) {
    if(Object.prototype.hasOwnProperty.call(value, key)) {
      obj[key] = value[key];
    }
  }
}

exports.extend = extend;var toString = Object.prototype.toString;
exports.toString = toString;
// Sourced from lodash
// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
var isFunction = function(value) {
  return typeof value === 'function';
};
// fallback for older versions of Chrome and Safari
if (isFunction(/x/)) {
  isFunction = function(value) {
    return typeof value === 'function' && toString.call(value) === '[object Function]';
  };
}
var isFunction;
exports.isFunction = isFunction;
var isArray = Array.isArray || function(value) {
  return (value && typeof value === 'object') ? toString.call(value) === '[object Array]' : false;
};
exports.isArray = isArray;

function escapeExpression(string) {
  // don't escape SafeStrings, since they're already safe
  if (string instanceof SafeString) {
    return string.toString();
  } else if (!string && string !== 0) {
    return "";
  }

  // Force a string conversion as this will be done by the append regardless and
  // the regex test will do this transparently behind the scenes, causing issues if
  // an object's to string has escaped characters in it.
  string = "" + string;

  if(!possible.test(string)) { return string; }
  return string.replace(badChars, escapeChar);
}

exports.escapeExpression = escapeExpression;function isEmpty(value) {
  if (!value && value !== 0) {
    return true;
  } else if (isArray(value) && value.length === 0) {
    return true;
  } else {
    return false;
  }
}

exports.isEmpty = isEmpty;
},{"./safe-string":612}],614:[function(require,module,exports){
// Create a simple path alias to allow browserify to resolve
// the runtime on a supported path.
module.exports = require('./dist/cjs/handlebars.runtime');

},{"./dist/cjs/handlebars.runtime":608}],615:[function(require,module,exports){
module.exports = require("handlebars/runtime")["default"];

},{"handlebars/runtime":614}],616:[function(require,module,exports){
var root = require('./_root');

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;

},{"./_root":631}],617:[function(require,module,exports){
/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

module.exports = arrayMap;

},{}],618:[function(require,module,exports){
var baseProperty = require('./_baseProperty');

/**
 * Gets the size of an ASCII `string`.
 *
 * @private
 * @param {string} string The string inspect.
 * @returns {number} Returns the string size.
 */
var asciiSize = baseProperty('length');

module.exports = asciiSize;

},{"./_baseProperty":621}],619:[function(require,module,exports){
/**
 * Converts an ASCII `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function asciiToArray(string) {
  return string.split('');
}

module.exports = asciiToArray;

},{}],620:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    getRawTag = require('./_getRawTag'),
    objectToString = require('./_objectToString');

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  value = Object(value);
  return (symToStringTag && symToStringTag in value)
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;

},{"./_Symbol":616,"./_getRawTag":628,"./_objectToString":630}],621:[function(require,module,exports){
/**
 * The base implementation of `_.property` without support for deep paths.
 *
 * @private
 * @param {string} key The key of the property to get.
 * @returns {Function} Returns the new accessor function.
 */
function baseProperty(key) {
  return function(object) {
    return object == null ? undefined : object[key];
  };
}

module.exports = baseProperty;

},{}],622:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeFloor = Math.floor;

/**
 * The base implementation of `_.repeat` which doesn't coerce arguments.
 *
 * @private
 * @param {string} string The string to repeat.
 * @param {number} n The number of times to repeat the string.
 * @returns {string} Returns the repeated string.
 */
function baseRepeat(string, n) {
  var result = '';
  if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
    return result;
  }
  // Leverage the exponentiation by squaring algorithm for a faster repeat.
  // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
  do {
    if (n % 2) {
      result += string;
    }
    n = nativeFloor(n / 2);
    if (n) {
      string += string;
    }
  } while (n);

  return result;
}

module.exports = baseRepeat;

},{}],623:[function(require,module,exports){
/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

module.exports = baseSlice;

},{}],624:[function(require,module,exports){
var Symbol = require('./_Symbol'),
    arrayMap = require('./_arrayMap'),
    isArray = require('./isArray'),
    isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

module.exports = baseToString;

},{"./_Symbol":616,"./_arrayMap":617,"./isArray":638,"./isSymbol":641}],625:[function(require,module,exports){
var baseSlice = require('./_baseSlice');

/**
 * Casts `array` to a slice if it's needed.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {number} start The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the cast slice.
 */
function castSlice(array, start, end) {
  var length = array.length;
  end = end === undefined ? length : end;
  return (!start && end >= length) ? array : baseSlice(array, start, end);
}

module.exports = castSlice;

},{"./_baseSlice":623}],626:[function(require,module,exports){
var baseRepeat = require('./_baseRepeat'),
    baseToString = require('./_baseToString'),
    castSlice = require('./_castSlice'),
    hasUnicode = require('./_hasUnicode'),
    stringSize = require('./_stringSize'),
    stringToArray = require('./_stringToArray');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeCeil = Math.ceil;

/**
 * Creates the padding for `string` based on `length`. The `chars` string
 * is truncated if the number of characters exceeds `length`.
 *
 * @private
 * @param {number} length The padding length.
 * @param {string} [chars=' '] The string used as padding.
 * @returns {string} Returns the padding for `string`.
 */
function createPadding(length, chars) {
  chars = chars === undefined ? ' ' : baseToString(chars);

  var charsLength = chars.length;
  if (charsLength < 2) {
    return charsLength ? baseRepeat(chars, length) : chars;
  }
  var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
  return hasUnicode(chars)
    ? castSlice(stringToArray(result), 0, length).join('')
    : result.slice(0, length);
}

module.exports = createPadding;

},{"./_baseRepeat":622,"./_baseToString":624,"./_castSlice":625,"./_hasUnicode":629,"./_stringSize":632,"./_stringToArray":633}],627:[function(require,module,exports){
(function (global){
/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

module.exports = freeGlobal;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],628:[function(require,module,exports){
var Symbol = require('./_Symbol');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;

},{"./_Symbol":616}],629:[function(require,module,exports){
/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsZWJ = '\\u200d';

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */
function hasUnicode(string) {
  return reHasUnicode.test(string);
}

module.exports = hasUnicode;

},{}],630:[function(require,module,exports){
/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;

},{}],631:[function(require,module,exports){
var freeGlobal = require('./_freeGlobal');

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;

},{"./_freeGlobal":627}],632:[function(require,module,exports){
var asciiSize = require('./_asciiSize'),
    hasUnicode = require('./_hasUnicode'),
    unicodeSize = require('./_unicodeSize');

/**
 * Gets the number of symbols in `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the string size.
 */
function stringSize(string) {
  return hasUnicode(string)
    ? unicodeSize(string)
    : asciiSize(string);
}

module.exports = stringSize;

},{"./_asciiSize":618,"./_hasUnicode":629,"./_unicodeSize":634}],633:[function(require,module,exports){
var asciiToArray = require('./_asciiToArray'),
    hasUnicode = require('./_hasUnicode'),
    unicodeToArray = require('./_unicodeToArray');

/**
 * Converts `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function stringToArray(string) {
  return hasUnicode(string)
    ? unicodeToArray(string)
    : asciiToArray(string);
}

module.exports = stringToArray;

},{"./_asciiToArray":619,"./_hasUnicode":629,"./_unicodeToArray":635}],634:[function(require,module,exports){
/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + rsAstralRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

/**
 * Gets the size of a Unicode `string`.
 *
 * @private
 * @param {string} string The string inspect.
 * @returns {number} Returns the string size.
 */
function unicodeSize(string) {
  var result = reUnicode.lastIndex = 0;
  while (reUnicode.test(string)) {
    ++result;
  }
  return result;
}

module.exports = unicodeSize;

},{}],635:[function(require,module,exports){
/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + rsAstralRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

/**
 * Converts a Unicode `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}

module.exports = unicodeToArray;

},{}],636:[function(require,module,exports){
var toInteger = require('./toInteger');

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that invokes `func`, with the `this` binding and arguments
 * of the created function, while it's called less than `n` times. Subsequent
 * calls to the created function return the result of the last `func` invocation.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Function
 * @param {number} n The number of calls at which `func` is no longer invoked.
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * jQuery(element).on('click', _.before(5, addContactToList));
 * // => Allows adding up to 4 contacts to the list.
 */
function before(n, func) {
  var result;
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  n = toInteger(n);
  return function() {
    if (--n > 0) {
      result = func.apply(this, arguments);
    }
    if (n <= 1) {
      func = undefined;
    }
    return result;
  };
}

module.exports = before;

},{"./toInteger":647}],637:[function(require,module,exports){
var isObject = require('./isObject'),
    now = require('./now'),
    toNumber = require('./toNumber');

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

module.exports = debounce;

},{"./isObject":639,"./now":642,"./toNumber":648}],638:[function(require,module,exports){
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;

},{}],639:[function(require,module,exports){
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;

},{}],640:[function(require,module,exports){
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;

},{}],641:[function(require,module,exports){
var baseGetTag = require('./_baseGetTag'),
    isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

module.exports = isSymbol;

},{"./_baseGetTag":620,"./isObjectLike":640}],642:[function(require,module,exports){
var root = require('./_root');

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

module.exports = now;

},{"./_root":631}],643:[function(require,module,exports){
var before = require('./before');

/**
 * Creates a function that is restricted to invoking `func` once. Repeat calls
 * to the function return the value of the first invocation. The `func` is
 * invoked with the `this` binding and arguments of the created function.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * var initialize = _.once(createApplication);
 * initialize();
 * initialize();
 * // => `createApplication` is invoked once
 */
function once(func) {
  return before(2, func);
}

module.exports = once;

},{"./before":636}],644:[function(require,module,exports){
var createPadding = require('./_createPadding'),
    stringSize = require('./_stringSize'),
    toInteger = require('./toInteger'),
    toString = require('./toString');

/**
 * Pads `string` on the left side if it's shorter than `length`. Padding
 * characters are truncated if they exceed `length`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to pad.
 * @param {number} [length=0] The padding length.
 * @param {string} [chars=' '] The string used as padding.
 * @returns {string} Returns the padded string.
 * @example
 *
 * _.padStart('abc', 6);
 * // => '   abc'
 *
 * _.padStart('abc', 6, '_-');
 * // => '_-_abc'
 *
 * _.padStart('abc', 3);
 * // => 'abc'
 */
function padStart(string, length, chars) {
  string = toString(string);
  length = toInteger(length);

  var strLength = length ? stringSize(string) : 0;
  return (length && strLength < length)
    ? (createPadding(length - strLength, chars) + string)
    : string;
}

module.exports = padStart;

},{"./_createPadding":626,"./_stringSize":632,"./toInteger":647,"./toString":649}],645:[function(require,module,exports){
var debounce = require('./debounce'),
    isObject = require('./isObject');

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

module.exports = throttle;

},{"./debounce":637,"./isObject":639}],646:[function(require,module,exports){
var toNumber = require('./toNumber');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

module.exports = toFinite;

},{"./toNumber":648}],647:[function(require,module,exports){
var toFinite = require('./toFinite');

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

module.exports = toInteger;

},{"./toFinite":646}],648:[function(require,module,exports){
var isObject = require('./isObject'),
    isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;

},{"./isObject":639,"./isSymbol":641}],649:[function(require,module,exports){
var baseToString = require('./_baseToString');

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

module.exports = toString;

},{"./_baseToString":624}],650:[function(require,module,exports){
//! moment.js
//! version : 2.17.0
//! authors : Tim Wood, Iskren Chernev, Moment.js contributors
//! license : MIT
//! momentjs.com

;(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    global.moment = factory()
}(this, (function () { 'use strict';

var hookCallback;

function hooks () {
    return hookCallback.apply(null, arguments);
}

// This is done to register the method called with moment()
// without creating circular dependencies.
function setHookCallback (callback) {
    hookCallback = callback;
}

function isArray(input) {
    return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
}

function isObject(input) {
    // IE8 will treat undefined and null as object if it wasn't for
    // input != null
    return input != null && Object.prototype.toString.call(input) === '[object Object]';
}

function isObjectEmpty(obj) {
    var k;
    for (k in obj) {
        // even if its not own property I'd still call it non-empty
        return false;
    }
    return true;
}

function isNumber(input) {
    return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
}

function isDate(input) {
    return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
}

function map(arr, fn) {
    var res = [], i;
    for (i = 0; i < arr.length; ++i) {
        res.push(fn(arr[i], i));
    }
    return res;
}

function hasOwnProp(a, b) {
    return Object.prototype.hasOwnProperty.call(a, b);
}

function extend(a, b) {
    for (var i in b) {
        if (hasOwnProp(b, i)) {
            a[i] = b[i];
        }
    }

    if (hasOwnProp(b, 'toString')) {
        a.toString = b.toString;
    }

    if (hasOwnProp(b, 'valueOf')) {
        a.valueOf = b.valueOf;
    }

    return a;
}

function createUTC (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, true).utc();
}

function defaultParsingFlags() {
    // We need to deep clone this object.
    return {
        empty           : false,
        unusedTokens    : [],
        unusedInput     : [],
        overflow        : -2,
        charsLeftOver   : 0,
        nullInput       : false,
        invalidMonth    : null,
        invalidFormat   : false,
        userInvalidated : false,
        iso             : false,
        parsedDateParts : [],
        meridiem        : null
    };
}

function getParsingFlags(m) {
    if (m._pf == null) {
        m._pf = defaultParsingFlags();
    }
    return m._pf;
}

var some;
if (Array.prototype.some) {
    some = Array.prototype.some;
} else {
    some = function (fun) {
        var t = Object(this);
        var len = t.length >>> 0;

        for (var i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
                return true;
            }
        }

        return false;
    };
}

var some$1 = some;

function isValid(m) {
    if (m._isValid == null) {
        var flags = getParsingFlags(m);
        var parsedParts = some$1.call(flags.parsedDateParts, function (i) {
            return i != null;
        });
        var isNowValid = !isNaN(m._d.getTime()) &&
            flags.overflow < 0 &&
            !flags.empty &&
            !flags.invalidMonth &&
            !flags.invalidWeekday &&
            !flags.nullInput &&
            !flags.invalidFormat &&
            !flags.userInvalidated &&
            (!flags.meridiem || (flags.meridiem && parsedParts));

        if (m._strict) {
            isNowValid = isNowValid &&
                flags.charsLeftOver === 0 &&
                flags.unusedTokens.length === 0 &&
                flags.bigHour === undefined;
        }

        if (Object.isFrozen == null || !Object.isFrozen(m)) {
            m._isValid = isNowValid;
        }
        else {
            return isNowValid;
        }
    }
    return m._isValid;
}

function createInvalid (flags) {
    var m = createUTC(NaN);
    if (flags != null) {
        extend(getParsingFlags(m), flags);
    }
    else {
        getParsingFlags(m).userInvalidated = true;
    }

    return m;
}

function isUndefined(input) {
    return input === void 0;
}

// Plugins that add properties should also add the key here (null value),
// so we can properly clone ourselves.
var momentProperties = hooks.momentProperties = [];

function copyConfig(to, from) {
    var i, prop, val;

    if (!isUndefined(from._isAMomentObject)) {
        to._isAMomentObject = from._isAMomentObject;
    }
    if (!isUndefined(from._i)) {
        to._i = from._i;
    }
    if (!isUndefined(from._f)) {
        to._f = from._f;
    }
    if (!isUndefined(from._l)) {
        to._l = from._l;
    }
    if (!isUndefined(from._strict)) {
        to._strict = from._strict;
    }
    if (!isUndefined(from._tzm)) {
        to._tzm = from._tzm;
    }
    if (!isUndefined(from._isUTC)) {
        to._isUTC = from._isUTC;
    }
    if (!isUndefined(from._offset)) {
        to._offset = from._offset;
    }
    if (!isUndefined(from._pf)) {
        to._pf = getParsingFlags(from);
    }
    if (!isUndefined(from._locale)) {
        to._locale = from._locale;
    }

    if (momentProperties.length > 0) {
        for (i in momentProperties) {
            prop = momentProperties[i];
            val = from[prop];
            if (!isUndefined(val)) {
                to[prop] = val;
            }
        }
    }

    return to;
}

var updateInProgress = false;

// Moment prototype object
function Moment(config) {
    copyConfig(this, config);
    this._d = new Date(config._d != null ? config._d.getTime() : NaN);
    if (!this.isValid()) {
        this._d = new Date(NaN);
    }
    // Prevent infinite loop in case updateOffset creates new moment
    // objects.
    if (updateInProgress === false) {
        updateInProgress = true;
        hooks.updateOffset(this);
        updateInProgress = false;
    }
}

function isMoment (obj) {
    return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
}

function absFloor (number) {
    if (number < 0) {
        // -0 -> 0
        return Math.ceil(number) || 0;
    } else {
        return Math.floor(number);
    }
}

function toInt(argumentForCoercion) {
    var coercedNumber = +argumentForCoercion,
        value = 0;

    if (coercedNumber !== 0 && isFinite(coercedNumber)) {
        value = absFloor(coercedNumber);
    }

    return value;
}

// compare two arrays, return the number of differences
function compareArrays(array1, array2, dontConvert) {
    var len = Math.min(array1.length, array2.length),
        lengthDiff = Math.abs(array1.length - array2.length),
        diffs = 0,
        i;
    for (i = 0; i < len; i++) {
        if ((dontConvert && array1[i] !== array2[i]) ||
            (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
            diffs++;
        }
    }
    return diffs + lengthDiff;
}

function warn(msg) {
    if (hooks.suppressDeprecationWarnings === false &&
            (typeof console !==  'undefined') && console.warn) {
        console.warn('Deprecation warning: ' + msg);
    }
}

function deprecate(msg, fn) {
    var firstTime = true;

    return extend(function () {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(null, msg);
        }
        if (firstTime) {
            var args = [];
            var arg;
            for (var i = 0; i < arguments.length; i++) {
                arg = '';
                if (typeof arguments[i] === 'object') {
                    arg += '\n[' + i + '] ';
                    for (var key in arguments[0]) {
                        arg += key + ': ' + arguments[0][key] + ', ';
                    }
                    arg = arg.slice(0, -2); // Remove trailing comma and space
                } else {
                    arg = arguments[i];
                }
                args.push(arg);
            }
            warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
            firstTime = false;
        }
        return fn.apply(this, arguments);
    }, fn);
}

var deprecations = {};

function deprecateSimple(name, msg) {
    if (hooks.deprecationHandler != null) {
        hooks.deprecationHandler(name, msg);
    }
    if (!deprecations[name]) {
        warn(msg);
        deprecations[name] = true;
    }
}

hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;

function isFunction(input) {
    return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
}

function set (config) {
    var prop, i;
    for (i in config) {
        prop = config[i];
        if (isFunction(prop)) {
            this[i] = prop;
        } else {
            this['_' + i] = prop;
        }
    }
    this._config = config;
    // Lenient ordinal parsing accepts just a number in addition to
    // number + (possibly) stuff coming from _ordinalParseLenient.
    this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
}

function mergeConfigs(parentConfig, childConfig) {
    var res = extend({}, parentConfig), prop;
    for (prop in childConfig) {
        if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                res[prop] = {};
                extend(res[prop], parentConfig[prop]);
                extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
                res[prop] = childConfig[prop];
            } else {
                delete res[prop];
            }
        }
    }
    for (prop in parentConfig) {
        if (hasOwnProp(parentConfig, prop) &&
                !hasOwnProp(childConfig, prop) &&
                isObject(parentConfig[prop])) {
            // make sure changes to properties don't modify parent config
            res[prop] = extend({}, res[prop]);
        }
    }
    return res;
}

function Locale(config) {
    if (config != null) {
        this.set(config);
    }
}

var keys;

if (Object.keys) {
    keys = Object.keys;
} else {
    keys = function (obj) {
        var i, res = [];
        for (i in obj) {
            if (hasOwnProp(obj, i)) {
                res.push(i);
            }
        }
        return res;
    };
}

var keys$1 = keys;

var defaultCalendar = {
    sameDay : '[Today at] LT',
    nextDay : '[Tomorrow at] LT',
    nextWeek : 'dddd [at] LT',
    lastDay : '[Yesterday at] LT',
    lastWeek : '[Last] dddd [at] LT',
    sameElse : 'L'
};

function calendar (key, mom, now) {
    var output = this._calendar[key] || this._calendar['sameElse'];
    return isFunction(output) ? output.call(mom, now) : output;
}

var defaultLongDateFormat = {
    LTS  : 'h:mm:ss A',
    LT   : 'h:mm A',
    L    : 'MM/DD/YYYY',
    LL   : 'MMMM D, YYYY',
    LLL  : 'MMMM D, YYYY h:mm A',
    LLLL : 'dddd, MMMM D, YYYY h:mm A'
};

function longDateFormat (key) {
    var format = this._longDateFormat[key],
        formatUpper = this._longDateFormat[key.toUpperCase()];

    if (format || !formatUpper) {
        return format;
    }

    this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function (val) {
        return val.slice(1);
    });

    return this._longDateFormat[key];
}

var defaultInvalidDate = 'Invalid date';

function invalidDate () {
    return this._invalidDate;
}

var defaultOrdinal = '%d';
var defaultOrdinalParse = /\d{1,2}/;

function ordinal (number) {
    return this._ordinal.replace('%d', number);
}

var defaultRelativeTime = {
    future : 'in %s',
    past   : '%s ago',
    s  : 'a few seconds',
    m  : 'a minute',
    mm : '%d minutes',
    h  : 'an hour',
    hh : '%d hours',
    d  : 'a day',
    dd : '%d days',
    M  : 'a month',
    MM : '%d months',
    y  : 'a year',
    yy : '%d years'
};

function relativeTime (number, withoutSuffix, string, isFuture) {
    var output = this._relativeTime[string];
    return (isFunction(output)) ?
        output(number, withoutSuffix, string, isFuture) :
        output.replace(/%d/i, number);
}

function pastFuture (diff, output) {
    var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
    return isFunction(format) ? format(output) : format.replace(/%s/i, output);
}

var aliases = {};

function addUnitAlias (unit, shorthand) {
    var lowerCase = unit.toLowerCase();
    aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
}

function normalizeUnits(units) {
    return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
}

function normalizeObjectUnits(inputObject) {
    var normalizedInput = {},
        normalizedProp,
        prop;

    for (prop in inputObject) {
        if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
                normalizedInput[normalizedProp] = inputObject[prop];
            }
        }
    }

    return normalizedInput;
}

var priorities = {};

function addUnitPriority(unit, priority) {
    priorities[unit] = priority;
}

function getPrioritizedUnits(unitsObj) {
    var units = [];
    for (var u in unitsObj) {
        units.push({unit: u, priority: priorities[u]});
    }
    units.sort(function (a, b) {
        return a.priority - b.priority;
    });
    return units;
}

function makeGetSet (unit, keepTime) {
    return function (value) {
        if (value != null) {
            set$1(this, unit, value);
            hooks.updateOffset(this, keepTime);
            return this;
        } else {
            return get(this, unit);
        }
    };
}

function get (mom, unit) {
    return mom.isValid() ?
        mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
}

function set$1 (mom, unit, value) {
    if (mom.isValid()) {
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
    }
}

// MOMENTS

function stringGet (units) {
    units = normalizeUnits(units);
    if (isFunction(this[units])) {
        return this[units]();
    }
    return this;
}


function stringSet (units, value) {
    if (typeof units === 'object') {
        units = normalizeObjectUnits(units);
        var prioritized = getPrioritizedUnits(units);
        for (var i = 0; i < prioritized.length; i++) {
            this[prioritized[i].unit](units[prioritized[i].unit]);
        }
    } else {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units](value);
        }
    }
    return this;
}

function zeroFill(number, targetLength, forceSign) {
    var absNumber = '' + Math.abs(number),
        zerosToFill = targetLength - absNumber.length,
        sign = number >= 0;
    return (sign ? (forceSign ? '+' : '') : '-') +
        Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}

var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

var formatFunctions = {};

var formatTokenFunctions = {};

// token:    'M'
// padded:   ['MM', 2]
// ordinal:  'Mo'
// callback: function () { this.month() + 1 }
function addFormatToken (token, padded, ordinal, callback) {
    var func = callback;
    if (typeof callback === 'string') {
        func = function () {
            return this[callback]();
        };
    }
    if (token) {
        formatTokenFunctions[token] = func;
    }
    if (padded) {
        formatTokenFunctions[padded[0]] = function () {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
        };
    }
    if (ordinal) {
        formatTokenFunctions[ordinal] = function () {
            return this.localeData().ordinal(func.apply(this, arguments), token);
        };
    }
}

function removeFormattingTokens(input) {
    if (input.match(/\[[\s\S]/)) {
        return input.replace(/^\[|\]$/g, '');
    }
    return input.replace(/\\/g, '');
}

function makeFormatFunction(format) {
    var array = format.match(formattingTokens), i, length;

    for (i = 0, length = array.length; i < length; i++) {
        if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
        } else {
            array[i] = removeFormattingTokens(array[i]);
        }
    }

    return function (mom) {
        var output = '', i;
        for (i = 0; i < length; i++) {
            output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
        }
        return output;
    };
}

// format date using native date object
function formatMoment(m, format) {
    if (!m.isValid()) {
        return m.localeData().invalidDate();
    }

    format = expandFormat(format, m.localeData());
    formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

    return formatFunctions[format](m);
}

function expandFormat(format, locale) {
    var i = 5;

    function replaceLongDateFormatTokens(input) {
        return locale.longDateFormat(input) || input;
    }

    localFormattingTokens.lastIndex = 0;
    while (i >= 0 && localFormattingTokens.test(format)) {
        format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
        localFormattingTokens.lastIndex = 0;
        i -= 1;
    }

    return format;
}

var match1         = /\d/;            //       0 - 9
var match2         = /\d\d/;          //      00 - 99
var match3         = /\d{3}/;         //     000 - 999
var match4         = /\d{4}/;         //    0000 - 9999
var match6         = /[+-]?\d{6}/;    // -999999 - 999999
var match1to2      = /\d\d?/;         //       0 - 99
var match3to4      = /\d\d\d\d?/;     //     999 - 9999
var match5to6      = /\d\d\d\d\d\d?/; //   99999 - 999999
var match1to3      = /\d{1,3}/;       //       0 - 999
var match1to4      = /\d{1,4}/;       //       0 - 9999
var match1to6      = /[+-]?\d{1,6}/;  // -999999 - 999999

var matchUnsigned  = /\d+/;           //       0 - inf
var matchSigned    = /[+-]?\d+/;      //    -inf - inf

var matchOffset    = /Z|[+-]\d\d:?\d\d/gi; // +00:00 -00:00 +0000 -0000 or Z
var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi; // +00 -00 +00:00 -00:00 +0000 -0000 or Z

var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/; // 123456789 123456789.123

// any word (or two) characters or numbers including two/three word month in arabic.
// includes scottish gaelic two word and hyphenated months
var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;


var regexes = {};

function addRegexToken (token, regex, strictRegex) {
    regexes[token] = isFunction(regex) ? regex : function (isStrict, localeData) {
        return (isStrict && strictRegex) ? strictRegex : regex;
    };
}

function getParseRegexForToken (token, config) {
    if (!hasOwnProp(regexes, token)) {
        return new RegExp(unescapeFormat(token));
    }

    return regexes[token](config._strict, config._locale);
}

// Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
function unescapeFormat(s) {
    return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
        return p1 || p2 || p3 || p4;
    }));
}

function regexEscape(s) {
    return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
}

var tokens = {};

function addParseToken (token, callback) {
    var i, func = callback;
    if (typeof token === 'string') {
        token = [token];
    }
    if (isNumber(callback)) {
        func = function (input, array) {
            array[callback] = toInt(input);
        };
    }
    for (i = 0; i < token.length; i++) {
        tokens[token[i]] = func;
    }
}

function addWeekParseToken (token, callback) {
    addParseToken(token, function (input, array, config, token) {
        config._w = config._w || {};
        callback(input, config._w, config, token);
    });
}

function addTimeToArrayFromToken(token, input, config) {
    if (input != null && hasOwnProp(tokens, token)) {
        tokens[token](input, config._a, config, token);
    }
}

var YEAR = 0;
var MONTH = 1;
var DATE = 2;
var HOUR = 3;
var MINUTE = 4;
var SECOND = 5;
var MILLISECOND = 6;
var WEEK = 7;
var WEEKDAY = 8;

var indexOf;

if (Array.prototype.indexOf) {
    indexOf = Array.prototype.indexOf;
} else {
    indexOf = function (o) {
        // I know
        var i;
        for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
                return i;
            }
        }
        return -1;
    };
}

var indexOf$1 = indexOf;

function daysInMonth(year, month) {
    return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
}

// FORMATTING

addFormatToken('M', ['MM', 2], 'Mo', function () {
    return this.month() + 1;
});

addFormatToken('MMM', 0, 0, function (format) {
    return this.localeData().monthsShort(this, format);
});

addFormatToken('MMMM', 0, 0, function (format) {
    return this.localeData().months(this, format);
});

// ALIASES

addUnitAlias('month', 'M');

// PRIORITY

addUnitPriority('month', 8);

// PARSING

addRegexToken('M',    match1to2);
addRegexToken('MM',   match1to2, match2);
addRegexToken('MMM',  function (isStrict, locale) {
    return locale.monthsShortRegex(isStrict);
});
addRegexToken('MMMM', function (isStrict, locale) {
    return locale.monthsRegex(isStrict);
});

addParseToken(['M', 'MM'], function (input, array) {
    array[MONTH] = toInt(input) - 1;
});

addParseToken(['MMM', 'MMMM'], function (input, array, config, token) {
    var month = config._locale.monthsParse(input, token, config._strict);
    // if we didn't find a month name, mark the date as invalid.
    if (month != null) {
        array[MONTH] = month;
    } else {
        getParsingFlags(config).invalidMonth = input;
    }
});

// LOCALES

var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
function localeMonths (m, format) {
    if (!m) {
        return this._months;
    }
    return isArray(this._months) ? this._months[m.month()] :
        this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
}

var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
function localeMonthsShort (m, format) {
    if (!m) {
        return this._monthsShort;
    }
    return isArray(this._monthsShort) ? this._monthsShort[m.month()] :
        this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
}

function handleStrictParse(monthName, format, strict) {
    var i, ii, mom, llc = monthName.toLocaleLowerCase();
    if (!this._monthsParse) {
        // this is not used
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
        for (i = 0; i < 12; ++i) {
            mom = createUTC([2000, i]);
            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'MMM') {
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'MMM') {
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._longMonthsParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeMonthsParse (monthName, format, strict) {
    var i, mom, regex;

    if (this._monthsParseExact) {
        return handleStrictParse.call(this, monthName, format, strict);
    }

    if (!this._monthsParse) {
        this._monthsParse = [];
        this._longMonthsParse = [];
        this._shortMonthsParse = [];
    }

    // TODO: add sorting
    // Sorting makes sure if one month (or abbr) is a prefix of another
    // see sorting in computeMonthsParse
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
        }
        if (!strict && !this._monthsParse[i]) {
            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
            return i;
        } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
            return i;
        } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
        }
    }
}

// MOMENTS

function setMonth (mom, value) {
    var dayOfMonth;

    if (!mom.isValid()) {
        // No op
        return mom;
    }

    if (typeof value === 'string') {
        if (/^\d+$/.test(value)) {
            value = toInt(value);
        } else {
            value = mom.localeData().monthsParse(value);
            // TODO: Another silent failure?
            if (!isNumber(value)) {
                return mom;
            }
        }
    }

    dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
    mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
    return mom;
}

function getSetMonth (value) {
    if (value != null) {
        setMonth(this, value);
        hooks.updateOffset(this, true);
        return this;
    } else {
        return get(this, 'Month');
    }
}

function getDaysInMonth () {
    return daysInMonth(this.year(), this.month());
}

var defaultMonthsShortRegex = matchWord;
function monthsShortRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsShortStrictRegex;
        } else {
            return this._monthsShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsShortRegex')) {
            this._monthsShortRegex = defaultMonthsShortRegex;
        }
        return this._monthsShortStrictRegex && isStrict ?
            this._monthsShortStrictRegex : this._monthsShortRegex;
    }
}

var defaultMonthsRegex = matchWord;
function monthsRegex (isStrict) {
    if (this._monthsParseExact) {
        if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
        }
        if (isStrict) {
            return this._monthsStrictRegex;
        } else {
            return this._monthsRegex;
        }
    } else {
        if (!hasOwnProp(this, '_monthsRegex')) {
            this._monthsRegex = defaultMonthsRegex;
        }
        return this._monthsStrictRegex && isStrict ?
            this._monthsStrictRegex : this._monthsRegex;
    }
}

function computeMonthsParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom;
    for (i = 0; i < 12; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, i]);
        shortPieces.push(this.monthsShort(mom, ''));
        longPieces.push(this.months(mom, ''));
        mixedPieces.push(this.months(mom, ''));
        mixedPieces.push(this.monthsShort(mom, ''));
    }
    // Sorting makes sure if one month (or abbr) is a prefix of another it
    // will match the longer piece.
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 12; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
    }
    for (i = 0; i < 24; i++) {
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._monthsShortRegex = this._monthsRegex;
    this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
}

// FORMATTING

addFormatToken('Y', 0, 0, function () {
    var y = this.year();
    return y <= 9999 ? '' + y : '+' + y;
});

addFormatToken(0, ['YY', 2], 0, function () {
    return this.year() % 100;
});

addFormatToken(0, ['YYYY',   4],       0, 'year');
addFormatToken(0, ['YYYYY',  5],       0, 'year');
addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

// ALIASES

addUnitAlias('year', 'y');

// PRIORITIES

addUnitPriority('year', 1);

// PARSING

addRegexToken('Y',      matchSigned);
addRegexToken('YY',     match1to2, match2);
addRegexToken('YYYY',   match1to4, match4);
addRegexToken('YYYYY',  match1to6, match6);
addRegexToken('YYYYYY', match1to6, match6);

addParseToken(['YYYYY', 'YYYYYY'], YEAR);
addParseToken('YYYY', function (input, array) {
    array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken('YY', function (input, array) {
    array[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken('Y', function (input, array) {
    array[YEAR] = parseInt(input, 10);
});

// HELPERS

function daysInYear(year) {
    return isLeapYear(year) ? 366 : 365;
}

function isLeapYear(year) {
    return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
}

// HOOKS

hooks.parseTwoDigitYear = function (input) {
    return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
};

// MOMENTS

var getSetYear = makeGetSet('FullYear', true);

function getIsLeapYear () {
    return isLeapYear(this.year());
}

function createDate (y, m, d, h, M, s, ms) {
    //can't just apply() to create a date:
    //http://stackoverflow.com/questions/181348/instantiating-a-javascript-object-by-calling-prototype-constructor-apply
    var date = new Date(y, m, d, h, M, s, ms);

    //the date constructor remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
        date.setFullYear(y);
    }
    return date;
}

function createUTCDate (y) {
    var date = new Date(Date.UTC.apply(null, arguments));

    //the Date.UTC function remaps years 0-99 to 1900-1999
    if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
        date.setUTCFullYear(y);
    }
    return date;
}

// start-of-first-week - start-of-year
function firstWeekOffset(year, dow, doy) {
    var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
        fwd = 7 + dow - doy,
        // first-week day local weekday -- which local weekday is fwd
        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

    return -fwdlw + fwd - 1;
}

//http://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
    var localWeekday = (7 + weekday - dow) % 7,
        weekOffset = firstWeekOffset(year, dow, doy),
        dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
        resYear, resDayOfYear;

    if (dayOfYear <= 0) {
        resYear = year - 1;
        resDayOfYear = daysInYear(resYear) + dayOfYear;
    } else if (dayOfYear > daysInYear(year)) {
        resYear = year + 1;
        resDayOfYear = dayOfYear - daysInYear(year);
    } else {
        resYear = year;
        resDayOfYear = dayOfYear;
    }

    return {
        year: resYear,
        dayOfYear: resDayOfYear
    };
}

function weekOfYear(mom, dow, doy) {
    var weekOffset = firstWeekOffset(mom.year(), dow, doy),
        week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
        resWeek, resYear;

    if (week < 1) {
        resYear = mom.year() - 1;
        resWeek = week + weeksInYear(resYear, dow, doy);
    } else if (week > weeksInYear(mom.year(), dow, doy)) {
        resWeek = week - weeksInYear(mom.year(), dow, doy);
        resYear = mom.year() + 1;
    } else {
        resYear = mom.year();
        resWeek = week;
    }

    return {
        week: resWeek,
        year: resYear
    };
}

function weeksInYear(year, dow, doy) {
    var weekOffset = firstWeekOffset(year, dow, doy),
        weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
    return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}

// FORMATTING

addFormatToken('w', ['ww', 2], 'wo', 'week');
addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

// ALIASES

addUnitAlias('week', 'w');
addUnitAlias('isoWeek', 'W');

// PRIORITIES

addUnitPriority('week', 5);
addUnitPriority('isoWeek', 5);

// PARSING

addRegexToken('w',  match1to2);
addRegexToken('ww', match1to2, match2);
addRegexToken('W',  match1to2);
addRegexToken('WW', match1to2, match2);

addWeekParseToken(['w', 'ww', 'W', 'WW'], function (input, week, config, token) {
    week[token.substr(0, 1)] = toInt(input);
});

// HELPERS

// LOCALES

function localeWeek (mom) {
    return weekOfYear(mom, this._week.dow, this._week.doy).week;
}

var defaultLocaleWeek = {
    dow : 0, // Sunday is the first day of the week.
    doy : 6  // The week that contains Jan 1st is the first week of the year.
};

function localeFirstDayOfWeek () {
    return this._week.dow;
}

function localeFirstDayOfYear () {
    return this._week.doy;
}

// MOMENTS

function getSetWeek (input) {
    var week = this.localeData().week(this);
    return input == null ? week : this.add((input - week) * 7, 'd');
}

function getSetISOWeek (input) {
    var week = weekOfYear(this, 1, 4).week;
    return input == null ? week : this.add((input - week) * 7, 'd');
}

// FORMATTING

addFormatToken('d', 0, 'do', 'day');

addFormatToken('dd', 0, 0, function (format) {
    return this.localeData().weekdaysMin(this, format);
});

addFormatToken('ddd', 0, 0, function (format) {
    return this.localeData().weekdaysShort(this, format);
});

addFormatToken('dddd', 0, 0, function (format) {
    return this.localeData().weekdays(this, format);
});

addFormatToken('e', 0, 0, 'weekday');
addFormatToken('E', 0, 0, 'isoWeekday');

// ALIASES

addUnitAlias('day', 'd');
addUnitAlias('weekday', 'e');
addUnitAlias('isoWeekday', 'E');

// PRIORITY
addUnitPriority('day', 11);
addUnitPriority('weekday', 11);
addUnitPriority('isoWeekday', 11);

// PARSING

addRegexToken('d',    match1to2);
addRegexToken('e',    match1to2);
addRegexToken('E',    match1to2);
addRegexToken('dd',   function (isStrict, locale) {
    return locale.weekdaysMinRegex(isStrict);
});
addRegexToken('ddd',   function (isStrict, locale) {
    return locale.weekdaysShortRegex(isStrict);
});
addRegexToken('dddd',   function (isStrict, locale) {
    return locale.weekdaysRegex(isStrict);
});

addWeekParseToken(['dd', 'ddd', 'dddd'], function (input, week, config, token) {
    var weekday = config._locale.weekdaysParse(input, token, config._strict);
    // if we didn't get a weekday name, mark the date as invalid
    if (weekday != null) {
        week.d = weekday;
    } else {
        getParsingFlags(config).invalidWeekday = input;
    }
});

addWeekParseToken(['d', 'e', 'E'], function (input, week, config, token) {
    week[token] = toInt(input);
});

// HELPERS

function parseWeekday(input, locale) {
    if (typeof input !== 'string') {
        return input;
    }

    if (!isNaN(input)) {
        return parseInt(input, 10);
    }

    input = locale.weekdaysParse(input);
    if (typeof input === 'number') {
        return input;
    }

    return null;
}

function parseIsoWeekday(input, locale) {
    if (typeof input === 'string') {
        return locale.weekdaysParse(input) % 7 || 7;
    }
    return isNaN(input) ? null : input;
}

// LOCALES

var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
function localeWeekdays (m, format) {
    if (!m) {
        return this._weekdays;
    }
    return isArray(this._weekdays) ? this._weekdays[m.day()] :
        this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
}

var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
function localeWeekdaysShort (m) {
    return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
}

var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
function localeWeekdaysMin (m) {
    return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
}

function handleStrictParse$1(weekdayName, format, strict) {
    var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._minWeekdaysParse = [];

        for (i = 0; i < 7; ++i) {
            mom = createUTC([2000, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
        }
    }

    if (strict) {
        if (format === 'dddd') {
            ii = indexOf$1.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    } else {
        if (format === 'dddd') {
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else if (format === 'ddd') {
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        } else {
            ii = indexOf$1.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._weekdaysParse, llc);
            if (ii !== -1) {
                return ii;
            }
            ii = indexOf$1.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
        }
    }
}

function localeWeekdaysParse (weekdayName, format, strict) {
    var i, mom, regex;

    if (this._weekdaysParseExact) {
        return handleStrictParse$1.call(this, weekdayName, format, strict);
    }

    if (!this._weekdaysParse) {
        this._weekdaysParse = [];
        this._minWeekdaysParse = [];
        this._shortWeekdaysParse = [];
        this._fullWeekdaysParse = [];
    }

    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already

        mom = createUTC([2000, 1]).day(i);
        if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
        }
        if (!this._weekdaysParse[i]) {
            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
        }
        // test the regex
        if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
        } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
        }
    }
}

// MOMENTS

function getSetDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
    if (input != null) {
        input = parseWeekday(input, this.localeData());
        return this.add(input - day, 'd');
    } else {
        return day;
    }
}

function getSetLocaleDayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
    return input == null ? weekday : this.add(input - weekday, 'd');
}

function getSetISODayOfWeek (input) {
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }

    // behaves the same as moment#day except
    // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
    // as a setter, sunday should belong to the previous week.

    if (input != null) {
        var weekday = parseIsoWeekday(input, this.localeData());
        return this.day(this.day() % 7 ? weekday : weekday - 7);
    } else {
        return this.day() || 7;
    }
}

var defaultWeekdaysRegex = matchWord;
function weekdaysRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysStrictRegex;
        } else {
            return this._weekdaysRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            this._weekdaysRegex = defaultWeekdaysRegex;
        }
        return this._weekdaysStrictRegex && isStrict ?
            this._weekdaysStrictRegex : this._weekdaysRegex;
    }
}

var defaultWeekdaysShortRegex = matchWord;
function weekdaysShortRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysShortStrictRegex;
        } else {
            return this._weekdaysShortRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysShortRegex')) {
            this._weekdaysShortRegex = defaultWeekdaysShortRegex;
        }
        return this._weekdaysShortStrictRegex && isStrict ?
            this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
    }
}

var defaultWeekdaysMinRegex = matchWord;
function weekdaysMinRegex (isStrict) {
    if (this._weekdaysParseExact) {
        if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
        }
        if (isStrict) {
            return this._weekdaysMinStrictRegex;
        } else {
            return this._weekdaysMinRegex;
        }
    } else {
        if (!hasOwnProp(this, '_weekdaysMinRegex')) {
            this._weekdaysMinRegex = defaultWeekdaysMinRegex;
        }
        return this._weekdaysMinStrictRegex && isStrict ?
            this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
    }
}


function computeWeekdaysParse () {
    function cmpLenRev(a, b) {
        return b.length - a.length;
    }

    var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [],
        i, mom, minp, shortp, longp;
    for (i = 0; i < 7; i++) {
        // make the regex if we don't have it already
        mom = createUTC([2000, 1]).day(i);
        minp = this.weekdaysMin(mom, '');
        shortp = this.weekdaysShort(mom, '');
        longp = this.weekdays(mom, '');
        minPieces.push(minp);
        shortPieces.push(shortp);
        longPieces.push(longp);
        mixedPieces.push(minp);
        mixedPieces.push(shortp);
        mixedPieces.push(longp);
    }
    // Sorting makes sure if one weekday (or abbr) is a prefix of another it
    // will match the longer piece.
    minPieces.sort(cmpLenRev);
    shortPieces.sort(cmpLenRev);
    longPieces.sort(cmpLenRev);
    mixedPieces.sort(cmpLenRev);
    for (i = 0; i < 7; i++) {
        shortPieces[i] = regexEscape(shortPieces[i]);
        longPieces[i] = regexEscape(longPieces[i]);
        mixedPieces[i] = regexEscape(mixedPieces[i]);
    }

    this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
    this._weekdaysShortRegex = this._weekdaysRegex;
    this._weekdaysMinRegex = this._weekdaysRegex;

    this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
    this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
    this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
}

// FORMATTING

function hFormat() {
    return this.hours() % 12 || 12;
}

function kFormat() {
    return this.hours() || 24;
}

addFormatToken('H', ['HH', 2], 0, 'hour');
addFormatToken('h', ['hh', 2], 0, hFormat);
addFormatToken('k', ['kk', 2], 0, kFormat);

addFormatToken('hmm', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});

addFormatToken('hmmss', 0, 0, function () {
    return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

addFormatToken('Hmm', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2);
});

addFormatToken('Hmmss', 0, 0, function () {
    return '' + this.hours() + zeroFill(this.minutes(), 2) +
        zeroFill(this.seconds(), 2);
});

function meridiem (token, lowercase) {
    addFormatToken(token, 0, 0, function () {
        return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
    });
}

meridiem('a', true);
meridiem('A', false);

// ALIASES

addUnitAlias('hour', 'h');

// PRIORITY
addUnitPriority('hour', 13);

// PARSING

function matchMeridiem (isStrict, locale) {
    return locale._meridiemParse;
}

addRegexToken('a',  matchMeridiem);
addRegexToken('A',  matchMeridiem);
addRegexToken('H',  match1to2);
addRegexToken('h',  match1to2);
addRegexToken('HH', match1to2, match2);
addRegexToken('hh', match1to2, match2);

addRegexToken('hmm', match3to4);
addRegexToken('hmmss', match5to6);
addRegexToken('Hmm', match3to4);
addRegexToken('Hmmss', match5to6);

addParseToken(['H', 'HH'], HOUR);
addParseToken(['a', 'A'], function (input, array, config) {
    config._isPm = config._locale.isPM(input);
    config._meridiem = input;
});
addParseToken(['h', 'hh'], function (input, array, config) {
    array[HOUR] = toInt(input);
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
    getParsingFlags(config).bigHour = true;
});
addParseToken('hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
    getParsingFlags(config).bigHour = true;
});
addParseToken('Hmm', function (input, array, config) {
    var pos = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos));
    array[MINUTE] = toInt(input.substr(pos));
});
addParseToken('Hmmss', function (input, array, config) {
    var pos1 = input.length - 4;
    var pos2 = input.length - 2;
    array[HOUR] = toInt(input.substr(0, pos1));
    array[MINUTE] = toInt(input.substr(pos1, 2));
    array[SECOND] = toInt(input.substr(pos2));
});

// LOCALES

function localeIsPM (input) {
    // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
    // Using charAt should be more compatible.
    return ((input + '').toLowerCase().charAt(0) === 'p');
}

var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
function localeMeridiem (hours, minutes, isLower) {
    if (hours > 11) {
        return isLower ? 'pm' : 'PM';
    } else {
        return isLower ? 'am' : 'AM';
    }
}


// MOMENTS

// Setting the hour should keep the time, because the user explicitly
// specified which hour he wants. So trying to maintain the same hour (in
// a new timezone) makes sense. Adding/subtracting hours does not follow
// this rule.
var getSetHour = makeGetSet('Hours', true);

// months
// week
// weekdays
// meridiem
var baseConfig = {
    calendar: defaultCalendar,
    longDateFormat: defaultLongDateFormat,
    invalidDate: defaultInvalidDate,
    ordinal: defaultOrdinal,
    ordinalParse: defaultOrdinalParse,
    relativeTime: defaultRelativeTime,

    months: defaultLocaleMonths,
    monthsShort: defaultLocaleMonthsShort,

    week: defaultLocaleWeek,

    weekdays: defaultLocaleWeekdays,
    weekdaysMin: defaultLocaleWeekdaysMin,
    weekdaysShort: defaultLocaleWeekdaysShort,

    meridiemParse: defaultLocaleMeridiemParse
};

// internal storage for locale config files
var locales = {};
var localeFamilies = {};
var globalLocale;

function normalizeLocale(key) {
    return key ? key.toLowerCase().replace('_', '-') : key;
}

// pick the locale from the array
// try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
// substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
function chooseLocale(names) {
    var i = 0, j, next, locale, split;

    while (i < names.length) {
        split = normalizeLocale(names[i]).split('-');
        j = split.length;
        next = normalizeLocale(names[i + 1]);
        next = next ? next.split('-') : null;
        while (j > 0) {
            locale = loadLocale(split.slice(0, j).join('-'));
            if (locale) {
                return locale;
            }
            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                //the next array item is better than a shallower substring of this one
                break;
            }
            j--;
        }
        i++;
    }
    return null;
}

function loadLocale(name) {
    var oldLocale = null;
    // TODO: Find a better way to register and load all the locales in Node
    if (!locales[name] && (typeof module !== 'undefined') &&
            module && module.exports) {
        try {
            oldLocale = globalLocale._abbr;
            require('./locale/' + name);
            // because defineLocale currently also sets the global locale, we
            // want to undo that for lazy loaded locales
            getSetGlobalLocale(oldLocale);
        } catch (e) { }
    }
    return locales[name];
}

// This function will load locale and then set the global locale.  If
// no arguments are passed in, it will simply return the current global
// locale key.
function getSetGlobalLocale (key, values) {
    var data;
    if (key) {
        if (isUndefined(values)) {
            data = getLocale(key);
        }
        else {
            data = defineLocale(key, values);
        }

        if (data) {
            // moment.duration._locale = moment._locale = data;
            globalLocale = data;
        }
    }

    return globalLocale._abbr;
}

function defineLocale (name, config) {
    if (config !== null) {
        var parentConfig = baseConfig;
        config.abbr = name;
        if (locales[name] != null) {
            deprecateSimple('defineLocaleOverride',
                    'use moment.updateLocale(localeName, config) to change ' +
                    'an existing locale. moment.defineLocale(localeName, ' +
                    'config) should only be used for creating a new locale ' +
                    'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
            parentConfig = locales[name]._config;
        } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
                parentConfig = locales[config.parentLocale]._config;
            } else {
                if (!localeFamilies[config.parentLocale]) {
                    localeFamilies[config.parentLocale] = [];
                }
                localeFamilies[config.parentLocale].push({
                    name: name,
                    config: config
                });
                return null;
            }
        }
        locales[name] = new Locale(mergeConfigs(parentConfig, config));

        if (localeFamilies[name]) {
            localeFamilies[name].forEach(function (x) {
                defineLocale(x.name, x.config);
            });
        }

        // backwards compat for now: also set the locale
        // make sure we set the locale AFTER all child locales have been
        // created, so we won't end up with the child locale set.
        getSetGlobalLocale(name);


        return locales[name];
    } else {
        // useful for testing
        delete locales[name];
        return null;
    }
}

function updateLocale(name, config) {
    if (config != null) {
        var locale, parentConfig = baseConfig;
        // MERGE
        if (locales[name] != null) {
            parentConfig = locales[name]._config;
        }
        config = mergeConfigs(parentConfig, config);
        locale = new Locale(config);
        locale.parentLocale = locales[name];
        locales[name] = locale;

        // backwards compat for now: also set the locale
        getSetGlobalLocale(name);
    } else {
        // pass null for config to unupdate, useful for tests
        if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
                locales[name] = locales[name].parentLocale;
            } else if (locales[name] != null) {
                delete locales[name];
            }
        }
    }
    return locales[name];
}

// returns locale data
function getLocale (key) {
    var locale;

    if (key && key._locale && key._locale._abbr) {
        key = key._locale._abbr;
    }

    if (!key) {
        return globalLocale;
    }

    if (!isArray(key)) {
        //short-circuit everything else
        locale = loadLocale(key);
        if (locale) {
            return locale;
        }
        key = [key];
    }

    return chooseLocale(key);
}

function listLocales() {
    return keys$1(locales);
}

function checkOverflow (m) {
    var overflow;
    var a = m._a;

    if (a && getParsingFlags(m).overflow === -2) {
        overflow =
            a[MONTH]       < 0 || a[MONTH]       > 11  ? MONTH :
            a[DATE]        < 1 || a[DATE]        > daysInMonth(a[YEAR], a[MONTH]) ? DATE :
            a[HOUR]        < 0 || a[HOUR]        > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR :
            a[MINUTE]      < 0 || a[MINUTE]      > 59  ? MINUTE :
            a[SECOND]      < 0 || a[SECOND]      > 59  ? SECOND :
            a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND :
            -1;

        if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
        }
        if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
        }
        if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
        }

        getParsingFlags(m).overflow = overflow;
    }

    return m;
}

// iso 8601 regex
// 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

var isoDates = [
    ['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/],
    ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/],
    ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/],
    ['GGGG-[W]WW', /\d{4}-W\d\d/, false],
    ['YYYY-DDD', /\d{4}-\d{3}/],
    ['YYYY-MM', /\d{4}-\d\d/, false],
    ['YYYYYYMMDD', /[+-]\d{10}/],
    ['YYYYMMDD', /\d{8}/],
    // YYYYMM is NOT allowed by the standard
    ['GGGG[W]WWE', /\d{4}W\d{3}/],
    ['GGGG[W]WW', /\d{4}W\d{2}/, false],
    ['YYYYDDD', /\d{7}/]
];

// iso time formats and regexes
var isoTimes = [
    ['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/],
    ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/],
    ['HH:mm:ss', /\d\d:\d\d:\d\d/],
    ['HH:mm', /\d\d:\d\d/],
    ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/],
    ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/],
    ['HHmmss', /\d\d\d\d\d\d/],
    ['HHmm', /\d\d\d\d/],
    ['HH', /\d\d/]
];

var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

// date from iso format
function configFromISO(config) {
    var i, l,
        string = config._i,
        match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
        allowTime, dateFormat, timeFormat, tzFormat;

    if (match) {
        getParsingFlags(config).iso = true;

        for (i = 0, l = isoDates.length; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
                dateFormat = isoDates[i][0];
                allowTime = isoDates[i][2] !== false;
                break;
            }
        }
        if (dateFormat == null) {
            config._isValid = false;
            return;
        }
        if (match[3]) {
            for (i = 0, l = isoTimes.length; i < l; i++) {
                if (isoTimes[i][1].exec(match[3])) {
                    // match[2] should be 'T' or space
                    timeFormat = (match[2] || ' ') + isoTimes[i][0];
                    break;
                }
            }
            if (timeFormat == null) {
                config._isValid = false;
                return;
            }
        }
        if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
        }
        if (match[4]) {
            if (tzRegex.exec(match[4])) {
                tzFormat = 'Z';
            } else {
                config._isValid = false;
                return;
            }
        }
        config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
        configFromStringAndFormat(config);
    } else {
        config._isValid = false;
    }
}

// date from iso format or fallback
function configFromString(config) {
    var matched = aspNetJsonRegex.exec(config._i);

    if (matched !== null) {
        config._d = new Date(+matched[1]);
        return;
    }

    configFromISO(config);
    if (config._isValid === false) {
        delete config._isValid;
        hooks.createFromInputFallback(config);
    }
}

hooks.createFromInputFallback = deprecate(
    'value provided is not in a recognized ISO format. moment construction falls back to js Date(), ' +
    'which is not reliable across all browsers and versions. Non ISO date formats are ' +
    'discouraged and will be removed in an upcoming major release. Please refer to ' +
    'http://momentjs.com/guides/#/warnings/js-date/ for more info.',
    function (config) {
        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
    }
);

// Pick the first defined of two or three arguments.
function defaults(a, b, c) {
    if (a != null) {
        return a;
    }
    if (b != null) {
        return b;
    }
    return c;
}

function currentDateArray(config) {
    // hooks is actually the exported moment object
    var nowValue = new Date(hooks.now());
    if (config._useUTC) {
        return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
    }
    return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}

// convert an array to a date.
// the array should mirror the parameters below
// note: all values past the year are optional and will default to the lowest possible value.
// [year, month, day , hour, minute, second, millisecond]
function configFromArray (config) {
    var i, date, input = [], currentDate, yearToUse;

    if (config._d) {
        return;
    }

    currentDate = currentDateArray(config);

    //compute day of the year from weeks and weekdays
    if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
        dayOfYearFromWeekInfo(config);
    }

    //if the day of the year is set, figure out what it is
    if (config._dayOfYear) {
        yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

        if (config._dayOfYear > daysInYear(yearToUse)) {
            getParsingFlags(config)._overflowDayOfYear = true;
        }

        date = createUTCDate(yearToUse, 0, config._dayOfYear);
        config._a[MONTH] = date.getUTCMonth();
        config._a[DATE] = date.getUTCDate();
    }

    // Default to current date.
    // * if no year, month, day of month are given, default to today
    // * if day of month is given, default month and year
    // * if month is given, default only year
    // * if year is given, don't default anything
    for (i = 0; i < 3 && config._a[i] == null; ++i) {
        config._a[i] = input[i] = currentDate[i];
    }

    // Zero out whatever was not defaulted, including time
    for (; i < 7; i++) {
        config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
    }

    // Check for 24:00:00.000
    if (config._a[HOUR] === 24 &&
            config._a[MINUTE] === 0 &&
            config._a[SECOND] === 0 &&
            config._a[MILLISECOND] === 0) {
        config._nextDay = true;
        config._a[HOUR] = 0;
    }

    config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
    // Apply timezone offset from input. The actual utcOffset can be changed
    // with parseZone.
    if (config._tzm != null) {
        config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
    }

    if (config._nextDay) {
        config._a[HOUR] = 24;
    }
}

function dayOfYearFromWeekInfo(config) {
    var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

    w = config._w;
    if (w.GG != null || w.W != null || w.E != null) {
        dow = 1;
        doy = 4;

        // TODO: We need to take the current isoWeekYear, but that depends on
        // how we interpret now (local, utc, fixed offset). So create
        // a now version of current config (take local/utc/offset flags, and
        // create now).
        weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
        week = defaults(w.W, 1);
        weekday = defaults(w.E, 1);
        if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
        }
    } else {
        dow = config._locale._week.dow;
        doy = config._locale._week.doy;

        var curWeek = weekOfYear(createLocal(), dow, doy);

        weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

        // Default to current week.
        week = defaults(w.w, curWeek.week);

        if (w.d != null) {
            // weekday -- low day numbers are considered next week
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
                weekdayOverflow = true;
            }
        } else if (w.e != null) {
            // local weekday -- counting starts from begining of week
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
                weekdayOverflow = true;
            }
        } else {
            // default to begining of week
            weekday = dow;
        }
    }
    if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
        getParsingFlags(config)._overflowWeeks = true;
    } else if (weekdayOverflow != null) {
        getParsingFlags(config)._overflowWeekday = true;
    } else {
        temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
        config._a[YEAR] = temp.year;
        config._dayOfYear = temp.dayOfYear;
    }
}

// constant that refers to the ISO standard
hooks.ISO_8601 = function () {};

// date from string and format string
function configFromStringAndFormat(config) {
    // TODO: Move this to another part of the creation flow to prevent circular deps
    if (config._f === hooks.ISO_8601) {
        configFromISO(config);
        return;
    }

    config._a = [];
    getParsingFlags(config).empty = true;

    // This array is used to make a Date, either with `new Date` or `Date.UTC`
    var string = '' + config._i,
        i, parsedInput, tokens, token, skipped,
        stringLength = string.length,
        totalParsedInputLength = 0;

    tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

    for (i = 0; i < tokens.length; i++) {
        token = tokens[i];
        parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
        // console.log('token', token, 'parsedInput', parsedInput,
        //         'regex', getParseRegexForToken(token, config));
        if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
                getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength += parsedInput.length;
        }
        // don't parse if it's not a known token
        if (formatTokenFunctions[token]) {
            if (parsedInput) {
                getParsingFlags(config).empty = false;
            }
            else {
                getParsingFlags(config).unusedTokens.push(token);
            }
            addTimeToArrayFromToken(token, parsedInput, config);
        }
        else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token);
        }
    }

    // add remaining unparsed input length to the string
    getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
    if (string.length > 0) {
        getParsingFlags(config).unusedInput.push(string);
    }

    // clear _12h flag if hour is <= 12
    if (config._a[HOUR] <= 12 &&
        getParsingFlags(config).bigHour === true &&
        config._a[HOUR] > 0) {
        getParsingFlags(config).bigHour = undefined;
    }

    getParsingFlags(config).parsedDateParts = config._a.slice(0);
    getParsingFlags(config).meridiem = config._meridiem;
    // handle meridiem
    config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

    configFromArray(config);
    checkOverflow(config);
}


function meridiemFixWrap (locale, hour, meridiem) {
    var isPm;

    if (meridiem == null) {
        // nothing to do
        return hour;
    }
    if (locale.meridiemHour != null) {
        return locale.meridiemHour(hour, meridiem);
    } else if (locale.isPM != null) {
        // Fallback
        isPm = locale.isPM(meridiem);
        if (isPm && hour < 12) {
            hour += 12;
        }
        if (!isPm && hour === 12) {
            hour = 0;
        }
        return hour;
    } else {
        // this is not supposed to happen
        return hour;
    }
}

// date from string and array of format strings
function configFromStringAndArray(config) {
    var tempConfig,
        bestMoment,

        scoreToBeat,
        i,
        currentScore;

    if (config._f.length === 0) {
        getParsingFlags(config).invalidFormat = true;
        config._d = new Date(NaN);
        return;
    }

    for (i = 0; i < config._f.length; i++) {
        currentScore = 0;
        tempConfig = copyConfig({}, config);
        if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
        }
        tempConfig._f = config._f[i];
        configFromStringAndFormat(tempConfig);

        if (!isValid(tempConfig)) {
            continue;
        }

        // if there is any input that was not parsed add a penalty for that format
        currentScore += getParsingFlags(tempConfig).charsLeftOver;

        //or tokens
        currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

        getParsingFlags(tempConfig).score = currentScore;

        if (scoreToBeat == null || currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
        }
    }

    extend(config, bestMoment || tempConfig);
}

function configFromObject(config) {
    if (config._d) {
        return;
    }

    var i = normalizeObjectUnits(config._i);
    config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function (obj) {
        return obj && parseInt(obj, 10);
    });

    configFromArray(config);
}

function createFromConfig (config) {
    var res = new Moment(checkOverflow(prepareConfig(config)));
    if (res._nextDay) {
        // Adding is smart enough around DST
        res.add(1, 'd');
        res._nextDay = undefined;
    }

    return res;
}

function prepareConfig (config) {
    var input = config._i,
        format = config._f;

    config._locale = config._locale || getLocale(config._l);

    if (input === null || (format === undefined && input === '')) {
        return createInvalid({nullInput: true});
    }

    if (typeof input === 'string') {
        config._i = input = config._locale.preparse(input);
    }

    if (isMoment(input)) {
        return new Moment(checkOverflow(input));
    } else if (isDate(input)) {
        config._d = input;
    } else if (isArray(format)) {
        configFromStringAndArray(config);
    } else if (format) {
        configFromStringAndFormat(config);
    }  else {
        configFromInput(config);
    }

    if (!isValid(config)) {
        config._d = null;
    }

    return config;
}

function configFromInput(config) {
    var input = config._i;
    if (input === undefined) {
        config._d = new Date(hooks.now());
    } else if (isDate(input)) {
        config._d = new Date(input.valueOf());
    } else if (typeof input === 'string') {
        configFromString(config);
    } else if (isArray(input)) {
        config._a = map(input.slice(0), function (obj) {
            return parseInt(obj, 10);
        });
        configFromArray(config);
    } else if (typeof(input) === 'object') {
        configFromObject(config);
    } else if (isNumber(input)) {
        // from milliseconds
        config._d = new Date(input);
    } else {
        hooks.createFromInputFallback(config);
    }
}

function createLocalOrUTC (input, format, locale, strict, isUTC) {
    var c = {};

    if (locale === true || locale === false) {
        strict = locale;
        locale = undefined;
    }

    if ((isObject(input) && isObjectEmpty(input)) ||
            (isArray(input) && input.length === 0)) {
        input = undefined;
    }
    // object construction must be done this way.
    // https://github.com/moment/moment/issues/1423
    c._isAMomentObject = true;
    c._useUTC = c._isUTC = isUTC;
    c._l = locale;
    c._i = input;
    c._f = format;
    c._strict = strict;

    return createFromConfig(c);
}

function createLocal (input, format, locale, strict) {
    return createLocalOrUTC(input, format, locale, strict, false);
}

var prototypeMin = deprecate(
    'moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

var prototypeMax = deprecate(
    'moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/',
    function () {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
        } else {
            return createInvalid();
        }
    }
);

// Pick a moment m from moments so that m[fn](other) is true for all
// other. This relies on the function fn to be transitive.
//
// moments should either be an array of moment objects or an array, whose
// first element is an array of moment objects.
function pickBy(fn, moments) {
    var res, i;
    if (moments.length === 1 && isArray(moments[0])) {
        moments = moments[0];
    }
    if (!moments.length) {
        return createLocal();
    }
    res = moments[0];
    for (i = 1; i < moments.length; ++i) {
        if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
        }
    }
    return res;
}

// TODO: Use [].sort instead?
function min () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isBefore', args);
}

function max () {
    var args = [].slice.call(arguments, 0);

    return pickBy('isAfter', args);
}

var now = function () {
    return Date.now ? Date.now() : +(new Date());
};

function Duration (duration) {
    var normalizedInput = normalizeObjectUnits(duration),
        years = normalizedInput.year || 0,
        quarters = normalizedInput.quarter || 0,
        months = normalizedInput.month || 0,
        weeks = normalizedInput.week || 0,
        days = normalizedInput.day || 0,
        hours = normalizedInput.hour || 0,
        minutes = normalizedInput.minute || 0,
        seconds = normalizedInput.second || 0,
        milliseconds = normalizedInput.millisecond || 0;

    // representation for dateAddRemove
    this._milliseconds = +milliseconds +
        seconds * 1e3 + // 1000
        minutes * 6e4 + // 1000 * 60
        hours * 1000 * 60 * 60; //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
    // Because of dateAddRemove treats 24 hours as different from a
    // day when working around DST, we need to store them separately
    this._days = +days +
        weeks * 7;
    // It is impossible translate months into days without knowing
    // which months you are are talking about, so we have to store
    // it separately.
    this._months = +months +
        quarters * 3 +
        years * 12;

    this._data = {};

    this._locale = getLocale();

    this._bubble();
}

function isDuration (obj) {
    return obj instanceof Duration;
}

function absRound (number) {
    if (number < 0) {
        return Math.round(-1 * number) * -1;
    } else {
        return Math.round(number);
    }
}

// FORMATTING

function offset (token, separator) {
    addFormatToken(token, 0, 0, function () {
        var offset = this.utcOffset();
        var sign = '+';
        if (offset < 0) {
            offset = -offset;
            sign = '-';
        }
        return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
    });
}

offset('Z', ':');
offset('ZZ', '');

// PARSING

addRegexToken('Z',  matchShortOffset);
addRegexToken('ZZ', matchShortOffset);
addParseToken(['Z', 'ZZ'], function (input, array, config) {
    config._useUTC = true;
    config._tzm = offsetFromString(matchShortOffset, input);
});

// HELPERS

// timezone chunker
// '+10:00' > ['10',  '00']
// '-1530'  > ['-15', '30']
var chunkOffset = /([\+\-]|\d\d)/gi;

function offsetFromString(matcher, string) {
    var matches = (string || '').match(matcher);

    if (matches === null) {
        return null;
    }

    var chunk   = matches[matches.length - 1] || [];
    var parts   = (chunk + '').match(chunkOffset) || ['-', 0, 0];
    var minutes = +(parts[1] * 60) + toInt(parts[2]);

    return minutes === 0 ?
      0 :
      parts[0] === '+' ? minutes : -minutes;
}

// Return a moment from input, that is local/utc/zone equivalent to model.
function cloneWithOffset(input, model) {
    var res, diff;
    if (model._isUTC) {
        res = model.clone();
        diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
        // Use low-level api, because this fn is low-level api.
        res._d.setTime(res._d.valueOf() + diff);
        hooks.updateOffset(res, false);
        return res;
    } else {
        return createLocal(input).local();
    }
}

function getDateOffset (m) {
    // On Firefox.24 Date#getTimezoneOffset returns a floating point.
    // https://github.com/moment/moment/pull/1871
    return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
}

// HOOKS

// This function will be called whenever a moment is mutated.
// It is intended to keep the offset in sync with the timezone.
hooks.updateOffset = function () {};

// MOMENTS

// keepLocalTime = true means only change the timezone, without
// affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
// 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
// +0200, so we adjust the time as needed, to be valid.
//
// Keeping the time actually adds/subtracts (one hour)
// from the actual represented time. That is why we call updateOffset
// a second time. In case it wants us to change the offset again
// _changeInProgress == true case, then we have to adjust, because
// there is no such time in the given timezone.
function getSetOffset (input, keepLocalTime) {
    var offset = this._offset || 0,
        localAdjust;
    if (!this.isValid()) {
        return input != null ? this : NaN;
    }
    if (input != null) {
        if (typeof input === 'string') {
            input = offsetFromString(matchShortOffset, input);
            if (input === null) {
                return this;
            }
        } else if (Math.abs(input) < 16) {
            input = input * 60;
        }
        if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
        }
        this._offset = input;
        this._isUTC = true;
        if (localAdjust != null) {
            this.add(localAdjust, 'm');
        }
        if (offset !== input) {
            if (!keepLocalTime || this._changeInProgress) {
                addSubtract(this, createDuration(input - offset, 'm'), 1, false);
            } else if (!this._changeInProgress) {
                this._changeInProgress = true;
                hooks.updateOffset(this, true);
                this._changeInProgress = null;
            }
        }
        return this;
    } else {
        return this._isUTC ? offset : getDateOffset(this);
    }
}

function getSetZone (input, keepLocalTime) {
    if (input != null) {
        if (typeof input !== 'string') {
            input = -input;
        }

        this.utcOffset(input, keepLocalTime);

        return this;
    } else {
        return -this.utcOffset();
    }
}

function setOffsetToUTC (keepLocalTime) {
    return this.utcOffset(0, keepLocalTime);
}

function setOffsetToLocal (keepLocalTime) {
    if (this._isUTC) {
        this.utcOffset(0, keepLocalTime);
        this._isUTC = false;

        if (keepLocalTime) {
            this.subtract(getDateOffset(this), 'm');
        }
    }
    return this;
}

function setOffsetToParsedOffset () {
    if (this._tzm != null) {
        this.utcOffset(this._tzm);
    } else if (typeof this._i === 'string') {
        var tZone = offsetFromString(matchOffset, this._i);
        if (tZone != null) {
            this.utcOffset(tZone);
        }
        else {
            this.utcOffset(0, true);
        }
    }
    return this;
}

function hasAlignedHourOffset (input) {
    if (!this.isValid()) {
        return false;
    }
    input = input ? createLocal(input).utcOffset() : 0;

    return (this.utcOffset() - input) % 60 === 0;
}

function isDaylightSavingTime () {
    return (
        this.utcOffset() > this.clone().month(0).utcOffset() ||
        this.utcOffset() > this.clone().month(5).utcOffset()
    );
}

function isDaylightSavingTimeShifted () {
    if (!isUndefined(this._isDSTShifted)) {
        return this._isDSTShifted;
    }

    var c = {};

    copyConfig(c, this);
    c = prepareConfig(c);

    if (c._a) {
        var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
        this._isDSTShifted = this.isValid() &&
            compareArrays(c._a, other.toArray()) > 0;
    } else {
        this._isDSTShifted = false;
    }

    return this._isDSTShifted;
}

function isLocal () {
    return this.isValid() ? !this._isUTC : false;
}

function isUtcOffset () {
    return this.isValid() ? this._isUTC : false;
}

function isUtc () {
    return this.isValid() ? this._isUTC && this._offset === 0 : false;
}

// ASP.NET json date format regex
var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

// from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
// somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
// and further modified to allow for strings containing both week and day
var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;

function createDuration (input, key) {
    var duration = input,
        // matching against regexp is expensive, do it on demand
        match = null,
        sign,
        ret,
        diffRes;

    if (isDuration(input)) {
        duration = {
            ms : input._milliseconds,
            d  : input._days,
            M  : input._months
        };
    } else if (isNumber(input)) {
        duration = {};
        if (key) {
            duration[key] = input;
        } else {
            duration.milliseconds = input;
        }
    } else if (!!(match = aspNetRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
            y  : 0,
            d  : toInt(match[DATE])                         * sign,
            h  : toInt(match[HOUR])                         * sign,
            m  : toInt(match[MINUTE])                       * sign,
            s  : toInt(match[SECOND])                       * sign,
            ms : toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
        };
    } else if (!!(match = isoRegex.exec(input))) {
        sign = (match[1] === '-') ? -1 : 1;
        duration = {
            y : parseIso(match[2], sign),
            M : parseIso(match[3], sign),
            w : parseIso(match[4], sign),
            d : parseIso(match[5], sign),
            h : parseIso(match[6], sign),
            m : parseIso(match[7], sign),
            s : parseIso(match[8], sign)
        };
    } else if (duration == null) {// checks for null or undefined
        duration = {};
    } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
        diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

        duration = {};
        duration.ms = diffRes.milliseconds;
        duration.M = diffRes.months;
    }

    ret = new Duration(duration);

    if (isDuration(input) && hasOwnProp(input, '_locale')) {
        ret._locale = input._locale;
    }

    return ret;
}

createDuration.fn = Duration.prototype;

function parseIso (inp, sign) {
    // We'd normally use ~~inp for this, but unfortunately it also
    // converts floats to ints.
    // inp may be undefined, so careful calling replace on it.
    var res = inp && parseFloat(inp.replace(',', '.'));
    // apply sign while we're at it
    return (isNaN(res) ? 0 : res) * sign;
}

function positiveMomentsDifference(base, other) {
    var res = {milliseconds: 0, months: 0};

    res.months = other.month() - base.month() +
        (other.year() - base.year()) * 12;
    if (base.clone().add(res.months, 'M').isAfter(other)) {
        --res.months;
    }

    res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

    return res;
}

function momentsDifference(base, other) {
    var res;
    if (!(base.isValid() && other.isValid())) {
        return {milliseconds: 0, months: 0};
    }

    other = cloneWithOffset(other, base);
    if (base.isBefore(other)) {
        res = positiveMomentsDifference(base, other);
    } else {
        res = positiveMomentsDifference(other, base);
        res.milliseconds = -res.milliseconds;
        res.months = -res.months;
    }

    return res;
}

// TODO: remove 'name' arg after deprecation is removed
function createAdder(direction, name) {
    return function (val, period) {
        var dur, tmp;
        //invert the arguments, but complain about it
        if (period !== null && !isNaN(+period)) {
            deprecateSimple(name, 'moment().' + name  + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' +
            'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
            tmp = val; val = period; period = tmp;
        }

        val = typeof val === 'string' ? +val : val;
        dur = createDuration(val, period);
        addSubtract(this, dur, direction);
        return this;
    };
}

function addSubtract (mom, duration, isAdding, updateOffset) {
    var milliseconds = duration._milliseconds,
        days = absRound(duration._days),
        months = absRound(duration._months);

    if (!mom.isValid()) {
        // No op
        return;
    }

    updateOffset = updateOffset == null ? true : updateOffset;

    if (milliseconds) {
        mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
    }
    if (days) {
        set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
    }
    if (months) {
        setMonth(mom, get(mom, 'Month') + months * isAdding);
    }
    if (updateOffset) {
        hooks.updateOffset(mom, days || months);
    }
}

var add      = createAdder(1, 'add');
var subtract = createAdder(-1, 'subtract');

function getCalendarFormat(myMoment, now) {
    var diff = myMoment.diff(now, 'days', true);
    return diff < -6 ? 'sameElse' :
            diff < -1 ? 'lastWeek' :
            diff < 0 ? 'lastDay' :
            diff < 1 ? 'sameDay' :
            diff < 2 ? 'nextDay' :
            diff < 7 ? 'nextWeek' : 'sameElse';
}

function calendar$1 (time, formats) {
    // We want to compare the start of today, vs this.
    // Getting start-of-today depends on whether we're local/utc/offset or not.
    var now = time || createLocal(),
        sod = cloneWithOffset(now, this).startOf('day'),
        format = hooks.calendarFormat(this, sod) || 'sameElse';

    var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

    return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
}

function clone () {
    return new Moment(this);
}

function isAfter (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() > localInput.valueOf();
    } else {
        return localInput.valueOf() < this.clone().startOf(units).valueOf();
    }
}

function isBefore (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input);
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() < localInput.valueOf();
    } else {
        return this.clone().endOf(units).valueOf() < localInput.valueOf();
    }
}

function isBetween (from, to, units, inclusivity) {
    inclusivity = inclusivity || '()';
    return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) &&
        (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
}

function isSame (input, units) {
    var localInput = isMoment(input) ? input : createLocal(input),
        inputMs;
    if (!(this.isValid() && localInput.isValid())) {
        return false;
    }
    units = normalizeUnits(units || 'millisecond');
    if (units === 'millisecond') {
        return this.valueOf() === localInput.valueOf();
    } else {
        inputMs = localInput.valueOf();
        return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
    }
}

function isSameOrAfter (input, units) {
    return this.isSame(input, units) || this.isAfter(input,units);
}

function isSameOrBefore (input, units) {
    return this.isSame(input, units) || this.isBefore(input,units);
}

function diff (input, units, asFloat) {
    var that,
        zoneDelta,
        delta, output;

    if (!this.isValid()) {
        return NaN;
    }

    that = cloneWithOffset(input, this);

    if (!that.isValid()) {
        return NaN;
    }

    zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

    units = normalizeUnits(units);

    if (units === 'year' || units === 'month' || units === 'quarter') {
        output = monthDiff(this, that);
        if (units === 'quarter') {
            output = output / 3;
        } else if (units === 'year') {
            output = output / 12;
        }
    } else {
        delta = this - that;
        output = units === 'second' ? delta / 1e3 : // 1000
            units === 'minute' ? delta / 6e4 : // 1000 * 60
            units === 'hour' ? delta / 36e5 : // 1000 * 60 * 60
            units === 'day' ? (delta - zoneDelta) / 864e5 : // 1000 * 60 * 60 * 24, negate dst
            units === 'week' ? (delta - zoneDelta) / 6048e5 : // 1000 * 60 * 60 * 24 * 7, negate dst
            delta;
    }
    return asFloat ? output : absFloor(output);
}

function monthDiff (a, b) {
    // difference in months
    var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
        // b is in (anchor - 1 month, anchor + 1 month)
        anchor = a.clone().add(wholeMonthDiff, 'months'),
        anchor2, adjust;

    if (b - anchor < 0) {
        anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor - anchor2);
    } else {
        anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
        // linear across the month
        adjust = (b - anchor) / (anchor2 - anchor);
    }

    //check for negative zero, return zero if negative zero
    return -(wholeMonthDiff + adjust) || 0;
}

hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

function toString () {
    return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
}

function toISOString () {
    var m = this.clone().utc();
    if (0 < m.year() && m.year() <= 9999) {
        if (isFunction(Date.prototype.toISOString)) {
            // native implementation is ~50x faster, use it when we can
            return this.toDate().toISOString();
        } else {
            return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
        }
    } else {
        return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
    }
}

/**
 * Return a human readable representation of a moment that can
 * also be evaluated to get a new moment which is the same
 *
 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
 */
function inspect () {
    if (!this.isValid()) {
        return 'moment.invalid(/* ' + this._i + ' */)';
    }
    var func = 'moment';
    var zone = '';
    if (!this.isLocal()) {
        func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
        zone = 'Z';
    }
    var prefix = '[' + func + '("]';
    var year = (0 < this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
    var datetime = '-MM-DD[T]HH:mm:ss.SSS';
    var suffix = zone + '[")]';

    return this.format(prefix + year + datetime + suffix);
}

function format (inputString) {
    if (!inputString) {
        inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
    }
    var output = formatMoment(this, inputString);
    return this.localeData().postformat(output);
}

function from (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function fromNow (withoutSuffix) {
    return this.from(createLocal(), withoutSuffix);
}

function to (time, withoutSuffix) {
    if (this.isValid() &&
            ((isMoment(time) && time.isValid()) ||
             createLocal(time).isValid())) {
        return createDuration({from: this, to: time}).locale(this.locale()).humanize(!withoutSuffix);
    } else {
        return this.localeData().invalidDate();
    }
}

function toNow (withoutSuffix) {
    return this.to(createLocal(), withoutSuffix);
}

// If passed a locale key, it will set the locale for this
// instance.  Otherwise, it will return the locale configuration
// variables for this instance.
function locale (key) {
    var newLocaleData;

    if (key === undefined) {
        return this._locale._abbr;
    } else {
        newLocaleData = getLocale(key);
        if (newLocaleData != null) {
            this._locale = newLocaleData;
        }
        return this;
    }
}

var lang = deprecate(
    'moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.',
    function (key) {
        if (key === undefined) {
            return this.localeData();
        } else {
            return this.locale(key);
        }
    }
);

function localeData () {
    return this._locale;
}

function startOf (units) {
    units = normalizeUnits(units);
    // the following switch intentionally omits break keywords
    // to utilize falling through the cases.
    switch (units) {
        case 'year':
            this.month(0);
            /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
            /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
        case 'date':
            this.hours(0);
            /* falls through */
        case 'hour':
            this.minutes(0);
            /* falls through */
        case 'minute':
            this.seconds(0);
            /* falls through */
        case 'second':
            this.milliseconds(0);
    }

    // weeks are a special case
    if (units === 'week') {
        this.weekday(0);
    }
    if (units === 'isoWeek') {
        this.isoWeekday(1);
    }

    // quarters are also special
    if (units === 'quarter') {
        this.month(Math.floor(this.month() / 3) * 3);
    }

    return this;
}

function endOf (units) {
    units = normalizeUnits(units);
    if (units === undefined || units === 'millisecond') {
        return this;
    }

    // 'date' is an alias for 'day', so it should be considered as such.
    if (units === 'date') {
        units = 'day';
    }

    return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
}

function valueOf () {
    return this._d.valueOf() - ((this._offset || 0) * 60000);
}

function unix () {
    return Math.floor(this.valueOf() / 1000);
}

function toDate () {
    return new Date(this.valueOf());
}

function toArray () {
    var m = this;
    return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
}

function toObject () {
    var m = this;
    return {
        years: m.year(),
        months: m.month(),
        date: m.date(),
        hours: m.hours(),
        minutes: m.minutes(),
        seconds: m.seconds(),
        milliseconds: m.milliseconds()
    };
}

function toJSON () {
    // new Date(NaN).toJSON() === null
    return this.isValid() ? this.toISOString() : null;
}

function isValid$1 () {
    return isValid(this);
}

function parsingFlags () {
    return extend({}, getParsingFlags(this));
}

function invalidAt () {
    return getParsingFlags(this).overflow;
}

function creationData() {
    return {
        input: this._i,
        format: this._f,
        locale: this._locale,
        isUTC: this._isUTC,
        strict: this._strict
    };
}

// FORMATTING

addFormatToken(0, ['gg', 2], 0, function () {
    return this.weekYear() % 100;
});

addFormatToken(0, ['GG', 2], 0, function () {
    return this.isoWeekYear() % 100;
});

function addWeekYearFormatToken (token, getter) {
    addFormatToken(0, [token, token.length], 0, getter);
}

addWeekYearFormatToken('gggg',     'weekYear');
addWeekYearFormatToken('ggggg',    'weekYear');
addWeekYearFormatToken('GGGG',  'isoWeekYear');
addWeekYearFormatToken('GGGGG', 'isoWeekYear');

// ALIASES

addUnitAlias('weekYear', 'gg');
addUnitAlias('isoWeekYear', 'GG');

// PRIORITY

addUnitPriority('weekYear', 1);
addUnitPriority('isoWeekYear', 1);


// PARSING

addRegexToken('G',      matchSigned);
addRegexToken('g',      matchSigned);
addRegexToken('GG',     match1to2, match2);
addRegexToken('gg',     match1to2, match2);
addRegexToken('GGGG',   match1to4, match4);
addRegexToken('gggg',   match1to4, match4);
addRegexToken('GGGGG',  match1to6, match6);
addRegexToken('ggggg',  match1to6, match6);

addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function (input, week, config, token) {
    week[token.substr(0, 2)] = toInt(input);
});

addWeekParseToken(['gg', 'GG'], function (input, week, config, token) {
    week[token] = hooks.parseTwoDigitYear(input);
});

// MOMENTS

function getSetWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input,
            this.week(),
            this.weekday(),
            this.localeData()._week.dow,
            this.localeData()._week.doy);
}

function getSetISOWeekYear (input) {
    return getSetWeekYearHelper.call(this,
            input, this.isoWeek(), this.isoWeekday(), 1, 4);
}

function getISOWeeksInYear () {
    return weeksInYear(this.year(), 1, 4);
}

function getWeeksInYear () {
    var weekInfo = this.localeData()._week;
    return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}

function getSetWeekYearHelper(input, week, weekday, dow, doy) {
    var weeksTarget;
    if (input == null) {
        return weekOfYear(this, dow, doy).year;
    } else {
        weeksTarget = weeksInYear(input, dow, doy);
        if (week > weeksTarget) {
            week = weeksTarget;
        }
        return setWeekAll.call(this, input, week, weekday, dow, doy);
    }
}

function setWeekAll(weekYear, week, weekday, dow, doy) {
    var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
        date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

    this.year(date.getUTCFullYear());
    this.month(date.getUTCMonth());
    this.date(date.getUTCDate());
    return this;
}

// FORMATTING

addFormatToken('Q', 0, 'Qo', 'quarter');

// ALIASES

addUnitAlias('quarter', 'Q');

// PRIORITY

addUnitPriority('quarter', 7);

// PARSING

addRegexToken('Q', match1);
addParseToken('Q', function (input, array) {
    array[MONTH] = (toInt(input) - 1) * 3;
});

// MOMENTS

function getSetQuarter (input) {
    return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}

// FORMATTING

addFormatToken('D', ['DD', 2], 'Do', 'date');

// ALIASES

addUnitAlias('date', 'D');

// PRIOROITY
addUnitPriority('date', 9);

// PARSING

addRegexToken('D',  match1to2);
addRegexToken('DD', match1to2, match2);
addRegexToken('Do', function (isStrict, locale) {
    return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
});

addParseToken(['D', 'DD'], DATE);
addParseToken('Do', function (input, array) {
    array[DATE] = toInt(input.match(match1to2)[0], 10);
});

// MOMENTS

var getSetDayOfMonth = makeGetSet('Date', true);

// FORMATTING

addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

// ALIASES

addUnitAlias('dayOfYear', 'DDD');

// PRIORITY
addUnitPriority('dayOfYear', 4);

// PARSING

addRegexToken('DDD',  match1to3);
addRegexToken('DDDD', match3);
addParseToken(['DDD', 'DDDD'], function (input, array, config) {
    config._dayOfYear = toInt(input);
});

// HELPERS

// MOMENTS

function getSetDayOfYear (input) {
    var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
    return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
}

// FORMATTING

addFormatToken('m', ['mm', 2], 0, 'minute');

// ALIASES

addUnitAlias('minute', 'm');

// PRIORITY

addUnitPriority('minute', 14);

// PARSING

addRegexToken('m',  match1to2);
addRegexToken('mm', match1to2, match2);
addParseToken(['m', 'mm'], MINUTE);

// MOMENTS

var getSetMinute = makeGetSet('Minutes', false);

// FORMATTING

addFormatToken('s', ['ss', 2], 0, 'second');

// ALIASES

addUnitAlias('second', 's');

// PRIORITY

addUnitPriority('second', 15);

// PARSING

addRegexToken('s',  match1to2);
addRegexToken('ss', match1to2, match2);
addParseToken(['s', 'ss'], SECOND);

// MOMENTS

var getSetSecond = makeGetSet('Seconds', false);

// FORMATTING

addFormatToken('S', 0, 0, function () {
    return ~~(this.millisecond() / 100);
});

addFormatToken(0, ['SS', 2], 0, function () {
    return ~~(this.millisecond() / 10);
});

addFormatToken(0, ['SSS', 3], 0, 'millisecond');
addFormatToken(0, ['SSSS', 4], 0, function () {
    return this.millisecond() * 10;
});
addFormatToken(0, ['SSSSS', 5], 0, function () {
    return this.millisecond() * 100;
});
addFormatToken(0, ['SSSSSS', 6], 0, function () {
    return this.millisecond() * 1000;
});
addFormatToken(0, ['SSSSSSS', 7], 0, function () {
    return this.millisecond() * 10000;
});
addFormatToken(0, ['SSSSSSSS', 8], 0, function () {
    return this.millisecond() * 100000;
});
addFormatToken(0, ['SSSSSSSSS', 9], 0, function () {
    return this.millisecond() * 1000000;
});


// ALIASES

addUnitAlias('millisecond', 'ms');

// PRIORITY

addUnitPriority('millisecond', 16);

// PARSING

addRegexToken('S',    match1to3, match1);
addRegexToken('SS',   match1to3, match2);
addRegexToken('SSS',  match1to3, match3);

var token;
for (token = 'SSSS'; token.length <= 9; token += 'S') {
    addRegexToken(token, matchUnsigned);
}

function parseMs(input, array) {
    array[MILLISECOND] = toInt(('0.' + input) * 1000);
}

for (token = 'S'; token.length <= 9; token += 'S') {
    addParseToken(token, parseMs);
}
// MOMENTS

var getSetMillisecond = makeGetSet('Milliseconds', false);

// FORMATTING

addFormatToken('z',  0, 0, 'zoneAbbr');
addFormatToken('zz', 0, 0, 'zoneName');

// MOMENTS

function getZoneAbbr () {
    return this._isUTC ? 'UTC' : '';
}

function getZoneName () {
    return this._isUTC ? 'Coordinated Universal Time' : '';
}

var proto = Moment.prototype;

proto.add               = add;
proto.calendar          = calendar$1;
proto.clone             = clone;
proto.diff              = diff;
proto.endOf             = endOf;
proto.format            = format;
proto.from              = from;
proto.fromNow           = fromNow;
proto.to                = to;
proto.toNow             = toNow;
proto.get               = stringGet;
proto.invalidAt         = invalidAt;
proto.isAfter           = isAfter;
proto.isBefore          = isBefore;
proto.isBetween         = isBetween;
proto.isSame            = isSame;
proto.isSameOrAfter     = isSameOrAfter;
proto.isSameOrBefore    = isSameOrBefore;
proto.isValid           = isValid$1;
proto.lang              = lang;
proto.locale            = locale;
proto.localeData        = localeData;
proto.max               = prototypeMax;
proto.min               = prototypeMin;
proto.parsingFlags      = parsingFlags;
proto.set               = stringSet;
proto.startOf           = startOf;
proto.subtract          = subtract;
proto.toArray           = toArray;
proto.toObject          = toObject;
proto.toDate            = toDate;
proto.toISOString       = toISOString;
proto.inspect           = inspect;
proto.toJSON            = toJSON;
proto.toString          = toString;
proto.unix              = unix;
proto.valueOf           = valueOf;
proto.creationData      = creationData;

// Year
proto.year       = getSetYear;
proto.isLeapYear = getIsLeapYear;

// Week Year
proto.weekYear    = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;

// Quarter
proto.quarter = proto.quarters = getSetQuarter;

// Month
proto.month       = getSetMonth;
proto.daysInMonth = getDaysInMonth;

// Week
proto.week           = proto.weeks        = getSetWeek;
proto.isoWeek        = proto.isoWeeks     = getSetISOWeek;
proto.weeksInYear    = getWeeksInYear;
proto.isoWeeksInYear = getISOWeeksInYear;

// Day
proto.date       = getSetDayOfMonth;
proto.day        = proto.days             = getSetDayOfWeek;
proto.weekday    = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear  = getSetDayOfYear;

// Hour
proto.hour = proto.hours = getSetHour;

// Minute
proto.minute = proto.minutes = getSetMinute;

// Second
proto.second = proto.seconds = getSetSecond;

// Millisecond
proto.millisecond = proto.milliseconds = getSetMillisecond;

// Offset
proto.utcOffset            = getSetOffset;
proto.utc                  = setOffsetToUTC;
proto.local                = setOffsetToLocal;
proto.parseZone            = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST                = isDaylightSavingTime;
proto.isLocal              = isLocal;
proto.isUtcOffset          = isUtcOffset;
proto.isUtc                = isUtc;
proto.isUTC                = isUtc;

// Timezone
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;

// Deprecations
proto.dates  = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
proto.years  = deprecate('years accessor is deprecated. Use year instead', getSetYear);
proto.zone   = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

function createUnix (input) {
    return createLocal(input * 1000);
}

function createInZone () {
    return createLocal.apply(null, arguments).parseZone();
}

function preParsePostFormat (string) {
    return string;
}

var proto$1 = Locale.prototype;

proto$1.calendar        = calendar;
proto$1.longDateFormat  = longDateFormat;
proto$1.invalidDate     = invalidDate;
proto$1.ordinal         = ordinal;
proto$1.preparse        = preParsePostFormat;
proto$1.postformat      = preParsePostFormat;
proto$1.relativeTime    = relativeTime;
proto$1.pastFuture      = pastFuture;
proto$1.set             = set;

// Month
proto$1.months            =        localeMonths;
proto$1.monthsShort       =        localeMonthsShort;
proto$1.monthsParse       =        localeMonthsParse;
proto$1.monthsRegex       = monthsRegex;
proto$1.monthsShortRegex  = monthsShortRegex;

// Week
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;

// Day of Week
proto$1.weekdays       =        localeWeekdays;
proto$1.weekdaysMin    =        localeWeekdaysMin;
proto$1.weekdaysShort  =        localeWeekdaysShort;
proto$1.weekdaysParse  =        localeWeekdaysParse;

proto$1.weekdaysRegex       =        weekdaysRegex;
proto$1.weekdaysShortRegex  =        weekdaysShortRegex;
proto$1.weekdaysMinRegex    =        weekdaysMinRegex;

// Hours
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;

function get$1 (format, index, field, setter) {
    var locale = getLocale();
    var utc = createUTC().set(setter, index);
    return locale[field](utc, format);
}

function listMonthsImpl (format, index, field) {
    if (isNumber(format)) {
        index = format;
        format = undefined;
    }

    format = format || '';

    if (index != null) {
        return get$1(format, index, field, 'month');
    }

    var i;
    var out = [];
    for (i = 0; i < 12; i++) {
        out[i] = get$1(format, i, field, 'month');
    }
    return out;
}

// ()
// (5)
// (fmt, 5)
// (fmt)
// (true)
// (true, 5)
// (true, fmt, 5)
// (true, fmt)
function listWeekdaysImpl (localeSorted, format, index, field) {
    if (typeof localeSorted === 'boolean') {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    } else {
        format = localeSorted;
        index = format;
        localeSorted = false;

        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';
    }

    var locale = getLocale(),
        shift = localeSorted ? locale._week.dow : 0;

    if (index != null) {
        return get$1(format, (index + shift) % 7, field, 'day');
    }

    var i;
    var out = [];
    for (i = 0; i < 7; i++) {
        out[i] = get$1(format, (i + shift) % 7, field, 'day');
    }
    return out;
}

function listMonths (format, index) {
    return listMonthsImpl(format, index, 'months');
}

function listMonthsShort (format, index) {
    return listMonthsImpl(format, index, 'monthsShort');
}

function listWeekdays (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
}

function listWeekdaysShort (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
}

function listWeekdaysMin (localeSorted, format, index) {
    return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
}

getSetGlobalLocale('en', {
    ordinalParse: /\d{1,2}(th|st|nd|rd)/,
    ordinal : function (number) {
        var b = number % 10,
            output = (toInt(number % 100 / 10) === 1) ? 'th' :
            (b === 1) ? 'st' :
            (b === 2) ? 'nd' :
            (b === 3) ? 'rd' : 'th';
        return number + output;
    }
});

// Side effect imports
hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

var mathAbs = Math.abs;

function abs () {
    var data           = this._data;

    this._milliseconds = mathAbs(this._milliseconds);
    this._days         = mathAbs(this._days);
    this._months       = mathAbs(this._months);

    data.milliseconds  = mathAbs(data.milliseconds);
    data.seconds       = mathAbs(data.seconds);
    data.minutes       = mathAbs(data.minutes);
    data.hours         = mathAbs(data.hours);
    data.months        = mathAbs(data.months);
    data.years         = mathAbs(data.years);

    return this;
}

function addSubtract$1 (duration, input, value, direction) {
    var other = createDuration(input, value);

    duration._milliseconds += direction * other._milliseconds;
    duration._days         += direction * other._days;
    duration._months       += direction * other._months;

    return duration._bubble();
}

// supports only 2.0-style add(1, 's') or add(duration)
function add$1 (input, value) {
    return addSubtract$1(this, input, value, 1);
}

// supports only 2.0-style subtract(1, 's') or subtract(duration)
function subtract$1 (input, value) {
    return addSubtract$1(this, input, value, -1);
}

function absCeil (number) {
    if (number < 0) {
        return Math.floor(number);
    } else {
        return Math.ceil(number);
    }
}

function bubble () {
    var milliseconds = this._milliseconds;
    var days         = this._days;
    var months       = this._months;
    var data         = this._data;
    var seconds, minutes, hours, years, monthsFromDays;

    // if we have a mix of positive and negative values, bubble down first
    // check: https://github.com/moment/moment/issues/2166
    if (!((milliseconds >= 0 && days >= 0 && months >= 0) ||
            (milliseconds <= 0 && days <= 0 && months <= 0))) {
        milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
        days = 0;
        months = 0;
    }

    // The following code bubbles up values, see the tests for
    // examples of what that means.
    data.milliseconds = milliseconds % 1000;

    seconds           = absFloor(milliseconds / 1000);
    data.seconds      = seconds % 60;

    minutes           = absFloor(seconds / 60);
    data.minutes      = minutes % 60;

    hours             = absFloor(minutes / 60);
    data.hours        = hours % 24;

    days += absFloor(hours / 24);

    // convert days to months
    monthsFromDays = absFloor(daysToMonths(days));
    months += monthsFromDays;
    days -= absCeil(monthsToDays(monthsFromDays));

    // 12 months -> 1 year
    years = absFloor(months / 12);
    months %= 12;

    data.days   = days;
    data.months = months;
    data.years  = years;

    return this;
}

function daysToMonths (days) {
    // 400 years have 146097 days (taking into account leap year rules)
    // 400 years have 12 months === 4800
    return days * 4800 / 146097;
}

function monthsToDays (months) {
    // the reverse of daysToMonths
    return months * 146097 / 4800;
}

function as (units) {
    var days;
    var months;
    var milliseconds = this._milliseconds;

    units = normalizeUnits(units);

    if (units === 'month' || units === 'year') {
        days   = this._days   + milliseconds / 864e5;
        months = this._months + daysToMonths(days);
        return units === 'month' ? months : months / 12;
    } else {
        // handle milliseconds separately because of floating point math errors (issue #1867)
        days = this._days + Math.round(monthsToDays(this._months));
        switch (units) {
            case 'week'   : return days / 7     + milliseconds / 6048e5;
            case 'day'    : return days         + milliseconds / 864e5;
            case 'hour'   : return days * 24    + milliseconds / 36e5;
            case 'minute' : return days * 1440  + milliseconds / 6e4;
            case 'second' : return days * 86400 + milliseconds / 1000;
            // Math.floor prevents floating point math errors here
            case 'millisecond': return Math.floor(days * 864e5) + milliseconds;
            default: throw new Error('Unknown unit ' + units);
        }
    }
}

// TODO: Use this.as('ms')?
function valueOf$1 () {
    return (
        this._milliseconds +
        this._days * 864e5 +
        (this._months % 12) * 2592e6 +
        toInt(this._months / 12) * 31536e6
    );
}

function makeAs (alias) {
    return function () {
        return this.as(alias);
    };
}

var asMilliseconds = makeAs('ms');
var asSeconds      = makeAs('s');
var asMinutes      = makeAs('m');
var asHours        = makeAs('h');
var asDays         = makeAs('d');
var asWeeks        = makeAs('w');
var asMonths       = makeAs('M');
var asYears        = makeAs('y');

function get$2 (units) {
    units = normalizeUnits(units);
    return this[units + 's']();
}

function makeGetter(name) {
    return function () {
        return this._data[name];
    };
}

var milliseconds = makeGetter('milliseconds');
var seconds      = makeGetter('seconds');
var minutes      = makeGetter('minutes');
var hours        = makeGetter('hours');
var days         = makeGetter('days');
var months       = makeGetter('months');
var years        = makeGetter('years');

function weeks () {
    return absFloor(this.days() / 7);
}

var round = Math.round;
var thresholds = {
    s: 45,  // seconds to minute
    m: 45,  // minutes to hour
    h: 22,  // hours to day
    d: 26,  // days to month
    M: 11   // months to year
};

// helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
    return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
}

function relativeTime$1 (posNegDuration, withoutSuffix, locale) {
    var duration = createDuration(posNegDuration).abs();
    var seconds  = round(duration.as('s'));
    var minutes  = round(duration.as('m'));
    var hours    = round(duration.as('h'));
    var days     = round(duration.as('d'));
    var months   = round(duration.as('M'));
    var years    = round(duration.as('y'));

    var a = seconds < thresholds.s && ['s', seconds]  ||
            minutes <= 1           && ['m']           ||
            minutes < thresholds.m && ['mm', minutes] ||
            hours   <= 1           && ['h']           ||
            hours   < thresholds.h && ['hh', hours]   ||
            days    <= 1           && ['d']           ||
            days    < thresholds.d && ['dd', days]    ||
            months  <= 1           && ['M']           ||
            months  < thresholds.M && ['MM', months]  ||
            years   <= 1           && ['y']           || ['yy', years];

    a[2] = withoutSuffix;
    a[3] = +posNegDuration > 0;
    a[4] = locale;
    return substituteTimeAgo.apply(null, a);
}

// This function allows you to set the rounding function for relative time strings
function getSetRelativeTimeRounding (roundingFunction) {
    if (roundingFunction === undefined) {
        return round;
    }
    if (typeof(roundingFunction) === 'function') {
        round = roundingFunction;
        return true;
    }
    return false;
}

// This function allows you to set a threshold for relative time strings
function getSetRelativeTimeThreshold (threshold, limit) {
    if (thresholds[threshold] === undefined) {
        return false;
    }
    if (limit === undefined) {
        return thresholds[threshold];
    }
    thresholds[threshold] = limit;
    return true;
}

function humanize (withSuffix) {
    var locale = this.localeData();
    var output = relativeTime$1(this, !withSuffix, locale);

    if (withSuffix) {
        output = locale.pastFuture(+this, output);
    }

    return locale.postformat(output);
}

var abs$1 = Math.abs;

function toISOString$1() {
    // for ISO strings we do not use the normal bubbling rules:
    //  * milliseconds bubble up until they become hours
    //  * days do not bubble at all
    //  * months bubble up until they become years
    // This is because there is no context-free conversion between hours and days
    // (think of clock changes)
    // and also not between days and months (28-31 days per month)
    var seconds = abs$1(this._milliseconds) / 1000;
    var days         = abs$1(this._days);
    var months       = abs$1(this._months);
    var minutes, hours, years;

    // 3600 seconds -> 60 minutes -> 1 hour
    minutes           = absFloor(seconds / 60);
    hours             = absFloor(minutes / 60);
    seconds %= 60;
    minutes %= 60;

    // 12 months -> 1 year
    years  = absFloor(months / 12);
    months %= 12;


    // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
    var Y = years;
    var M = months;
    var D = days;
    var h = hours;
    var m = minutes;
    var s = seconds;
    var total = this.asSeconds();

    if (!total) {
        // this is the same as C#'s (Noda) and python (isodate)...
        // but not other JS (goog.date)
        return 'P0D';
    }

    return (total < 0 ? '-' : '') +
        'P' +
        (Y ? Y + 'Y' : '') +
        (M ? M + 'M' : '') +
        (D ? D + 'D' : '') +
        ((h || m || s) ? 'T' : '') +
        (h ? h + 'H' : '') +
        (m ? m + 'M' : '') +
        (s ? s + 'S' : '');
}

var proto$2 = Duration.prototype;

proto$2.abs            = abs;
proto$2.add            = add$1;
proto$2.subtract       = subtract$1;
proto$2.as             = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds      = asSeconds;
proto$2.asMinutes      = asMinutes;
proto$2.asHours        = asHours;
proto$2.asDays         = asDays;
proto$2.asWeeks        = asWeeks;
proto$2.asMonths       = asMonths;
proto$2.asYears        = asYears;
proto$2.valueOf        = valueOf$1;
proto$2._bubble        = bubble;
proto$2.get            = get$2;
proto$2.milliseconds   = milliseconds;
proto$2.seconds        = seconds;
proto$2.minutes        = minutes;
proto$2.hours          = hours;
proto$2.days           = days;
proto$2.weeks          = weeks;
proto$2.months         = months;
proto$2.years          = years;
proto$2.humanize       = humanize;
proto$2.toISOString    = toISOString$1;
proto$2.toString       = toISOString$1;
proto$2.toJSON         = toISOString$1;
proto$2.locale         = locale;
proto$2.localeData     = localeData;

// Deprecations
proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
proto$2.lang = lang;

// Side effect imports

// FORMATTING

addFormatToken('X', 0, 0, 'unix');
addFormatToken('x', 0, 0, 'valueOf');

// PARSING

addRegexToken('x', matchSigned);
addRegexToken('X', matchTimestamp);
addParseToken('X', function (input, array, config) {
    config._d = new Date(parseFloat(input, 10) * 1000);
});
addParseToken('x', function (input, array, config) {
    config._d = new Date(toInt(input));
});

// Side effect imports


hooks.version = '2.17.0';

setHookCallback(createLocal);

hooks.fn                    = proto;
hooks.min                   = min;
hooks.max                   = max;
hooks.now                   = now;
hooks.utc                   = createUTC;
hooks.unix                  = createUnix;
hooks.months                = listMonths;
hooks.isDate                = isDate;
hooks.locale                = getSetGlobalLocale;
hooks.invalid               = createInvalid;
hooks.duration              = createDuration;
hooks.isMoment              = isMoment;
hooks.weekdays              = listWeekdays;
hooks.parseZone             = createInZone;
hooks.localeData            = getLocale;
hooks.isDuration            = isDuration;
hooks.monthsShort           = listMonthsShort;
hooks.weekdaysMin           = listWeekdaysMin;
hooks.defineLocale          = defineLocale;
hooks.updateLocale          = updateLocale;
hooks.locales               = listLocales;
hooks.weekdaysShort         = listWeekdaysShort;
hooks.normalizeUnits        = normalizeUnits;
hooks.relativeTimeRounding = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat        = getCalendarFormat;
hooks.prototype             = proto;

return hooks;

})));

},{}],651:[function(require,module,exports){
var indexOf = require('./indexOf');

    /**
     * Combines an array with all the items of another.
     * Does not allow duplicates and is case and type sensitive.
     */
    function combine(arr1, arr2) {
        if (arr2 == null) {
            return arr1;
        }

        var i = -1, len = arr2.length;
        while (++i < len) {
            if (indexOf(arr1, arr2[i]) === -1) {
                arr1.push(arr2[i]);
            }
        }

        return arr1;
    }
    module.exports = combine;


},{"./indexOf":660}],652:[function(require,module,exports){
var indexOf = require('./indexOf');

    /**
     * If array contains values.
     */
    function contains(arr, val) {
        return indexOf(arr, val) !== -1;
    }
    module.exports = contains;


},{"./indexOf":660}],653:[function(require,module,exports){
var unique = require('./unique');
var filter = require('./filter');
var some = require('./some');
var contains = require('./contains');
var slice = require('./slice');


    /**
     * Return a new Array with elements that aren't present in the other Arrays.
     */
    function difference(arr) {
        var arrs = slice(arguments, 1),
            result = filter(unique(arr), function(needle){
                return !some(arrs, function(haystack){
                    return contains(haystack, needle);
                });
            });
        return result;
    }

    module.exports = difference;



},{"./contains":652,"./filter":656,"./slice":664,"./some":665,"./unique":666}],654:[function(require,module,exports){
var is = require('../lang/is');
var isArray = require('../lang/isArray');
var every = require('./every');

    /**
     * Compares if both arrays have the same elements
     */
    function equals(a, b, callback){
        callback = callback || is;

        if (!isArray(a) || !isArray(b)) {
            return callback(a, b);
        }

        if (a.length !== b.length) {
            return false;
        }

        return every(a, makeCompare(callback), b);
    }

    function makeCompare(callback) {
        return function(value, i) {
            return i in this && callback(value, this[i]);
        };
    }

    module.exports = equals;



},{"../lang/is":674,"../lang/isArray":675,"./every":655}],655:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array every
     */
    function every(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = true;
        if (arr == null) {
            return result;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if (!callback(arr[i], i, arr) ) {
                result = false;
                break;
            }
        }

        return result;
    }

    module.exports = every;


},{"../function/makeIterator_":668}],656:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array filter
     */
    function filter(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var results = [];
        if (arr == null) {
            return results;
        }

        var i = -1, len = arr.length, value;
        while (++i < len) {
            value = arr[i];
            if (callback(value, i, arr)) {
                results.push(value);
            }
        }

        return results;
    }

    module.exports = filter;



},{"../function/makeIterator_":668}],657:[function(require,module,exports){
var findIndex = require('./findIndex');

    /**
     * Returns first item that matches criteria
     */
    function find(arr, iterator, thisObj){
        var idx = findIndex(arr, iterator, thisObj);
        return idx >= 0? arr[idx] : void(0);
    }

    module.exports = find;



},{"./findIndex":658}],658:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Returns the index of the first item that matches criteria
     */
    function findIndex(arr, iterator, thisObj){
        iterator = makeIterator(iterator, thisObj);
        if (arr == null) {
            return -1;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            if (iterator(arr[i], i, arr)) {
                return i;
            }
        }

        return -1;
    }

    module.exports = findIndex;


},{"../function/makeIterator_":668}],659:[function(require,module,exports){


    /**
     * Array forEach
     */
    function forEach(arr, callback, thisObj) {
        if (arr == null) {
            return;
        }
        var i = -1,
            len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if ( callback.call(thisObj, arr[i], i, arr) === false ) {
                break;
            }
        }
    }

    module.exports = forEach;



},{}],660:[function(require,module,exports){


    /**
     * Array.indexOf
     */
    function indexOf(arr, item, fromIndex) {
        fromIndex = fromIndex || 0;
        if (arr == null) {
            return -1;
        }

        var len = arr.length,
            i = fromIndex < 0 ? len + fromIndex : fromIndex;
        while (i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if (arr[i] === item) {
                return i;
            }

            i++;
        }

        return -1;
    }

    module.exports = indexOf;


},{}],661:[function(require,module,exports){
var unique = require('./unique');
var filter = require('./filter');
var every = require('./every');
var contains = require('./contains');
var slice = require('./slice');


    /**
     * Return a new Array with elements common to all Arrays.
     * - based on underscore.js implementation
     */
    function intersection(arr) {
        var arrs = slice(arguments, 1),
            result = filter(unique(arr), function(needle){
                return every(arrs, function(haystack){
                    return contains(haystack, needle);
                });
            });
        return result;
    }

    module.exports = intersection;



},{"./contains":652,"./every":655,"./filter":656,"./slice":664,"./unique":666}],662:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array map
     */
    function map(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var results = [];
        if (arr == null){
            return results;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            results[i] = callback(arr[i], i, arr);
        }

        return results;
    }

     module.exports = map;


},{"../function/makeIterator_":668}],663:[function(require,module,exports){
var indexOf = require('./indexOf');

    /**
     * Remove a single item from the array.
     * (it won't remove duplicates, just a single item)
     */
    function remove(arr, item){
        var idx = indexOf(arr, item);
        if (idx !== -1) arr.splice(idx, 1);
    }

    module.exports = remove;


},{"./indexOf":660}],664:[function(require,module,exports){


    /**
     * Create slice of source array or array-like object
     */
    function slice(arr, start, end){
        var len = arr.length;

        if (start == null) {
            start = 0;
        } else if (start < 0) {
            start = Math.max(len + start, 0);
        } else {
            start = Math.min(start, len);
        }

        if (end == null) {
            end = len;
        } else if (end < 0) {
            end = Math.max(len + end, 0);
        } else {
            end = Math.min(end, len);
        }

        var result = [];
        while (start < end) {
            result.push(arr[start++]);
        }

        return result;
    }

    module.exports = slice;



},{}],665:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array some
     */
    function some(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = false;
        if (arr == null) {
            return result;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if ( callback(arr[i], i, arr) ) {
                result = true;
                break;
            }
        }

        return result;
    }

    module.exports = some;


},{"../function/makeIterator_":668}],666:[function(require,module,exports){
var filter = require('./filter');

    /**
     * @return {array} Array of unique items
     */
    function unique(arr, compare){
        compare = compare || isEqual;
        return filter(arr, function(item, i, arr){
            var n = arr.length;
            while (++i < n) {
                if ( compare(item, arr[i]) ) {
                    return false;
                }
            }
            return true;
        });
    }

    function isEqual(a, b){
        return a === b;
    }

    module.exports = unique;



},{"./filter":656}],667:[function(require,module,exports){


    /**
     * Returns the first argument provided to it.
     */
    function identity(val){
        return val;
    }

    module.exports = identity;



},{}],668:[function(require,module,exports){
var identity = require('./identity');
var prop = require('./prop');
var deepMatches = require('../object/deepMatches');

    /**
     * Converts argument into a valid iterator.
     * Used internally on most array/object/collection methods that receives a
     * callback/iterator providing a shortcut syntax.
     */
    function makeIterator(src, thisObj){
        if (src == null) {
            return identity;
        }
        switch(typeof src) {
            case 'function':
                // function is the first to improve perf (most common case)
                // also avoid using `Function#call` if not needed, which boosts
                // perf a lot in some cases
                return (typeof thisObj !== 'undefined')? function(val, i, arr){
                    return src.call(thisObj, val, i, arr);
                } : src;
            case 'object':
                return function(val){
                    return deepMatches(val, src);
                };
            case 'string':
            case 'number':
                return prop(src);
        }
    }

    module.exports = makeIterator;



},{"../object/deepMatches":684,"./identity":667,"./prop":669}],669:[function(require,module,exports){


    /**
     * Returns a function that gets a property of the passed object
     */
    function prop(name){
        return function(obj){
            return obj[name];
        };
    }

    module.exports = prop;



},{}],670:[function(require,module,exports){
var kindOf = require('./kindOf');
var isPlainObject = require('./isPlainObject');
var mixIn = require('../object/mixIn');

    /**
     * Clone native types.
     */
    function clone(val){
        switch (kindOf(val)) {
            case 'Object':
                return cloneObject(val);
            case 'Array':
                return cloneArray(val);
            case 'RegExp':
                return cloneRegExp(val);
            case 'Date':
                return cloneDate(val);
            default:
                return val;
        }
    }

    function cloneObject(source) {
        if (isPlainObject(source)) {
            return mixIn({}, source);
        } else {
            return source;
        }
    }

    function cloneRegExp(r) {
        var flags = '';
        flags += r.multiline ? 'm' : '';
        flags += r.global ? 'g' : '';
        flags += r.ignoreCase ? 'i' : '';
        return new RegExp(r.source, flags);
    }

    function cloneDate(date) {
        return new Date(+date);
    }

    function cloneArray(arr) {
        return arr.slice();
    }

    module.exports = clone;



},{"../object/mixIn":692,"./isPlainObject":679,"./kindOf":681}],671:[function(require,module,exports){
var mixIn = require('../object/mixIn');

    /**
     * Create Object using prototypal inheritance and setting custom properties.
     * - Mix between Douglas Crockford Prototypal Inheritance <http://javascript.crockford.com/prototypal.html> and the EcmaScript 5 `Object.create()` method.
     * @param {object} parent    Parent Object.
     * @param {object} [props] Object properties.
     * @return {object} Created object.
     */
    function createObject(parent, props){
        function F(){}
        F.prototype = parent;
        return mixIn(new F(), props);

    }
    module.exports = createObject;



},{"../object/mixIn":692}],672:[function(require,module,exports){
var clone = require('./clone');
var forOwn = require('../object/forOwn');
var kindOf = require('./kindOf');
var isPlainObject = require('./isPlainObject');

    /**
     * Recursively clone native types.
     */
    function deepClone(val, instanceClone) {
        switch ( kindOf(val) ) {
            case 'Object':
                return cloneObject(val, instanceClone);
            case 'Array':
                return cloneArray(val, instanceClone);
            default:
                return clone(val);
        }
    }

    function cloneObject(source, instanceClone) {
        if (isPlainObject(source)) {
            var out = {};
            forOwn(source, function(val, key) {
                this[key] = deepClone(val, instanceClone);
            }, out);
            return out;
        } else if (instanceClone) {
            return instanceClone(source);
        } else {
            return source;
        }
    }

    function cloneArray(arr, instanceClone) {
        var out = [],
            i = -1,
            n = arr.length,
            val;
        while (++i < n) {
            out[i] = deepClone(arr[i], instanceClone);
        }
        return out;
    }

    module.exports = deepClone;




},{"../object/forOwn":689,"./clone":670,"./isPlainObject":679,"./kindOf":681}],673:[function(require,module,exports){
var is = require('./is');
var isObject = require('./isObject');
var isArray = require('./isArray');
var objEquals = require('../object/equals');
var arrEquals = require('../array/equals');

    /**
     * Recursively checks for same properties and values.
     */
    function deepEquals(a, b, callback){
        callback = callback || is;

        var bothObjects = isObject(a) && isObject(b);
        var bothArrays = !bothObjects && isArray(a) && isArray(b);

        if (!bothObjects && !bothArrays) {
            return callback(a, b);
        }

        function compare(a, b){
            return deepEquals(a, b, callback);
        }

        var method = bothObjects ? objEquals : arrEquals;
        return method(a, b, compare);
    }

    module.exports = deepEquals;



},{"../array/equals":654,"../object/equals":686,"./is":674,"./isArray":675,"./isObject":678}],674:[function(require,module,exports){


    /**
     * Check if both arguments are egal.
     */
    function is(x, y){
        // implementation borrowed from harmony:egal spec
        if (x === y) {
          // 0 === -0, but they are not identical
          return x !== 0 || 1 / x === 1 / y;
        }

        // NaN !== NaN, but they are identical.
        // NaNs are the only non-reflexive value, i.e., if x !== x,
        // then x is a NaN.
        // isNaN is broken: it converts its argument to number, so
        // isNaN("foo") => true
        return x !== x && y !== y;
    }

    module.exports = is;



},{}],675:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    var isArray = Array.isArray || function (val) {
        return isKind(val, 'Array');
    };
    module.exports = isArray;


},{"./isKind":676}],676:[function(require,module,exports){
var kindOf = require('./kindOf');
    /**
     * Check if value is from a specific "kind".
     */
    function isKind(val, kind){
        return kindOf(val) === kind;
    }
    module.exports = isKind;


},{"./kindOf":681}],677:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isNumber(val) {
        return isKind(val, 'Number');
    }
    module.exports = isNumber;


},{"./isKind":676}],678:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isObject(val) {
        return isKind(val, 'Object');
    }
    module.exports = isObject;


},{"./isKind":676}],679:[function(require,module,exports){


    /**
     * Checks if the value is created by the `Object` constructor.
     */
    function isPlainObject(value) {
        return (!!value && typeof value === 'object' &&
            value.constructor === Object);
    }

    module.exports = isPlainObject;



},{}],680:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isRegExp(val) {
        return isKind(val, 'RegExp');
    }
    module.exports = isRegExp;


},{"./isKind":676}],681:[function(require,module,exports){


    var _rKind = /^\[object (.*)\]$/,
        _toString = Object.prototype.toString,
        UNDEF;

    /**
     * Gets the "kind" of value. (e.g. "String", "Number", etc)
     */
    function kindOf(val) {
        if (val === null) {
            return 'Null';
        } else if (val === UNDEF) {
            return 'Undefined';
        } else {
            return _rKind.exec( _toString.call(val) )[1];
        }
    }
    module.exports = kindOf;


},{}],682:[function(require,module,exports){


    /**
     * Typecast a value to a String, using an empty string value for null or
     * undefined.
     */
    function toString(val){
        return val == null ? '' : val.toString();
    }

    module.exports = toString;



},{}],683:[function(require,module,exports){
var forOwn = require('./forOwn');
var isPlainObject = require('../lang/isPlainObject');

    /**
     * Deeply copy missing properties in the target from the defaults.
     */
    function deepFillIn(target, defaults){
        var i = 0,
            n = arguments.length,
            obj;

        while(++i < n) {
            obj = arguments[i];
            if (obj) {
                // jshint loopfunc: true
                forOwn(obj, function(newValue, key) {
                    var curValue = target[key];
                    if (curValue == null) {
                        target[key] = newValue;
                    } else if (isPlainObject(curValue) &&
                               isPlainObject(newValue)) {
                        deepFillIn(curValue, newValue);
                    }
                });
            }
        }

        return target;
    }

    module.exports = deepFillIn;



},{"../lang/isPlainObject":679,"./forOwn":689}],684:[function(require,module,exports){
var forOwn = require('./forOwn');
var isArray = require('../lang/isArray');

    function containsMatch(array, pattern) {
        var i = -1, length = array.length;
        while (++i < length) {
            if (deepMatches(array[i], pattern)) {
                return true;
            }
        }

        return false;
    }

    function matchArray(target, pattern) {
        var i = -1, patternLength = pattern.length;
        while (++i < patternLength) {
            if (!containsMatch(target, pattern[i])) {
                return false;
            }
        }

        return true;
    }

    function matchObject(target, pattern) {
        var result = true;
        forOwn(pattern, function(val, key) {
            if (!deepMatches(target[key], val)) {
                // Return false to break out of forOwn early
                return (result = false);
            }
        });

        return result;
    }

    /**
     * Recursively check if the objects match.
     */
    function deepMatches(target, pattern){
        if (target && typeof target === 'object') {
            if (isArray(target) && isArray(pattern)) {
                return matchArray(target, pattern);
            } else {
                return matchObject(target, pattern);
            }
        } else {
            return target === pattern;
        }
    }

    module.exports = deepMatches;



},{"../lang/isArray":675,"./forOwn":689}],685:[function(require,module,exports){
var forOwn = require('./forOwn');
var isPlainObject = require('../lang/isPlainObject');

    /**
     * Mixes objects into the target object, recursively mixing existing child
     * objects.
     */
    function deepMixIn(target, objects) {
        var i = 0,
            n = arguments.length,
            obj;

        while(++i < n){
            obj = arguments[i];
            if (obj) {
                forOwn(obj, copyProp, target);
            }
        }

        return target;
    }

    function copyProp(val, key) {
        var existing = this[key];
        if (isPlainObject(val) && isPlainObject(existing)) {
            deepMixIn(existing, val);
        } else {
            this[key] = val;
        }
    }

    module.exports = deepMixIn;



},{"../lang/isPlainObject":679,"./forOwn":689}],686:[function(require,module,exports){
var hasOwn = require('./hasOwn');
var every = require('./every');
var isObject = require('../lang/isObject');
var is = require('../lang/is');

    // Makes a function to compare the object values from the specified compare
    // operation callback.
    function makeCompare(callback) {
        return function(value, key) {
            return hasOwn(this, key) && callback(value, this[key]);
        };
    }

    function checkProperties(value, key) {
        return hasOwn(this, key);
    }

    /**
     * Checks if two objects have the same keys and values.
     */
    function equals(a, b, callback) {
        callback = callback || is;

        if (!isObject(a) || !isObject(b)) {
            return callback(a, b);
        }

        return (every(a, makeCompare(callback), b) &&
                every(b, checkProperties, a));
    }

    module.exports = equals;


},{"../lang/is":674,"../lang/isObject":678,"./every":687,"./hasOwn":690}],687:[function(require,module,exports){
var forOwn = require('./forOwn');
var makeIterator = require('../function/makeIterator_');

    /**
     * Object every
     */
    function every(obj, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = true;
        forOwn(obj, function(val, key) {
            // we consider any falsy values as "false" on purpose so shorthand
            // syntax can be used to check property existence
            if (!callback(val, key, obj)) {
                result = false;
                return false; // break
            }
        });
        return result;
    }

    module.exports = every;



},{"../function/makeIterator_":668,"./forOwn":689}],688:[function(require,module,exports){
var hasOwn = require('./hasOwn');

    var _hasDontEnumBug,
        _dontEnums;

    function checkDontEnum(){
        _dontEnums = [
                'toString',
                'toLocaleString',
                'valueOf',
                'hasOwnProperty',
                'isPrototypeOf',
                'propertyIsEnumerable',
                'constructor'
            ];

        _hasDontEnumBug = true;

        for (var key in {'toString': null}) {
            _hasDontEnumBug = false;
        }
    }

    /**
     * Similar to Array/forEach but works over object properties and fixes Don't
     * Enum bug on IE.
     * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
     */
    function forIn(obj, fn, thisObj){
        var key, i = 0;
        // no need to check if argument is a real object that way we can use
        // it for arrays, functions, date, etc.

        //post-pone check till needed
        if (_hasDontEnumBug == null) checkDontEnum();

        for (key in obj) {
            if (exec(fn, obj, key, thisObj) === false) {
                break;
            }
        }


        if (_hasDontEnumBug) {
            var ctor = obj.constructor,
                isProto = !!ctor && obj === ctor.prototype;

            while (key = _dontEnums[i++]) {
                // For constructor, if it is a prototype object the constructor
                // is always non-enumerable unless defined otherwise (and
                // enumerated above).  For non-prototype objects, it will have
                // to be defined on this object, since it cannot be defined on
                // any prototype objects.
                //
                // For other [[DontEnum]] properties, check if the value is
                // different than Object prototype value.
                if (
                    (key !== 'constructor' ||
                        (!isProto && hasOwn(obj, key))) &&
                    obj[key] !== Object.prototype[key]
                ) {
                    if (exec(fn, obj, key, thisObj) === false) {
                        break;
                    }
                }
            }
        }
    }

    function exec(fn, obj, key, thisObj){
        return fn.call(thisObj, obj[key], key, obj);
    }

    module.exports = forIn;



},{"./hasOwn":690}],689:[function(require,module,exports){
var hasOwn = require('./hasOwn');
var forIn = require('./forIn');

    /**
     * Similar to Array/forEach but works over object properties and fixes Don't
     * Enum bug on IE.
     * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
     */
    function forOwn(obj, fn, thisObj){
        forIn(obj, function(val, key){
            if (hasOwn(obj, key)) {
                return fn.call(thisObj, obj[key], key, obj);
            }
        });
    }

    module.exports = forOwn;



},{"./forIn":688,"./hasOwn":690}],690:[function(require,module,exports){


    /**
     * Safer Object.hasOwnProperty
     */
     function hasOwn(obj, prop){
         return Object.prototype.hasOwnProperty.call(obj, prop);
     }

     module.exports = hasOwn;



},{}],691:[function(require,module,exports){
var hasOwn = require('./hasOwn');
var deepClone = require('../lang/deepClone');
var isObject = require('../lang/isObject');

    /**
     * Deep merge objects.
     */
    function merge() {
        var i = 1,
            key, val, obj, target;

        // make sure we don't modify source element and it's properties
        // objects are passed by reference
        target = deepClone( arguments[0] );

        while (obj = arguments[i++]) {
            for (key in obj) {
                if ( ! hasOwn(obj, key) ) {
                    continue;
                }

                val = obj[key];

                if ( isObject(val) && isObject(target[key]) ){
                    // inception, deep merge objects
                    target[key] = merge(target[key], val);
                } else {
                    // make sure arrays, regexp, date, objects are cloned
                    target[key] = deepClone(val);
                }

            }
        }

        return target;
    }

    module.exports = merge;



},{"../lang/deepClone":672,"../lang/isObject":678,"./hasOwn":690}],692:[function(require,module,exports){
var forOwn = require('./forOwn');

    /**
    * Combine properties from all the objects into first one.
    * - This method affects target object in place, if you want to create a new Object pass an empty object as first param.
    * @param {object} target    Target Object
    * @param {...object} objects    Objects to be combined (0...n objects).
    * @return {object} Target Object.
    */
    function mixIn(target, objects){
        var i = 0,
            n = arguments.length,
            obj;
        while(++i < n){
            obj = arguments[i];
            if (obj != null) {
                forOwn(obj, copyProp, target);
            }
        }
        return target;
    }

    function copyProp(val, key){
        this[key] = val;
    }

    module.exports = mixIn;


},{"./forOwn":689}],693:[function(require,module,exports){
var slice = require('../array/slice');

    /**
     * Return a copy of the object, filtered to only have values for the whitelisted keys.
     */
    function pick(obj, var_keys){
        var keys = typeof arguments[1] !== 'string'? arguments[1] : slice(arguments, 1),
            out = {},
            i = 0, key;
        while (key = keys[i++]) {
            out[key] = obj[key];
        }
        return out;
    }

    module.exports = pick;



},{"../array/slice":664}],694:[function(require,module,exports){

    /**
     * Contains all Unicode white-spaces. Taken from
     * http://en.wikipedia.org/wiki/Whitespace_character.
     */
    module.exports = [
        ' ', '\n', '\r', '\t', '\f', '\v', '\u00A0', '\u1680', '\u180E',
        '\u2000', '\u2001', '\u2002', '\u2003', '\u2004', '\u2005', '\u2006',
        '\u2007', '\u2008', '\u2009', '\u200A', '\u2028', '\u2029', '\u202F',
        '\u205F', '\u3000'
    ];


},{}],695:[function(require,module,exports){
var toString = require('../lang/toString');

    /**
     * Escape RegExp string chars.
     */
    function escapeRegExp(str) {
        return toString(str).replace(/\W/g,'\\$&');
    }

    module.exports = escapeRegExp;



},{"../lang/toString":682}],696:[function(require,module,exports){
var toString = require('../lang/toString');
var WHITE_SPACES = require('./WHITE_SPACES');
    /**
     * Remove chars from beginning of string.
     */
    function ltrim(str, chars) {
        str = toString(str);
        chars = chars || WHITE_SPACES;

        var start = 0,
            len = str.length,
            charLen = chars.length,
            found = true,
            i, c;

        while (found && start < len) {
            found = false;
            i = -1;
            c = str.charAt(start);

            while (++i < charLen) {
                if (c === chars[i]) {
                    found = true;
                    start++;
                    break;
                }
            }
        }

        return (start >= len) ? '' : str.substr(start, len);
    }

    module.exports = ltrim;


},{"../lang/toString":682,"./WHITE_SPACES":694}],697:[function(require,module,exports){
var toString = require('../lang/toString');
var WHITE_SPACES = require('./WHITE_SPACES');
    /**
     * Remove chars from end of string.
     */
    function rtrim(str, chars) {
        str = toString(str);
        chars = chars || WHITE_SPACES;

        var end = str.length - 1,
            charLen = chars.length,
            found = true,
            i, c;

        while (found && end >= 0) {
            found = false;
            i = -1;
            c = str.charAt(end);

            while (++i < charLen) {
                if (c === chars[i]) {
                    found = true;
                    end--;
                    break;
                }
            }
        }

        return (end >= 0) ? str.substring(0, end + 1) : '';
    }

    module.exports = rtrim;


},{"../lang/toString":682,"./WHITE_SPACES":694}],698:[function(require,module,exports){
var toString = require('../lang/toString');
var WHITE_SPACES = require('./WHITE_SPACES');
var ltrim = require('./ltrim');
var rtrim = require('./rtrim');
    /**
     * Remove white-spaces from beginning and end of string.
     */
    function trim(str, chars) {
        str = toString(str);
        chars = chars || WHITE_SPACES;
        return ltrim(rtrim(str, chars), chars);
    }

    module.exports = trim;


},{"../lang/toString":682,"./WHITE_SPACES":694,"./ltrim":696,"./rtrim":697}],699:[function(require,module,exports){


    /**
     * Get current time in miliseconds
     */
    function now(){
        // yes, we defer the work to another function to allow mocking it
        // during the tests
        return now.get();
    }

    now.get = (typeof Date.now === 'function')? Date.now : function(){
        return +(new Date());
    };

    module.exports = now;



},{}],700:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000
var m = s * 60
var h = m * 60
var d = h * 24
var y = d * 365.25

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {}
  var type = typeof val
  if (type === 'string' && val.length > 0) {
    return parse(val)
  } else if (type === 'number' && isNaN(val) === false) {
    return options.long ?
			fmtLong(val) :
			fmtShort(val)
  }
  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val))
}

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str)
  if (str.length > 10000) {
    return
  }
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str)
  if (!match) {
    return
  }
  var n = parseFloat(match[1])
  var type = (match[2] || 'ms').toLowerCase()
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y
    case 'days':
    case 'day':
    case 'd':
      return n * d
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n
    default:
      return undefined
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  if (ms >= d) {
    return Math.round(ms / d) + 'd'
  }
  if (ms >= h) {
    return Math.round(ms / h) + 'h'
  }
  if (ms >= m) {
    return Math.round(ms / m) + 'm'
  }
  if (ms >= s) {
    return Math.round(ms / s) + 's'
  }
  return ms + 'ms'
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  return plural(ms, d, 'day') ||
    plural(ms, h, 'hour') ||
    plural(ms, m, 'minute') ||
    plural(ms, s, 'second') ||
    ms + ' ms'
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) {
    return
  }
  if (ms < n * 1.5) {
    return Math.floor(ms / n) + ' ' + name
  }
  return Math.ceil(ms / n) + ' ' + name + 's'
}

},{}],701:[function(require,module,exports){
'use strict';
/* eslint-disable no-unused-vars */
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (e) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (Object.getOwnPropertySymbols) {
			symbols = Object.getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},{}],702:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],703:[function(require,module,exports){
var _curry2 = require('./internal/_curry2');
var _dispatchable = require('./internal/_dispatchable');
var _xall = require('./internal/_xall');


/**
 * Returns `true` if all elements of the list match the predicate, `false` if there are any
 * that don't.
 *
 * Acts as a transducer if a transformer is given in list position.
 * @see R.transduce
 *
 * @func
 * @memberOf R
 * @category List
 * @sig (a -> Boolean) -> [a] -> Boolean
 * @param {Function} fn The predicate function.
 * @param {Array} list The array to consider.
 * @return {Boolean} `true` if the predicate is satisfied by every element, `false`
 *         otherwise.
 * @see R.any, R.none
 * @example
 *
 *      var lessThan2 = R.flip(R.lt)(2);
 *      var lessThan3 = R.flip(R.lt)(3);
 *      R.all(lessThan2)([1, 2]); //=> false
 *      R.all(lessThan3)([1, 2]); //=> true
 */
module.exports = _curry2(_dispatchable('all', _xall, function all(fn, list) {
  var idx = 0;
  while (idx < list.length) {
    if (!fn(list[idx])) {
      return false;
    }
    idx += 1;
  }
  return true;
}));

},{"./internal/_curry2":710,"./internal/_dispatchable":711,"./internal/_xall":721}],704:[function(require,module,exports){
var _contains = require('./internal/_contains');
var _curry2 = require('./internal/_curry2');


/**
 * Returns `true` if the specified value is equal, in `R.equals` terms,
 * to at least one element of the given list; `false` otherwise.
 *
 * @func
 * @memberOf R
 * @category List
 * @sig a -> [a] -> Boolean
 * @param {Object} a The item to compare against.
 * @param {Array} list The array to consider.
 * @return {Boolean} `true` if the item is in the list, `false` otherwise.
 *
 * @example
 *
 *      R.contains(3, [1, 2, 3]); //=> true
 *      R.contains(4, [1, 2, 3]); //=> false
 *      R.contains([42], [[42]]); //=> true
 */
module.exports = _curry2(_contains);

},{"./internal/_contains":708,"./internal/_curry2":710}],705:[function(require,module,exports){
var _curry2 = require('./internal/_curry2');
var _equals = require('./internal/_equals');
var _hasMethod = require('./internal/_hasMethod');


/**
 * Returns `true` if its arguments are equivalent, `false` otherwise.
 * Dispatches to an `equals` method if present. Handles cyclical data
 * structures.
 *
 * @func
 * @memberOf R
 * @category Relation
 * @sig a -> b -> Boolean
 * @param {*} a
 * @param {*} b
 * @return {Boolean}
 * @example
 *
 *      R.equals(1, 1); //=> true
 *      R.equals(1, '1'); //=> false
 *      R.equals([1, 2, 3], [1, 2, 3]); //=> true
 *
 *      var a = {}; a.v = a;
 *      var b = {}; b.v = b;
 *      R.equals(a, b); //=> true
 */
module.exports = _curry2(function equals(a, b) {
  return _hasMethod('equals', a) ? a.equals(b) :
         _hasMethod('equals', b) ? b.equals(a) : _equals(a, b, [], []);
});

},{"./internal/_curry2":710,"./internal/_equals":712,"./internal/_hasMethod":714}],706:[function(require,module,exports){
var _curry2 = require('./internal/_curry2');
var _has = require('./internal/_has');


/**
 * Returns whether or not an object has an own property with
 * the specified name
 *
 * @func
 * @memberOf R
 * @category Object
 * @sig s -> {s: x} -> Boolean
 * @param {String} prop The name of the property to check for.
 * @param {Object} obj The object to query.
 * @return {Boolean} Whether the property exists.
 * @example
 *
 *      var hasName = R.has('name');
 *      hasName({name: 'alice'});   //=> true
 *      hasName({name: 'bob'});     //=> true
 *      hasName({});                //=> false
 *
 *      var point = {x: 0, y: 0};
 *      var pointHas = R.has(R.__, point);
 *      pointHas('x');  //=> true
 *      pointHas('y');  //=> true
 *      pointHas('z');  //=> false
 */
module.exports = _curry2(_has);

},{"./internal/_curry2":710,"./internal/_has":713}],707:[function(require,module,exports){
var _curry2 = require('./internal/_curry2');


/**
 * Returns true if its arguments are identical, false otherwise. Values are
 * identical if they reference the same memory. `NaN` is identical to `NaN`;
 * `0` and `-0` are not identical.
 *
 * @func
 * @memberOf R
 * @category Relation
 * @sig a -> a -> Boolean
 * @param {*} a
 * @param {*} b
 * @return {Boolean}
 * @example
 *
 *      var o = {};
 *      R.identical(o, o); //=> true
 *      R.identical(1, 1); //=> true
 *      R.identical(1, '1'); //=> false
 *      R.identical([], []); //=> false
 *      R.identical(0, -0); //=> false
 *      R.identical(NaN, NaN); //=> true
 */
module.exports = _curry2(function identical(a, b) {
  // SameValue algorithm
  if (a === b) { // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    return a !== 0 || 1 / a === 1 / b;
  } else {
    // Step 6.a: NaN == NaN
    return a !== a && b !== b;
  }
});

},{"./internal/_curry2":710}],708:[function(require,module,exports){
var _indexOf = require('./_indexOf');


module.exports = function _contains(a, list) {
  return _indexOf(list, a, 0) >= 0;
};

},{"./_indexOf":715}],709:[function(require,module,exports){
/**
 * Optimized internal two-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */
module.exports = function _curry1(fn) {
  return function f1(a) {
    if (arguments.length === 0) {
      return f1;
    } else if (a != null && a['@@functional/placeholder'] === true) {
      return f1;
    } else {
      return fn.apply(this, arguments);
    }
  };
};

},{}],710:[function(require,module,exports){
var _curry1 = require('./_curry1');


/**
 * Optimized internal two-arity curry function.
 *
 * @private
 * @category Function
 * @param {Function} fn The function to curry.
 * @return {Function} The curried function.
 */
module.exports = function _curry2(fn) {
  return function f2(a, b) {
    var n = arguments.length;
    if (n === 0) {
      return f2;
    } else if (n === 1 && a != null && a['@@functional/placeholder'] === true) {
      return f2;
    } else if (n === 1) {
      return _curry1(function(b) { return fn(a, b); });
    } else if (n === 2 && a != null && a['@@functional/placeholder'] === true &&
                          b != null && b['@@functional/placeholder'] === true) {
      return f2;
    } else if (n === 2 && a != null && a['@@functional/placeholder'] === true) {
      return _curry1(function(a) { return fn(a, b); });
    } else if (n === 2 && b != null && b['@@functional/placeholder'] === true) {
      return _curry1(function(b) { return fn(a, b); });
    } else {
      return fn(a, b);
    }
  };
};

},{"./_curry1":709}],711:[function(require,module,exports){
var _isArray = require('./_isArray');
var _isTransformer = require('./_isTransformer');
var _slice = require('./_slice');


/**
 * Returns a function that dispatches with different strategies based on the
 * object in list position (last argument). If it is an array, executes [fn].
 * Otherwise, if it has a  function with [methodname], it will execute that
 * function (functor case). Otherwise, if it is a transformer, uses transducer
 * [xf] to return a new transformer (transducer case). Otherwise, it will
 * default to executing [fn].
 *
 * @private
 * @param {String} methodname property to check for a custom implementation
 * @param {Function} xf transducer to initialize if object is transformer
 * @param {Function} fn default ramda implementation
 * @return {Function} A function that dispatches on object in list position
 */
module.exports = function _dispatchable(methodname, xf, fn) {
  return function() {
    var length = arguments.length;
    if (length === 0) {
      return fn();
    }
    var obj = arguments[length - 1];
    if (!_isArray(obj)) {
      var args = _slice(arguments, 0, length - 1);
      if (typeof obj[methodname] === 'function') {
        return obj[methodname].apply(obj, args);
      }
      if (_isTransformer(obj)) {
        var transducer = xf.apply(null, args);
        return transducer(obj);
      }
    }
    return fn.apply(this, arguments);
  };
};

},{"./_isArray":716,"./_isTransformer":717,"./_slice":720}],712:[function(require,module,exports){
var _has = require('./_has');
var identical = require('../identical');
var keys = require('../keys');
var type = require('../type');

// The algorithm used to handle cyclic structures is
// inspired by underscore's isEqual
module.exports = function _equals(a, b, stackA, stackB) {
  var typeA = type(a);
  if (typeA !== type(b)) {
    return false;
  }

  if (typeA === 'Boolean' || typeA === 'Number' || typeA === 'String') {
    return typeof a === 'object' ?
      typeof b === 'object' && identical(a.valueOf(), b.valueOf()) :
      identical(a, b);
  }

  if (identical(a, b)) {
    return true;
  }

  if (typeA === 'RegExp') {
    // RegExp equality algorithm: http://stackoverflow.com/a/10776635
    return (a.source === b.source) &&
           (a.global === b.global) &&
           (a.ignoreCase === b.ignoreCase) &&
           (a.multiline === b.multiline) &&
           (a.sticky === b.sticky) &&
           (a.unicode === b.unicode);
  }

  if (Object(a) === a) {
    if (typeA === 'Date' && a.getTime() !== b.getTime()) {
      return false;
    }

    var keysA = keys(a);
    if (keysA.length !== keys(b).length) {
      return false;
    }

    var idx = stackA.length - 1;
    while (idx >= 0) {
      if (stackA[idx] === a) {
        return stackB[idx] === b;
      }
      idx -= 1;
    }

    stackA[stackA.length] = a;
    stackB[stackB.length] = b;
    idx = keysA.length - 1;
    while (idx >= 0) {
      var key = keysA[idx];
      if (!_has(key, b) || !_equals(b[key], a[key], stackA, stackB)) {
        return false;
      }
      idx -= 1;
    }
    stackA.pop();
    stackB.pop();
    return true;
  }
  return false;
};

},{"../identical":707,"../keys":724,"../type":728,"./_has":713}],713:[function(require,module,exports){
module.exports = function _has(prop, obj) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
};

},{}],714:[function(require,module,exports){
var _isArray = require('./_isArray');


/**
 * Private function that determines whether or not a provided object has a given method.
 * Does not ignore methods stored on the object's prototype chain. Used for dynamically
 * dispatching Ramda methods to non-Array objects.
 *
 * @private
 * @param {String} methodName The name of the method to check for.
 * @param {Object} obj The object to test.
 * @return {Boolean} `true` has a given method, `false` otherwise.
 * @example
 *
 *      var person = { name: 'John' };
 *      person.shout = function() { alert(this.name); };
 *
 *      _hasMethod('shout', person); //=> true
 *      _hasMethod('foo', person); //=> false
 */
module.exports = function _hasMethod(methodName, obj) {
  return obj != null && !_isArray(obj) && typeof obj[methodName] === 'function';
};

},{"./_isArray":716}],715:[function(require,module,exports){
var equals = require('../equals');


module.exports = function _indexOf(list, item, from) {
  var idx = from;
  while (idx < list.length) {
    if (equals(list[idx], item)) {
      return idx;
    }
    idx += 1;
  }
  return -1;
};

},{"../equals":705}],716:[function(require,module,exports){
/**
 * Tests whether or not an object is an array.
 *
 * @private
 * @param {*} val The object to test.
 * @return {Boolean} `true` if `val` is an array, `false` otherwise.
 * @example
 *
 *      _isArray([]); //=> true
 *      _isArray(null); //=> false
 *      _isArray({}); //=> false
 */
module.exports = Array.isArray || function _isArray(val) {
  return (val != null &&
          val.length >= 0 &&
          Object.prototype.toString.call(val) === '[object Array]');
};

},{}],717:[function(require,module,exports){
module.exports = function _isTransformer(obj) {
  return typeof obj['@@transducer/step'] === 'function';
};

},{}],718:[function(require,module,exports){
module.exports = function _map(fn, list) {
  var idx = 0, len = list.length, result = Array(len);
  while (idx < len) {
    result[idx] = fn(list[idx]);
    idx += 1;
  }
  return result;
};

},{}],719:[function(require,module,exports){
module.exports = function _reduced(x) {
  return x && x['@@transducer/reduced'] ? x :
    {
      '@@transducer/value': x,
      '@@transducer/reduced': true
    };
};

},{}],720:[function(require,module,exports){
/**
 * An optimized, private array `slice` implementation.
 *
 * @private
 * @param {Arguments|Array} args The array or arguments object to consider.
 * @param {Number} [from=0] The array index to slice from, inclusive.
 * @param {Number} [to=args.length] The array index to slice to, exclusive.
 * @return {Array} A new, sliced array.
 * @example
 *
 *      _slice([1, 2, 3, 4, 5], 1, 3); //=> [2, 3]
 *
 *      var firstThreeArgs = function(a, b, c, d) {
 *        return _slice(arguments, 0, 3);
 *      };
 *      firstThreeArgs(1, 2, 3, 4); //=> [1, 2, 3]
 */
module.exports = function _slice(args, from, to) {
  switch (arguments.length) {
    case 1: return _slice(args, 0, args.length);
    case 2: return _slice(args, from, args.length);
    default:
      var list = [];
      var idx = 0;
      var len = Math.max(0, Math.min(args.length, to) - from);
      while (idx < len) {
        list[idx] = args[from + idx];
        idx += 1;
      }
      return list;
  }
};

},{}],721:[function(require,module,exports){
var _curry2 = require('./_curry2');
var _reduced = require('./_reduced');
var _xfBase = require('./_xfBase');


module.exports = (function() {
  function XAll(f, xf) {
    this.xf = xf;
    this.f = f;
    this.all = true;
  }
  XAll.prototype['@@transducer/init'] = _xfBase.init;
  XAll.prototype['@@transducer/result'] = function(result) {
    if (this.all) {
      result = this.xf['@@transducer/step'](result, true);
    }
    return this.xf['@@transducer/result'](result);
  };
  XAll.prototype['@@transducer/step'] = function(result, input) {
    if (!this.f(input)) {
      this.all = false;
      result = _reduced(this.xf['@@transducer/step'](result, false));
    }
    return result;
  };

  return _curry2(function _xall(f, xf) { return new XAll(f, xf); });
})();

},{"./_curry2":710,"./_reduced":719,"./_xfBase":722}],722:[function(require,module,exports){
module.exports = {
  init: function() {
    return this.xf['@@transducer/init']();
  },
  result: function(result) {
    return this.xf['@@transducer/result'](result);
  }
};

},{}],723:[function(require,module,exports){
var _curry2 = require('./_curry2');
var _xfBase = require('./_xfBase');


module.exports = (function() {
  function XMap(f, xf) {
    this.xf = xf;
    this.f = f;
  }
  XMap.prototype['@@transducer/init'] = _xfBase.init;
  XMap.prototype['@@transducer/result'] = _xfBase.result;
  XMap.prototype['@@transducer/step'] = function(result, input) {
    return this.xf['@@transducer/step'](result, this.f(input));
  };

  return _curry2(function _xmap(f, xf) { return new XMap(f, xf); });
})();

},{"./_curry2":710,"./_xfBase":722}],724:[function(require,module,exports){
var _curry1 = require('./internal/_curry1');
var _has = require('./internal/_has');


/**
 * Returns a list containing the names of all the enumerable own
 * properties of the supplied object.
 * Note that the order of the output array is not guaranteed to be
 * consistent across different JS platforms.
 *
 * @func
 * @memberOf R
 * @category Object
 * @sig {k: v} -> [k]
 * @param {Object} obj The object to extract properties from
 * @return {Array} An array of the object's own properties.
 * @example
 *
 *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
 */
module.exports = (function() {
  // cover IE < 9 keys issues
  var hasEnumBug = !({toString: null}).propertyIsEnumerable('toString');
  var nonEnumerableProps = ['constructor', 'valueOf', 'isPrototypeOf', 'toString',
                            'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  var contains = function contains(list, item) {
    var idx = 0;
    while (idx < list.length) {
      if (list[idx] === item) {
        return true;
      }
      idx += 1;
    }
    return false;
  };

  return typeof Object.keys === 'function' ?
    _curry1(function keys(obj) {
      return Object(obj) !== obj ? [] : Object.keys(obj);
    }) :
    _curry1(function keys(obj) {
      if (Object(obj) !== obj) {
        return [];
      }
      var prop, ks = [], nIdx;
      for (prop in obj) {
        if (_has(prop, obj)) {
          ks[ks.length] = prop;
        }
      }
      if (hasEnumBug) {
        nIdx = nonEnumerableProps.length - 1;
        while (nIdx >= 0) {
          prop = nonEnumerableProps[nIdx];
          if (_has(prop, obj) && !contains(ks, prop)) {
            ks[ks.length] = prop;
          }
          nIdx -= 1;
        }
      }
      return ks;
    });
}());

},{"./internal/_curry1":709,"./internal/_has":713}],725:[function(require,module,exports){
var _curry2 = require('./internal/_curry2');
var _dispatchable = require('./internal/_dispatchable');
var _map = require('./internal/_map');
var _xmap = require('./internal/_xmap');


/**
 * Returns a new list, constructed by applying the supplied function to every element of the
 * supplied list.
 *
 * Note: `R.map` does not skip deleted or unassigned indices (sparse arrays), unlike the
 * native `Array.prototype.map` method. For more details on this behavior, see:
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Description
 *
 * Acts as a transducer if a transformer is given in list position.
 * @see R.transduce
 *
 * @func
 * @memberOf R
 * @category List
 * @sig (a -> b) -> [a] -> [b]
 * @param {Function} fn The function to be called on every element of the input `list`.
 * @param {Array} list The list to be iterated over.
 * @return {Array} The new list.
 * @example
 *
 *      var double = function(x) {
 *        return x * 2;
 *      };
 *
 *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]
 */
module.exports = _curry2(_dispatchable('map', _xmap, _map));

},{"./internal/_curry2":710,"./internal/_dispatchable":711,"./internal/_map":718,"./internal/_xmap":723}],726:[function(require,module,exports){
var _curry2 = require('./internal/_curry2');
var map = require('./map');
var prop = require('./prop');


/**
 * Returns a new list by plucking the same named property off all objects in the list supplied.
 *
 * @func
 * @memberOf R
 * @category List
 * @sig k -> [{k: v}] -> [v]
 * @param {Number|String} key The key name to pluck off of each object.
 * @param {Array} list The array to consider.
 * @return {Array} The list of values for the given key.
 * @example
 *
 *      R.pluck('a')([{a: 1}, {a: 2}]); //=> [1, 2]
 *      R.pluck(0)([[1, 2], [3, 4]]);   //=> [1, 3]
 */
module.exports = _curry2(function pluck(p, list) {
  return map(prop(p), list);
});

},{"./internal/_curry2":710,"./map":725,"./prop":727}],727:[function(require,module,exports){
var _curry2 = require('./internal/_curry2');


/**
 * Returns a function that when supplied an object returns the indicated property of that object, if it exists.
 *
 * @func
 * @memberOf R
 * @category Object
 * @sig s -> {s: a} -> a | Undefined
 * @param {String} p The property name
 * @param {Object} obj The object to query
 * @return {*} The value at `obj.p`.
 * @example
 *
 *      R.prop('x', {x: 100}); //=> 100
 *      R.prop('x', {}); //=> undefined
 */
module.exports = _curry2(function prop(p, obj) { return obj[p]; });

},{"./internal/_curry2":710}],728:[function(require,module,exports){
var _curry1 = require('./internal/_curry1');


/**
 * Gives a single-word string description of the (native) type of a value, returning such
 * answers as 'Object', 'Number', 'Array', or 'Null'.  Does not attempt to distinguish user
 * Object types any further, reporting them all as 'Object'.
 *
 * @func
 * @memberOf R
 * @category Type
 * @sig (* -> {*}) -> String
 * @param {*} val The value to test
 * @return {String}
 * @example
 *
 *      R.type({}); //=> "Object"
 *      R.type(1); //=> "Number"
 *      R.type(false); //=> "Boolean"
 *      R.type('s'); //=> "String"
 *      R.type(null); //=> "Null"
 *      R.type([]); //=> "Array"
 *      R.type(/[A-z]/); //=> "RegExp"
 */
module.exports = _curry1(function type(val) {
  return val === null      ? 'Null'      :
         val === undefined ? 'Undefined' :
         Object.prototype.toString.call(val).slice(8, -1);
});

},{"./internal/_curry1":709}],729:[function(require,module,exports){
module.exports = require('react/lib/ReactCSSTransitionGroup');
},{"react/lib/ReactCSSTransitionGroup":854}],730:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = undefined;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _class, _temp2; /**
                     * Adapted from ReactCSSTransitionGroup.js by Facebook
                     *
                     * @providesModule ReactCSSTransitionReplace
                     */

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _ReactCSSTransitionGroupChild = require('react/lib/ReactCSSTransitionGroupChild');

var _ReactCSSTransitionGroupChild2 = _interopRequireDefault(_ReactCSSTransitionGroupChild);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? _defaults(subClass, superClass) : _defaults(subClass, superClass); }

var reactCSSTransitionGroupChild = _react2.default.createFactory(_ReactCSSTransitionGroupChild2.default);

var TICK = 17;

function createTransitionTimeoutPropValidator(transitionType) {
  var timeoutPropName = 'transition' + transitionType + 'Timeout';
  var enabledPropName = 'transition' + transitionType;

  return function (props) {
    // If the transition is enabled
    if (props[enabledPropName]) {
      // If no timeout duration is provided
      if (!props[timeoutPropName]) {
        return new Error(timeoutPropName + ' wasn\'t supplied to ReactCSSTransitionReplace: ' + 'this can cause unreliable animations and won\'t be supported in ' + 'a future version of React. See ' + 'https://fb.me/react-animation-transition-group-timeout for more ' + 'information.');

        // If the duration isn't a number
      } else if (typeof props[timeoutPropName] != 'number') {
        return new Error(timeoutPropName + ' must be a number (in milliseconds)');
      }
    }
  };
}

var ReactCSSTransitionReplace = (_temp2 = _class = function (_React$Component) {
  _inherits(ReactCSSTransitionReplace, _React$Component);

  function ReactCSSTransitionReplace() {
    var _temp, _this, _ret;

    _classCallCheck(this, ReactCSSTransitionReplace);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      currentChild: _this.props.children ? _react2.default.Children.only(_this.props.children) : undefined,
      currentChildKey: _this.props.children ? '1' : '',
      nextChild: undefined,
      nextChildKey: '',
      height: null,
      width: null,
      isLeaving: false
    }, _this._handleDoneAppearing = function () {
      _this.isTransitioning = false;
    }, _this._handleDoneEntering = function () {
      var _this2 = _this;
      var state = _this2.state;


      _this.isTransitioning = false;
      _this.setState({
        currentChild: state.nextChild,
        currentChildKey: state.nextChildKey,
        nextChild: undefined,
        nextChildKey: '',
        height: null,
        width: null
      });
    }, _this._handleDoneLeaving = function () {
      if (_this.isTransitioning) {
        var state = { currentChild: undefined, isLeaving: false };

        if (!_this.state.nextChild) {
          _this.isTransitioning = false;
          state.height = null;
          state.width = null;
        }

        _this.setState(state);
      }
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  ReactCSSTransitionReplace.prototype.componentDidMount = function componentDidMount() {
    if (this.props.transitionAppear && this.state.currentChild) {
      this.appearCurrent();
    }
  };

  ReactCSSTransitionReplace.prototype.componentWillUnmount = function componentWillUnmount() {
    clearTimeout(this.timeout);
  };

  ReactCSSTransitionReplace.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    // Setting false indicates that the child has changed, but it is a removal so there is no next child.
    var nextChild = nextProps.children ? _react2.default.Children.only(nextProps.children) : false;
    var currentChild = this.state.currentChild;

    if (currentChild && nextChild && nextChild.key === currentChild.key) {
      // Nothing changed, but we are re-rendering so update the currentChild.
      return this.setState({
        currentChild: nextChild
      });
    }

    if (!currentChild && !nextChild && this.state.nextChild) {
      // The container was empty before and the entering element is being removed again while
      // transitioning in. Since a CSS transition can't be reversed cleanly midway the height
      // is just forced back to zero immediately and the child removed.
      return this.cancelTransition();
    }

    var state = this.state;

    // Set the next child to start the transition, and set the current height.

    this.setState({
      nextChild: nextChild,
      nextChildKey: state.currentChildKey ? String(Number(state.currentChildKey) + 1) : '1',
      height: state.currentChild ? _reactDom2.default.findDOMNode(this.refs.curr).offsetHeight : 0,
      width: state.currentChild && this.props.changeWidth ? _reactDom2.default.findDOMNode(this.refs.curr).offsetWidth : null
    });

    // Enqueue setting the next height to trigger the height transition.
    this.enqueueHeightTransition(nextChild);
  };

  ReactCSSTransitionReplace.prototype.componentDidUpdate = function componentDidUpdate() {
    if (!this.isTransitioning && !this.state.isLeaving) {
      var _state = this.state;
      var currentChild = _state.currentChild;
      var nextChild = _state.nextChild;


      if (currentChild && (nextChild || nextChild === false || nextChild === null)) {
        this.leaveCurrent();
      }
      if (nextChild) {
        this.enterNext();
      }
    }
  };

  ReactCSSTransitionReplace.prototype.enqueueHeightTransition = function enqueueHeightTransition(nextChild) {
    var _this3 = this;

    var tickCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    this.timeout = setTimeout(function () {
      if (!nextChild) {
        return _this3.setState({
          height: 0,
          width: _this3.props.changeWidth ? 0 : null
        });
      }

      var nextNode = _reactDom2.default.findDOMNode(_this3.refs.next);
      if (nextNode) {
        _this3.setState({
          height: nextNode.offsetHeight,
          width: _this3.props.changeWidth ? nextNode.offsetWidth : null
        });
      } else {
        // The DOM hasn't rendered the entering element yet, so wait another tick.
        // Getting stuck in a loop shouldn't happen, but it's better to be safe.
        if (tickCount < 10) {
          _this3.enqueueHeightTransition(nextChild, tickCount + 1);
        }
      }
    }, TICK);
  };

  ReactCSSTransitionReplace.prototype.appearCurrent = function appearCurrent() {
    this.refs.curr.componentWillAppear(this._handleDoneAppearing);
    this.isTransitioning = true;
  };

  ReactCSSTransitionReplace.prototype.enterNext = function enterNext() {
    this.refs.next.componentWillEnter(this._handleDoneEntering);
    this.isTransitioning = true;
  };

  ReactCSSTransitionReplace.prototype.leaveCurrent = function leaveCurrent() {
    this.refs.curr.componentWillLeave(this._handleDoneLeaving);
    this.isTransitioning = true;
    this.setState({ isLeaving: true });
  };

  // When the leave transition time-out expires the animation classes are removed, so the
  // element must be removed from the DOM if the enter transition is still in progress.


  ReactCSSTransitionReplace.prototype.cancelTransition = function cancelTransition() {
    this.isTransitioning = false;
    clearTimeout(this.timeout);
    return this.setState({
      nextChild: undefined,
      nextChildKey: '',
      height: null,
      width: null
    });
  };

  ReactCSSTransitionReplace.prototype._wrapChild = function _wrapChild(child, moreProps) {
    var transitionName = this.props.transitionName;

    if ((typeof transitionName === 'undefined' ? 'undefined' : _typeof(transitionName)) == 'object' && transitionName !== null) {
      transitionName = _extends({}, transitionName);
      delete transitionName.height;
    }

    // We need to provide this childFactory so that
    // ReactCSSTransitionReplaceChild can receive updates to name,
    // enter, and leave while it is leaving.
    return reactCSSTransitionGroupChild(_extends({
      name: transitionName,
      appear: this.props.transitionAppear,
      enter: this.props.transitionEnter,
      leave: this.props.transitionLeave,
      appearTimeout: this.props.transitionAppearTimeout,
      enterTimeout: this.props.transitionEnterTimeout,
      leaveTimeout: this.props.transitionLeaveTimeout
    }, moreProps), child);
  };

  ReactCSSTransitionReplace.prototype.render = function render() {
    var _state2 = this.state;
    var currentChild = _state2.currentChild;
    var currentChildKey = _state2.currentChildKey;
    var nextChild = _state2.nextChild;
    var nextChildKey = _state2.nextChildKey;
    var height = _state2.height;
    var width = _state2.width;
    var isLeaving = _state2.isLeaving;

    var childrenToRender = [];

    var _props = this.props;
    var overflowHidden = _props.overflowHidden;
    var transitionName = _props.transitionName;
    var component = _props.component;
    var transitionAppear = _props.transitionAppear;
    var transitionEnter = _props.transitionEnter;
    var transitionLeave = _props.transitionLeave;
    var changeWidth = _props.changeWidth;
    var transitionAppearTimeout = _props.transitionAppearTimeout;
    var transitionEnterTimeout = _props.transitionEnterTimeout;
    var transitionLeaveTimeout = _props.transitionLeaveTimeout;

    var containerProps = _objectWithoutProperties(_props, ['overflowHidden', 'transitionName', 'component', 'transitionAppear', 'transitionEnter', 'transitionLeave', 'changeWidth', 'transitionAppearTimeout', 'transitionEnterTimeout', 'transitionLeaveTimeout']);

    if (currentChild) {
      childrenToRender.push(_react2.default.createElement('span', { key: currentChildKey }, this._wrapChild(typeof currentChild.type == 'string' ? currentChild : _react2.default.cloneElement(currentChild, { isLeaving: isLeaving }), { ref: 'curr' })));
    }

    if (height !== null) {
      var heightClassName = (typeof transitionName === 'undefined' ? 'undefined' : _typeof(transitionName)) == 'object' && transitionName !== null ? transitionName.height || '' : String(transitionName) + '-height';

      containerProps.className = String(containerProps.className || '') + ' ' + String(heightClassName);
      containerProps.style = _extends({}, containerProps.style, {
        position: 'relative',
        display: 'block',
        height: height
      });

      if (overflowHidden) {
        containerProps.style.overflow = 'hidden';
      }

      if (changeWidth) {
        containerProps.style.width = width;
      }
    }

    if (nextChild) {
      childrenToRender.push(_react2.default.createElement('span', {
        style: {
          position: 'absolute',
          top: 0,
          left: 0,
          right: 0,
          bottom: 0
        },
        key: nextChildKey
      }, this._wrapChild(nextChild, { ref: 'next' })));
    }

    return _react2.default.createElement(component, containerProps, childrenToRender);
  };

  return ReactCSSTransitionReplace;
}(_react2.default.Component), _class.displayName = 'ReactCSSTransitionReplace', _class.defaultProps = {
  transitionAppear: false,
  transitionEnter: true,
  transitionLeave: true,
  overflowHidden: true,
  component: 'span',
  changeWidth: false
}, _temp2);
exports.default = ReactCSSTransitionReplace;
module.exports = exports['default'];
},{"react":879,"react-dom":731,"react/lib/ReactCSSTransitionGroupChild":855}],731:[function(require,module,exports){
'use strict';

module.exports = require('./lib/ReactDOM');

},{"./lib/ReactDOM":761}],732:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ARIADOMPropertyConfig = {
  Properties: {
    // Global States and Properties
    'aria-current': 0, // state
    'aria-details': 0,
    'aria-disabled': 0, // state
    'aria-hidden': 0, // state
    'aria-invalid': 0, // state
    'aria-keyshortcuts': 0,
    'aria-label': 0,
    'aria-roledescription': 0,
    // Widget Attributes
    'aria-autocomplete': 0,
    'aria-checked': 0,
    'aria-expanded': 0,
    'aria-haspopup': 0,
    'aria-level': 0,
    'aria-modal': 0,
    'aria-multiline': 0,
    'aria-multiselectable': 0,
    'aria-orientation': 0,
    'aria-placeholder': 0,
    'aria-pressed': 0,
    'aria-readonly': 0,
    'aria-required': 0,
    'aria-selected': 0,
    'aria-sort': 0,
    'aria-valuemax': 0,
    'aria-valuemin': 0,
    'aria-valuenow': 0,
    'aria-valuetext': 0,
    // Live Region Attributes
    'aria-atomic': 0,
    'aria-busy': 0,
    'aria-live': 0,
    'aria-relevant': 0,
    // Drag-and-Drop Attributes
    'aria-dropeffect': 0,
    'aria-grabbed': 0,
    // Relationship Attributes
    'aria-activedescendant': 0,
    'aria-colcount': 0,
    'aria-colindex': 0,
    'aria-colspan': 0,
    'aria-controls': 0,
    'aria-describedby': 0,
    'aria-errormessage': 0,
    'aria-flowto': 0,
    'aria-labelledby': 0,
    'aria-owns': 0,
    'aria-posinset': 0,
    'aria-rowcount': 0,
    'aria-rowindex': 0,
    'aria-rowspan': 0,
    'aria-setsize': 0
  },
  DOMAttributeNames: {},
  DOMPropertyNames: {}
};

module.exports = ARIADOMPropertyConfig;
},{}],733:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ReactDOMComponentTree = require('./ReactDOMComponentTree');

var focusNode = require('fbjs/lib/focusNode');

var AutoFocusUtils = {
  focusDOMComponent: function () {
    focusNode(ReactDOMComponentTree.getNodeFromInstance(this));
  }
};

module.exports = AutoFocusUtils;
},{"./ReactDOMComponentTree":764,"fbjs/lib/focusNode":596}],734:[function(require,module,exports){
/**
 * Copyright 2013-present Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var EventPropagators = require('./EventPropagators');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var FallbackCompositionState = require('./FallbackCompositionState');
var SyntheticCompositionEvent = require('./SyntheticCompositionEvent');
var SyntheticInputEvent = require('./SyntheticInputEvent');

var END_KEYCODES = [9, 13, 27, 32]; // Tab, Return, Esc, Space
var START_KEYCODE = 229;

var canUseCompositionEvent = ExecutionEnvironment.canUseDOM && 'CompositionEvent' in window;

var documentMode = null;
if (ExecutionEnvironment.canUseDOM && 'documentMode' in document) {
  documentMode = document.documentMode;
}

// Webkit offers a very useful `textInput` event that can be used to
// directly represent `beforeInput`. The IE `textinput` event is not as
// useful, so we don't use it.
var canUseTextInputEvent = ExecutionEnvironment.canUseDOM && 'TextEvent' in window && !documentMode && !isPresto();

// In IE9+, we have access to composition events, but the data supplied
// by the native compositionend event may be incorrect. Japanese ideographic
// spaces, for instance (\u3000) are not recorded correctly.
var useFallbackCompositionData = ExecutionEnvironment.canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);

/**
 * Opera <= 12 includes TextEvent in window, but does not fire
 * text input events. Rely on keypress instead.
 */
function isPresto() {
  var opera = window.opera;
  return typeof opera === 'object' && typeof opera.version === 'function' && parseInt(opera.version(), 10) <= 12;
}

var SPACEBAR_CODE = 32;
var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);

// Events and their corresponding property names.
var eventTypes = {
  beforeInput: {
    phasedRegistrationNames: {
      bubbled: 'onBeforeInput',
      captured: 'onBeforeInputCapture'
    },
    dependencies: ['topCompositionEnd', 'topKeyPress', 'topTextInput', 'topPaste']
  },
  compositionEnd: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionEnd',
      captured: 'onCompositionEndCapture'
    },
    dependencies: ['topBlur', 'topCompositionEnd', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  },
  compositionStart: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionStart',
      captured: 'onCompositionStartCapture'
    },
    dependencies: ['topBlur', 'topCompositionStart', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  },
  compositionUpdate: {
    phasedRegistrationNames: {
      bubbled: 'onCompositionUpdate',
      captured: 'onCompositionUpdateCapture'
    },
    dependencies: ['topBlur', 'topCompositionUpdate', 'topKeyDown', 'topKeyPress', 'topKeyUp', 'topMouseDown']
  }
};

// Track whether we've ever handled a keypress on the space key.
var hasSpaceKeypress = false;

/**
 * Return whether a native keypress event is assumed to be a command.
 * This is required because Firefox fires `keypress` events for key commands
 * (cut, copy, select-all, etc.) even though no character is inserted.
 */
function isKeypressCommand(nativeEvent) {
  return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) &&
  // ctrlKey && altKey is equivalent to AltGr, and is not a command.
  !(nativeEvent.ctrlKey && nativeEvent.altKey);
}

/**
 * Translate native top level events into event types.
 *
 * @param {string} topLevelType
 * @return {object}
 */
function getCompositionEventType(topLevelType) {
  switch (topLevelType) {
    case 'topCompositionStart':
      return eventTypes.compositionStart;
    case 'topCompositionEnd':
      return eventTypes.compositionEnd;
    case 'topCompositionUpdate':
      return eventTypes.compositionUpdate;
  }
}

/**
 * Does our fallback best-guess model think this event signifies that
 * composition has begun?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionStart(topLevelType, nativeEvent) {
  return topLevelType === 'topKeyDown' && nativeEvent.keyCode === START_KEYCODE;
}

/**
 * Does our fallback mode think that this event is the end of composition?
 *
 * @param {string} topLevelType
 * @param {object} nativeEvent
 * @return {boolean}
 */
function isFallbackCompositionEnd(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case 'topKeyUp':
      // Command keys insert or clear IME input.
      return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
    case 'topKeyDown':
      // Expect IME keyCode on each keydown. If we get any other
      // code we must have exited earlier.
      return nativeEvent.keyCode !== START_KEYCODE;
    case 'topKeyPress':
    case 'topMouseDown':
    case 'topBlur':
      // Events are not possible without cancelling IME.
      return true;
    default:
      return false;
  }
}

/**
 * Google Input Tools provides composition data via a CustomEvent,
 * with the `data` property populated in the `detail` object. If this
 * is available on the event object, use it. If not, this is a plain
 * composition event and we have nothing special to extract.
 *
 * @param {object} nativeEvent
 * @return {?string}
 */
function getDataFromCustomEvent(nativeEvent) {
  var detail = nativeEvent.detail;
  if (typeof detail === 'object' && 'data' in detail) {
    return detail.data;
  }
  return null;
}

// Track the current IME composition fallback object, if any.
var currentComposition = null;

/**
 * @return {?object} A SyntheticCompositionEvent.
 */
function extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var eventType;
  var fallbackData;

  if (canUseCompositionEvent) {
    eventType = getCompositionEventType(topLevelType);
  } else if (!currentComposition) {
    if (isFallbackCompositionStart(topLevelType, nativeEvent)) {
      eventType = eventTypes.compositionStart;
    }
  } else if (isFallbackCompositionEnd(topLevelType, nativeEvent)) {
    eventType = eventTypes.compositionEnd;
  }

  if (!eventType) {
    return null;
  }

  if (useFallbackCompositionData) {
    // The current composition is stored statically and must not be
    // overwritten while composition continues.
    if (!currentComposition && eventType === eventTypes.compositionStart) {
      currentComposition = FallbackCompositionState.getPooled(nativeEventTarget);
    } else if (eventType === eventTypes.compositionEnd) {
      if (currentComposition) {
        fallbackData = currentComposition.getData();
      }
    }
  }

  var event = SyntheticCompositionEvent.getPooled(eventType, targetInst, nativeEvent, nativeEventTarget);

  if (fallbackData) {
    // Inject data generated from fallback path into the synthetic event.
    // This matches the property of native CompositionEventInterface.
    event.data = fallbackData;
  } else {
    var customData = getDataFromCustomEvent(nativeEvent);
    if (customData !== null) {
      event.data = customData;
    }
  }

  EventPropagators.accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The string corresponding to this `beforeInput` event.
 */
function getNativeBeforeInputChars(topLevelType, nativeEvent) {
  switch (topLevelType) {
    case 'topCompositionEnd':
      return getDataFromCustomEvent(nativeEvent);
    case 'topKeyPress':
      /**
       * If native `textInput` events are available, our goal is to make
       * use of them. However, there is a special case: the spacebar key.
       * In Webkit, preventing default on a spacebar `textInput` event
       * cancels character insertion, but it *also* causes the browser
       * to fall back to its default spacebar behavior of scrolling the
       * page.
       *
       * Tracking at:
       * https://code.google.com/p/chromium/issues/detail?id=355103
       *
       * To avoid this issue, use the keypress event as if no `textInput`
       * event is available.
       */
      var which = nativeEvent.which;
      if (which !== SPACEBAR_CODE) {
        return null;
      }

      hasSpaceKeypress = true;
      return SPACEBAR_CHAR;

    case 'topTextInput':
      // Record the characters to be added to the DOM.
      var chars = nativeEvent.data;

      // If it's a spacebar character, assume that we have already handled
      // it at the keypress level and bail immediately. Android Chrome
      // doesn't give us keycodes, so we need to blacklist it.
      if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
        return null;
      }

      return chars;

    default:
      // For other native event types, do nothing.
      return null;
  }
}

/**
 * For browsers that do not provide the `textInput` event, extract the
 * appropriate string to use for SyntheticInputEvent.
 *
 * @param {string} topLevelType Record from `EventConstants`.
 * @param {object} nativeEvent Native browser event.
 * @return {?string} The fallback string for this `beforeInput` event.
 */
function getFallbackBeforeInputChars(topLevelType, nativeEvent) {
  // If we are currently composing (IME) and using a fallback to do so,
  // try to extract the composed characters from the fallback object.
  // If composition event is available, we extract a string only at
  // compositionevent, otherwise extract it at fallback events.
  if (currentComposition) {
    if (topLevelType === 'topCompositionEnd' || !canUseCompositionEvent && isFallbackCompositionEnd(topLevelType, nativeEvent)) {
      var chars = currentComposition.getData();
      FallbackCompositionState.release(currentComposition);
      currentComposition = null;
      return chars;
    }
    return null;
  }

  switch (topLevelType) {
    case 'topPaste':
      // If a paste event occurs after a keypress, throw out the input
      // chars. Paste events should not lead to BeforeInput events.
      return null;
    case 'topKeyPress':
      /**
       * As of v27, Firefox may fire keypress events even when no character
       * will be inserted. A few possibilities:
       *
       * - `which` is `0`. Arrow keys, Esc key, etc.
       *
       * - `which` is the pressed key code, but no char is available.
       *   Ex: 'AltGr + d` in Polish. There is no modified character for
       *   this key combination and no character is inserted into the
       *   document, but FF fires the keypress for char code `100` anyway.
       *   No `input` event will occur.
       *
       * - `which` is the pressed key code, but a command combination is
       *   being used. Ex: `Cmd+C`. No character is inserted, and no
       *   `input` event will occur.
       */
      if (nativeEvent.which && !isKeypressCommand(nativeEvent)) {
        return String.fromCharCode(nativeEvent.which);
      }
      return null;
    case 'topCompositionEnd':
      return useFallbackCompositionData ? null : nativeEvent.data;
    default:
      return null;
  }
}

/**
 * Extract a SyntheticInputEvent for `beforeInput`, based on either native
 * `textInput` or fallback behavior.
 *
 * @return {?object} A SyntheticInputEvent.
 */
function extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget) {
  var chars;

  if (canUseTextInputEvent) {
    chars = getNativeBeforeInputChars(topLevelType, nativeEvent);
  } else {
    chars = getFallbackBeforeInputChars(topLevelType, nativeEvent);
  }

  // If no characters are being inserted, no BeforeInput event should
  // be fired.
  if (!chars) {
    return null;
  }

  var event = SyntheticInputEvent.getPooled(eventTypes.beforeInput, targetInst, nativeEvent, nativeEventTarget);

  event.data = chars;
  EventPropagators.accumulateTwoPhaseDispatches(event);
  return event;
}

/**
 * Create an `onBeforeInput` event to match
 * http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105/#events-inputevents.
 *
 * This event plugin is based on the native `textInput` event
 * available in Chrome, Safari, Opera, and IE. This event fires after
 * `onKeyPress` and `onCompositionEnd`, but before `onInput`.
 *
 * `beforeInput` is spec'd but not implemented in any browsers, and
 * the `input` event does not provide any useful information about what has
 * actually been added, contrary to the spec. Thus, `textInput` is the best
 * available event to identify the characters that have actually been inserted
 * into the target node.
 *
 * This plugin is also responsible for emitting `composition` events, thus
 * allowing us to share composition fallback code for both `beforeInput` and
 * `composition` event types.
 */
var BeforeInputEventPlugin = {

  eventTypes: eventTypes,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    return [extractCompositionEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget), extractBeforeInputEvent(topLevelType, targetInst, nativeEvent, nativeEventTarget)];
  }
};

module.exports = BeforeInputEventPlugin;
},{"./EventPropagators":750,"./FallbackCompositionState":751,"./SyntheticCompositionEvent":808,"./SyntheticInputEvent":812,"fbjs/lib/ExecutionEnvironment":588}],735:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

/**
 * CSS properties which accept numbers but are not in units of "px".
 */

var isUnitlessNumber = {
  animationIterationCount: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridRow: true,
  gridColumn: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,

  // SVG-related properties
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
};

/**
 * @param {string} prefix vendor-specific prefix, eg: Webkit
 * @param {string} key style name, eg: transitionDuration
 * @return {string} style name prefixed with `prefix`, properly camelCased, eg:
 * WebkitTransitionDuration
 */
function prefixKey(prefix, key) {
  return prefix + key.charAt(0).toUpperCase() + key.substring(1);
}

/**
 * Support style names that may come passed in prefixed by adding permutations
 * of vendor prefixes.
 */
var prefixes = ['Webkit', 'ms', 'Moz', 'O'];

// Using Object.keys here, or else the vanilla for-in loop makes IE8 go into an
// infinite loop, because it iterates over the newly added props too.
Object.keys(isUnitlessNumber).forEach(function (prop) {
  prefixes.forEach(function (prefix) {
    isUnitlessNumber[prefixKey(prefix, prop)] = isUnitlessNumber[prop];
  });
});

/**
 * Most style properties can be unset by doing .style[prop] = '' but IE8
 * doesn't like doing that with shorthand properties so for the properties that
 * IE8 breaks on, which are listed here, we instead unset each of the
 * individual properties. See http://bugs.jquery.com/ticket/12385.
 * The 4-value 'clock' properties like margin, padding, border-width seem to
 * behave without any problems. Curiously, list-style works too without any
 * special prodding.
 */
var shorthandPropertyExpansions = {
  background: {
    backgroundAttachment: true,
    backgroundColor: true,
    backgroundImage: true,
    backgroundPositionX: true,
    backgroundPositionY: true,
    backgroundRepeat: true
  },
  backgroundPosition: {
    backgroundPositionX: true,
    backgroundPositionY: true
  },
  border: {
    borderWidth: true,
    borderStyle: true,
    borderColor: true
  },
  borderBottom: {
    borderBottomWidth: true,
    borderBottomStyle: true,
    borderBottomColor: true
  },
  borderLeft: {
    borderLeftWidth: true,
    borderLeftStyle: true,
    borderLeftColor: true
  },
  borderRight: {
    borderRightWidth: true,
    borderRightStyle: true,
    borderRightColor: true
  },
  borderTop: {
    borderTopWidth: true,
    borderTopStyle: true,
    borderTopColor: true
  },
  font: {
    fontStyle: true,
    fontVariant: true,
    fontWeight: true,
    fontSize: true,
    lineHeight: true,
    fontFamily: true
  },
  outline: {
    outlineWidth: true,
    outlineStyle: true,
    outlineColor: true
  }
};

var CSSProperty = {
  isUnitlessNumber: isUnitlessNumber,
  shorthandPropertyExpansions: shorthandPropertyExpansions
};

module.exports = CSSProperty;
},{}],736:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var CSSProperty = require('./CSSProperty');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var ReactInstrumentation = require('./ReactInstrumentation');

var camelizeStyleName = require('fbjs/lib/camelizeStyleName');
var dangerousStyleValue = require('./dangerousStyleValue');
var hyphenateStyleName = require('fbjs/lib/hyphenateStyleName');
var memoizeStringOnly = require('fbjs/lib/memoizeStringOnly');
var warning = require('fbjs/lib/warning');

var processStyleName = memoizeStringOnly(function (styleName) {
  return hyphenateStyleName(styleName);
});

var hasShorthandPropertyBug = false;
var styleFloatAccessor = 'cssFloat';
if (ExecutionEnvironment.canUseDOM) {
  var tempStyle = document.createElement('div').style;
  try {
    // IE8 throws "Invalid argument." if resetting shorthand style properties.
    tempStyle.font = '';
  } catch (e) {
    hasShorthandPropertyBug = true;
  }
  // IE8 only supports accessing cssFloat (standard) as styleFloat
  if (document.documentElement.style.cssFloat === undefined) {
    styleFloatAccessor = 'styleFloat';
  }
}

/**
 * Operations for dealing with CSS properties.
 */
var CSSPropertyOperations = {

  /**
   * Serializes a mapping of style properties for use as inline styles:
   *
   *   > createMarkupForStyles({width: '200px', height: 0})
   *   "width:200px;height:0;"
   *
   * Undefined values are ignored so that declarative programming is easier.
   * The result should be HTML-escaped before insertion into the DOM.
   *
   * @param {object} styles
   * @param {ReactDOMComponent} component
   * @return {?string}
   */
  createMarkupForStyles: function (styles, component) {
    var serialized = '';
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      var styleValue = styles[styleName];
      if (styleValue != null) {
        serialized += processStyleName(styleName) + ':';
        serialized += dangerousStyleValue(styleName, styleValue, component) + ';';
      }
    }
    return serialized || null;
  },

  /**
   * Sets the value for multiple styles on a node.  If a value is specified as
   * '' (empty string), the corresponding style property will be unset.
   *
   * @param {DOMElement} node
   * @param {object} styles
   * @param {ReactDOMComponent} component
   */
  setValueForStyles: function (node, styles, component) {
    var style = node.style;
    for (var styleName in styles) {
      if (!styles.hasOwnProperty(styleName)) {
        continue;
      }
      var styleValue = dangerousStyleValue(styleName, styles[styleName], component);
      if (styleName === 'float' || styleName === 'cssFloat') {
        styleName = styleFloatAccessor;
      }
      if (styleValue) {
        style[styleName] = styleValue;
      } else {
        var expansion = hasShorthandPropertyBug && CSSProperty.shorthandPropertyExpansions[styleName];
        if (expansion) {
          // Shorthand property that IE8 won't like unsetting, so unset each
          // component to placate it
          for (var individualStyleName in expansion) {
            style[individualStyleName] = '';
          }
        } else {
          style[styleName] = '';
        }
      }
    }
  }

};

module.exports = CSSPropertyOperations;
},{"./CSSProperty":735,"./ReactInstrumentation":788,"./dangerousStyleValue":824,"fbjs/lib/ExecutionEnvironment":588,"fbjs/lib/camelizeStyleName":590,"fbjs/lib/hyphenateStyleName":601,"fbjs/lib/memoizeStringOnly":605,"fbjs/lib/warning":607}],737:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var PooledClass = require('./PooledClass');

var invariant = require('fbjs/lib/invariant');

/**
 * A specialized pseudo-event module to help keep track of components waiting to
 * be notified when their DOM representations are available for use.
 *
 * This implements `PooledClass`, so you should never need to instantiate this.
 * Instead, use `CallbackQueue.getPooled()`.
 *
 * @class ReactMountReady
 * @implements PooledClass
 * @internal
 */

var CallbackQueue = function () {
  function CallbackQueue(arg) {
    _classCallCheck(this, CallbackQueue);

    this._callbacks = null;
    this._contexts = null;
    this._arg = arg;
  }

  /**
   * Enqueues a callback to be invoked when `notifyAll` is invoked.
   *
   * @param {function} callback Invoked when `notifyAll` is invoked.
   * @param {?object} context Context to call `callback` with.
   * @internal
   */


  CallbackQueue.prototype.enqueue = function enqueue(callback, context) {
    this._callbacks = this._callbacks || [];
    this._callbacks.push(callback);
    this._contexts = this._contexts || [];
    this._contexts.push(context);
  };

  /**
   * Invokes all enqueued callbacks and clears the queue. This is invoked after
   * the DOM representation of a component has been created or updated.
   *
   * @internal
   */


  CallbackQueue.prototype.notifyAll = function notifyAll() {
    var callbacks = this._callbacks;
    var contexts = this._contexts;
    var arg = this._arg;
    if (callbacks && contexts) {
      !(callbacks.length === contexts.length) ? _prodInvariant('24') : void 0;
      this._callbacks = null;
      this._contexts = null;
      for (var i = 0; i < callbacks.length; i++) {
        callbacks[i].call(contexts[i], arg);
      }
      callbacks.length = 0;
      contexts.length = 0;
    }
  };

  CallbackQueue.prototype.checkpoint = function checkpoint() {
    return this._callbacks ? this._callbacks.length : 0;
  };

  CallbackQueue.prototype.rollback = function rollback(len) {
    if (this._callbacks && this._contexts) {
      this._callbacks.length = len;
      this._contexts.length = len;
    }
  };

  /**
   * Resets the internal queue.
   *
   * @internal
   */


  CallbackQueue.prototype.reset = function reset() {
    this._callbacks = null;
    this._contexts = null;
  };

  /**
   * `PooledClass` looks for this.
   */


  CallbackQueue.prototype.destructor = function destructor() {
    this.reset();
  };

  return CallbackQueue;
}();

module.exports = PooledClass.addPoolingTo(CallbackQueue);
},{"./PooledClass":755,"./reactProdInvariant":843,"fbjs/lib/invariant":602}],738:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var EventPluginHub = require('./EventPluginHub');
var EventPropagators = require('./EventPropagators');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactUpdates = require('./ReactUpdates');
var SyntheticEvent = require('./SyntheticEvent');

var getEventTarget = require('./getEventTarget');
var isEventSupported = require('./isEventSupported');
var isTextInputElement = require('./isTextInputElement');

var eventTypes = {
  change: {
    phasedRegistrationNames: {
      bubbled: 'onChange',
      captured: 'onChangeCapture'
    },
    dependencies: ['topBlur', 'topChange', 'topClick', 'topFocus', 'topInput', 'topKeyDown', 'topKeyUp', 'topSelectionChange']
  }
};

/**
 * For IE shims
 */
var activeElement = null;
var activeElementInst = null;
var activeElementValue = null;
var activeElementValueProp = null;

/**
 * SECTION: handle `change` event
 */
function shouldUseChangeEvent(elem) {
  var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
  return nodeName === 'select' || nodeName === 'input' && elem.type === 'file';
}

var doesChangeEventBubble = false;
if (ExecutionEnvironment.canUseDOM) {
  // See `handleChange` comment below
  doesChangeEventBubble = isEventSupported('change') && (!document.documentMode || document.documentMode > 8);
}

function manualDispatchChangeEvent(nativeEvent) {
  var event = SyntheticEvent.getPooled(eventTypes.change, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
  EventPropagators.accumulateTwoPhaseDispatches(event);

  // If change and propertychange bubbled, we'd just bind to it like all the
  // other events and have it go through ReactBrowserEventEmitter. Since it
  // doesn't, we manually listen for the events and so we have to enqueue and
  // process the abstract event manually.
  //
  // Batching is necessary here in order to ensure that all event handlers run
  // before the next rerender (including event handlers attached to ancestor
  // elements instead of directly on the input). Without this, controlled
  // components don't work properly in conjunction with event bubbling because
  // the component is rerendered and the value reverted before all the event
  // handlers can run. See https://github.com/facebook/react/issues/708.
  ReactUpdates.batchedUpdates(runEventInBatch, event);
}

function runEventInBatch(event) {
  EventPluginHub.enqueueEvents(event);
  EventPluginHub.processEventQueue(false);
}

function startWatchingForChangeEventIE8(target, targetInst) {
  activeElement = target;
  activeElementInst = targetInst;
  activeElement.attachEvent('onchange', manualDispatchChangeEvent);
}

function stopWatchingForChangeEventIE8() {
  if (!activeElement) {
    return;
  }
  activeElement.detachEvent('onchange', manualDispatchChangeEvent);
  activeElement = null;
  activeElementInst = null;
}

function getTargetInstForChangeEvent(topLevelType, targetInst) {
  if (topLevelType === 'topChange') {
    return targetInst;
  }
}
function handleEventsForChangeEventIE8(topLevelType, target, targetInst) {
  if (topLevelType === 'topFocus') {
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForChangeEventIE8();
    startWatchingForChangeEventIE8(target, targetInst);
  } else if (topLevelType === 'topBlur') {
    stopWatchingForChangeEventIE8();
  }
}

/**
 * SECTION: handle `input` event
 */
var isInputEventSupported = false;
if (ExecutionEnvironment.canUseDOM) {
  // IE9 claims to support the input event but fails to trigger it when
  // deleting text, so we ignore its input events.
  // IE10+ fire input events to often, such when a placeholder
  // changes or when an input with a placeholder is focused.
  isInputEventSupported = isEventSupported('input') && (!document.documentMode || document.documentMode > 11);
}

/**
 * (For IE <=11) Replacement getter/setter for the `value` property that gets
 * set on the active element.
 */
var newValueProp = {
  get: function () {
    return activeElementValueProp.get.call(this);
  },
  set: function (val) {
    // Cast to a string so we can do equality checks.
    activeElementValue = '' + val;
    activeElementValueProp.set.call(this, val);
  }
};

/**
 * (For IE <=11) Starts tracking propertychange events on the passed-in element
 * and override the value property so that we can distinguish user events from
 * value changes in JS.
 */
function startWatchingForValueChange(target, targetInst) {
  activeElement = target;
  activeElementInst = targetInst;
  activeElementValue = target.value;
  activeElementValueProp = Object.getOwnPropertyDescriptor(target.constructor.prototype, 'value');

  // Not guarded in a canDefineProperty check: IE8 supports defineProperty only
  // on DOM elements
  Object.defineProperty(activeElement, 'value', newValueProp);
  if (activeElement.attachEvent) {
    activeElement.attachEvent('onpropertychange', handlePropertyChange);
  } else {
    activeElement.addEventListener('propertychange', handlePropertyChange, false);
  }
}

/**
 * (For IE <=11) Removes the event listeners from the currently-tracked element,
 * if any exists.
 */
function stopWatchingForValueChange() {
  if (!activeElement) {
    return;
  }

  // delete restores the original property definition
  delete activeElement.value;

  if (activeElement.detachEvent) {
    activeElement.detachEvent('onpropertychange', handlePropertyChange);
  } else {
    activeElement.removeEventListener('propertychange', handlePropertyChange, false);
  }

  activeElement = null;
  activeElementInst = null;
  activeElementValue = null;
  activeElementValueProp = null;
}

/**
 * (For IE <=11) Handles a propertychange event, sending a `change` event if
 * the value of the active element has changed.
 */
function handlePropertyChange(nativeEvent) {
  if (nativeEvent.propertyName !== 'value') {
    return;
  }
  var value = nativeEvent.srcElement.value;
  if (value === activeElementValue) {
    return;
  }
  activeElementValue = value;

  manualDispatchChangeEvent(nativeEvent);
}

/**
 * If a `change` event should be fired, returns the target's ID.
 */
function getTargetInstForInputEvent(topLevelType, targetInst) {
  if (topLevelType === 'topInput') {
    // In modern browsers (i.e., not IE8 or IE9), the input event is exactly
    // what we want so fall through here and trigger an abstract event
    return targetInst;
  }
}

function handleEventsForInputEventIE(topLevelType, target, targetInst) {
  if (topLevelType === 'topFocus') {
    // In IE8, we can capture almost all .value changes by adding a
    // propertychange handler and looking for events with propertyName
    // equal to 'value'
    // In IE9-11, propertychange fires for most input events but is buggy and
    // doesn't fire when text is deleted, but conveniently, selectionchange
    // appears to fire in all of the remaining cases so we catch those and
    // forward the event if the value has changed
    // In either case, we don't want to call the event handler if the value
    // is changed from JS so we redefine a setter for `.value` that updates
    // our activeElementValue variable, allowing us to ignore those changes
    //
    // stopWatching() should be a noop here but we call it just in case we
    // missed a blur event somehow.
    stopWatchingForValueChange();
    startWatchingForValueChange(target, targetInst);
  } else if (topLevelType === 'topBlur') {
    stopWatchingForValueChange();
  }
}

// For IE8 and IE9.
function getTargetInstForInputEventIE(topLevelType, targetInst) {
  if (topLevelType === 'topSelectionChange' || topLevelType === 'topKeyUp' || topLevelType === 'topKeyDown') {
    // On the selectionchange event, the target is just document which isn't
    // helpful for us so just check activeElement instead.
    //
    // 99% of the time, keydown and keyup aren't necessary. IE8 fails to fire
    // propertychange on the first input event after setting `value` from a
    // script and fires only keydown, keypress, keyup. Catching keyup usually
    // gets it and catching keydown lets us fire an event for the first
    // keystroke if user does a key repeat (it'll be a little delayed: right
    // before the second keystroke). Other input methods (e.g., paste) seem to
    // fire selectionchange normally.
    if (activeElement && activeElement.value !== activeElementValue) {
      activeElementValue = activeElement.value;
      return activeElementInst;
    }
  }
}

/**
 * SECTION: handle `click` event
 */
function shouldUseClickEvent(elem) {
  // Use the `click` event to detect changes to checkbox and radio inputs.
  // This approach works across all browsers, whereas `change` does not fire
  // until `blur` in IE8.
  return elem.nodeName && elem.nodeName.toLowerCase() === 'input' && (elem.type === 'checkbox' || elem.type === 'radio');
}

function getTargetInstForClickEvent(topLevelType, targetInst) {
  if (topLevelType === 'topClick') {
    return targetInst;
  }
}

/**
 * This plugin creates an `onChange` event that normalizes change events
 * across form elements. This event fires at a time when it's possible to
 * change the element's value without seeing a flicker.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - select
 */
var ChangeEventPlugin = {

  eventTypes: eventTypes,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;

    var getTargetInstFunc, handleEventFunc;
    if (shouldUseChangeEvent(targetNode)) {
      if (doesChangeEventBubble) {
        getTargetInstFunc = getTargetInstForChangeEvent;
      } else {
        handleEventFunc = handleEventsForChangeEventIE8;
      }
    } else if (isTextInputElement(targetNode)) {
      if (isInputEventSupported) {
        getTargetInstFunc = getTargetInstForInputEvent;
      } else {
        getTargetInstFunc = getTargetInstForInputEventIE;
        handleEventFunc = handleEventsForInputEventIE;
      }
    } else if (shouldUseClickEvent(targetNode)) {
      getTargetInstFunc = getTargetInstForClickEvent;
    }

    if (getTargetInstFunc) {
      var inst = getTargetInstFunc(topLevelType, targetInst);
      if (inst) {
        var event = SyntheticEvent.getPooled(eventTypes.change, inst, nativeEvent, nativeEventTarget);
        event.type = 'change';
        EventPropagators.accumulateTwoPhaseDispatches(event);
        return event;
      }
    }

    if (handleEventFunc) {
      handleEventFunc(topLevelType, targetNode, targetInst);
    }
  }

};

module.exports = ChangeEventPlugin;
},{"./EventPluginHub":747,"./EventPropagators":750,"./ReactDOMComponentTree":764,"./ReactUpdates":801,"./SyntheticEvent":810,"./getEventTarget":832,"./isEventSupported":840,"./isTextInputElement":841,"fbjs/lib/ExecutionEnvironment":588}],739:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var DOMLazyTree = require('./DOMLazyTree');
var Danger = require('./Danger');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactInstrumentation = require('./ReactInstrumentation');

var createMicrosoftUnsafeLocalFunction = require('./createMicrosoftUnsafeLocalFunction');
var setInnerHTML = require('./setInnerHTML');
var setTextContent = require('./setTextContent');

function getNodeAfter(parentNode, node) {
  // Special case for text components, which return [open, close] comments
  // from getHostNode.
  if (Array.isArray(node)) {
    node = node[1];
  }
  return node ? node.nextSibling : parentNode.firstChild;
}

/**
 * Inserts `childNode` as a child of `parentNode` at the `index`.
 *
 * @param {DOMElement} parentNode Parent node in which to insert.
 * @param {DOMElement} childNode Child node to insert.
 * @param {number} index Index at which to insert the child.
 * @internal
 */
var insertChildAt = createMicrosoftUnsafeLocalFunction(function (parentNode, childNode, referenceNode) {
  // We rely exclusively on `insertBefore(node, null)` instead of also using
  // `appendChild(node)`. (Using `undefined` is not allowed by all browsers so
  // we are careful to use `null`.)
  parentNode.insertBefore(childNode, referenceNode);
});

function insertLazyTreeChildAt(parentNode, childTree, referenceNode) {
  DOMLazyTree.insertTreeBefore(parentNode, childTree, referenceNode);
}

function moveChild(parentNode, childNode, referenceNode) {
  if (Array.isArray(childNode)) {
    moveDelimitedText(parentNode, childNode[0], childNode[1], referenceNode);
  } else {
    insertChildAt(parentNode, childNode, referenceNode);
  }
}

function removeChild(parentNode, childNode) {
  if (Array.isArray(childNode)) {
    var closingComment = childNode[1];
    childNode = childNode[0];
    removeDelimitedText(parentNode, childNode, closingComment);
    parentNode.removeChild(closingComment);
  }
  parentNode.removeChild(childNode);
}

function moveDelimitedText(parentNode, openingComment, closingComment, referenceNode) {
  var node = openingComment;
  while (true) {
    var nextNode = node.nextSibling;
    insertChildAt(parentNode, node, referenceNode);
    if (node === closingComment) {
      break;
    }
    node = nextNode;
  }
}

function removeDelimitedText(parentNode, startNode, closingComment) {
  while (true) {
    var node = startNode.nextSibling;
    if (node === closingComment) {
      // The closing comment is removed by ReactMultiChild.
      break;
    } else {
      parentNode.removeChild(node);
    }
  }
}

function replaceDelimitedText(openingComment, closingComment, stringText) {
  var parentNode = openingComment.parentNode;
  var nodeAfterComment = openingComment.nextSibling;
  if (nodeAfterComment === closingComment) {
    // There are no text nodes between the opening and closing comments; insert
    // a new one if stringText isn't empty.
    if (stringText) {
      insertChildAt(parentNode, document.createTextNode(stringText), nodeAfterComment);
    }
  } else {
    if (stringText) {
      // Set the text content of the first node after the opening comment, and
      // remove all following nodes up until the closing comment.
      setTextContent(nodeAfterComment, stringText);
      removeDelimitedText(parentNode, nodeAfterComment, closingComment);
    } else {
      removeDelimitedText(parentNode, openingComment, closingComment);
    }
  }
}

var dangerouslyReplaceNodeWithMarkup = Danger.dangerouslyReplaceNodeWithMarkup;

/**
 * Operations for updating with DOM children.
 */
var DOMChildrenOperations = {

  dangerouslyReplaceNodeWithMarkup: dangerouslyReplaceNodeWithMarkup,

  replaceDelimitedText: replaceDelimitedText,

  /**
   * Updates a component's children by processing a series of updates. The
   * update configurations are each expected to have a `parentNode` property.
   *
   * @param {array<object>} updates List of update configurations.
   * @internal
   */
  processUpdates: function (parentNode, updates) {
    for (var k = 0; k < updates.length; k++) {
      var update = updates[k];
      switch (update.type) {
        case 'INSERT_MARKUP':
          insertLazyTreeChildAt(parentNode, update.content, getNodeAfter(parentNode, update.afterNode));
          break;
        case 'MOVE_EXISTING':
          moveChild(parentNode, update.fromNode, getNodeAfter(parentNode, update.afterNode));
          break;
        case 'SET_MARKUP':
          setInnerHTML(parentNode, update.content);
          break;
        case 'TEXT_CONTENT':
          setTextContent(parentNode, update.content);
          break;
        case 'REMOVE_NODE':
          removeChild(parentNode, update.fromNode);
          break;
      }
    }
  }

};

module.exports = DOMChildrenOperations;
},{"./DOMLazyTree":740,"./Danger":744,"./ReactDOMComponentTree":764,"./ReactInstrumentation":788,"./createMicrosoftUnsafeLocalFunction":823,"./setInnerHTML":845,"./setTextContent":846}],740:[function(require,module,exports){
/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var DOMNamespaces = require('./DOMNamespaces');
var setInnerHTML = require('./setInnerHTML');

var createMicrosoftUnsafeLocalFunction = require('./createMicrosoftUnsafeLocalFunction');
var setTextContent = require('./setTextContent');

var ELEMENT_NODE_TYPE = 1;
var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

/**
 * In IE (8-11) and Edge, appending nodes with no children is dramatically
 * faster than appending a full subtree, so we essentially queue up the
 * .appendChild calls here and apply them so each node is added to its parent
 * before any children are added.
 *
 * In other browsers, doing so is slower or neutral compared to the other order
 * (in Firefox, twice as slow) so we only do this inversion in IE.
 *
 * See https://github.com/spicyj/innerhtml-vs-createelement-vs-clonenode.
 */
var enableLazy = typeof document !== 'undefined' && typeof document.documentMode === 'number' || typeof navigator !== 'undefined' && typeof navigator.userAgent === 'string' && /\bEdge\/\d/.test(navigator.userAgent);

function insertTreeChildren(tree) {
  if (!enableLazy) {
    return;
  }
  var node = tree.node;
  var children = tree.children;
  if (children.length) {
    for (var i = 0; i < children.length; i++) {
      insertTreeBefore(node, children[i], null);
    }
  } else if (tree.html != null) {
    setInnerHTML(node, tree.html);
  } else if (tree.text != null) {
    setTextContent(node, tree.text);
  }
}

var insertTreeBefore = createMicrosoftUnsafeLocalFunction(function (parentNode, tree, referenceNode) {
  // DocumentFragments aren't actually part of the DOM after insertion so
  // appending children won't update the DOM. We need to ensure the fragment
  // is properly populated first, breaking out of our lazy approach for just
  // this level. Also, some <object> plugins (like Flash Player) will read
  // <param> nodes immediately upon insertion into the DOM, so <object>
  // must also be populated prior to insertion into the DOM.
  if (tree.node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE || tree.node.nodeType === ELEMENT_NODE_TYPE && tree.node.nodeName.toLowerCase() === 'object' && (tree.node.namespaceURI == null || tree.node.namespaceURI === DOMNamespaces.html)) {
    insertTreeChildren(tree);
    parentNode.insertBefore(tree.node, referenceNode);
  } else {
    parentNode.insertBefore(tree.node, referenceNode);
    insertTreeChildren(tree);
  }
});

function replaceChildWithTree(oldNode, newTree) {
  oldNode.parentNode.replaceChild(newTree.node, oldNode);
  insertTreeChildren(newTree);
}

function queueChild(parentTree, childTree) {
  if (enableLazy) {
    parentTree.children.push(childTree);
  } else {
    parentTree.node.appendChild(childTree.node);
  }
}

function queueHTML(tree, html) {
  if (enableLazy) {
    tree.html = html;
  } else {
    setInnerHTML(tree.node, html);
  }
}

function queueText(tree, text) {
  if (enableLazy) {
    tree.text = text;
  } else {
    setTextContent(tree.node, text);
  }
}

function toString() {
  return this.node.nodeName;
}

function DOMLazyTree(node) {
  return {
    node: node,
    children: [],
    html: null,
    text: null,
    toString: toString
  };
}

DOMLazyTree.insertTreeBefore = insertTreeBefore;
DOMLazyTree.replaceChildWithTree = replaceChildWithTree;
DOMLazyTree.queueChild = queueChild;
DOMLazyTree.queueHTML = queueHTML;
DOMLazyTree.queueText = queueText;

module.exports = DOMLazyTree;
},{"./DOMNamespaces":741,"./createMicrosoftUnsafeLocalFunction":823,"./setInnerHTML":845,"./setTextContent":846}],741:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var DOMNamespaces = {
  html: 'http://www.w3.org/1999/xhtml',
  mathml: 'http://www.w3.org/1998/Math/MathML',
  svg: 'http://www.w3.org/2000/svg'
};

module.exports = DOMNamespaces;
},{}],742:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var invariant = require('fbjs/lib/invariant');

function checkMask(value, bitmask) {
  return (value & bitmask) === bitmask;
}

var DOMPropertyInjection = {
  /**
   * Mapping from normalized, camelcased property names to a configuration that
   * specifies how the associated DOM property should be accessed or rendered.
   */
  MUST_USE_PROPERTY: 0x1,
  HAS_BOOLEAN_VALUE: 0x4,
  HAS_NUMERIC_VALUE: 0x8,
  HAS_POSITIVE_NUMERIC_VALUE: 0x10 | 0x8,
  HAS_OVERLOADED_BOOLEAN_VALUE: 0x20,

  /**
   * Inject some specialized knowledge about the DOM. This takes a config object
   * with the following properties:
   *
   * isCustomAttribute: function that given an attribute name will return true
   * if it can be inserted into the DOM verbatim. Useful for data-* or aria-*
   * attributes where it's impossible to enumerate all of the possible
   * attribute names,
   *
   * Properties: object mapping DOM property name to one of the
   * DOMPropertyInjection constants or null. If your attribute isn't in here,
   * it won't get written to the DOM.
   *
   * DOMAttributeNames: object mapping React attribute name to the DOM
   * attribute name. Attribute names not specified use the **lowercase**
   * normalized name.
   *
   * DOMAttributeNamespaces: object mapping React attribute name to the DOM
   * attribute namespace URL. (Attribute names not specified use no namespace.)
   *
   * DOMPropertyNames: similar to DOMAttributeNames but for DOM properties.
   * Property names not specified use the normalized name.
   *
   * DOMMutationMethods: Properties that require special mutation methods. If
   * `value` is undefined, the mutation method should unset the property.
   *
   * @param {object} domPropertyConfig the config as described above.
   */
  injectDOMPropertyConfig: function (domPropertyConfig) {
    var Injection = DOMPropertyInjection;
    var Properties = domPropertyConfig.Properties || {};
    var DOMAttributeNamespaces = domPropertyConfig.DOMAttributeNamespaces || {};
    var DOMAttributeNames = domPropertyConfig.DOMAttributeNames || {};
    var DOMPropertyNames = domPropertyConfig.DOMPropertyNames || {};
    var DOMMutationMethods = domPropertyConfig.DOMMutationMethods || {};

    if (domPropertyConfig.isCustomAttribute) {
      DOMProperty._isCustomAttributeFunctions.push(domPropertyConfig.isCustomAttribute);
    }

    for (var propName in Properties) {
      !!DOMProperty.properties.hasOwnProperty(propName) ? _prodInvariant('48', propName) : void 0;

      var lowerCased = propName.toLowerCase();
      var propConfig = Properties[propName];

      var propertyInfo = {
        attributeName: lowerCased,
        attributeNamespace: null,
        propertyName: propName,
        mutationMethod: null,

        mustUseProperty: checkMask(propConfig, Injection.MUST_USE_PROPERTY),
        hasBooleanValue: checkMask(propConfig, Injection.HAS_BOOLEAN_VALUE),
        hasNumericValue: checkMask(propConfig, Injection.HAS_NUMERIC_VALUE),
        hasPositiveNumericValue: checkMask(propConfig, Injection.HAS_POSITIVE_NUMERIC_VALUE),
        hasOverloadedBooleanValue: checkMask(propConfig, Injection.HAS_OVERLOADED_BOOLEAN_VALUE)
      };
      !(propertyInfo.hasBooleanValue + propertyInfo.hasNumericValue + propertyInfo.hasOverloadedBooleanValue <= 1) ? _prodInvariant('50', propName) : void 0;

      if (DOMAttributeNames.hasOwnProperty(propName)) {
        var attributeName = DOMAttributeNames[propName];
        propertyInfo.attributeName = attributeName;
      }

      if (DOMAttributeNamespaces.hasOwnProperty(propName)) {
        propertyInfo.attributeNamespace = DOMAttributeNamespaces[propName];
      }

      if (DOMPropertyNames.hasOwnProperty(propName)) {
        propertyInfo.propertyName = DOMPropertyNames[propName];
      }

      if (DOMMutationMethods.hasOwnProperty(propName)) {
        propertyInfo.mutationMethod = DOMMutationMethods[propName];
      }

      DOMProperty.properties[propName] = propertyInfo;
    }
  }
};

/* eslint-disable max-len */
var ATTRIBUTE_NAME_START_CHAR = ':A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
/* eslint-enable max-len */

/**
 * DOMProperty exports lookup objects that can be used like functions:
 *
 *   > DOMProperty.isValid['id']
 *   true
 *   > DOMProperty.isValid['foobar']
 *   undefined
 *
 * Although this may be confusing, it performs better in general.
 *
 * @see http://jsperf.com/key-exists
 * @see http://jsperf.com/key-missing
 */
var DOMProperty = {

  ID_ATTRIBUTE_NAME: 'data-reactid',
  ROOT_ATTRIBUTE_NAME: 'data-reactroot',

  ATTRIBUTE_NAME_START_CHAR: ATTRIBUTE_NAME_START_CHAR,
  ATTRIBUTE_NAME_CHAR: ATTRIBUTE_NAME_START_CHAR + '\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040',

  /**
   * Map from property "standard name" to an object with info about how to set
   * the property in the DOM. Each object contains:
   *
   * attributeName:
   *   Used when rendering markup or with `*Attribute()`.
   * attributeNamespace
   * propertyName:
   *   Used on DOM node instances. (This includes properties that mutate due to
   *   external factors.)
   * mutationMethod:
   *   If non-null, used instead of the property or `setAttribute()` after
   *   initial render.
   * mustUseProperty:
   *   Whether the property must be accessed and mutated as an object property.
   * hasBooleanValue:
   *   Whether the property should be removed when set to a falsey value.
   * hasNumericValue:
   *   Whether the property must be numeric or parse as a numeric and should be
   *   removed when set to a falsey value.
   * hasPositiveNumericValue:
   *   Whether the property must be positive numeric or parse as a positive
   *   numeric and should be removed when set to a falsey value.
   * hasOverloadedBooleanValue:
   *   Whether the property can be used as a flag as well as with a value.
   *   Removed when strictly equal to false; present without a value when
   *   strictly equal to true; present with a value otherwise.
   */
  properties: {},

  /**
   * Mapping from lowercase property names to the properly cased version, used
   * to warn in the case of missing properties. Available only in __DEV__.
   *
   * autofocus is predefined, because adding it to the property whitelist
   * causes unintended side effects.
   *
   * @type {Object}
   */
  getPossibleStandardName: null,

  /**
   * All of the isCustomAttribute() functions that have been injected.
   */
  _isCustomAttributeFunctions: [],

  /**
   * Checks whether a property name is a custom attribute.
   * @method
   */
  isCustomAttribute: function (attributeName) {
    for (var i = 0; i < DOMProperty._isCustomAttributeFunctions.length; i++) {
      var isCustomAttributeFn = DOMProperty._isCustomAttributeFunctions[i];
      if (isCustomAttributeFn(attributeName)) {
        return true;
      }
    }
    return false;
  },

  injection: DOMPropertyInjection
};

module.exports = DOMProperty;
},{"./reactProdInvariant":843,"fbjs/lib/invariant":602}],743:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var DOMProperty = require('./DOMProperty');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactInstrumentation = require('./ReactInstrumentation');

var quoteAttributeValueForBrowser = require('./quoteAttributeValueForBrowser');
var warning = require('fbjs/lib/warning');

var VALID_ATTRIBUTE_NAME_REGEX = new RegExp('^[' + DOMProperty.ATTRIBUTE_NAME_START_CHAR + '][' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$');
var illegalAttributeNameCache = {};
var validatedAttributeNameCache = {};

function isAttributeNameSafe(attributeName) {
  if (validatedAttributeNameCache.hasOwnProperty(attributeName)) {
    return true;
  }
  if (illegalAttributeNameCache.hasOwnProperty(attributeName)) {
    return false;
  }
  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
    validatedAttributeNameCache[attributeName] = true;
    return true;
  }
  illegalAttributeNameCache[attributeName] = true;
  void 0;
  return false;
}

function shouldIgnoreValue(propertyInfo, value) {
  return value == null || propertyInfo.hasBooleanValue && !value || propertyInfo.hasNumericValue && isNaN(value) || propertyInfo.hasPositiveNumericValue && value < 1 || propertyInfo.hasOverloadedBooleanValue && value === false;
}

/**
 * Operations for dealing with DOM properties.
 */
var DOMPropertyOperations = {

  /**
   * Creates markup for the ID property.
   *
   * @param {string} id Unescaped ID.
   * @return {string} Markup string.
   */
  createMarkupForID: function (id) {
    return DOMProperty.ID_ATTRIBUTE_NAME + '=' + quoteAttributeValueForBrowser(id);
  },

  setAttributeForID: function (node, id) {
    node.setAttribute(DOMProperty.ID_ATTRIBUTE_NAME, id);
  },

  createMarkupForRoot: function () {
    return DOMProperty.ROOT_ATTRIBUTE_NAME + '=""';
  },

  setAttributeForRoot: function (node) {
    node.setAttribute(DOMProperty.ROOT_ATTRIBUTE_NAME, '');
  },

  /**
   * Creates markup for a property.
   *
   * @param {string} name
   * @param {*} value
   * @return {?string} Markup string, or null if the property was invalid.
   */
  createMarkupForProperty: function (name, value) {
    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
    if (propertyInfo) {
      if (shouldIgnoreValue(propertyInfo, value)) {
        return '';
      }
      var attributeName = propertyInfo.attributeName;
      if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
        return attributeName + '=""';
      }
      return attributeName + '=' + quoteAttributeValueForBrowser(value);
    } else if (DOMProperty.isCustomAttribute(name)) {
      if (value == null) {
        return '';
      }
      return name + '=' + quoteAttributeValueForBrowser(value);
    }
    return null;
  },

  /**
   * Creates markup for a custom property.
   *
   * @param {string} name
   * @param {*} value
   * @return {string} Markup string, or empty string if the property was invalid.
   */
  createMarkupForCustomAttribute: function (name, value) {
    if (!isAttributeNameSafe(name) || value == null) {
      return '';
    }
    return name + '=' + quoteAttributeValueForBrowser(value);
  },

  /**
   * Sets the value for a property on a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   * @param {*} value
   */
  setValueForProperty: function (node, name, value) {
    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
    if (propertyInfo) {
      var mutationMethod = propertyInfo.mutationMethod;
      if (mutationMethod) {
        mutationMethod(node, value);
      } else if (shouldIgnoreValue(propertyInfo, value)) {
        this.deleteValueForProperty(node, name);
        return;
      } else if (propertyInfo.mustUseProperty) {
        // Contrary to `setAttribute`, object properties are properly
        // `toString`ed by IE8/9.
        node[propertyInfo.propertyName] = value;
      } else {
        var attributeName = propertyInfo.attributeName;
        var namespace = propertyInfo.attributeNamespace;
        // `setAttribute` with objects becomes only `[object]` in IE8/9,
        // ('' + value) makes it output the correct toString()-value.
        if (namespace) {
          node.setAttributeNS(namespace, attributeName, '' + value);
        } else if (propertyInfo.hasBooleanValue || propertyInfo.hasOverloadedBooleanValue && value === true) {
          node.setAttribute(attributeName, '');
        } else {
          node.setAttribute(attributeName, '' + value);
        }
      }
    } else if (DOMProperty.isCustomAttribute(name)) {
      DOMPropertyOperations.setValueForAttribute(node, name, value);
      return;
    }
  },

  setValueForAttribute: function (node, name, value) {
    if (!isAttributeNameSafe(name)) {
      return;
    }
    if (value == null) {
      node.removeAttribute(name);
    } else {
      node.setAttribute(name, '' + value);
    }
  },

  /**
   * Deletes an attributes from a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   */
  deleteValueForAttribute: function (node, name) {
    node.removeAttribute(name);
  },

  /**
   * Deletes the value for a property on a node.
   *
   * @param {DOMElement} node
   * @param {string} name
   */
  deleteValueForProperty: function (node, name) {
    var propertyInfo = DOMProperty.properties.hasOwnProperty(name) ? DOMProperty.properties[name] : null;
    if (propertyInfo) {
      var mutationMethod = propertyInfo.mutationMethod;
      if (mutationMethod) {
        mutationMethod(node, undefined);
      } else if (propertyInfo.mustUseProperty) {
        var propName = propertyInfo.propertyName;
        if (propertyInfo.hasBooleanValue) {
          node[propName] = false;
        } else {
          node[propName] = '';
        }
      } else {
        node.removeAttribute(propertyInfo.attributeName);
      }
    } else if (DOMProperty.isCustomAttribute(name)) {
      node.removeAttribute(name);
    }
  }

};

module.exports = DOMPropertyOperations;
},{"./DOMProperty":742,"./ReactDOMComponentTree":764,"./ReactInstrumentation":788,"./quoteAttributeValueForBrowser":842,"fbjs/lib/warning":607}],744:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var DOMLazyTree = require('./DOMLazyTree');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var createNodesFromMarkup = require('fbjs/lib/createNodesFromMarkup');
var emptyFunction = require('fbjs/lib/emptyFunction');
var invariant = require('fbjs/lib/invariant');

var Danger = {

  /**
   * Replaces a node with a string of markup at its current position within its
   * parent. The markup must render into a single root node.
   *
   * @param {DOMElement} oldChild Child node to replace.
   * @param {string} markup Markup to render in place of the child node.
   * @internal
   */
  dangerouslyReplaceNodeWithMarkup: function (oldChild, markup) {
    !ExecutionEnvironment.canUseDOM ? _prodInvariant('56') : void 0;
    !markup ? _prodInvariant('57') : void 0;
    !(oldChild.nodeName !== 'HTML') ? _prodInvariant('58') : void 0;

    if (typeof markup === 'string') {
      var newChild = createNodesFromMarkup(markup, emptyFunction)[0];
      oldChild.parentNode.replaceChild(newChild, oldChild);
    } else {
      DOMLazyTree.replaceChildWithTree(oldChild, markup);
    }
  }

};

module.exports = Danger;
},{"./DOMLazyTree":740,"./reactProdInvariant":843,"fbjs/lib/ExecutionEnvironment":588,"fbjs/lib/createNodesFromMarkup":593,"fbjs/lib/emptyFunction":594,"fbjs/lib/invariant":602}],745:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

/**
 * Module that is injectable into `EventPluginHub`, that specifies a
 * deterministic ordering of `EventPlugin`s. A convenient way to reason about
 * plugins, without having to package every one of them. This is better than
 * having plugins be ordered in the same order that they are injected because
 * that ordering would be influenced by the packaging order.
 * `ResponderEventPlugin` must occur before `SimpleEventPlugin` so that
 * preventing default on events is convenient in `SimpleEventPlugin` handlers.
 */

var DefaultEventPluginOrder = ['ResponderEventPlugin', 'SimpleEventPlugin', 'TapEventPlugin', 'EnterLeaveEventPlugin', 'ChangeEventPlugin', 'SelectEventPlugin', 'BeforeInputEventPlugin'];

module.exports = DefaultEventPluginOrder;
},{}],746:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var EventPropagators = require('./EventPropagators');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var SyntheticMouseEvent = require('./SyntheticMouseEvent');

var eventTypes = {
  mouseEnter: {
    registrationName: 'onMouseEnter',
    dependencies: ['topMouseOut', 'topMouseOver']
  },
  mouseLeave: {
    registrationName: 'onMouseLeave',
    dependencies: ['topMouseOut', 'topMouseOver']
  }
};

var EnterLeaveEventPlugin = {

  eventTypes: eventTypes,

  /**
   * For almost every interaction we care about, there will be both a top-level
   * `mouseover` and `mouseout` event that occurs. Only use `mouseout` so that
   * we do not extract duplicate events. However, moving the mouse into the
   * browser from outside will not fire a `mouseout` event. In this case, we use
   * the `mouseover` top-level event.
   */
  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    if (topLevelType === 'topMouseOver' && (nativeEvent.relatedTarget || nativeEvent.fromElement)) {
      return null;
    }
    if (topLevelType !== 'topMouseOut' && topLevelType !== 'topMouseOver') {
      // Must not be a mouse in or mouse out - ignoring.
      return null;
    }

    var win;
    if (nativeEventTarget.window === nativeEventTarget) {
      // `nativeEventTarget` is probably a window object.
      win = nativeEventTarget;
    } else {
      // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
      var doc = nativeEventTarget.ownerDocument;
      if (doc) {
        win = doc.defaultView || doc.parentWindow;
      } else {
        win = window;
      }
    }

    var from;
    var to;
    if (topLevelType === 'topMouseOut') {
      from = targetInst;
      var related = nativeEvent.relatedTarget || nativeEvent.toElement;
      to = related ? ReactDOMComponentTree.getClosestInstanceFromNode(related) : null;
    } else {
      // Moving to a node from outside the window.
      from = null;
      to = targetInst;
    }

    if (from === to) {
      // Nothing pertains to our managed components.
      return null;
    }

    var fromNode = from == null ? win : ReactDOMComponentTree.getNodeFromInstance(from);
    var toNode = to == null ? win : ReactDOMComponentTree.getNodeFromInstance(to);

    var leave = SyntheticMouseEvent.getPooled(eventTypes.mouseLeave, from, nativeEvent, nativeEventTarget);
    leave.type = 'mouseleave';
    leave.target = fromNode;
    leave.relatedTarget = toNode;

    var enter = SyntheticMouseEvent.getPooled(eventTypes.mouseEnter, to, nativeEvent, nativeEventTarget);
    enter.type = 'mouseenter';
    enter.target = toNode;
    enter.relatedTarget = fromNode;

    EventPropagators.accumulateEnterLeaveDispatches(leave, enter, from, to);

    return [leave, enter];
  }

};

module.exports = EnterLeaveEventPlugin;
},{"./EventPropagators":750,"./ReactDOMComponentTree":764,"./SyntheticMouseEvent":814}],747:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var EventPluginRegistry = require('./EventPluginRegistry');
var EventPluginUtils = require('./EventPluginUtils');
var ReactErrorUtils = require('./ReactErrorUtils');

var accumulateInto = require('./accumulateInto');
var forEachAccumulated = require('./forEachAccumulated');
var invariant = require('fbjs/lib/invariant');

/**
 * Internal store for event listeners
 */
var listenerBank = {};

/**
 * Internal queue of events that have accumulated their dispatches and are
 * waiting to have their dispatches executed.
 */
var eventQueue = null;

/**
 * Dispatches an event and releases it back into the pool, unless persistent.
 *
 * @param {?object} event Synthetic event to be dispatched.
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @private
 */
var executeDispatchesAndRelease = function (event, simulated) {
  if (event) {
    EventPluginUtils.executeDispatchesInOrder(event, simulated);

    if (!event.isPersistent()) {
      event.constructor.release(event);
    }
  }
};
var executeDispatchesAndReleaseSimulated = function (e) {
  return executeDispatchesAndRelease(e, true);
};
var executeDispatchesAndReleaseTopLevel = function (e) {
  return executeDispatchesAndRelease(e, false);
};

var getDictionaryKey = function (inst) {
  // Prevents V8 performance issue:
  // https://github.com/facebook/react/pull/7232
  return '.' + inst._rootNodeID;
};

function isInteractive(tag) {
  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
}

function shouldPreventMouseEvent(name, type, props) {
  switch (name) {
    case 'onClick':
    case 'onClickCapture':
    case 'onDoubleClick':
    case 'onDoubleClickCapture':
    case 'onMouseDown':
    case 'onMouseDownCapture':
    case 'onMouseMove':
    case 'onMouseMoveCapture':
    case 'onMouseUp':
    case 'onMouseUpCapture':
      return !!(props.disabled && isInteractive(type));
    default:
      return false;
  }
}

/**
 * This is a unified interface for event plugins to be installed and configured.
 *
 * Event plugins can implement the following properties:
 *
 *   `extractEvents` {function(string, DOMEventTarget, string, object): *}
 *     Required. When a top-level event is fired, this method is expected to
 *     extract synthetic events that will in turn be queued and dispatched.
 *
 *   `eventTypes` {object}
 *     Optional, plugins that fire events must publish a mapping of registration
 *     names that are used to register listeners. Values of this mapping must
 *     be objects that contain `registrationName` or `phasedRegistrationNames`.
 *
 *   `executeDispatch` {function(object, function, string)}
 *     Optional, allows plugins to override how an event gets dispatched. By
 *     default, the listener is simply invoked.
 *
 * Each plugin that is injected into `EventsPluginHub` is immediately operable.
 *
 * @public
 */
var EventPluginHub = {

  /**
   * Methods for injecting dependencies.
   */
  injection: {

    /**
     * @param {array} InjectedEventPluginOrder
     * @public
     */
    injectEventPluginOrder: EventPluginRegistry.injectEventPluginOrder,

    /**
     * @param {object} injectedNamesToPlugins Map from names to plugin modules.
     */
    injectEventPluginsByName: EventPluginRegistry.injectEventPluginsByName

  },

  /**
   * Stores `listener` at `listenerBank[registrationName][key]`. Is idempotent.
   *
   * @param {object} inst The instance, which is the source of events.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @param {function} listener The callback to store.
   */
  putListener: function (inst, registrationName, listener) {
    !(typeof listener === 'function') ? _prodInvariant('94', registrationName, typeof listener) : void 0;

    var key = getDictionaryKey(inst);
    var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {});
    bankForRegistrationName[key] = listener;

    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
    if (PluginModule && PluginModule.didPutListener) {
      PluginModule.didPutListener(inst, registrationName, listener);
    }
  },

  /**
   * @param {object} inst The instance, which is the source of events.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @return {?function} The stored callback.
   */
  getListener: function (inst, registrationName) {
    // TODO: shouldPreventMouseEvent is DOM-specific and definitely should not
    // live here; needs to be moved to a better place soon
    var bankForRegistrationName = listenerBank[registrationName];
    if (shouldPreventMouseEvent(registrationName, inst._currentElement.type, inst._currentElement.props)) {
      return null;
    }
    var key = getDictionaryKey(inst);
    return bankForRegistrationName && bankForRegistrationName[key];
  },

  /**
   * Deletes a listener from the registration bank.
   *
   * @param {object} inst The instance, which is the source of events.
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   */
  deleteListener: function (inst, registrationName) {
    var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
    if (PluginModule && PluginModule.willDeleteListener) {
      PluginModule.willDeleteListener(inst, registrationName);
    }

    var bankForRegistrationName = listenerBank[registrationName];
    // TODO: This should never be null -- when is it?
    if (bankForRegistrationName) {
      var key = getDictionaryKey(inst);
      delete bankForRegistrationName[key];
    }
  },

  /**
   * Deletes all listeners for the DOM element with the supplied ID.
   *
   * @param {object} inst The instance, which is the source of events.
   */
  deleteAllListeners: function (inst) {
    var key = getDictionaryKey(inst);
    for (var registrationName in listenerBank) {
      if (!listenerBank.hasOwnProperty(registrationName)) {
        continue;
      }

      if (!listenerBank[registrationName][key]) {
        continue;
      }

      var PluginModule = EventPluginRegistry.registrationNameModules[registrationName];
      if (PluginModule && PluginModule.willDeleteListener) {
        PluginModule.willDeleteListener(inst, registrationName);
      }

      delete listenerBank[registrationName][key];
    }
  },

  /**
   * Allows registered plugins an opportunity to extract events from top-level
   * native browser events.
   *
   * @return {*} An accumulation of synthetic events.
   * @internal
   */
  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var events;
    var plugins = EventPluginRegistry.plugins;
    for (var i = 0; i < plugins.length; i++) {
      // Not every plugin in the ordering may be loaded at runtime.
      var possiblePlugin = plugins[i];
      if (possiblePlugin) {
        var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
        if (extractedEvents) {
          events = accumulateInto(events, extractedEvents);
        }
      }
    }
    return events;
  },

  /**
   * Enqueues a synthetic event that should be dispatched when
   * `processEventQueue` is invoked.
   *
   * @param {*} events An accumulation of synthetic events.
   * @internal
   */
  enqueueEvents: function (events) {
    if (events) {
      eventQueue = accumulateInto(eventQueue, events);
    }
  },

  /**
   * Dispatches all synthetic events on the event queue.
   *
   * @internal
   */
  processEventQueue: function (simulated) {
    // Set `eventQueue` to null before processing it so that we can tell if more
    // events get enqueued while processing.
    var processingEventQueue = eventQueue;
    eventQueue = null;
    if (simulated) {
      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated);
    } else {
      forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel);
    }
    !!eventQueue ? _prodInvariant('95') : void 0;
    // This would be a good time to rethrow if any of the event handlers threw.
    ReactErrorUtils.rethrowCaughtError();
  },

  /**
   * These are needed for tests only. Do not use!
   */
  __purge: function () {
    listenerBank = {};
  },

  __getListenerBank: function () {
    return listenerBank;
  }

};

module.exports = EventPluginHub;
},{"./EventPluginRegistry":748,"./EventPluginUtils":749,"./ReactErrorUtils":780,"./accumulateInto":821,"./forEachAccumulated":828,"./reactProdInvariant":843,"fbjs/lib/invariant":602}],748:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var invariant = require('fbjs/lib/invariant');

/**
 * Injectable ordering of event plugins.
 */
var eventPluginOrder = null;

/**
 * Injectable mapping from names to event plugin modules.
 */
var namesToPlugins = {};

/**
 * Recomputes the plugin list using the injected plugins and plugin ordering.
 *
 * @private
 */
function recomputePluginOrdering() {
  if (!eventPluginOrder) {
    // Wait until an `eventPluginOrder` is injected.
    return;
  }
  for (var pluginName in namesToPlugins) {
    var pluginModule = namesToPlugins[pluginName];
    var pluginIndex = eventPluginOrder.indexOf(pluginName);
    !(pluginIndex > -1) ? _prodInvariant('96', pluginName) : void 0;
    if (EventPluginRegistry.plugins[pluginIndex]) {
      continue;
    }
    !pluginModule.extractEvents ? _prodInvariant('97', pluginName) : void 0;
    EventPluginRegistry.plugins[pluginIndex] = pluginModule;
    var publishedEvents = pluginModule.eventTypes;
    for (var eventName in publishedEvents) {
      !publishEventForPlugin(publishedEvents[eventName], pluginModule, eventName) ? _prodInvariant('98', eventName, pluginName) : void 0;
    }
  }
}

/**
 * Publishes an event so that it can be dispatched by the supplied plugin.
 *
 * @param {object} dispatchConfig Dispatch configuration for the event.
 * @param {object} PluginModule Plugin publishing the event.
 * @return {boolean} True if the event was successfully published.
 * @private
 */
function publishEventForPlugin(dispatchConfig, pluginModule, eventName) {
  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? _prodInvariant('99', eventName) : void 0;
  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;

  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;
  if (phasedRegistrationNames) {
    for (var phaseName in phasedRegistrationNames) {
      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {
        var phasedRegistrationName = phasedRegistrationNames[phaseName];
        publishRegistrationName(phasedRegistrationName, pluginModule, eventName);
      }
    }
    return true;
  } else if (dispatchConfig.registrationName) {
    publishRegistrationName(dispatchConfig.registrationName, pluginModule, eventName);
    return true;
  }
  return false;
}

/**
 * Publishes a registration name that is used to identify dispatched events and
 * can be used with `EventPluginHub.putListener` to register listeners.
 *
 * @param {string} registrationName Registration name to add.
 * @param {object} PluginModule Plugin publishing the event.
 * @private
 */
function publishRegistrationName(registrationName, pluginModule, eventName) {
  !!EventPluginRegistry.registrationNameModules[registrationName] ? _prodInvariant('100', registrationName) : void 0;
  EventPluginRegistry.registrationNameModules[registrationName] = pluginModule;
  EventPluginRegistry.registrationNameDependencies[registrationName] = pluginModule.eventTypes[eventName].dependencies;
}

/**
 * Registers plugins so that they can extract and dispatch events.
 *
 * @see {EventPluginHub}
 */
var EventPluginRegistry = {

  /**
   * Ordered list of injected plugins.
   */
  plugins: [],

  /**
   * Mapping from event name to dispatch config
   */
  eventNameDispatchConfigs: {},

  /**
   * Mapping from registration name to plugin module
   */
  registrationNameModules: {},

  /**
   * Mapping from registration name to event name
   */
  registrationNameDependencies: {},

  /**
   * Mapping from lowercase registration names to the properly cased version,
   * used to warn in the case of missing event handlers. Available
   * only in __DEV__.
   * @type {Object}
   */
  possibleRegistrationNames: null,
  // Trust the developer to only use possibleRegistrationNames in __DEV__

  /**
   * Injects an ordering of plugins (by plugin name). This allows the ordering
   * to be decoupled from injection of the actual plugins so that ordering is
   * always deterministic regardless of packaging, on-the-fly injection, etc.
   *
   * @param {array} InjectedEventPluginOrder
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginOrder}
   */
  injectEventPluginOrder: function (injectedEventPluginOrder) {
    !!eventPluginOrder ? _prodInvariant('101') : void 0;
    // Clone the ordering so it cannot be dynamically mutated.
    eventPluginOrder = Array.prototype.slice.call(injectedEventPluginOrder);
    recomputePluginOrdering();
  },

  /**
   * Injects plugins to be used by `EventPluginHub`. The plugin names must be
   * in the ordering injected by `injectEventPluginOrder`.
   *
   * Plugins can be injected as part of page initialization or on-the-fly.
   *
   * @param {object} injectedNamesToPlugins Map from names to plugin modules.
   * @internal
   * @see {EventPluginHub.injection.injectEventPluginsByName}
   */
  injectEventPluginsByName: function (injectedNamesToPlugins) {
    var isOrderingDirty = false;
    for (var pluginName in injectedNamesToPlugins) {
      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {
        continue;
      }
      var pluginModule = injectedNamesToPlugins[pluginName];
      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== pluginModule) {
        !!namesToPlugins[pluginName] ? _prodInvariant('102', pluginName) : void 0;
        namesToPlugins[pluginName] = pluginModule;
        isOrderingDirty = true;
      }
    }
    if (isOrderingDirty) {
      recomputePluginOrdering();
    }
  },

  /**
   * Looks up the plugin for the supplied event.
   *
   * @param {object} event A synthetic event.
   * @return {?object} The plugin that created the supplied event.
   * @internal
   */
  getPluginModuleForEvent: function (event) {
    var dispatchConfig = event.dispatchConfig;
    if (dispatchConfig.registrationName) {
      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;
    }
    if (dispatchConfig.phasedRegistrationNames !== undefined) {
      // pulling phasedRegistrationNames out of dispatchConfig helps Flow see
      // that it is not undefined.
      var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;

      for (var phase in phasedRegistrationNames) {
        if (!phasedRegistrationNames.hasOwnProperty(phase)) {
          continue;
        }
        var pluginModule = EventPluginRegistry.registrationNameModules[phasedRegistrationNames[phase]];
        if (pluginModule) {
          return pluginModule;
        }
      }
    }
    return null;
  },

  /**
   * Exposed for unit testing.
   * @private
   */
  _resetEventPlugins: function () {
    eventPluginOrder = null;
    for (var pluginName in namesToPlugins) {
      if (namesToPlugins.hasOwnProperty(pluginName)) {
        delete namesToPlugins[pluginName];
      }
    }
    EventPluginRegistry.plugins.length = 0;

    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;
    for (var eventName in eventNameDispatchConfigs) {
      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {
        delete eventNameDispatchConfigs[eventName];
      }
    }

    var registrationNameModules = EventPluginRegistry.registrationNameModules;
    for (var registrationName in registrationNameModules) {
      if (registrationNameModules.hasOwnProperty(registrationName)) {
        delete registrationNameModules[registrationName];
      }
    }
  }

};

module.exports = EventPluginRegistry;
},{"./reactProdInvariant":843,"fbjs/lib/invariant":602}],749:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactErrorUtils = require('./ReactErrorUtils');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

/**
 * Injected dependencies:
 */

/**
 * - `ComponentTree`: [required] Module that can convert between React instances
 *   and actual node references.
 */
var ComponentTree;
var TreeTraversal;
var injection = {
  injectComponentTree: function (Injected) {
    ComponentTree = Injected;
  },
  injectTreeTraversal: function (Injected) {
    TreeTraversal = Injected;
  }
};

function isEndish(topLevelType) {
  return topLevelType === 'topMouseUp' || topLevelType === 'topTouchEnd' || topLevelType === 'topTouchCancel';
}

function isMoveish(topLevelType) {
  return topLevelType === 'topMouseMove' || topLevelType === 'topTouchMove';
}
function isStartish(topLevelType) {
  return topLevelType === 'topMouseDown' || topLevelType === 'topTouchStart';
}

var validateEventDispatches;

/**
 * Dispatch the event to the listener.
 * @param {SyntheticEvent} event SyntheticEvent to handle
 * @param {boolean} simulated If the event is simulated (changes exn behavior)
 * @param {function} listener Application-level callback
 * @param {*} inst Internal component instance
 */
function executeDispatch(event, simulated, listener, inst) {
  var type = event.type || 'unknown-event';
  event.currentTarget = EventPluginUtils.getNodeFromInstance(inst);
  if (simulated) {
    ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event);
  } else {
    ReactErrorUtils.invokeGuardedCallback(type, listener, event);
  }
  event.currentTarget = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches.
 */
function executeDispatchesInOrder(event, simulated) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchInstances = event._dispatchInstances;
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and Instances are two parallel arrays that are always in sync.
      executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]);
    }
  } else if (dispatchListeners) {
    executeDispatch(event, simulated, dispatchListeners, dispatchInstances);
  }
  event._dispatchListeners = null;
  event._dispatchInstances = null;
}

/**
 * Standard/simple iteration through an event's collected dispatches, but stops
 * at the first dispatch execution returning true, and returns that id.
 *
 * @return {?string} id of the first dispatch execution who's listener returns
 * true, or null if no listener returned true.
 */
function executeDispatchesInOrderStopAtTrueImpl(event) {
  var dispatchListeners = event._dispatchListeners;
  var dispatchInstances = event._dispatchInstances;
  if (Array.isArray(dispatchListeners)) {
    for (var i = 0; i < dispatchListeners.length; i++) {
      if (event.isPropagationStopped()) {
        break;
      }
      // Listeners and Instances are two parallel arrays that are always in sync.
      if (dispatchListeners[i](event, dispatchInstances[i])) {
        return dispatchInstances[i];
      }
    }
  } else if (dispatchListeners) {
    if (dispatchListeners(event, dispatchInstances)) {
      return dispatchInstances;
    }
  }
  return null;
}

/**
 * @see executeDispatchesInOrderStopAtTrueImpl
 */
function executeDispatchesInOrderStopAtTrue(event) {
  var ret = executeDispatchesInOrderStopAtTrueImpl(event);
  event._dispatchInstances = null;
  event._dispatchListeners = null;
  return ret;
}

/**
 * Execution of a "direct" dispatch - there must be at most one dispatch
 * accumulated on the event or it is considered an error. It doesn't really make
 * sense for an event with multiple dispatches (bubbled) to keep track of the
 * return values at each dispatch execution, but it does tend to make sense when
 * dealing with "direct" dispatches.
 *
 * @return {*} The return value of executing the single dispatch.
 */
function executeDirectDispatch(event) {
  var dispatchListener = event._dispatchListeners;
  var dispatchInstance = event._dispatchInstances;
  !!Array.isArray(dispatchListener) ? _prodInvariant('103') : void 0;
  event.currentTarget = dispatchListener ? EventPluginUtils.getNodeFromInstance(dispatchInstance) : null;
  var res = dispatchListener ? dispatchListener(event) : null;
  event.currentTarget = null;
  event._dispatchListeners = null;
  event._dispatchInstances = null;
  return res;
}

/**
 * @param {SyntheticEvent} event
 * @return {boolean} True iff number of dispatches accumulated is greater than 0.
 */
function hasDispatches(event) {
  return !!event._dispatchListeners;
}

/**
 * General utilities that are useful in creating custom Event Plugins.
 */
var EventPluginUtils = {
  isEndish: isEndish,
  isMoveish: isMoveish,
  isStartish: isStartish,

  executeDirectDispatch: executeDirectDispatch,
  executeDispatchesInOrder: executeDispatchesInOrder,
  executeDispatchesInOrderStopAtTrue: executeDispatchesInOrderStopAtTrue,
  hasDispatches: hasDispatches,

  getInstanceFromNode: function (node) {
    return ComponentTree.getInstanceFromNode(node);
  },
  getNodeFromInstance: function (node) {
    return ComponentTree.getNodeFromInstance(node);
  },
  isAncestor: function (a, b) {
    return TreeTraversal.isAncestor(a, b);
  },
  getLowestCommonAncestor: function (a, b) {
    return TreeTraversal.getLowestCommonAncestor(a, b);
  },
  getParentInstance: function (inst) {
    return TreeTraversal.getParentInstance(inst);
  },
  traverseTwoPhase: function (target, fn, arg) {
    return TreeTraversal.traverseTwoPhase(target, fn, arg);
  },
  traverseEnterLeave: function (from, to, fn, argFrom, argTo) {
    return TreeTraversal.traverseEnterLeave(from, to, fn, argFrom, argTo);
  },

  injection: injection
};

module.exports = EventPluginUtils;
},{"./ReactErrorUtils":780,"./reactProdInvariant":843,"fbjs/lib/invariant":602,"fbjs/lib/warning":607}],750:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var EventPluginHub = require('./EventPluginHub');
var EventPluginUtils = require('./EventPluginUtils');

var accumulateInto = require('./accumulateInto');
var forEachAccumulated = require('./forEachAccumulated');
var warning = require('fbjs/lib/warning');

var getListener = EventPluginHub.getListener;

/**
 * Some event types have a notion of different registration names for different
 * "phases" of propagation. This finds listeners by a given phase.
 */
function listenerAtPhase(inst, event, propagationPhase) {
  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];
  return getListener(inst, registrationName);
}

/**
 * Tags a `SyntheticEvent` with dispatched listeners. Creating this function
 * here, allows us to not have to bind or create functions for each event.
 * Mutating the event's members allows us to not have to create a wrapping
 * "dispatch" object that pairs the event with the listener.
 */
function accumulateDirectionalDispatches(inst, phase, event) {
  var listener = listenerAtPhase(inst, event, phase);
  if (listener) {
    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
    event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
  }
}

/**
 * Collect dispatches (must be entirely collected before dispatching - see unit
 * tests). Lazily allocate the array to conserve memory.  We must loop through
 * each event and perform the traversal for each one. We cannot perform a
 * single traversal for the entire collection of events because each event may
 * have a different target.
 */
function accumulateTwoPhaseDispatchesSingle(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    EventPluginUtils.traverseTwoPhase(event._targetInst, accumulateDirectionalDispatches, event);
  }
}

/**
 * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.
 */
function accumulateTwoPhaseDispatchesSingleSkipTarget(event) {
  if (event && event.dispatchConfig.phasedRegistrationNames) {
    var targetInst = event._targetInst;
    var parentInst = targetInst ? EventPluginUtils.getParentInstance(targetInst) : null;
    EventPluginUtils.traverseTwoPhase(parentInst, accumulateDirectionalDispatches, event);
  }
}

/**
 * Accumulates without regard to direction, does not look for phased
 * registration names. Same as `accumulateDirectDispatchesSingle` but without
 * requiring that the `dispatchMarker` be the same as the dispatched ID.
 */
function accumulateDispatches(inst, ignoredDirection, event) {
  if (event && event.dispatchConfig.registrationName) {
    var registrationName = event.dispatchConfig.registrationName;
    var listener = getListener(inst, registrationName);
    if (listener) {
      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);
      event._dispatchInstances = accumulateInto(event._dispatchInstances, inst);
    }
  }
}

/**
 * Accumulates dispatches on an `SyntheticEvent`, but only for the
 * `dispatchMarker`.
 * @param {SyntheticEvent} event
 */
function accumulateDirectDispatchesSingle(event) {
  if (event && event.dispatchConfig.registrationName) {
    accumulateDispatches(event._targetInst, null, event);
  }
}

function accumulateTwoPhaseDispatches(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);
}

function accumulateTwoPhaseDispatchesSkipTarget(events) {
  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);
}

function accumulateEnterLeaveDispatches(leave, enter, from, to) {
  EventPluginUtils.traverseEnterLeave(from, to, accumulateDispatches, leave, enter);
}

function accumulateDirectDispatches(events) {
  forEachAccumulated(events, accumulateDirectDispatchesSingle);
}

/**
 * A small set of propagation patterns, each of which will accept a small amount
 * of information, and generate a set of "dispatch ready event objects" - which
 * are sets of events that have already been annotated with a set of dispatched
 * listener functions/ids. The API is designed this way to discourage these
 * propagation strategies from actually executing the dispatches, since we
 * always want to collect the entire set of dispatches before executing event a
 * single one.
 *
 * @constructor EventPropagators
 */
var EventPropagators = {
  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,
  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,
  accumulateDirectDispatches: accumulateDirectDispatches,
  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches
};

module.exports = EventPropagators;
},{"./EventPluginHub":747,"./EventPluginUtils":749,"./accumulateInto":821,"./forEachAccumulated":828,"fbjs/lib/warning":607}],751:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

var PooledClass = require('./PooledClass');

var getTextContentAccessor = require('./getTextContentAccessor');

/**
 * This helper class stores information about text content of a target node,
 * allowing comparison of content before and after a given event.
 *
 * Identify the node where selection currently begins, then observe
 * both its text content and its current position in the DOM. Since the
 * browser may natively replace the target node during composition, we can
 * use its position to find its replacement.
 *
 * @param {DOMEventTarget} root
 */
function FallbackCompositionState(root) {
  this._root = root;
  this._startText = this.getText();
  this._fallbackText = null;
}

_assign(FallbackCompositionState.prototype, {
  destructor: function () {
    this._root = null;
    this._startText = null;
    this._fallbackText = null;
  },

  /**
   * Get current text of input.
   *
   * @return {string}
   */
  getText: function () {
    if ('value' in this._root) {
      return this._root.value;
    }
    return this._root[getTextContentAccessor()];
  },

  /**
   * Determine the differing substring between the initially stored
   * text content and the current content.
   *
   * @return {string}
   */
  getData: function () {
    if (this._fallbackText) {
      return this._fallbackText;
    }

    var start;
    var startValue = this._startText;
    var startLength = startValue.length;
    var end;
    var endValue = this.getText();
    var endLength = endValue.length;

    for (start = 0; start < startLength; start++) {
      if (startValue[start] !== endValue[start]) {
        break;
      }
    }

    var minEnd = startLength - start;
    for (end = 1; end <= minEnd; end++) {
      if (startValue[startLength - end] !== endValue[endLength - end]) {
        break;
      }
    }

    var sliceTail = end > 1 ? 1 - end : undefined;
    this._fallbackText = endValue.slice(start, sliceTail);
    return this._fallbackText;
  }
});

PooledClass.addPoolingTo(FallbackCompositionState);

module.exports = FallbackCompositionState;
},{"./PooledClass":755,"./getTextContentAccessor":837,"object-assign":701}],752:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var DOMProperty = require('./DOMProperty');

var MUST_USE_PROPERTY = DOMProperty.injection.MUST_USE_PROPERTY;
var HAS_BOOLEAN_VALUE = DOMProperty.injection.HAS_BOOLEAN_VALUE;
var HAS_NUMERIC_VALUE = DOMProperty.injection.HAS_NUMERIC_VALUE;
var HAS_POSITIVE_NUMERIC_VALUE = DOMProperty.injection.HAS_POSITIVE_NUMERIC_VALUE;
var HAS_OVERLOADED_BOOLEAN_VALUE = DOMProperty.injection.HAS_OVERLOADED_BOOLEAN_VALUE;

var HTMLDOMPropertyConfig = {
  isCustomAttribute: RegExp.prototype.test.bind(new RegExp('^(data|aria)-[' + DOMProperty.ATTRIBUTE_NAME_CHAR + ']*$')),
  Properties: {
    /**
     * Standard Properties
     */
    accept: 0,
    acceptCharset: 0,
    accessKey: 0,
    action: 0,
    allowFullScreen: HAS_BOOLEAN_VALUE,
    allowTransparency: 0,
    alt: 0,
    // specifies target context for links with `preload` type
    as: 0,
    async: HAS_BOOLEAN_VALUE,
    autoComplete: 0,
    // autoFocus is polyfilled/normalized by AutoFocusUtils
    // autoFocus: HAS_BOOLEAN_VALUE,
    autoPlay: HAS_BOOLEAN_VALUE,
    capture: HAS_BOOLEAN_VALUE,
    cellPadding: 0,
    cellSpacing: 0,
    charSet: 0,
    challenge: 0,
    checked: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    cite: 0,
    classID: 0,
    className: 0,
    cols: HAS_POSITIVE_NUMERIC_VALUE,
    colSpan: 0,
    content: 0,
    contentEditable: 0,
    contextMenu: 0,
    controls: HAS_BOOLEAN_VALUE,
    coords: 0,
    crossOrigin: 0,
    data: 0, // For `<object />` acts as `src`.
    dateTime: 0,
    'default': HAS_BOOLEAN_VALUE,
    defer: HAS_BOOLEAN_VALUE,
    dir: 0,
    disabled: HAS_BOOLEAN_VALUE,
    download: HAS_OVERLOADED_BOOLEAN_VALUE,
    draggable: 0,
    encType: 0,
    form: 0,
    formAction: 0,
    formEncType: 0,
    formMethod: 0,
    formNoValidate: HAS_BOOLEAN_VALUE,
    formTarget: 0,
    frameBorder: 0,
    headers: 0,
    height: 0,
    hidden: HAS_BOOLEAN_VALUE,
    high: 0,
    href: 0,
    hrefLang: 0,
    htmlFor: 0,
    httpEquiv: 0,
    icon: 0,
    id: 0,
    inputMode: 0,
    integrity: 0,
    is: 0,
    keyParams: 0,
    keyType: 0,
    kind: 0,
    label: 0,
    lang: 0,
    list: 0,
    loop: HAS_BOOLEAN_VALUE,
    low: 0,
    manifest: 0,
    marginHeight: 0,
    marginWidth: 0,
    max: 0,
    maxLength: 0,
    media: 0,
    mediaGroup: 0,
    method: 0,
    min: 0,
    minLength: 0,
    // Caution; `option.selected` is not updated if `select.multiple` is
    // disabled with `removeAttribute`.
    multiple: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    muted: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    name: 0,
    nonce: 0,
    noValidate: HAS_BOOLEAN_VALUE,
    open: HAS_BOOLEAN_VALUE,
    optimum: 0,
    pattern: 0,
    placeholder: 0,
    playsInline: HAS_BOOLEAN_VALUE,
    poster: 0,
    preload: 0,
    profile: 0,
    radioGroup: 0,
    readOnly: HAS_BOOLEAN_VALUE,
    referrerPolicy: 0,
    rel: 0,
    required: HAS_BOOLEAN_VALUE,
    reversed: HAS_BOOLEAN_VALUE,
    role: 0,
    rows: HAS_POSITIVE_NUMERIC_VALUE,
    rowSpan: HAS_NUMERIC_VALUE,
    sandbox: 0,
    scope: 0,
    scoped: HAS_BOOLEAN_VALUE,
    scrolling: 0,
    seamless: HAS_BOOLEAN_VALUE,
    selected: MUST_USE_PROPERTY | HAS_BOOLEAN_VALUE,
    shape: 0,
    size: HAS_POSITIVE_NUMERIC_VALUE,
    sizes: 0,
    span: HAS_POSITIVE_NUMERIC_VALUE,
    spellCheck: 0,
    src: 0,
    srcDoc: 0,
    srcLang: 0,
    srcSet: 0,
    start: HAS_NUMERIC_VALUE,
    step: 0,
    style: 0,
    summary: 0,
    tabIndex: 0,
    target: 0,
    title: 0,
    // Setting .type throws on non-<input> tags
    type: 0,
    useMap: 0,
    value: 0,
    width: 0,
    wmode: 0,
    wrap: 0,

    /**
     * RDFa Properties
     */
    about: 0,
    datatype: 0,
    inlist: 0,
    prefix: 0,
    // property is also supported for OpenGraph in meta tags.
    property: 0,
    resource: 0,
    'typeof': 0,
    vocab: 0,

    /**
     * Non-standard Properties
     */
    // autoCapitalize and autoCorrect are supported in Mobile Safari for
    // keyboard hints.
    autoCapitalize: 0,
    autoCorrect: 0,
    // autoSave allows WebKit/Blink to persist values of input fields on page reloads
    autoSave: 0,
    // color is for Safari mask-icon link
    color: 0,
    // itemProp, itemScope, itemType are for
    // Microdata support. See http://schema.org/docs/gs.html
    itemProp: 0,
    itemScope: HAS_BOOLEAN_VALUE,
    itemType: 0,
    // itemID and itemRef are for Microdata support as well but
    // only specified in the WHATWG spec document. See
    // https://html.spec.whatwg.org/multipage/microdata.html#microdata-dom-api
    itemID: 0,
    itemRef: 0,
    // results show looking glass icon and recent searches on input
    // search fields in WebKit/Blink
    results: 0,
    // IE-only attribute that specifies security restrictions on an iframe
    // as an alternative to the sandbox attribute on IE<10
    security: 0,
    // IE-only attribute that controls focus behavior
    unselectable: 0
  },
  DOMAttributeNames: {
    acceptCharset: 'accept-charset',
    className: 'class',
    htmlFor: 'for',
    httpEquiv: 'http-equiv'
  },
  DOMPropertyNames: {}
};

module.exports = HTMLDOMPropertyConfig;
},{"./DOMProperty":742}],753:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

/**
 * Escape and wrap key so it is safe to use as a reactid
 *
 * @param {string} key to be escaped.
 * @return {string} the escaped key.
 */

function escape(key) {
  var escapeRegex = /[=:]/g;
  var escaperLookup = {
    '=': '=0',
    ':': '=2'
  };
  var escapedString = ('' + key).replace(escapeRegex, function (match) {
    return escaperLookup[match];
  });

  return '$' + escapedString;
}

/**
 * Unescape and unwrap key for human-readable display
 *
 * @param {string} key to unescape.
 * @return {string} the unescaped key.
 */
function unescape(key) {
  var unescapeRegex = /(=0|=2)/g;
  var unescaperLookup = {
    '=0': '=',
    '=2': ':'
  };
  var keySubstring = key[0] === '.' && key[1] === '$' ? key.substring(2) : key.substring(1);

  return ('' + keySubstring).replace(unescapeRegex, function (match) {
    return unescaperLookup[match];
  });
}

var KeyEscapeUtils = {
  escape: escape,
  unescape: unescape
};

module.exports = KeyEscapeUtils;
},{}],754:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var React = require('react/lib/React');
var ReactPropTypesSecret = require('./ReactPropTypesSecret');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

var hasReadOnlyValue = {
  'button': true,
  'checkbox': true,
  'image': true,
  'hidden': true,
  'radio': true,
  'reset': true,
  'submit': true
};

function _assertSingleLink(inputProps) {
  !(inputProps.checkedLink == null || inputProps.valueLink == null) ? _prodInvariant('87') : void 0;
}
function _assertValueLink(inputProps) {
  _assertSingleLink(inputProps);
  !(inputProps.value == null && inputProps.onChange == null) ? _prodInvariant('88') : void 0;
}

function _assertCheckedLink(inputProps) {
  _assertSingleLink(inputProps);
  !(inputProps.checked == null && inputProps.onChange == null) ? _prodInvariant('89') : void 0;
}

var propTypes = {
  value: function (props, propName, componentName) {
    if (!props[propName] || hasReadOnlyValue[props.type] || props.onChange || props.readOnly || props.disabled) {
      return null;
    }
    return new Error('You provided a `value` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultValue`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
  },
  checked: function (props, propName, componentName) {
    if (!props[propName] || props.onChange || props.readOnly || props.disabled) {
      return null;
    }
    return new Error('You provided a `checked` prop to a form field without an ' + '`onChange` handler. This will render a read-only field. If ' + 'the field should be mutable use `defaultChecked`. Otherwise, ' + 'set either `onChange` or `readOnly`.');
  },
  onChange: React.PropTypes.func
};

var loggedTypeFailures = {};
function getDeclarationErrorAddendum(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

/**
 * Provide a linked `value` attribute for controlled forms. You should not use
 * this outside of the ReactDOM controlled form components.
 */
var LinkedValueUtils = {
  checkPropTypes: function (tagName, props, owner) {
    for (var propName in propTypes) {
      if (propTypes.hasOwnProperty(propName)) {
        var error = propTypes[propName](props, propName, tagName, 'prop', null, ReactPropTypesSecret);
      }
      if (error instanceof Error && !(error.message in loggedTypeFailures)) {
        // Only monitor this failure once because there tends to be a lot of the
        // same error.
        loggedTypeFailures[error.message] = true;

        var addendum = getDeclarationErrorAddendum(owner);
        void 0;
      }
    }
  },

  /**
   * @param {object} inputProps Props for form component
   * @return {*} current value of the input either from value prop or link.
   */
  getValue: function (inputProps) {
    if (inputProps.valueLink) {
      _assertValueLink(inputProps);
      return inputProps.valueLink.value;
    }
    return inputProps.value;
  },

  /**
   * @param {object} inputProps Props for form component
   * @return {*} current checked status of the input either from checked prop
   *             or link.
   */
  getChecked: function (inputProps) {
    if (inputProps.checkedLink) {
      _assertCheckedLink(inputProps);
      return inputProps.checkedLink.value;
    }
    return inputProps.checked;
  },

  /**
   * @param {object} inputProps Props for form component
   * @param {SyntheticEvent} event change event to handle
   */
  executeOnChange: function (inputProps, event) {
    if (inputProps.valueLink) {
      _assertValueLink(inputProps);
      return inputProps.valueLink.requestChange(event.target.value);
    } else if (inputProps.checkedLink) {
      _assertCheckedLink(inputProps);
      return inputProps.checkedLink.requestChange(event.target.checked);
    } else if (inputProps.onChange) {
      return inputProps.onChange.call(undefined, event);
    }
  }
};

module.exports = LinkedValueUtils;
},{"./ReactPropTypesSecret":794,"./reactProdInvariant":843,"fbjs/lib/invariant":602,"fbjs/lib/warning":607,"react/lib/React":852}],755:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var invariant = require('fbjs/lib/invariant');

/**
 * Static poolers. Several custom versions for each potential number of
 * arguments. A completely generic pooler is easy to implement, but would
 * require accessing the `arguments` object. In each of these, `this` refers to
 * the Class itself, not an instance. If any others are needed, simply add them
 * here, or in their own files.
 */
var oneArgumentPooler = function (copyFieldsFrom) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, copyFieldsFrom);
    return instance;
  } else {
    return new Klass(copyFieldsFrom);
  }
};

var twoArgumentPooler = function (a1, a2) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2);
    return instance;
  } else {
    return new Klass(a1, a2);
  }
};

var threeArgumentPooler = function (a1, a2, a3) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3);
    return instance;
  } else {
    return new Klass(a1, a2, a3);
  }
};

var fourArgumentPooler = function (a1, a2, a3, a4) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4);
  }
};

var fiveArgumentPooler = function (a1, a2, a3, a4, a5) {
  var Klass = this;
  if (Klass.instancePool.length) {
    var instance = Klass.instancePool.pop();
    Klass.call(instance, a1, a2, a3, a4, a5);
    return instance;
  } else {
    return new Klass(a1, a2, a3, a4, a5);
  }
};

var standardReleaser = function (instance) {
  var Klass = this;
  !(instance instanceof Klass) ? _prodInvariant('25') : void 0;
  instance.destructor();
  if (Klass.instancePool.length < Klass.poolSize) {
    Klass.instancePool.push(instance);
  }
};

var DEFAULT_POOL_SIZE = 10;
var DEFAULT_POOLER = oneArgumentPooler;

/**
 * Augments `CopyConstructor` to be a poolable class, augmenting only the class
 * itself (statically) not adding any prototypical fields. Any CopyConstructor
 * you give this may have a `poolSize` property, and will look for a
 * prototypical `destructor` on instances.
 *
 * @param {Function} CopyConstructor Constructor that can be used to reset.
 * @param {Function} pooler Customizable pooler.
 */
var addPoolingTo = function (CopyConstructor, pooler) {
  // Casting as any so that flow ignores the actual implementation and trusts
  // it to match the type we declared
  var NewKlass = CopyConstructor;
  NewKlass.instancePool = [];
  NewKlass.getPooled = pooler || DEFAULT_POOLER;
  if (!NewKlass.poolSize) {
    NewKlass.poolSize = DEFAULT_POOL_SIZE;
  }
  NewKlass.release = standardReleaser;
  return NewKlass;
};

var PooledClass = {
  addPoolingTo: addPoolingTo,
  oneArgumentPooler: oneArgumentPooler,
  twoArgumentPooler: twoArgumentPooler,
  threeArgumentPooler: threeArgumentPooler,
  fourArgumentPooler: fourArgumentPooler,
  fiveArgumentPooler: fiveArgumentPooler
};

module.exports = PooledClass;
},{"./reactProdInvariant":843,"fbjs/lib/invariant":602}],756:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

var EventPluginRegistry = require('./EventPluginRegistry');
var ReactEventEmitterMixin = require('./ReactEventEmitterMixin');
var ViewportMetrics = require('./ViewportMetrics');

var getVendorPrefixedEventName = require('./getVendorPrefixedEventName');
var isEventSupported = require('./isEventSupported');

/**
 * Summary of `ReactBrowserEventEmitter` event handling:
 *
 *  - Top-level delegation is used to trap most native browser events. This
 *    may only occur in the main thread and is the responsibility of
 *    ReactEventListener, which is injected and can therefore support pluggable
 *    event sources. This is the only work that occurs in the main thread.
 *
 *  - We normalize and de-duplicate events to account for browser quirks. This
 *    may be done in the worker thread.
 *
 *  - Forward these native events (with the associated top-level type used to
 *    trap it) to `EventPluginHub`, which in turn will ask plugins if they want
 *    to extract any synthetic events.
 *
 *  - The `EventPluginHub` will then process each event by annotating them with
 *    "dispatches", a sequence of listeners and IDs that care about that event.
 *
 *  - The `EventPluginHub` then dispatches the events.
 *
 * Overview of React and the event system:
 *
 * +------------+    .
 * |    DOM     |    .
 * +------------+    .
 *       |           .
 *       v           .
 * +------------+    .
 * | ReactEvent |    .
 * |  Listener  |    .
 * +------------+    .                         +-----------+
 *       |           .               +--------+|SimpleEvent|
 *       |           .               |         |Plugin     |
 * +-----|------+    .               v         +-----------+
 * |     |      |    .    +--------------+                    +------------+
 * |     +-----------.--->|EventPluginHub|                    |    Event   |
 * |            |    .    |              |     +-----------+  | Propagators|
 * | ReactEvent |    .    |              |     |TapEvent   |  |------------|
 * |  Emitter   |    .    |              |<---+|Plugin     |  |other plugin|
 * |            |    .    |              |     +-----------+  |  utilities |
 * |     +-----------.--->|              |                    +------------+
 * |     |      |    .    +--------------+
 * +-----|------+    .                ^        +-----------+
 *       |           .                |        |Enter/Leave|
 *       +           .                +-------+|Plugin     |
 * +-------------+   .                         +-----------+
 * | application |   .
 * |-------------|   .
 * |             |   .
 * |             |   .
 * +-------------+   .
 *                   .
 *    React Core     .  General Purpose Event Plugin System
 */

var hasEventPageXY;
var alreadyListeningTo = {};
var isMonitoringScrollValue = false;
var reactTopListenersCounter = 0;

// For events like 'submit' which don't consistently bubble (which we trap at a
// lower node than `document`), binding at `document` would cause duplicate
// events so we don't include them here
var topEventMapping = {
  topAbort: 'abort',
  topAnimationEnd: getVendorPrefixedEventName('animationend') || 'animationend',
  topAnimationIteration: getVendorPrefixedEventName('animationiteration') || 'animationiteration',
  topAnimationStart: getVendorPrefixedEventName('animationstart') || 'animationstart',
  topBlur: 'blur',
  topCanPlay: 'canplay',
  topCanPlayThrough: 'canplaythrough',
  topChange: 'change',
  topClick: 'click',
  topCompositionEnd: 'compositionend',
  topCompositionStart: 'compositionstart',
  topCompositionUpdate: 'compositionupdate',
  topContextMenu: 'contextmenu',
  topCopy: 'copy',
  topCut: 'cut',
  topDoubleClick: 'dblclick',
  topDrag: 'drag',
  topDragEnd: 'dragend',
  topDragEnter: 'dragenter',
  topDragExit: 'dragexit',
  topDragLeave: 'dragleave',
  topDragOver: 'dragover',
  topDragStart: 'dragstart',
  topDrop: 'drop',
  topDurationChange: 'durationchange',
  topEmptied: 'emptied',
  topEncrypted: 'encrypted',
  topEnded: 'ended',
  topError: 'error',
  topFocus: 'focus',
  topInput: 'input',
  topKeyDown: 'keydown',
  topKeyPress: 'keypress',
  topKeyUp: 'keyup',
  topLoadedData: 'loadeddata',
  topLoadedMetadata: 'loadedmetadata',
  topLoadStart: 'loadstart',
  topMouseDown: 'mousedown',
  topMouseMove: 'mousemove',
  topMouseOut: 'mouseout',
  topMouseOver: 'mouseover',
  topMouseUp: 'mouseup',
  topPaste: 'paste',
  topPause: 'pause',
  topPlay: 'play',
  topPlaying: 'playing',
  topProgress: 'progress',
  topRateChange: 'ratechange',
  topScroll: 'scroll',
  topSeeked: 'seeked',
  topSeeking: 'seeking',
  topSelectionChange: 'selectionchange',
  topStalled: 'stalled',
  topSuspend: 'suspend',
  topTextInput: 'textInput',
  topTimeUpdate: 'timeupdate',
  topTouchCancel: 'touchcancel',
  topTouchEnd: 'touchend',
  topTouchMove: 'touchmove',
  topTouchStart: 'touchstart',
  topTransitionEnd: getVendorPrefixedEventName('transitionend') || 'transitionend',
  topVolumeChange: 'volumechange',
  topWaiting: 'waiting',
  topWheel: 'wheel'
};

/**
 * To ensure no conflicts with other potential React instances on the page
 */
var topListenersIDKey = '_reactListenersID' + String(Math.random()).slice(2);

function getListeningForDocument(mountAt) {
  // In IE8, `mountAt` is a host object and doesn't have `hasOwnProperty`
  // directly.
  if (!Object.prototype.hasOwnProperty.call(mountAt, topListenersIDKey)) {
    mountAt[topListenersIDKey] = reactTopListenersCounter++;
    alreadyListeningTo[mountAt[topListenersIDKey]] = {};
  }
  return alreadyListeningTo[mountAt[topListenersIDKey]];
}

/**
 * `ReactBrowserEventEmitter` is used to attach top-level event listeners. For
 * example:
 *
 *   EventPluginHub.putListener('myID', 'onClick', myFunction);
 *
 * This would allocate a "registration" of `('onClick', myFunction)` on 'myID'.
 *
 * @internal
 */
var ReactBrowserEventEmitter = _assign({}, ReactEventEmitterMixin, {

  /**
   * Injectable event backend
   */
  ReactEventListener: null,

  injection: {
    /**
     * @param {object} ReactEventListener
     */
    injectReactEventListener: function (ReactEventListener) {
      ReactEventListener.setHandleTopLevel(ReactBrowserEventEmitter.handleTopLevel);
      ReactBrowserEventEmitter.ReactEventListener = ReactEventListener;
    }
  },

  /**
   * Sets whether or not any created callbacks should be enabled.
   *
   * @param {boolean} enabled True if callbacks should be enabled.
   */
  setEnabled: function (enabled) {
    if (ReactBrowserEventEmitter.ReactEventListener) {
      ReactBrowserEventEmitter.ReactEventListener.setEnabled(enabled);
    }
  },

  /**
   * @return {boolean} True if callbacks are enabled.
   */
  isEnabled: function () {
    return !!(ReactBrowserEventEmitter.ReactEventListener && ReactBrowserEventEmitter.ReactEventListener.isEnabled());
  },

  /**
   * We listen for bubbled touch events on the document object.
   *
   * Firefox v8.01 (and possibly others) exhibited strange behavior when
   * mounting `onmousemove` events at some node that was not the document
   * element. The symptoms were that if your mouse is not moving over something
   * contained within that mount point (for example on the background) the
   * top-level listeners for `onmousemove` won't be called. However, if you
   * register the `mousemove` on the document object, then it will of course
   * catch all `mousemove`s. This along with iOS quirks, justifies restricting
   * top-level listeners to the document object only, at least for these
   * movement types of events and possibly all events.
   *
   * @see http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
   *
   * Also, `keyup`/`keypress`/`keydown` do not bubble to the window on IE, but
   * they bubble to document.
   *
   * @param {string} registrationName Name of listener (e.g. `onClick`).
   * @param {object} contentDocumentHandle Document which owns the container
   */
  listenTo: function (registrationName, contentDocumentHandle) {
    var mountAt = contentDocumentHandle;
    var isListening = getListeningForDocument(mountAt);
    var dependencies = EventPluginRegistry.registrationNameDependencies[registrationName];

    for (var i = 0; i < dependencies.length; i++) {
      var dependency = dependencies[i];
      if (!(isListening.hasOwnProperty(dependency) && isListening[dependency])) {
        if (dependency === 'topWheel') {
          if (isEventSupported('wheel')) {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'wheel', mountAt);
          } else if (isEventSupported('mousewheel')) {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'mousewheel', mountAt);
          } else {
            // Firefox needs to capture a different mouse scroll event.
            // @see http://www.quirksmode.org/dom/events/tests/scroll.html
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topWheel', 'DOMMouseScroll', mountAt);
          }
        } else if (dependency === 'topScroll') {

          if (isEventSupported('scroll', true)) {
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topScroll', 'scroll', mountAt);
          } else {
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topScroll', 'scroll', ReactBrowserEventEmitter.ReactEventListener.WINDOW_HANDLE);
          }
        } else if (dependency === 'topFocus' || dependency === 'topBlur') {

          if (isEventSupported('focus', true)) {
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topFocus', 'focus', mountAt);
            ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent('topBlur', 'blur', mountAt);
          } else if (isEventSupported('focusin')) {
            // IE has `focusin` and `focusout` events which bubble.
            // @see http://www.quirksmode.org/blog/archives/2008/04/delegating_the.html
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topFocus', 'focusin', mountAt);
            ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent('topBlur', 'focusout', mountAt);
          }

          // to make sure blur and focus event listeners are only attached once
          isListening.topBlur = true;
          isListening.topFocus = true;
        } else if (topEventMapping.hasOwnProperty(dependency)) {
          ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(dependency, topEventMapping[dependency], mountAt);
        }

        isListening[dependency] = true;
      }
    }
  },

  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {
    return ReactBrowserEventEmitter.ReactEventListener.trapBubbledEvent(topLevelType, handlerBaseName, handle);
  },

  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {
    return ReactBrowserEventEmitter.ReactEventListener.trapCapturedEvent(topLevelType, handlerBaseName, handle);
  },

  /**
   * Protect against document.createEvent() returning null
   * Some popup blocker extensions appear to do this:
   * https://github.com/facebook/react/issues/6887
   */
  supportsEventPageXY: function () {
    if (!document.createEvent) {
      return false;
    }
    var ev = document.createEvent('MouseEvent');
    return ev != null && 'pageX' in ev;
  },

  /**
   * Listens to window scroll and resize events. We cache scroll values so that
   * application code can access them without triggering reflows.
   *
   * ViewportMetrics is only used by SyntheticMouse/TouchEvent and only when
   * pageX/pageY isn't supported (legacy browsers).
   *
   * NOTE: Scroll events do not bubble.
   *
   * @see http://www.quirksmode.org/dom/events/scroll.html
   */
  ensureScrollValueMonitoring: function () {
    if (hasEventPageXY === undefined) {
      hasEventPageXY = ReactBrowserEventEmitter.supportsEventPageXY();
    }
    if (!hasEventPageXY && !isMonitoringScrollValue) {
      var refresh = ViewportMetrics.refreshScrollValues;
      ReactBrowserEventEmitter.ReactEventListener.monitorScrollValue(refresh);
      isMonitoringScrollValue = true;
    }
  }

});

module.exports = ReactBrowserEventEmitter;
},{"./EventPluginRegistry":748,"./ReactEventEmitterMixin":781,"./ViewportMetrics":820,"./getVendorPrefixedEventName":838,"./isEventSupported":840,"object-assign":701}],757:[function(require,module,exports){
(function (process){
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ReactReconciler = require('./ReactReconciler');

var instantiateReactComponent = require('./instantiateReactComponent');
var KeyEscapeUtils = require('./KeyEscapeUtils');
var shouldUpdateReactComponent = require('./shouldUpdateReactComponent');
var traverseAllChildren = require('./traverseAllChildren');
var warning = require('fbjs/lib/warning');

var ReactComponentTreeHook;

if (typeof process !== 'undefined' && process.env && "production" === 'test') {
  // Temporary hack.
  // Inline requires don't work well with Jest:
  // https://github.com/facebook/react/issues/7240
  // Remove the inline requires when we don't need them anymore:
  // https://github.com/facebook/react/pull/7178
  ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');
}

function instantiateChild(childInstances, child, name, selfDebugID) {
  // We found a component instance.
  var keyUnique = childInstances[name] === undefined;
  if (child != null && keyUnique) {
    childInstances[name] = instantiateReactComponent(child, true);
  }
}

/**
 * ReactChildReconciler provides helpers for initializing or updating a set of
 * children. Its output is suitable for passing it onto ReactMultiChild which
 * does diffed reordering and insertion.
 */
var ReactChildReconciler = {
  /**
   * Generates a "mount image" for each of the supplied children. In the case
   * of `ReactDOMComponent`, a mount image is a string of markup.
   *
   * @param {?object} nestedChildNodes Nested child maps.
   * @return {?object} A set of child instances.
   * @internal
   */
  instantiateChildren: function (nestedChildNodes, transaction, context, selfDebugID // 0 in production and for roots
  ) {
    if (nestedChildNodes == null) {
      return null;
    }
    var childInstances = {};

    {
      traverseAllChildren(nestedChildNodes, instantiateChild, childInstances);
    }
    return childInstances;
  },

  /**
   * Updates the rendered children and returns a new set of children.
   *
   * @param {?object} prevChildren Previously initialized set of children.
   * @param {?object} nextChildren Flat child element maps.
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   * @return {?object} A new set of child instances.
   * @internal
   */
  updateChildren: function (prevChildren, nextChildren, mountImages, removedNodes, transaction, hostParent, hostContainerInfo, context, selfDebugID // 0 in production and for roots
  ) {
    // We currently don't have a way to track moves here but if we use iterators
    // instead of for..in we can zip the iterators and check if an item has
    // moved.
    // TODO: If nothing has changed, return the prevChildren object so that we
    // can quickly bailout if nothing has changed.
    if (!nextChildren && !prevChildren) {
      return;
    }
    var name;
    var prevChild;
    for (name in nextChildren) {
      if (!nextChildren.hasOwnProperty(name)) {
        continue;
      }
      prevChild = prevChildren && prevChildren[name];
      var prevElement = prevChild && prevChild._currentElement;
      var nextElement = nextChildren[name];
      if (prevChild != null && shouldUpdateReactComponent(prevElement, nextElement)) {
        ReactReconciler.receiveComponent(prevChild, nextElement, transaction, context);
        nextChildren[name] = prevChild;
      } else {
        if (prevChild) {
          removedNodes[name] = ReactReconciler.getHostNode(prevChild);
          ReactReconciler.unmountComponent(prevChild, false);
        }
        // The child must be instantiated before it's mounted.
        var nextChildInstance = instantiateReactComponent(nextElement, true);
        nextChildren[name] = nextChildInstance;
        // Creating mount image now ensures refs are resolved in right order
        // (see https://github.com/facebook/react/pull/7101 for explanation).
        var nextChildMountImage = ReactReconciler.mountComponent(nextChildInstance, transaction, hostParent, hostContainerInfo, context, selfDebugID);
        mountImages.push(nextChildMountImage);
      }
    }
    // Unmount children that are no longer present.
    for (name in prevChildren) {
      if (prevChildren.hasOwnProperty(name) && !(nextChildren && nextChildren.hasOwnProperty(name))) {
        prevChild = prevChildren[name];
        removedNodes[name] = ReactReconciler.getHostNode(prevChild);
        ReactReconciler.unmountComponent(prevChild, false);
      }
    }
  },

  /**
   * Unmounts all rendered children. This should be used to clean up children
   * when this component is unmounted.
   *
   * @param {?object} renderedChildren Previously initialized set of children.
   * @internal
   */
  unmountChildren: function (renderedChildren, safely) {
    for (var name in renderedChildren) {
      if (renderedChildren.hasOwnProperty(name)) {
        var renderedChild = renderedChildren[name];
        ReactReconciler.unmountComponent(renderedChild, safely);
      }
    }
  }

};

module.exports = ReactChildReconciler;
}).call(this,require('_process'))
},{"./KeyEscapeUtils":753,"./ReactReconciler":796,"./instantiateReactComponent":839,"./shouldUpdateReactComponent":847,"./traverseAllChildren":848,"_process":702,"fbjs/lib/warning":607,"react/lib/ReactComponentTreeHook":859}],758:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var DOMChildrenOperations = require('./DOMChildrenOperations');
var ReactDOMIDOperations = require('./ReactDOMIDOperations');

/**
 * Abstracts away all functionality of the reconciler that requires knowledge of
 * the browser context. TODO: These callers should be refactored to avoid the
 * need for this injection.
 */
var ReactComponentBrowserEnvironment = {

  processChildrenUpdates: ReactDOMIDOperations.dangerouslyProcessChildrenUpdates,

  replaceNodeWithMarkup: DOMChildrenOperations.dangerouslyReplaceNodeWithMarkup

};

module.exports = ReactComponentBrowserEnvironment;
},{"./DOMChildrenOperations":739,"./ReactDOMIDOperations":768}],759:[function(require,module,exports){
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var invariant = require('fbjs/lib/invariant');

var injected = false;

var ReactComponentEnvironment = {

  /**
   * Optionally injectable hook for swapping out mount images in the middle of
   * the tree.
   */
  replaceNodeWithMarkup: null,

  /**
   * Optionally injectable hook for processing a queue of child updates. Will
   * later move into MultiChildComponents.
   */
  processChildrenUpdates: null,

  injection: {
    injectEnvironment: function (environment) {
      !!injected ? _prodInvariant('104') : void 0;
      ReactComponentEnvironment.replaceNodeWithMarkup = environment.replaceNodeWithMarkup;
      ReactComponentEnvironment.processChildrenUpdates = environment.processChildrenUpdates;
      injected = true;
    }
  }

};

module.exports = ReactComponentEnvironment;
},{"./reactProdInvariant":843,"fbjs/lib/invariant":602}],760:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant'),
    _assign = require('object-assign');

var React = require('react/lib/React');
var ReactComponentEnvironment = require('./ReactComponentEnvironment');
var ReactCurrentOwner = require('react/lib/ReactCurrentOwner');
var ReactErrorUtils = require('./ReactErrorUtils');
var ReactInstanceMap = require('./ReactInstanceMap');
var ReactInstrumentation = require('./ReactInstrumentation');
var ReactNodeTypes = require('./ReactNodeTypes');
var ReactReconciler = require('./ReactReconciler');

var emptyObject = require('fbjs/lib/emptyObject');
var invariant = require('fbjs/lib/invariant');
var shallowEqual = require('fbjs/lib/shallowEqual');
var shouldUpdateReactComponent = require('./shouldUpdateReactComponent');
var warning = require('fbjs/lib/warning');

var CompositeTypes = {
  ImpureClass: 0,
  PureClass: 1,
  StatelessFunctional: 2
};

function StatelessComponent(Component) {}
StatelessComponent.prototype.render = function () {
  var Component = ReactInstanceMap.get(this)._currentElement.type;
  var element = Component(this.props, this.context, this.updater);
  warnIfInvalidElement(Component, element);
  return element;
};

function warnIfInvalidElement(Component, element) {}

function shouldConstruct(Component) {
  return !!(Component.prototype && Component.prototype.isReactComponent);
}

function isPureComponent(Component) {
  return !!(Component.prototype && Component.prototype.isPureReactComponent);
}

// Separated into a function to contain deoptimizations caused by try/finally.
function measureLifeCyclePerf(fn, debugID, timerType) {
  if (debugID === 0) {
    // Top-level wrappers (see ReactMount) and empty components (see
    // ReactDOMEmptyComponent) are invisible to hooks and devtools.
    // Both are implementation details that should go away in the future.
    return fn();
  }

  ReactInstrumentation.debugTool.onBeginLifeCycleTimer(debugID, timerType);
  try {
    return fn();
  } finally {
    ReactInstrumentation.debugTool.onEndLifeCycleTimer(debugID, timerType);
  }
}

/**
 * ------------------ The Life-Cycle of a Composite Component ------------------
 *
 * - constructor: Initialization of state. The instance is now retained.
 *   - componentWillMount
 *   - render
 *   - [children's constructors]
 *     - [children's componentWillMount and render]
 *     - [children's componentDidMount]
 *     - componentDidMount
 *
 *       Update Phases:
 *       - componentWillReceiveProps (only called if parent updated)
 *       - shouldComponentUpdate
 *         - componentWillUpdate
 *           - render
 *           - [children's constructors or receive props phases]
 *         - componentDidUpdate
 *
 *     - componentWillUnmount
 *     - [children's componentWillUnmount]
 *   - [children destroyed]
 * - (destroyed): The instance is now blank, released by React and ready for GC.
 *
 * -----------------------------------------------------------------------------
 */

/**
 * An incrementing ID assigned to each component when it is mounted. This is
 * used to enforce the order in which `ReactUpdates` updates dirty components.
 *
 * @private
 */
var nextMountID = 1;

/**
 * @lends {ReactCompositeComponent.prototype}
 */
var ReactCompositeComponent = {

  /**
   * Base constructor for all composite component.
   *
   * @param {ReactElement} element
   * @final
   * @internal
   */
  construct: function (element) {
    this._currentElement = element;
    this._rootNodeID = 0;
    this._compositeType = null;
    this._instance = null;
    this._hostParent = null;
    this._hostContainerInfo = null;

    // See ReactUpdateQueue
    this._updateBatchNumber = null;
    this._pendingElement = null;
    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;

    this._renderedNodeType = null;
    this._renderedComponent = null;
    this._context = null;
    this._mountOrder = 0;
    this._topLevelWrapper = null;

    // See ReactUpdates and ReactUpdateQueue.
    this._pendingCallbacks = null;

    // ComponentWillUnmount shall only be called once
    this._calledComponentWillUnmount = false;
  },

  /**
   * Initializes the component, renders markup, and registers event listeners.
   *
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {?object} hostParent
   * @param {?object} hostContainerInfo
   * @param {?object} context
   * @return {?string} Rendered markup to be inserted into the DOM.
   * @final
   * @internal
   */
  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
    var _this = this;

    this._context = context;
    this._mountOrder = nextMountID++;
    this._hostParent = hostParent;
    this._hostContainerInfo = hostContainerInfo;

    var publicProps = this._currentElement.props;
    var publicContext = this._processContext(context);

    var Component = this._currentElement.type;

    var updateQueue = transaction.getUpdateQueue();

    // Initialize the public class
    var doConstruct = shouldConstruct(Component);
    var inst = this._constructComponent(doConstruct, publicProps, publicContext, updateQueue);
    var renderedElement;

    // Support functional components
    if (!doConstruct && (inst == null || inst.render == null)) {
      renderedElement = inst;
      warnIfInvalidElement(Component, renderedElement);
      !(inst === null || inst === false || React.isValidElement(inst)) ? _prodInvariant('105', Component.displayName || Component.name || 'Component') : void 0;
      inst = new StatelessComponent(Component);
      this._compositeType = CompositeTypes.StatelessFunctional;
    } else {
      if (isPureComponent(Component)) {
        this._compositeType = CompositeTypes.PureClass;
      } else {
        this._compositeType = CompositeTypes.ImpureClass;
      }
    }

    // These should be set up in the constructor, but as a convenience for
    // simpler class abstractions, we set them up after the fact.
    inst.props = publicProps;
    inst.context = publicContext;
    inst.refs = emptyObject;
    inst.updater = updateQueue;

    this._instance = inst;

    // Store a reference from the instance back to the internal representation
    ReactInstanceMap.set(inst, this);

    var initialState = inst.state;
    if (initialState === undefined) {
      inst.state = initialState = null;
    }
    !(typeof initialState === 'object' && !Array.isArray(initialState)) ? _prodInvariant('106', this.getName() || 'ReactCompositeComponent') : void 0;

    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;

    var markup;
    if (inst.unstable_handleError) {
      markup = this.performInitialMountWithErrorHandling(renderedElement, hostParent, hostContainerInfo, transaction, context);
    } else {
      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
    }

    if (inst.componentDidMount) {
      {
        transaction.getReactMountReady().enqueue(inst.componentDidMount, inst);
      }
    }

    return markup;
  },

  _constructComponent: function (doConstruct, publicProps, publicContext, updateQueue) {
    {
      return this._constructComponentWithoutOwner(doConstruct, publicProps, publicContext, updateQueue);
    }
  },

  _constructComponentWithoutOwner: function (doConstruct, publicProps, publicContext, updateQueue) {
    var Component = this._currentElement.type;

    if (doConstruct) {
      {
        return new Component(publicProps, publicContext, updateQueue);
      }
    }

    {
      return Component(publicProps, publicContext, updateQueue);
    }
  },

  performInitialMountWithErrorHandling: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
    var markup;
    var checkpoint = transaction.checkpoint();
    try {
      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
    } catch (e) {
      // Roll back to checkpoint, handle error (which may add items to the transaction), and take a new checkpoint
      transaction.rollback(checkpoint);
      this._instance.unstable_handleError(e);
      if (this._pendingStateQueue) {
        this._instance.state = this._processPendingState(this._instance.props, this._instance.context);
      }
      checkpoint = transaction.checkpoint();

      this._renderedComponent.unmountComponent(true);
      transaction.rollback(checkpoint);

      // Try again - we've informed the component about the error, so they can render an error message this time.
      // If this throws again, the error will bubble up (and can be caught by a higher error boundary).
      markup = this.performInitialMount(renderedElement, hostParent, hostContainerInfo, transaction, context);
    }
    return markup;
  },

  performInitialMount: function (renderedElement, hostParent, hostContainerInfo, transaction, context) {
    var inst = this._instance;

    var debugID = 0;

    if (inst.componentWillMount) {
      {
        inst.componentWillMount();
      }
      // When mounting, calls to `setState` by `componentWillMount` will set
      // `this._pendingStateQueue` without triggering a re-render.
      if (this._pendingStateQueue) {
        inst.state = this._processPendingState(inst.props, inst.context);
      }
    }

    // If not a stateless component, we now render
    if (renderedElement === undefined) {
      renderedElement = this._renderValidatedComponent();
    }

    var nodeType = ReactNodeTypes.getType(renderedElement);
    this._renderedNodeType = nodeType;
    var child = this._instantiateReactComponent(renderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
    );
    this._renderedComponent = child;

    var markup = ReactReconciler.mountComponent(child, transaction, hostParent, hostContainerInfo, this._processChildContext(context), debugID);

    return markup;
  },

  getHostNode: function () {
    return ReactReconciler.getHostNode(this._renderedComponent);
  },

  /**
   * Releases any resources allocated by `mountComponent`.
   *
   * @final
   * @internal
   */
  unmountComponent: function (safely) {
    if (!this._renderedComponent) {
      return;
    }

    var inst = this._instance;

    if (inst.componentWillUnmount && !inst._calledComponentWillUnmount) {
      inst._calledComponentWillUnmount = true;

      if (safely) {
        var name = this.getName() + '.componentWillUnmount()';
        ReactErrorUtils.invokeGuardedCallback(name, inst.componentWillUnmount.bind(inst));
      } else {
        {
          inst.componentWillUnmount();
        }
      }
    }

    if (this._renderedComponent) {
      ReactReconciler.unmountComponent(this._renderedComponent, safely);
      this._renderedNodeType = null;
      this._renderedComponent = null;
      this._instance = null;
    }

    // Reset pending fields
    // Even if this component is scheduled for another update in ReactUpdates,
    // it would still be ignored because these fields are reset.
    this._pendingStateQueue = null;
    this._pendingReplaceState = false;
    this._pendingForceUpdate = false;
    this._pendingCallbacks = null;
    this._pendingElement = null;

    // These fields do not really need to be reset since this object is no
    // longer accessible.
    this._context = null;
    this._rootNodeID = 0;
    this._topLevelWrapper = null;

    // Delete the reference from the instance to this internal representation
    // which allow the internals to be properly cleaned up even if the user
    // leaks a reference to the public instance.
    ReactInstanceMap.remove(inst);

    // Some existing components rely on inst.props even after they've been
    // destroyed (in event handlers).
    // TODO: inst.props = null;
    // TODO: inst.state = null;
    // TODO: inst.context = null;
  },

  /**
   * Filters the context object to only contain keys specified in
   * `contextTypes`
   *
   * @param {object} context
   * @return {?object}
   * @private
   */
  _maskContext: function (context) {
    var Component = this._currentElement.type;
    var contextTypes = Component.contextTypes;
    if (!contextTypes) {
      return emptyObject;
    }
    var maskedContext = {};
    for (var contextName in contextTypes) {
      maskedContext[contextName] = context[contextName];
    }
    return maskedContext;
  },

  /**
   * Filters the context object to only contain keys specified in
   * `contextTypes`, and asserts that they are valid.
   *
   * @param {object} context
   * @return {?object}
   * @private
   */
  _processContext: function (context) {
    var maskedContext = this._maskContext(context);
    return maskedContext;
  },

  /**
   * @param {object} currentContext
   * @return {object}
   * @private
   */
  _processChildContext: function (currentContext) {
    var Component = this._currentElement.type;
    var inst = this._instance;
    var childContext;

    if (inst.getChildContext) {
      {
        childContext = inst.getChildContext();
      }
    }

    if (childContext) {
      !(typeof Component.childContextTypes === 'object') ? _prodInvariant('107', this.getName() || 'ReactCompositeComponent') : void 0;
      for (var name in childContext) {
        !(name in Component.childContextTypes) ? _prodInvariant('108', this.getName() || 'ReactCompositeComponent', name) : void 0;
      }
      return _assign({}, currentContext, childContext);
    }
    return currentContext;
  },

  /**
   * Assert that the context types are valid
   *
   * @param {object} typeSpecs Map of context field to a ReactPropType
   * @param {object} values Runtime values that need to be type-checked
   * @param {string} location e.g. "prop", "context", "child context"
   * @private
   */
  _checkContextTypes: function (typeSpecs, values, location) {},

  receiveComponent: function (nextElement, transaction, nextContext) {
    var prevElement = this._currentElement;
    var prevContext = this._context;

    this._pendingElement = null;

    this.updateComponent(transaction, prevElement, nextElement, prevContext, nextContext);
  },

  /**
   * If any of `_pendingElement`, `_pendingStateQueue`, or `_pendingForceUpdate`
   * is set, update the component.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  performUpdateIfNecessary: function (transaction) {
    if (this._pendingElement != null) {
      ReactReconciler.receiveComponent(this, this._pendingElement, transaction, this._context);
    } else if (this._pendingStateQueue !== null || this._pendingForceUpdate) {
      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);
    } else {
      this._updateBatchNumber = null;
    }
  },

  /**
   * Perform an update to a mounted component. The componentWillReceiveProps and
   * shouldComponentUpdate methods are called, then (assuming the update isn't
   * skipped) the remaining update lifecycle methods are called and the DOM
   * representation is updated.
   *
   * By default, this implements React's rendering and reconciliation algorithm.
   * Sophisticated clients may wish to override this.
   *
   * @param {ReactReconcileTransaction} transaction
   * @param {ReactElement} prevParentElement
   * @param {ReactElement} nextParentElement
   * @internal
   * @overridable
   */
  updateComponent: function (transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext) {
    var inst = this._instance;
    !(inst != null) ? _prodInvariant('136', this.getName() || 'ReactCompositeComponent') : void 0;

    var willReceive = false;
    var nextContext;

    // Determine if the context has changed or not
    if (this._context === nextUnmaskedContext) {
      nextContext = inst.context;
    } else {
      nextContext = this._processContext(nextUnmaskedContext);
      willReceive = true;
    }

    var prevProps = prevParentElement.props;
    var nextProps = nextParentElement.props;

    // Not a simple state update but a props update
    if (prevParentElement !== nextParentElement) {
      willReceive = true;
    }

    // An update here will schedule an update but immediately set
    // _pendingStateQueue which will ensure that any state updates gets
    // immediately reconciled instead of waiting for the next batch.
    if (willReceive && inst.componentWillReceiveProps) {
      {
        inst.componentWillReceiveProps(nextProps, nextContext);
      }
    }

    var nextState = this._processPendingState(nextProps, nextContext);
    var shouldUpdate = true;

    if (!this._pendingForceUpdate) {
      if (inst.shouldComponentUpdate) {
        {
          shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext);
        }
      } else {
        if (this._compositeType === CompositeTypes.PureClass) {
          shouldUpdate = !shallowEqual(prevProps, nextProps) || !shallowEqual(inst.state, nextState);
        }
      }
    }

    this._updateBatchNumber = null;
    if (shouldUpdate) {
      this._pendingForceUpdate = false;
      // Will set `this.props`, `this.state` and `this.context`.
      this._performComponentUpdate(nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext);
    } else {
      // If it's determined that a component should not update, we still want
      // to set props and state but we shortcut the rest of the update.
      this._currentElement = nextParentElement;
      this._context = nextUnmaskedContext;
      inst.props = nextProps;
      inst.state = nextState;
      inst.context = nextContext;
    }
  },

  _processPendingState: function (props, context) {
    var inst = this._instance;
    var queue = this._pendingStateQueue;
    var replace = this._pendingReplaceState;
    this._pendingReplaceState = false;
    this._pendingStateQueue = null;

    if (!queue) {
      return inst.state;
    }

    if (replace && queue.length === 1) {
      return queue[0];
    }

    var nextState = _assign({}, replace ? queue[0] : inst.state);
    for (var i = replace ? 1 : 0; i < queue.length; i++) {
      var partial = queue[i];
      _assign(nextState, typeof partial === 'function' ? partial.call(inst, nextState, props, context) : partial);
    }

    return nextState;
  },

  /**
   * Merges new props and state, notifies delegate methods of update and
   * performs update.
   *
   * @param {ReactElement} nextElement Next element
   * @param {object} nextProps Next public object to set as properties.
   * @param {?object} nextState Next object to set as state.
   * @param {?object} nextContext Next public object to set as context.
   * @param {ReactReconcileTransaction} transaction
   * @param {?object} unmaskedContext
   * @private
   */
  _performComponentUpdate: function (nextElement, nextProps, nextState, nextContext, transaction, unmaskedContext) {
    var _this2 = this;

    var inst = this._instance;

    var hasComponentDidUpdate = Boolean(inst.componentDidUpdate);
    var prevProps;
    var prevState;
    var prevContext;
    if (hasComponentDidUpdate) {
      prevProps = inst.props;
      prevState = inst.state;
      prevContext = inst.context;
    }

    if (inst.componentWillUpdate) {
      {
        inst.componentWillUpdate(nextProps, nextState, nextContext);
      }
    }

    this._currentElement = nextElement;
    this._context = unmaskedContext;
    inst.props = nextProps;
    inst.state = nextState;
    inst.context = nextContext;

    this._updateRenderedComponent(transaction, unmaskedContext);

    if (hasComponentDidUpdate) {
      {
        transaction.getReactMountReady().enqueue(inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst);
      }
    }
  },

  /**
   * Call the component's `render` method and update the DOM accordingly.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  _updateRenderedComponent: function (transaction, context) {
    var prevComponentInstance = this._renderedComponent;
    var prevRenderedElement = prevComponentInstance._currentElement;
    var nextRenderedElement = this._renderValidatedComponent();

    var debugID = 0;

    if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) {
      ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context));
    } else {
      var oldHostNode = ReactReconciler.getHostNode(prevComponentInstance);
      ReactReconciler.unmountComponent(prevComponentInstance, false);

      var nodeType = ReactNodeTypes.getType(nextRenderedElement);
      this._renderedNodeType = nodeType;
      var child = this._instantiateReactComponent(nextRenderedElement, nodeType !== ReactNodeTypes.EMPTY /* shouldHaveDebugID */
      );
      this._renderedComponent = child;

      var nextMarkup = ReactReconciler.mountComponent(child, transaction, this._hostParent, this._hostContainerInfo, this._processChildContext(context), debugID);

      this._replaceNodeWithMarkup(oldHostNode, nextMarkup, prevComponentInstance);
    }
  },

  /**
   * Overridden in shallow rendering.
   *
   * @protected
   */
  _replaceNodeWithMarkup: function (oldHostNode, nextMarkup, prevInstance) {
    ReactComponentEnvironment.replaceNodeWithMarkup(oldHostNode, nextMarkup, prevInstance);
  },

  /**
   * @protected
   */
  _renderValidatedComponentWithoutOwnerOrContext: function () {
    var inst = this._instance;
    var renderedElement;

    {
      renderedElement = inst.render();
    }

    return renderedElement;
  },

  /**
   * @private
   */
  _renderValidatedComponent: function () {
    var renderedElement;
    if (this._compositeType !== CompositeTypes.StatelessFunctional) {
      ReactCurrentOwner.current = this;
      try {
        renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
      } finally {
        ReactCurrentOwner.current = null;
      }
    } else {
      renderedElement = this._renderValidatedComponentWithoutOwnerOrContext();
    }
    !(
    // TODO: An `isValidNode` function would probably be more appropriate
    (renderedElement === null || renderedElement === false || React.isValidElement(renderedElement))) ? _prodInvariant('109', this.getName() || 'ReactCompositeComponent') : void 0;

    return renderedElement;
  },

  /**
   * Lazily allocates the refs object and stores `component` as `ref`.
   *
   * @param {string} ref Reference name.
   * @param {component} component Component to store as `ref`.
   * @final
   * @private
   */
  attachRef: function (ref, component) {
    var inst = this.getPublicInstance();
    !(inst != null) ? _prodInvariant('110') : void 0;
    var publicComponentInstance = component.getPublicInstance();
    var refs = inst.refs === emptyObject ? inst.refs = {} : inst.refs;
    refs[ref] = publicComponentInstance;
  },

  /**
   * Detaches a reference name.
   *
   * @param {string} ref Name to dereference.
   * @final
   * @private
   */
  detachRef: function (ref) {
    var refs = this.getPublicInstance().refs;
    delete refs[ref];
  },

  /**
   * Get a text description of the component that can be used to identify it
   * in error messages.
   * @return {string} The name or null.
   * @internal
   */
  getName: function () {
    var type = this._currentElement.type;
    var constructor = this._instance && this._instance.constructor;
    return type.displayName || constructor && constructor.displayName || type.name || constructor && constructor.name || null;
  },

  /**
   * Get the publicly accessible representation of this component - i.e. what
   * is exposed by refs and returned by render. Can be null for stateless
   * components.
   *
   * @return {ReactComponent} the public component instance.
   * @internal
   */
  getPublicInstance: function () {
    var inst = this._instance;
    if (this._compositeType === CompositeTypes.StatelessFunctional) {
      return null;
    }
    return inst;
  },

  // Stub
  _instantiateReactComponent: null

};

module.exports = ReactCompositeComponent;
},{"./ReactComponentEnvironment":759,"./ReactErrorUtils":780,"./ReactInstanceMap":787,"./ReactInstrumentation":788,"./ReactNodeTypes":792,"./ReactReconciler":796,"./reactProdInvariant":843,"./shouldUpdateReactComponent":847,"fbjs/lib/emptyObject":595,"fbjs/lib/invariant":602,"fbjs/lib/shallowEqual":606,"fbjs/lib/warning":607,"object-assign":701,"react/lib/React":852,"react/lib/ReactCurrentOwner":860}],761:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/* globals __REACT_DEVTOOLS_GLOBAL_HOOK__*/

'use strict';

var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactDefaultInjection = require('./ReactDefaultInjection');
var ReactMount = require('./ReactMount');
var ReactReconciler = require('./ReactReconciler');
var ReactUpdates = require('./ReactUpdates');
var ReactVersion = require('./ReactVersion');

var findDOMNode = require('./findDOMNode');
var getHostComponentFromComposite = require('./getHostComponentFromComposite');
var renderSubtreeIntoContainer = require('./renderSubtreeIntoContainer');
var warning = require('fbjs/lib/warning');

ReactDefaultInjection.inject();

var ReactDOM = {
  findDOMNode: findDOMNode,
  render: ReactMount.render,
  unmountComponentAtNode: ReactMount.unmountComponentAtNode,
  version: ReactVersion,

  /* eslint-disable camelcase */
  unstable_batchedUpdates: ReactUpdates.batchedUpdates,
  unstable_renderSubtreeIntoContainer: renderSubtreeIntoContainer
};

// Inject the runtime into a devtools global hook regardless of browser.
// Allows for debugging when the hook is injected on the page.
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== 'undefined' && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.inject === 'function') {
  __REACT_DEVTOOLS_GLOBAL_HOOK__.inject({
    ComponentTree: {
      getClosestInstanceFromNode: ReactDOMComponentTree.getClosestInstanceFromNode,
      getNodeFromInstance: function (inst) {
        // inst is an internal instance (but could be a composite)
        if (inst._renderedComponent) {
          inst = getHostComponentFromComposite(inst);
        }
        if (inst) {
          return ReactDOMComponentTree.getNodeFromInstance(inst);
        } else {
          return null;
        }
      }
    },
    Mount: ReactMount,
    Reconciler: ReactReconciler
  });
}

module.exports = ReactDOM;
},{"./ReactDOMComponentTree":764,"./ReactDefaultInjection":777,"./ReactMount":790,"./ReactReconciler":796,"./ReactUpdates":801,"./ReactVersion":802,"./findDOMNode":826,"./getHostComponentFromComposite":833,"./renderSubtreeIntoContainer":844,"fbjs/lib/warning":607}],762:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/* global hasOwnProperty:true */

'use strict';

var _prodInvariant = require('./reactProdInvariant'),
    _assign = require('object-assign');

var AutoFocusUtils = require('./AutoFocusUtils');
var CSSPropertyOperations = require('./CSSPropertyOperations');
var DOMLazyTree = require('./DOMLazyTree');
var DOMNamespaces = require('./DOMNamespaces');
var DOMProperty = require('./DOMProperty');
var DOMPropertyOperations = require('./DOMPropertyOperations');
var EventPluginHub = require('./EventPluginHub');
var EventPluginRegistry = require('./EventPluginRegistry');
var ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');
var ReactDOMComponentFlags = require('./ReactDOMComponentFlags');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactDOMInput = require('./ReactDOMInput');
var ReactDOMOption = require('./ReactDOMOption');
var ReactDOMSelect = require('./ReactDOMSelect');
var ReactDOMTextarea = require('./ReactDOMTextarea');
var ReactInstrumentation = require('./ReactInstrumentation');
var ReactMultiChild = require('./ReactMultiChild');
var ReactServerRenderingTransaction = require('./ReactServerRenderingTransaction');

var emptyFunction = require('fbjs/lib/emptyFunction');
var escapeTextContentForBrowser = require('./escapeTextContentForBrowser');
var invariant = require('fbjs/lib/invariant');
var isEventSupported = require('./isEventSupported');
var shallowEqual = require('fbjs/lib/shallowEqual');
var validateDOMNesting = require('./validateDOMNesting');
var warning = require('fbjs/lib/warning');

var Flags = ReactDOMComponentFlags;
var deleteListener = EventPluginHub.deleteListener;
var getNode = ReactDOMComponentTree.getNodeFromInstance;
var listenTo = ReactBrowserEventEmitter.listenTo;
var registrationNameModules = EventPluginRegistry.registrationNameModules;

// For quickly matching children type, to test if can be treated as content.
var CONTENT_TYPES = { 'string': true, 'number': true };

var STYLE = 'style';
var HTML = '__html';
var RESERVED_PROPS = {
  children: null,
  dangerouslySetInnerHTML: null,
  suppressContentEditableWarning: null
};

// Node type for document fragments (Node.DOCUMENT_FRAGMENT_NODE).
var DOC_FRAGMENT_TYPE = 11;

function getDeclarationErrorAddendum(internalInstance) {
  if (internalInstance) {
    var owner = internalInstance._currentElement._owner || null;
    if (owner) {
      var name = owner.getName();
      if (name) {
        return ' This DOM node was rendered by `' + name + '`.';
      }
    }
  }
  return '';
}

function friendlyStringify(obj) {
  if (typeof obj === 'object') {
    if (Array.isArray(obj)) {
      return '[' + obj.map(friendlyStringify).join(', ') + ']';
    } else {
      var pairs = [];
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          var keyEscaped = /^[a-z$_][\w$_]*$/i.test(key) ? key : JSON.stringify(key);
          pairs.push(keyEscaped + ': ' + friendlyStringify(obj[key]));
        }
      }
      return '{' + pairs.join(', ') + '}';
    }
  } else if (typeof obj === 'string') {
    return JSON.stringify(obj);
  } else if (typeof obj === 'function') {
    return '[function object]';
  }
  // Differs from JSON.stringify in that undefined because undefined and that
  // inf and nan don't become null
  return String(obj);
}

var styleMutationWarning = {};

function checkAndWarnForMutatedStyle(style1, style2, component) {
  if (style1 == null || style2 == null) {
    return;
  }
  if (shallowEqual(style1, style2)) {
    return;
  }

  var componentName = component._tag;
  var owner = component._currentElement._owner;
  var ownerName;
  if (owner) {
    ownerName = owner.getName();
  }

  var hash = ownerName + '|' + componentName;

  if (styleMutationWarning.hasOwnProperty(hash)) {
    return;
  }

  styleMutationWarning[hash] = true;

  void 0;
}

/**
 * @param {object} component
 * @param {?object} props
 */
function assertValidProps(component, props) {
  if (!props) {
    return;
  }
  // Note the use of `==` which checks for null or undefined.
  if (voidElementTags[component._tag]) {
    !(props.children == null && props.dangerouslySetInnerHTML == null) ? _prodInvariant('137', component._tag, component._currentElement._owner ? ' Check the render method of ' + component._currentElement._owner.getName() + '.' : '') : void 0;
  }
  if (props.dangerouslySetInnerHTML != null) {
    !(props.children == null) ? _prodInvariant('60') : void 0;
    !(typeof props.dangerouslySetInnerHTML === 'object' && HTML in props.dangerouslySetInnerHTML) ? _prodInvariant('61') : void 0;
  }
  !(props.style == null || typeof props.style === 'object') ? _prodInvariant('62', getDeclarationErrorAddendum(component)) : void 0;
}

function enqueuePutListener(inst, registrationName, listener, transaction) {
  if (transaction instanceof ReactServerRenderingTransaction) {
    return;
  }
  var containerInfo = inst._hostContainerInfo;
  var isDocumentFragment = containerInfo._node && containerInfo._node.nodeType === DOC_FRAGMENT_TYPE;
  var doc = isDocumentFragment ? containerInfo._node : containerInfo._ownerDocument;
  listenTo(registrationName, doc);
  transaction.getReactMountReady().enqueue(putListener, {
    inst: inst,
    registrationName: registrationName,
    listener: listener
  });
}

function putListener() {
  var listenerToPut = this;
  EventPluginHub.putListener(listenerToPut.inst, listenerToPut.registrationName, listenerToPut.listener);
}

function inputPostMount() {
  var inst = this;
  ReactDOMInput.postMountWrapper(inst);
}

function textareaPostMount() {
  var inst = this;
  ReactDOMTextarea.postMountWrapper(inst);
}

function optionPostMount() {
  var inst = this;
  ReactDOMOption.postMountWrapper(inst);
}

var setAndValidateContentChildDev = emptyFunction;

// There are so many media events, it makes sense to just
// maintain a list rather than create a `trapBubbledEvent` for each
var mediaEvents = {
  topAbort: 'abort',
  topCanPlay: 'canplay',
  topCanPlayThrough: 'canplaythrough',
  topDurationChange: 'durationchange',
  topEmptied: 'emptied',
  topEncrypted: 'encrypted',
  topEnded: 'ended',
  topError: 'error',
  topLoadedData: 'loadeddata',
  topLoadedMetadata: 'loadedmetadata',
  topLoadStart: 'loadstart',
  topPause: 'pause',
  topPlay: 'play',
  topPlaying: 'playing',
  topProgress: 'progress',
  topRateChange: 'ratechange',
  topSeeked: 'seeked',
  topSeeking: 'seeking',
  topStalled: 'stalled',
  topSuspend: 'suspend',
  topTimeUpdate: 'timeupdate',
  topVolumeChange: 'volumechange',
  topWaiting: 'waiting'
};

function trapBubbledEventsLocal() {
  var inst = this;
  // If a component renders to null or if another component fatals and causes
  // the state of the tree to be corrupted, `node` here can be null.
  !inst._rootNodeID ? _prodInvariant('63') : void 0;
  var node = getNode(inst);
  !node ? _prodInvariant('64') : void 0;

  switch (inst._tag) {
    case 'iframe':
    case 'object':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
      break;
    case 'video':
    case 'audio':

      inst._wrapperState.listeners = [];
      // Create listener for each media event
      for (var event in mediaEvents) {
        if (mediaEvents.hasOwnProperty(event)) {
          inst._wrapperState.listeners.push(ReactBrowserEventEmitter.trapBubbledEvent(event, mediaEvents[event], node));
        }
      }
      break;
    case 'source':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node)];
      break;
    case 'img':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topError', 'error', node), ReactBrowserEventEmitter.trapBubbledEvent('topLoad', 'load', node)];
      break;
    case 'form':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topReset', 'reset', node), ReactBrowserEventEmitter.trapBubbledEvent('topSubmit', 'submit', node)];
      break;
    case 'input':
    case 'select':
    case 'textarea':
      inst._wrapperState.listeners = [ReactBrowserEventEmitter.trapBubbledEvent('topInvalid', 'invalid', node)];
      break;
  }
}

function postUpdateSelectWrapper() {
  ReactDOMSelect.postUpdateWrapper(this);
}

// For HTML, certain tags should omit their close tag. We keep a whitelist for
// those special-case tags.

var omittedCloseTags = {
  'area': true,
  'base': true,
  'br': true,
  'col': true,
  'embed': true,
  'hr': true,
  'img': true,
  'input': true,
  'keygen': true,
  'link': true,
  'meta': true,
  'param': true,
  'source': true,
  'track': true,
  'wbr': true
};

var newlineEatingTags = {
  'listing': true,
  'pre': true,
  'textarea': true
};

// For HTML, certain tags cannot have children. This has the same purpose as
// `omittedCloseTags` except that `menuitem` should still have its closing tag.

var voidElementTags = _assign({
  'menuitem': true
}, omittedCloseTags);

// We accept any tag to be rendered but since this gets injected into arbitrary
// HTML, we want to make sure that it's a safe tag.
// http://www.w3.org/TR/REC-xml/#NT-Name

var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/; // Simplified subset
var validatedTagCache = {};
var hasOwnProperty = {}.hasOwnProperty;

function validateDangerousTag(tag) {
  if (!hasOwnProperty.call(validatedTagCache, tag)) {
    !VALID_TAG_REGEX.test(tag) ? _prodInvariant('65', tag) : void 0;
    validatedTagCache[tag] = true;
  }
}

function isCustomComponent(tagName, props) {
  return tagName.indexOf('-') >= 0 || props.is != null;
}

var globalIdCounter = 1;

/**
 * Creates a new React class that is idempotent and capable of containing other
 * React components. It accepts event listeners and DOM properties that are
 * valid according to `DOMProperty`.
 *
 *  - Event listeners: `onClick`, `onMouseDown`, etc.
 *  - DOM properties: `className`, `name`, `title`, etc.
 *
 * The `style` property functions differently from the DOM API. It accepts an
 * object mapping of style properties to values.
 *
 * @constructor ReactDOMComponent
 * @extends ReactMultiChild
 */
function ReactDOMComponent(element) {
  var tag = element.type;
  validateDangerousTag(tag);
  this._currentElement = element;
  this._tag = tag.toLowerCase();
  this._namespaceURI = null;
  this._renderedChildren = null;
  this._previousStyle = null;
  this._previousStyleCopy = null;
  this._hostNode = null;
  this._hostParent = null;
  this._rootNodeID = 0;
  this._domID = 0;
  this._hostContainerInfo = null;
  this._wrapperState = null;
  this._topLevelWrapper = null;
  this._flags = 0;
}

ReactDOMComponent.displayName = 'ReactDOMComponent';

ReactDOMComponent.Mixin = {

  /**
   * Generates root tag markup then recurses. This method has side effects and
   * is not idempotent.
   *
   * @internal
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {?ReactDOMComponent} the parent component instance
   * @param {?object} info about the host container
   * @param {object} context
   * @return {string} The computed markup.
   */
  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
    this._rootNodeID = globalIdCounter++;
    this._domID = hostContainerInfo._idCounter++;
    this._hostParent = hostParent;
    this._hostContainerInfo = hostContainerInfo;

    var props = this._currentElement.props;

    switch (this._tag) {
      case 'audio':
      case 'form':
      case 'iframe':
      case 'img':
      case 'link':
      case 'object':
      case 'source':
      case 'video':
        this._wrapperState = {
          listeners: null
        };
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
      case 'input':
        ReactDOMInput.mountWrapper(this, props, hostParent);
        props = ReactDOMInput.getHostProps(this, props);
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
      case 'option':
        ReactDOMOption.mountWrapper(this, props, hostParent);
        props = ReactDOMOption.getHostProps(this, props);
        break;
      case 'select':
        ReactDOMSelect.mountWrapper(this, props, hostParent);
        props = ReactDOMSelect.getHostProps(this, props);
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
      case 'textarea':
        ReactDOMTextarea.mountWrapper(this, props, hostParent);
        props = ReactDOMTextarea.getHostProps(this, props);
        transaction.getReactMountReady().enqueue(trapBubbledEventsLocal, this);
        break;
    }

    assertValidProps(this, props);

    // We create tags in the namespace of their parent container, except HTML
    // tags get no namespace.
    var namespaceURI;
    var parentTag;
    if (hostParent != null) {
      namespaceURI = hostParent._namespaceURI;
      parentTag = hostParent._tag;
    } else if (hostContainerInfo._tag) {
      namespaceURI = hostContainerInfo._namespaceURI;
      parentTag = hostContainerInfo._tag;
    }
    if (namespaceURI == null || namespaceURI === DOMNamespaces.svg && parentTag === 'foreignobject') {
      namespaceURI = DOMNamespaces.html;
    }
    if (namespaceURI === DOMNamespaces.html) {
      if (this._tag === 'svg') {
        namespaceURI = DOMNamespaces.svg;
      } else if (this._tag === 'math') {
        namespaceURI = DOMNamespaces.mathml;
      }
    }
    this._namespaceURI = namespaceURI;

    var mountImage;
    if (transaction.useCreateElement) {
      var ownerDocument = hostContainerInfo._ownerDocument;
      var el;
      if (namespaceURI === DOMNamespaces.html) {
        if (this._tag === 'script') {
          // Create the script via .innerHTML so its "parser-inserted" flag is
          // set to true and it does not execute
          var div = ownerDocument.createElement('div');
          var type = this._currentElement.type;
          div.innerHTML = '<' + type + '></' + type + '>';
          el = div.removeChild(div.firstChild);
        } else if (props.is) {
          el = ownerDocument.createElement(this._currentElement.type, props.is);
        } else {
          // Separate else branch instead of using `props.is || undefined` above becuase of a Firefox bug.
          // See discussion in https://github.com/facebook/react/pull/6896
          // and discussion in https://bugzilla.mozilla.org/show_bug.cgi?id=1276240
          el = ownerDocument.createElement(this._currentElement.type);
        }
      } else {
        el = ownerDocument.createElementNS(namespaceURI, this._currentElement.type);
      }
      ReactDOMComponentTree.precacheNode(this, el);
      this._flags |= Flags.hasCachedChildNodes;
      if (!this._hostParent) {
        DOMPropertyOperations.setAttributeForRoot(el);
      }
      this._updateDOMProperties(null, props, transaction);
      var lazyTree = DOMLazyTree(el);
      this._createInitialChildren(transaction, props, context, lazyTree);
      mountImage = lazyTree;
    } else {
      var tagOpen = this._createOpenTagMarkupAndPutListeners(transaction, props);
      var tagContent = this._createContentMarkup(transaction, props, context);
      if (!tagContent && omittedCloseTags[this._tag]) {
        mountImage = tagOpen + '/>';
      } else {
        mountImage = tagOpen + '>' + tagContent + '</' + this._currentElement.type + '>';
      }
    }

    switch (this._tag) {
      case 'input':
        transaction.getReactMountReady().enqueue(inputPostMount, this);
        if (props.autoFocus) {
          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
        }
        break;
      case 'textarea':
        transaction.getReactMountReady().enqueue(textareaPostMount, this);
        if (props.autoFocus) {
          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
        }
        break;
      case 'select':
        if (props.autoFocus) {
          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
        }
        break;
      case 'button':
        if (props.autoFocus) {
          transaction.getReactMountReady().enqueue(AutoFocusUtils.focusDOMComponent, this);
        }
        break;
      case 'option':
        transaction.getReactMountReady().enqueue(optionPostMount, this);
        break;
    }

    return mountImage;
  },

  /**
   * Creates markup for the open tag and all attributes.
   *
   * This method has side effects because events get registered.
   *
   * Iterating over object properties is faster than iterating over arrays.
   * @see http://jsperf.com/obj-vs-arr-iteration
   *
   * @private
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} props
   * @return {string} Markup of opening tag.
   */
  _createOpenTagMarkupAndPutListeners: function (transaction, props) {
    var ret = '<' + this._currentElement.type;

    for (var propKey in props) {
      if (!props.hasOwnProperty(propKey)) {
        continue;
      }
      var propValue = props[propKey];
      if (propValue == null) {
        continue;
      }
      if (registrationNameModules.hasOwnProperty(propKey)) {
        if (propValue) {
          enqueuePutListener(this, propKey, propValue, transaction);
        }
      } else {
        if (propKey === STYLE) {
          if (propValue) {
            propValue = this._previousStyleCopy = _assign({}, props.style);
          }
          propValue = CSSPropertyOperations.createMarkupForStyles(propValue, this);
        }
        var markup = null;
        if (this._tag != null && isCustomComponent(this._tag, props)) {
          if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
            markup = DOMPropertyOperations.createMarkupForCustomAttribute(propKey, propValue);
          }
        } else {
          markup = DOMPropertyOperations.createMarkupForProperty(propKey, propValue);
        }
        if (markup) {
          ret += ' ' + markup;
        }
      }
    }

    // For static pages, no need to put React ID and checksum. Saves lots of
    // bytes.
    if (transaction.renderToStaticMarkup) {
      return ret;
    }

    if (!this._hostParent) {
      ret += ' ' + DOMPropertyOperations.createMarkupForRoot();
    }
    ret += ' ' + DOMPropertyOperations.createMarkupForID(this._domID);
    return ret;
  },

  /**
   * Creates markup for the content between the tags.
   *
   * @private
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} props
   * @param {object} context
   * @return {string} Content markup.
   */
  _createContentMarkup: function (transaction, props, context) {
    var ret = '';

    // Intentional use of != to avoid catching zero/false.
    var innerHTML = props.dangerouslySetInnerHTML;
    if (innerHTML != null) {
      if (innerHTML.__html != null) {
        ret = innerHTML.__html;
      }
    } else {
      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
      var childrenToUse = contentToUse != null ? null : props.children;
      if (contentToUse != null) {
        // TODO: Validate that text is allowed as a child of this node
        ret = escapeTextContentForBrowser(contentToUse);
      } else if (childrenToUse != null) {
        var mountImages = this.mountChildren(childrenToUse, transaction, context);
        ret = mountImages.join('');
      }
    }
    if (newlineEatingTags[this._tag] && ret.charAt(0) === '\n') {
      // text/html ignores the first character in these tags if it's a newline
      // Prefer to break application/xml over text/html (for now) by adding
      // a newline specifically to get eaten by the parser. (Alternately for
      // textareas, replacing "^\n" with "\r\n" doesn't get eaten, and the first
      // \r is normalized out by HTMLTextAreaElement#value.)
      // See: <http://www.w3.org/TR/html-polyglot/#newlines-in-textarea-and-pre>
      // See: <http://www.w3.org/TR/html5/syntax.html#element-restrictions>
      // See: <http://www.w3.org/TR/html5/syntax.html#newlines>
      // See: Parsing of "textarea" "listing" and "pre" elements
      //  from <http://www.w3.org/TR/html5/syntax.html#parsing-main-inbody>
      return '\n' + ret;
    } else {
      return ret;
    }
  },

  _createInitialChildren: function (transaction, props, context, lazyTree) {
    // Intentional use of != to avoid catching zero/false.
    var innerHTML = props.dangerouslySetInnerHTML;
    if (innerHTML != null) {
      if (innerHTML.__html != null) {
        DOMLazyTree.queueHTML(lazyTree, innerHTML.__html);
      }
    } else {
      var contentToUse = CONTENT_TYPES[typeof props.children] ? props.children : null;
      var childrenToUse = contentToUse != null ? null : props.children;
      if (contentToUse != null) {
        DOMLazyTree.queueText(lazyTree, contentToUse);
      } else if (childrenToUse != null) {
        var mountImages = this.mountChildren(childrenToUse, transaction, context);
        for (var i = 0; i < mountImages.length; i++) {
          DOMLazyTree.queueChild(lazyTree, mountImages[i]);
        }
      }
    }
  },

  /**
   * Receives a next element and updates the component.
   *
   * @internal
   * @param {ReactElement} nextElement
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {object} context
   */
  receiveComponent: function (nextElement, transaction, context) {
    var prevElement = this._currentElement;
    this._currentElement = nextElement;
    this.updateComponent(transaction, prevElement, nextElement, context);
  },

  /**
   * Updates a DOM component after it has already been allocated and
   * attached to the DOM. Reconciles the root DOM node, then recurses.
   *
   * @param {ReactReconcileTransaction} transaction
   * @param {ReactElement} prevElement
   * @param {ReactElement} nextElement
   * @internal
   * @overridable
   */
  updateComponent: function (transaction, prevElement, nextElement, context) {
    var lastProps = prevElement.props;
    var nextProps = this._currentElement.props;

    switch (this._tag) {
      case 'input':
        lastProps = ReactDOMInput.getHostProps(this, lastProps);
        nextProps = ReactDOMInput.getHostProps(this, nextProps);
        break;
      case 'option':
        lastProps = ReactDOMOption.getHostProps(this, lastProps);
        nextProps = ReactDOMOption.getHostProps(this, nextProps);
        break;
      case 'select':
        lastProps = ReactDOMSelect.getHostProps(this, lastProps);
        nextProps = ReactDOMSelect.getHostProps(this, nextProps);
        break;
      case 'textarea':
        lastProps = ReactDOMTextarea.getHostProps(this, lastProps);
        nextProps = ReactDOMTextarea.getHostProps(this, nextProps);
        break;
    }

    assertValidProps(this, nextProps);
    this._updateDOMProperties(lastProps, nextProps, transaction);
    this._updateDOMChildren(lastProps, nextProps, transaction, context);

    switch (this._tag) {
      case 'input':
        // Update the wrapper around inputs *after* updating props. This has to
        // happen after `_updateDOMProperties`. Otherwise HTML5 input validations
        // raise warnings and prevent the new value from being assigned.
        ReactDOMInput.updateWrapper(this);
        break;
      case 'textarea':
        ReactDOMTextarea.updateWrapper(this);
        break;
      case 'select':
        // <select> value update needs to occur after <option> children
        // reconciliation
        transaction.getReactMountReady().enqueue(postUpdateSelectWrapper, this);
        break;
    }
  },

  /**
   * Reconciles the properties by detecting differences in property values and
   * updating the DOM as necessary. This function is probably the single most
   * critical path for performance optimization.
   *
   * TODO: Benchmark whether checking for changed values in memory actually
   *       improves performance (especially statically positioned elements).
   * TODO: Benchmark the effects of putting this at the top since 99% of props
   *       do not change for a given reconciliation.
   * TODO: Benchmark areas that can be improved with caching.
   *
   * @private
   * @param {object} lastProps
   * @param {object} nextProps
   * @param {?DOMElement} node
   */
  _updateDOMProperties: function (lastProps, nextProps, transaction) {
    var propKey;
    var styleName;
    var styleUpdates;
    for (propKey in lastProps) {
      if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
        continue;
      }
      if (propKey === STYLE) {
        var lastStyle = this._previousStyleCopy;
        for (styleName in lastStyle) {
          if (lastStyle.hasOwnProperty(styleName)) {
            styleUpdates = styleUpdates || {};
            styleUpdates[styleName] = '';
          }
        }
        this._previousStyleCopy = null;
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        if (lastProps[propKey]) {
          // Only call deleteListener if there was a listener previously or
          // else willDeleteListener gets called when there wasn't actually a
          // listener (e.g., onClick={null})
          deleteListener(this, propKey);
        }
      } else if (isCustomComponent(this._tag, lastProps)) {
        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
          DOMPropertyOperations.deleteValueForAttribute(getNode(this), propKey);
        }
      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
        DOMPropertyOperations.deleteValueForProperty(getNode(this), propKey);
      }
    }
    for (propKey in nextProps) {
      var nextProp = nextProps[propKey];
      var lastProp = propKey === STYLE ? this._previousStyleCopy : lastProps != null ? lastProps[propKey] : undefined;
      if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
        continue;
      }
      if (propKey === STYLE) {
        if (nextProp) {
          nextProp = this._previousStyleCopy = _assign({}, nextProp);
        } else {
          this._previousStyleCopy = null;
        }
        if (lastProp) {
          // Unset styles on `lastProp` but not on `nextProp`.
          for (styleName in lastProp) {
            if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = '';
            }
          }
          // Update styles that changed since `lastProp`.
          for (styleName in nextProp) {
            if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
              styleUpdates = styleUpdates || {};
              styleUpdates[styleName] = nextProp[styleName];
            }
          }
        } else {
          // Relies on `updateStylesByID` not mutating `styleUpdates`.
          styleUpdates = nextProp;
        }
      } else if (registrationNameModules.hasOwnProperty(propKey)) {
        if (nextProp) {
          enqueuePutListener(this, propKey, nextProp, transaction);
        } else if (lastProp) {
          deleteListener(this, propKey);
        }
      } else if (isCustomComponent(this._tag, nextProps)) {
        if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
          DOMPropertyOperations.setValueForAttribute(getNode(this), propKey, nextProp);
        }
      } else if (DOMProperty.properties[propKey] || DOMProperty.isCustomAttribute(propKey)) {
        var node = getNode(this);
        // If we're updating to null or undefined, we should remove the property
        // from the DOM node instead of inadvertently setting to a string. This
        // brings us in line with the same behavior we have on initial render.
        if (nextProp != null) {
          DOMPropertyOperations.setValueForProperty(node, propKey, nextProp);
        } else {
          DOMPropertyOperations.deleteValueForProperty(node, propKey);
        }
      }
    }
    if (styleUpdates) {
      CSSPropertyOperations.setValueForStyles(getNode(this), styleUpdates, this);
    }
  },

  /**
   * Reconciles the children with the various properties that affect the
   * children content.
   *
   * @param {object} lastProps
   * @param {object} nextProps
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   */
  _updateDOMChildren: function (lastProps, nextProps, transaction, context) {
    var lastContent = CONTENT_TYPES[typeof lastProps.children] ? lastProps.children : null;
    var nextContent = CONTENT_TYPES[typeof nextProps.children] ? nextProps.children : null;

    var lastHtml = lastProps.dangerouslySetInnerHTML && lastProps.dangerouslySetInnerHTML.__html;
    var nextHtml = nextProps.dangerouslySetInnerHTML && nextProps.dangerouslySetInnerHTML.__html;

    // Note the use of `!=` which checks for null or undefined.
    var lastChildren = lastContent != null ? null : lastProps.children;
    var nextChildren = nextContent != null ? null : nextProps.children;

    // If we're switching from children to content/html or vice versa, remove
    // the old content
    var lastHasContentOrHtml = lastContent != null || lastHtml != null;
    var nextHasContentOrHtml = nextContent != null || nextHtml != null;
    if (lastChildren != null && nextChildren == null) {
      this.updateChildren(null, transaction, context);
    } else if (lastHasContentOrHtml && !nextHasContentOrHtml) {
      this.updateTextContent('');
    }

    if (nextContent != null) {
      if (lastContent !== nextContent) {
        this.updateTextContent('' + nextContent);
      }
    } else if (nextHtml != null) {
      if (lastHtml !== nextHtml) {
        this.updateMarkup('' + nextHtml);
      }
    } else if (nextChildren != null) {
      this.updateChildren(nextChildren, transaction, context);
    }
  },

  getHostNode: function () {
    return getNode(this);
  },

  /**
   * Destroys all event registrations for this instance. Does not remove from
   * the DOM. That must be done by the parent.
   *
   * @internal
   */
  unmountComponent: function (safely) {
    switch (this._tag) {
      case 'audio':
      case 'form':
      case 'iframe':
      case 'img':
      case 'link':
      case 'object':
      case 'source':
      case 'video':
        var listeners = this._wrapperState.listeners;
        if (listeners) {
          for (var i = 0; i < listeners.length; i++) {
            listeners[i].remove();
          }
        }
        break;
      case 'html':
      case 'head':
      case 'body':
        /**
         * Components like <html> <head> and <body> can't be removed or added
         * easily in a cross-browser way, however it's valuable to be able to
         * take advantage of React's reconciliation for styling and <title>
         * management. So we just document it and throw in dangerous cases.
         */
        _prodInvariant('66', this._tag);
        break;
    }

    this.unmountChildren(safely);
    ReactDOMComponentTree.uncacheNode(this);
    EventPluginHub.deleteAllListeners(this);
    this._rootNodeID = 0;
    this._domID = 0;
    this._wrapperState = null;
  },

  getPublicInstance: function () {
    return getNode(this);
  }

};

_assign(ReactDOMComponent.prototype, ReactDOMComponent.Mixin, ReactMultiChild.Mixin);

module.exports = ReactDOMComponent;
},{"./AutoFocusUtils":733,"./CSSPropertyOperations":736,"./DOMLazyTree":740,"./DOMNamespaces":741,"./DOMProperty":742,"./DOMPropertyOperations":743,"./EventPluginHub":747,"./EventPluginRegistry":748,"./ReactBrowserEventEmitter":756,"./ReactDOMComponentFlags":763,"./ReactDOMComponentTree":764,"./ReactDOMInput":769,"./ReactDOMOption":770,"./ReactDOMSelect":771,"./ReactDOMTextarea":774,"./ReactInstrumentation":788,"./ReactMultiChild":791,"./ReactServerRenderingTransaction":798,"./escapeTextContentForBrowser":825,"./isEventSupported":840,"./reactProdInvariant":843,"./validateDOMNesting":849,"fbjs/lib/emptyFunction":594,"fbjs/lib/invariant":602,"fbjs/lib/shallowEqual":606,"fbjs/lib/warning":607,"object-assign":701}],763:[function(require,module,exports){
/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ReactDOMComponentFlags = {
  hasCachedChildNodes: 1 << 0
};

module.exports = ReactDOMComponentFlags;
},{}],764:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var DOMProperty = require('./DOMProperty');
var ReactDOMComponentFlags = require('./ReactDOMComponentFlags');

var invariant = require('fbjs/lib/invariant');

var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
var Flags = ReactDOMComponentFlags;

var internalInstanceKey = '__reactInternalInstance$' + Math.random().toString(36).slice(2);

/**
 * Drill down (through composites and empty components) until we get a host or
 * host text component.
 *
 * This is pretty polymorphic but unavoidable with the current structure we have
 * for `_renderedChildren`.
 */
function getRenderedHostOrTextFromComponent(component) {
  var rendered;
  while (rendered = component._renderedComponent) {
    component = rendered;
  }
  return component;
}

/**
 * Populate `_hostNode` on the rendered host/text component with the given
 * DOM node. The passed `inst` can be a composite.
 */
function precacheNode(inst, node) {
  var hostInst = getRenderedHostOrTextFromComponent(inst);
  hostInst._hostNode = node;
  node[internalInstanceKey] = hostInst;
}

function uncacheNode(inst) {
  var node = inst._hostNode;
  if (node) {
    delete node[internalInstanceKey];
    inst._hostNode = null;
  }
}

/**
 * Populate `_hostNode` on each child of `inst`, assuming that the children
 * match up with the DOM (element) children of `node`.
 *
 * We cache entire levels at once to avoid an n^2 problem where we access the
 * children of a node sequentially and have to walk from the start to our target
 * node every time.
 *
 * Since we update `_renderedChildren` and the actual DOM at (slightly)
 * different times, we could race here and see a newer `_renderedChildren` than
 * the DOM nodes we see. To avoid this, ReactMultiChild calls
 * `prepareToManageChildren` before we change `_renderedChildren`, at which
 * time the container's child nodes are always cached (until it unmounts).
 */
function precacheChildNodes(inst, node) {
  if (inst._flags & Flags.hasCachedChildNodes) {
    return;
  }
  var children = inst._renderedChildren;
  var childNode = node.firstChild;
  outer: for (var name in children) {
    if (!children.hasOwnProperty(name)) {
      continue;
    }
    var childInst = children[name];
    var childID = getRenderedHostOrTextFromComponent(childInst)._domID;
    if (childID === 0) {
      // We're currently unmounting this child in ReactMultiChild; skip it.
      continue;
    }
    // We assume the child nodes are in the same order as the child instances.
    for (; childNode !== null; childNode = childNode.nextSibling) {
      if (childNode.nodeType === 1 && childNode.getAttribute(ATTR_NAME) === String(childID) || childNode.nodeType === 8 && childNode.nodeValue === ' react-text: ' + childID + ' ' || childNode.nodeType === 8 && childNode.nodeValue === ' react-empty: ' + childID + ' ') {
        precacheNode(childInst, childNode);
        continue outer;
      }
    }
    // We reached the end of the DOM children without finding an ID match.
    _prodInvariant('32', childID);
  }
  inst._flags |= Flags.hasCachedChildNodes;
}

/**
 * Given a DOM node, return the closest ReactDOMComponent or
 * ReactDOMTextComponent instance ancestor.
 */
function getClosestInstanceFromNode(node) {
  if (node[internalInstanceKey]) {
    return node[internalInstanceKey];
  }

  // Walk up the tree until we find an ancestor whose instance we have cached.
  var parents = [];
  while (!node[internalInstanceKey]) {
    parents.push(node);
    if (node.parentNode) {
      node = node.parentNode;
    } else {
      // Top of the tree. This node must not be part of a React tree (or is
      // unmounted, potentially).
      return null;
    }
  }

  var closest;
  var inst;
  for (; node && (inst = node[internalInstanceKey]); node = parents.pop()) {
    closest = inst;
    if (parents.length) {
      precacheChildNodes(inst, node);
    }
  }

  return closest;
}

/**
 * Given a DOM node, return the ReactDOMComponent or ReactDOMTextComponent
 * instance, or null if the node was not rendered by this React.
 */
function getInstanceFromNode(node) {
  var inst = getClosestInstanceFromNode(node);
  if (inst != null && inst._hostNode === node) {
    return inst;
  } else {
    return null;
  }
}

/**
 * Given a ReactDOMComponent or ReactDOMTextComponent, return the corresponding
 * DOM node.
 */
function getNodeFromInstance(inst) {
  // Without this first invariant, passing a non-DOM-component triggers the next
  // invariant for a missing parent, which is super confusing.
  !(inst._hostNode !== undefined) ? _prodInvariant('33') : void 0;

  if (inst._hostNode) {
    return inst._hostNode;
  }

  // Walk up the tree until we find an ancestor whose DOM node we have cached.
  var parents = [];
  while (!inst._hostNode) {
    parents.push(inst);
    !inst._hostParent ? _prodInvariant('34') : void 0;
    inst = inst._hostParent;
  }

  // Now parents contains each ancestor that does *not* have a cached native
  // node, and `inst` is the deepest ancestor that does.
  for (; parents.length; inst = parents.pop()) {
    precacheChildNodes(inst, inst._hostNode);
  }

  return inst._hostNode;
}

var ReactDOMComponentTree = {
  getClosestInstanceFromNode: getClosestInstanceFromNode,
  getInstanceFromNode: getInstanceFromNode,
  getNodeFromInstance: getNodeFromInstance,
  precacheChildNodes: precacheChildNodes,
  precacheNode: precacheNode,
  uncacheNode: uncacheNode
};

module.exports = ReactDOMComponentTree;
},{"./DOMProperty":742,"./ReactDOMComponentFlags":763,"./reactProdInvariant":843,"fbjs/lib/invariant":602}],765:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var validateDOMNesting = require('./validateDOMNesting');

var DOC_NODE_TYPE = 9;

function ReactDOMContainerInfo(topLevelWrapper, node) {
  var info = {
    _topLevelWrapper: topLevelWrapper,
    _idCounter: 1,
    _ownerDocument: node ? node.nodeType === DOC_NODE_TYPE ? node : node.ownerDocument : null,
    _node: node,
    _tag: node ? node.nodeName.toLowerCase() : null,
    _namespaceURI: node ? node.namespaceURI : null
  };
  return info;
}

module.exports = ReactDOMContainerInfo;
},{"./validateDOMNesting":849}],766:[function(require,module,exports){
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

var DOMLazyTree = require('./DOMLazyTree');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');

var ReactDOMEmptyComponent = function (instantiate) {
  // ReactCompositeComponent uses this:
  this._currentElement = null;
  // ReactDOMComponentTree uses these:
  this._hostNode = null;
  this._hostParent = null;
  this._hostContainerInfo = null;
  this._domID = 0;
};
_assign(ReactDOMEmptyComponent.prototype, {
  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
    var domID = hostContainerInfo._idCounter++;
    this._domID = domID;
    this._hostParent = hostParent;
    this._hostContainerInfo = hostContainerInfo;

    var nodeValue = ' react-empty: ' + this._domID + ' ';
    if (transaction.useCreateElement) {
      var ownerDocument = hostContainerInfo._ownerDocument;
      var node = ownerDocument.createComment(nodeValue);
      ReactDOMComponentTree.precacheNode(this, node);
      return DOMLazyTree(node);
    } else {
      if (transaction.renderToStaticMarkup) {
        // Normally we'd insert a comment node, but since this is a situation
        // where React won't take over (static pages), we can simply return
        // nothing.
        return '';
      }
      return '<!--' + nodeValue + '-->';
    }
  },
  receiveComponent: function () {},
  getHostNode: function () {
    return ReactDOMComponentTree.getNodeFromInstance(this);
  },
  unmountComponent: function () {
    ReactDOMComponentTree.uncacheNode(this);
  }
});

module.exports = ReactDOMEmptyComponent;
},{"./DOMLazyTree":740,"./ReactDOMComponentTree":764,"object-assign":701}],767:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ReactDOMFeatureFlags = {
  useCreateElement: true,
  useFiber: false
};

module.exports = ReactDOMFeatureFlags;
},{}],768:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var DOMChildrenOperations = require('./DOMChildrenOperations');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');

/**
 * Operations used to process updates to DOM nodes.
 */
var ReactDOMIDOperations = {

  /**
   * Updates a component's children by processing a series of updates.
   *
   * @param {array<object>} updates List of update configurations.
   * @internal
   */
  dangerouslyProcessChildrenUpdates: function (parentInst, updates) {
    var node = ReactDOMComponentTree.getNodeFromInstance(parentInst);
    DOMChildrenOperations.processUpdates(node, updates);
  }
};

module.exports = ReactDOMIDOperations;
},{"./DOMChildrenOperations":739,"./ReactDOMComponentTree":764}],769:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant'),
    _assign = require('object-assign');

var DOMPropertyOperations = require('./DOMPropertyOperations');
var LinkedValueUtils = require('./LinkedValueUtils');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactUpdates = require('./ReactUpdates');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

var didWarnValueLink = false;
var didWarnCheckedLink = false;
var didWarnValueDefaultValue = false;
var didWarnCheckedDefaultChecked = false;
var didWarnControlledToUncontrolled = false;
var didWarnUncontrolledToControlled = false;

function forceUpdateIfMounted() {
  if (this._rootNodeID) {
    // DOM component is still mounted; update
    ReactDOMInput.updateWrapper(this);
  }
}

function isControlled(props) {
  var usesChecked = props.type === 'checkbox' || props.type === 'radio';
  return usesChecked ? props.checked != null : props.value != null;
}

/**
 * Implements an <input> host component that allows setting these optional
 * props: `checked`, `value`, `defaultChecked`, and `defaultValue`.
 *
 * If `checked` or `value` are not supplied (or null/undefined), user actions
 * that affect the checked state or value will trigger updates to the element.
 *
 * If they are supplied (and not null/undefined), the rendered element will not
 * trigger updates to the element. Instead, the props must change in order for
 * the rendered element to be updated.
 *
 * The rendered element will be initialized as unchecked (or `defaultChecked`)
 * with an empty value (or `defaultValue`).
 *
 * @see http://www.w3.org/TR/2012/WD-html5-20121025/the-input-element.html
 */
var ReactDOMInput = {
  getHostProps: function (inst, props) {
    var value = LinkedValueUtils.getValue(props);
    var checked = LinkedValueUtils.getChecked(props);

    var hostProps = _assign({
      // Make sure we set .type before any other properties (setting .value
      // before .type means .value is lost in IE11 and below)
      type: undefined,
      // Make sure we set .step before .value (setting .value before .step
      // means .value is rounded on mount, based upon step precision)
      step: undefined,
      // Make sure we set .min & .max before .value (to ensure proper order
      // in corner cases such as min or max deriving from value, e.g. Issue #7170)
      min: undefined,
      max: undefined
    }, props, {
      defaultChecked: undefined,
      defaultValue: undefined,
      value: value != null ? value : inst._wrapperState.initialValue,
      checked: checked != null ? checked : inst._wrapperState.initialChecked,
      onChange: inst._wrapperState.onChange
    });

    return hostProps;
  },

  mountWrapper: function (inst, props) {
    var defaultValue = props.defaultValue;
    inst._wrapperState = {
      initialChecked: props.checked != null ? props.checked : props.defaultChecked,
      initialValue: props.value != null ? props.value : defaultValue,
      listeners: null,
      onChange: _handleChange.bind(inst)
    };
  },

  updateWrapper: function (inst) {
    var props = inst._currentElement.props;

    // TODO: Shouldn't this be getChecked(props)?
    var checked = props.checked;
    if (checked != null) {
      DOMPropertyOperations.setValueForProperty(ReactDOMComponentTree.getNodeFromInstance(inst), 'checked', checked || false);
    }

    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
    var value = LinkedValueUtils.getValue(props);
    if (value != null) {

      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      var newValue = '' + value;

      // To avoid side effects (such as losing text selection), only set value if changed
      if (newValue !== node.value) {
        node.value = newValue;
      }
    } else {
      if (props.value == null && props.defaultValue != null) {
        node.defaultValue = '' + props.defaultValue;
      }
      if (props.checked == null && props.defaultChecked != null) {
        node.defaultChecked = !!props.defaultChecked;
      }
    }
  },

  postMountWrapper: function (inst) {
    var props = inst._currentElement.props;

    // This is in postMount because we need access to the DOM node, which is not
    // available until after the component has mounted.
    var node = ReactDOMComponentTree.getNodeFromInstance(inst);

    // Detach value from defaultValue. We won't do anything if we're working on
    // submit or reset inputs as those values & defaultValues are linked. They
    // are not resetable nodes so this operation doesn't matter and actually
    // removes browser-default values (eg "Submit Query") when no value is
    // provided.

    switch (props.type) {
      case 'submit':
      case 'reset':
        break;
      case 'color':
      case 'date':
      case 'datetime':
      case 'datetime-local':
      case 'month':
      case 'time':
      case 'week':
        // This fixes the no-show issue on iOS Safari and Android Chrome:
        // https://github.com/facebook/react/issues/7233
        node.value = '';
        node.value = node.defaultValue;
        break;
      default:
        node.value = node.value;
        break;
    }

    // Normally, we'd just do `node.checked = node.checked` upon initial mount, less this bug
    // this is needed to work around a chrome bug where setting defaultChecked
    // will sometimes influence the value of checked (even after detachment).
    // Reference: https://bugs.chromium.org/p/chromium/issues/detail?id=608416
    // We need to temporarily unset name to avoid disrupting radio button groups.
    var name = node.name;
    if (name !== '') {
      node.name = '';
    }
    node.defaultChecked = !node.defaultChecked;
    node.defaultChecked = !node.defaultChecked;
    if (name !== '') {
      node.name = name;
    }
  }
};

function _handleChange(event) {
  var props = this._currentElement.props;

  var returnValue = LinkedValueUtils.executeOnChange(props, event);

  // Here we use asap to wait until all updates have propagated, which
  // is important when using controlled components within layers:
  // https://github.com/facebook/react/issues/1698
  ReactUpdates.asap(forceUpdateIfMounted, this);

  var name = props.name;
  if (props.type === 'radio' && name != null) {
    var rootNode = ReactDOMComponentTree.getNodeFromInstance(this);
    var queryRoot = rootNode;

    while (queryRoot.parentNode) {
      queryRoot = queryRoot.parentNode;
    }

    // If `rootNode.form` was non-null, then we could try `form.elements`,
    // but that sometimes behaves strangely in IE8. We could also try using
    // `form.getElementsByName`, but that will only return direct children
    // and won't include inputs that use the HTML5 `form=` attribute. Since
    // the input might not even be in a form, let's just use the global
    // `querySelectorAll` to ensure we don't miss anything.
    var group = queryRoot.querySelectorAll('input[name=' + JSON.stringify('' + name) + '][type="radio"]');

    for (var i = 0; i < group.length; i++) {
      var otherNode = group[i];
      if (otherNode === rootNode || otherNode.form !== rootNode.form) {
        continue;
      }
      // This will throw if radio buttons rendered by different copies of React
      // and the same name are rendered into the same form (same as #1939).
      // That's probably okay; we don't support it just as we don't support
      // mixing React radio buttons with non-React ones.
      var otherInstance = ReactDOMComponentTree.getInstanceFromNode(otherNode);
      !otherInstance ? _prodInvariant('90') : void 0;
      // If this is a controlled radio button group, forcing the input that
      // was previously checked to update will cause it to be come re-checked
      // as appropriate.
      ReactUpdates.asap(forceUpdateIfMounted, otherInstance);
    }
  }

  return returnValue;
}

module.exports = ReactDOMInput;
},{"./DOMPropertyOperations":743,"./LinkedValueUtils":754,"./ReactDOMComponentTree":764,"./ReactUpdates":801,"./reactProdInvariant":843,"fbjs/lib/invariant":602,"fbjs/lib/warning":607,"object-assign":701}],770:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

var React = require('react/lib/React');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactDOMSelect = require('./ReactDOMSelect');

var warning = require('fbjs/lib/warning');
var didWarnInvalidOptionChildren = false;

function flattenChildren(children) {
  var content = '';

  // Flatten children and warn if they aren't strings or numbers;
  // invalid types are ignored.
  React.Children.forEach(children, function (child) {
    if (child == null) {
      return;
    }
    if (typeof child === 'string' || typeof child === 'number') {
      content += child;
    } else if (!didWarnInvalidOptionChildren) {
      didWarnInvalidOptionChildren = true;
      void 0;
    }
  });

  return content;
}

/**
 * Implements an <option> host component that warns when `selected` is set.
 */
var ReactDOMOption = {
  mountWrapper: function (inst, props, hostParent) {
    // Look up whether this option is 'selected'
    var selectValue = null;
    if (hostParent != null) {
      var selectParent = hostParent;

      if (selectParent._tag === 'optgroup') {
        selectParent = selectParent._hostParent;
      }

      if (selectParent != null && selectParent._tag === 'select') {
        selectValue = ReactDOMSelect.getSelectValueContext(selectParent);
      }
    }

    // If the value is null (e.g., no specified value or after initial mount)
    // or missing (e.g., for <datalist>), we don't change props.selected
    var selected = null;
    if (selectValue != null) {
      var value;
      if (props.value != null) {
        value = props.value + '';
      } else {
        value = flattenChildren(props.children);
      }
      selected = false;
      if (Array.isArray(selectValue)) {
        // multiple
        for (var i = 0; i < selectValue.length; i++) {
          if ('' + selectValue[i] === value) {
            selected = true;
            break;
          }
        }
      } else {
        selected = '' + selectValue === value;
      }
    }

    inst._wrapperState = { selected: selected };
  },

  postMountWrapper: function (inst) {
    // value="" should make a value attribute (#6219)
    var props = inst._currentElement.props;
    if (props.value != null) {
      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
      node.setAttribute('value', props.value);
    }
  },

  getHostProps: function (inst, props) {
    var hostProps = _assign({ selected: undefined, children: undefined }, props);

    // Read state only from initial mount because <select> updates value
    // manually; we need the initial state only for server rendering
    if (inst._wrapperState.selected != null) {
      hostProps.selected = inst._wrapperState.selected;
    }

    var content = flattenChildren(props.children);

    if (content) {
      hostProps.children = content;
    }

    return hostProps;
  }

};

module.exports = ReactDOMOption;
},{"./ReactDOMComponentTree":764,"./ReactDOMSelect":771,"fbjs/lib/warning":607,"object-assign":701,"react/lib/React":852}],771:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

var LinkedValueUtils = require('./LinkedValueUtils');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactUpdates = require('./ReactUpdates');

var warning = require('fbjs/lib/warning');

var didWarnValueLink = false;
var didWarnValueDefaultValue = false;

function updateOptionsIfPendingUpdateAndMounted() {
  if (this._rootNodeID && this._wrapperState.pendingUpdate) {
    this._wrapperState.pendingUpdate = false;

    var props = this._currentElement.props;
    var value = LinkedValueUtils.getValue(props);

    if (value != null) {
      updateOptions(this, Boolean(props.multiple), value);
    }
  }
}

function getDeclarationErrorAddendum(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

var valuePropNames = ['value', 'defaultValue'];

/**
 * Validation function for `value` and `defaultValue`.
 * @private
 */
function checkSelectPropTypes(inst, props) {
  var owner = inst._currentElement._owner;
  LinkedValueUtils.checkPropTypes('select', props, owner);

  if (props.valueLink !== undefined && !didWarnValueLink) {
    void 0;
    didWarnValueLink = true;
  }

  for (var i = 0; i < valuePropNames.length; i++) {
    var propName = valuePropNames[i];
    if (props[propName] == null) {
      continue;
    }
    var isArray = Array.isArray(props[propName]);
    if (props.multiple && !isArray) {
      void 0;
    } else if (!props.multiple && isArray) {
      void 0;
    }
  }
}

/**
 * @param {ReactDOMComponent} inst
 * @param {boolean} multiple
 * @param {*} propValue A stringable (with `multiple`, a list of stringables).
 * @private
 */
function updateOptions(inst, multiple, propValue) {
  var selectedValue, i;
  var options = ReactDOMComponentTree.getNodeFromInstance(inst).options;

  if (multiple) {
    selectedValue = {};
    for (i = 0; i < propValue.length; i++) {
      selectedValue['' + propValue[i]] = true;
    }
    for (i = 0; i < options.length; i++) {
      var selected = selectedValue.hasOwnProperty(options[i].value);
      if (options[i].selected !== selected) {
        options[i].selected = selected;
      }
    }
  } else {
    // Do not set `select.value` as exact behavior isn't consistent across all
    // browsers for all cases.
    selectedValue = '' + propValue;
    for (i = 0; i < options.length; i++) {
      if (options[i].value === selectedValue) {
        options[i].selected = true;
        return;
      }
    }
    if (options.length) {
      options[0].selected = true;
    }
  }
}

/**
 * Implements a <select> host component that allows optionally setting the
 * props `value` and `defaultValue`. If `multiple` is false, the prop must be a
 * stringable. If `multiple` is true, the prop must be an array of stringables.
 *
 * If `value` is not supplied (or null/undefined), user actions that change the
 * selected option will trigger updates to the rendered options.
 *
 * If it is supplied (and not null/undefined), the rendered options will not
 * update in response to user actions. Instead, the `value` prop must change in
 * order for the rendered options to update.
 *
 * If `defaultValue` is provided, any options with the supplied values will be
 * selected.
 */
var ReactDOMSelect = {
  getHostProps: function (inst, props) {
    return _assign({}, props, {
      onChange: inst._wrapperState.onChange,
      value: undefined
    });
  },

  mountWrapper: function (inst, props) {
    var value = LinkedValueUtils.getValue(props);
    inst._wrapperState = {
      pendingUpdate: false,
      initialValue: value != null ? value : props.defaultValue,
      listeners: null,
      onChange: _handleChange.bind(inst),
      wasMultiple: Boolean(props.multiple)
    };

    if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
      void 0;
      didWarnValueDefaultValue = true;
    }
  },

  getSelectValueContext: function (inst) {
    // ReactDOMOption looks at this initial value so the initial generated
    // markup has correct `selected` attributes
    return inst._wrapperState.initialValue;
  },

  postUpdateWrapper: function (inst) {
    var props = inst._currentElement.props;

    // After the initial mount, we control selected-ness manually so don't pass
    // this value down
    inst._wrapperState.initialValue = undefined;

    var wasMultiple = inst._wrapperState.wasMultiple;
    inst._wrapperState.wasMultiple = Boolean(props.multiple);

    var value = LinkedValueUtils.getValue(props);
    if (value != null) {
      inst._wrapperState.pendingUpdate = false;
      updateOptions(inst, Boolean(props.multiple), value);
    } else if (wasMultiple !== Boolean(props.multiple)) {
      // For simplicity, reapply `defaultValue` if `multiple` is toggled.
      if (props.defaultValue != null) {
        updateOptions(inst, Boolean(props.multiple), props.defaultValue);
      } else {
        // Revert the select back to its default unselected state.
        updateOptions(inst, Boolean(props.multiple), props.multiple ? [] : '');
      }
    }
  }
};

function _handleChange(event) {
  var props = this._currentElement.props;
  var returnValue = LinkedValueUtils.executeOnChange(props, event);

  if (this._rootNodeID) {
    this._wrapperState.pendingUpdate = true;
  }
  ReactUpdates.asap(updateOptionsIfPendingUpdateAndMounted, this);
  return returnValue;
}

module.exports = ReactDOMSelect;
},{"./LinkedValueUtils":754,"./ReactDOMComponentTree":764,"./ReactUpdates":801,"fbjs/lib/warning":607,"object-assign":701}],772:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var getNodeForCharacterOffset = require('./getNodeForCharacterOffset');
var getTextContentAccessor = require('./getTextContentAccessor');

/**
 * While `isCollapsed` is available on the Selection object and `collapsed`
 * is available on the Range object, IE11 sometimes gets them wrong.
 * If the anchor/focus nodes and offsets are the same, the range is collapsed.
 */
function isCollapsed(anchorNode, anchorOffset, focusNode, focusOffset) {
  return anchorNode === focusNode && anchorOffset === focusOffset;
}

/**
 * Get the appropriate anchor and focus node/offset pairs for IE.
 *
 * The catch here is that IE's selection API doesn't provide information
 * about whether the selection is forward or backward, so we have to
 * behave as though it's always forward.
 *
 * IE text differs from modern selection in that it behaves as though
 * block elements end with a new line. This means character offsets will
 * differ between the two APIs.
 *
 * @param {DOMElement} node
 * @return {object}
 */
function getIEOffsets(node) {
  var selection = document.selection;
  var selectedRange = selection.createRange();
  var selectedLength = selectedRange.text.length;

  // Duplicate selection so we can move range without breaking user selection.
  var fromStart = selectedRange.duplicate();
  fromStart.moveToElementText(node);
  fromStart.setEndPoint('EndToStart', selectedRange);

  var startOffset = fromStart.text.length;
  var endOffset = startOffset + selectedLength;

  return {
    start: startOffset,
    end: endOffset
  };
}

/**
 * @param {DOMElement} node
 * @return {?object}
 */
function getModernOffsets(node) {
  var selection = window.getSelection && window.getSelection();

  if (!selection || selection.rangeCount === 0) {
    return null;
  }

  var anchorNode = selection.anchorNode;
  var anchorOffset = selection.anchorOffset;
  var focusNode = selection.focusNode;
  var focusOffset = selection.focusOffset;

  var currentRange = selection.getRangeAt(0);

  // In Firefox, range.startContainer and range.endContainer can be "anonymous
  // divs", e.g. the up/down buttons on an <input type="number">. Anonymous
  // divs do not seem to expose properties, triggering a "Permission denied
  // error" if any of its properties are accessed. The only seemingly possible
  // way to avoid erroring is to access a property that typically works for
  // non-anonymous divs and catch any error that may otherwise arise. See
  // https://bugzilla.mozilla.org/show_bug.cgi?id=208427
  try {
    /* eslint-disable no-unused-expressions */
    currentRange.startContainer.nodeType;
    currentRange.endContainer.nodeType;
    /* eslint-enable no-unused-expressions */
  } catch (e) {
    return null;
  }

  // If the node and offset values are the same, the selection is collapsed.
  // `Selection.isCollapsed` is available natively, but IE sometimes gets
  // this value wrong.
  var isSelectionCollapsed = isCollapsed(selection.anchorNode, selection.anchorOffset, selection.focusNode, selection.focusOffset);

  var rangeLength = isSelectionCollapsed ? 0 : currentRange.toString().length;

  var tempRange = currentRange.cloneRange();
  tempRange.selectNodeContents(node);
  tempRange.setEnd(currentRange.startContainer, currentRange.startOffset);

  var isTempRangeCollapsed = isCollapsed(tempRange.startContainer, tempRange.startOffset, tempRange.endContainer, tempRange.endOffset);

  var start = isTempRangeCollapsed ? 0 : tempRange.toString().length;
  var end = start + rangeLength;

  // Detect whether the selection is backward.
  var detectionRange = document.createRange();
  detectionRange.setStart(anchorNode, anchorOffset);
  detectionRange.setEnd(focusNode, focusOffset);
  var isBackward = detectionRange.collapsed;

  return {
    start: isBackward ? end : start,
    end: isBackward ? start : end
  };
}

/**
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setIEOffsets(node, offsets) {
  var range = document.selection.createRange().duplicate();
  var start, end;

  if (offsets.end === undefined) {
    start = offsets.start;
    end = start;
  } else if (offsets.start > offsets.end) {
    start = offsets.end;
    end = offsets.start;
  } else {
    start = offsets.start;
    end = offsets.end;
  }

  range.moveToElementText(node);
  range.moveStart('character', start);
  range.setEndPoint('EndToStart', range);
  range.moveEnd('character', end - start);
  range.select();
}

/**
 * In modern non-IE browsers, we can support both forward and backward
 * selections.
 *
 * Note: IE10+ supports the Selection object, but it does not support
 * the `extend` method, which means that even in modern IE, it's not possible
 * to programmatically create a backward selection. Thus, for all IE
 * versions, we use the old IE API to create our selections.
 *
 * @param {DOMElement|DOMTextNode} node
 * @param {object} offsets
 */
function setModernOffsets(node, offsets) {
  if (!window.getSelection) {
    return;
  }

  var selection = window.getSelection();
  var length = node[getTextContentAccessor()].length;
  var start = Math.min(offsets.start, length);
  var end = offsets.end === undefined ? start : Math.min(offsets.end, length);

  // IE 11 uses modern selection, but doesn't support the extend method.
  // Flip backward selections, so we can set with a single range.
  if (!selection.extend && start > end) {
    var temp = end;
    end = start;
    start = temp;
  }

  var startMarker = getNodeForCharacterOffset(node, start);
  var endMarker = getNodeForCharacterOffset(node, end);

  if (startMarker && endMarker) {
    var range = document.createRange();
    range.setStart(startMarker.node, startMarker.offset);
    selection.removeAllRanges();

    if (start > end) {
      selection.addRange(range);
      selection.extend(endMarker.node, endMarker.offset);
    } else {
      range.setEnd(endMarker.node, endMarker.offset);
      selection.addRange(range);
    }
  }
}

var useIEOffsets = ExecutionEnvironment.canUseDOM && 'selection' in document && !('getSelection' in window);

var ReactDOMSelection = {
  /**
   * @param {DOMElement} node
   */
  getOffsets: useIEOffsets ? getIEOffsets : getModernOffsets,

  /**
   * @param {DOMElement|DOMTextNode} node
   * @param {object} offsets
   */
  setOffsets: useIEOffsets ? setIEOffsets : setModernOffsets
};

module.exports = ReactDOMSelection;
},{"./getNodeForCharacterOffset":836,"./getTextContentAccessor":837,"fbjs/lib/ExecutionEnvironment":588}],773:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant'),
    _assign = require('object-assign');

var DOMChildrenOperations = require('./DOMChildrenOperations');
var DOMLazyTree = require('./DOMLazyTree');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');

var escapeTextContentForBrowser = require('./escapeTextContentForBrowser');
var invariant = require('fbjs/lib/invariant');
var validateDOMNesting = require('./validateDOMNesting');

/**
 * Text nodes violate a couple assumptions that React makes about components:
 *
 *  - When mounting text into the DOM, adjacent text nodes are merged.
 *  - Text nodes cannot be assigned a React root ID.
 *
 * This component is used to wrap strings between comment nodes so that they
 * can undergo the same reconciliation that is applied to elements.
 *
 * TODO: Investigate representing React components in the DOM with text nodes.
 *
 * @class ReactDOMTextComponent
 * @extends ReactComponent
 * @internal
 */
var ReactDOMTextComponent = function (text) {
  // TODO: This is really a ReactText (ReactNode), not a ReactElement
  this._currentElement = text;
  this._stringText = '' + text;
  // ReactDOMComponentTree uses these:
  this._hostNode = null;
  this._hostParent = null;

  // Properties
  this._domID = 0;
  this._mountIndex = 0;
  this._closingComment = null;
  this._commentNodes = null;
};

_assign(ReactDOMTextComponent.prototype, {

  /**
   * Creates the markup for this text node. This node is not intended to have
   * any features besides containing text content.
   *
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @return {string} Markup for this text node.
   * @internal
   */
  mountComponent: function (transaction, hostParent, hostContainerInfo, context) {
    var domID = hostContainerInfo._idCounter++;
    var openingValue = ' react-text: ' + domID + ' ';
    var closingValue = ' /react-text ';
    this._domID = domID;
    this._hostParent = hostParent;
    if (transaction.useCreateElement) {
      var ownerDocument = hostContainerInfo._ownerDocument;
      var openingComment = ownerDocument.createComment(openingValue);
      var closingComment = ownerDocument.createComment(closingValue);
      var lazyTree = DOMLazyTree(ownerDocument.createDocumentFragment());
      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(openingComment));
      if (this._stringText) {
        DOMLazyTree.queueChild(lazyTree, DOMLazyTree(ownerDocument.createTextNode(this._stringText)));
      }
      DOMLazyTree.queueChild(lazyTree, DOMLazyTree(closingComment));
      ReactDOMComponentTree.precacheNode(this, openingComment);
      this._closingComment = closingComment;
      return lazyTree;
    } else {
      var escapedText = escapeTextContentForBrowser(this._stringText);

      if (transaction.renderToStaticMarkup) {
        // Normally we'd wrap this between comment nodes for the reasons stated
        // above, but since this is a situation where React won't take over
        // (static pages), we can simply return the text as it is.
        return escapedText;
      }

      return '<!--' + openingValue + '-->' + escapedText + '<!--' + closingValue + '-->';
    }
  },

  /**
   * Updates this component by updating the text content.
   *
   * @param {ReactText} nextText The next text content
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  receiveComponent: function (nextText, transaction) {
    if (nextText !== this._currentElement) {
      this._currentElement = nextText;
      var nextStringText = '' + nextText;
      if (nextStringText !== this._stringText) {
        // TODO: Save this as pending props and use performUpdateIfNecessary
        // and/or updateComponent to do the actual update for consistency with
        // other component types?
        this._stringText = nextStringText;
        var commentNodes = this.getHostNode();
        DOMChildrenOperations.replaceDelimitedText(commentNodes[0], commentNodes[1], nextStringText);
      }
    }
  },

  getHostNode: function () {
    var hostNode = this._commentNodes;
    if (hostNode) {
      return hostNode;
    }
    if (!this._closingComment) {
      var openingComment = ReactDOMComponentTree.getNodeFromInstance(this);
      var node = openingComment.nextSibling;
      while (true) {
        !(node != null) ? _prodInvariant('67', this._domID) : void 0;
        if (node.nodeType === 8 && node.nodeValue === ' /react-text ') {
          this._closingComment = node;
          break;
        }
        node = node.nextSibling;
      }
    }
    hostNode = [this._hostNode, this._closingComment];
    this._commentNodes = hostNode;
    return hostNode;
  },

  unmountComponent: function () {
    this._closingComment = null;
    this._commentNodes = null;
    ReactDOMComponentTree.uncacheNode(this);
  }

});

module.exports = ReactDOMTextComponent;
},{"./DOMChildrenOperations":739,"./DOMLazyTree":740,"./ReactDOMComponentTree":764,"./escapeTextContentForBrowser":825,"./reactProdInvariant":843,"./validateDOMNesting":849,"fbjs/lib/invariant":602,"object-assign":701}],774:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant'),
    _assign = require('object-assign');

var LinkedValueUtils = require('./LinkedValueUtils');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactUpdates = require('./ReactUpdates');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

var didWarnValueLink = false;
var didWarnValDefaultVal = false;

function forceUpdateIfMounted() {
  if (this._rootNodeID) {
    // DOM component is still mounted; update
    ReactDOMTextarea.updateWrapper(this);
  }
}

/**
 * Implements a <textarea> host component that allows setting `value`, and
 * `defaultValue`. This differs from the traditional DOM API because value is
 * usually set as PCDATA children.
 *
 * If `value` is not supplied (or null/undefined), user actions that affect the
 * value will trigger updates to the element.
 *
 * If `value` is supplied (and not null/undefined), the rendered element will
 * not trigger updates to the element. Instead, the `value` prop must change in
 * order for the rendered element to be updated.
 *
 * The rendered element will be initialized with an empty value, the prop
 * `defaultValue` if specified, or the children content (deprecated).
 */
var ReactDOMTextarea = {
  getHostProps: function (inst, props) {
    !(props.dangerouslySetInnerHTML == null) ? _prodInvariant('91') : void 0;

    // Always set children to the same thing. In IE9, the selection range will
    // get reset if `textContent` is mutated.  We could add a check in setTextContent
    // to only set the value if/when the value differs from the node value (which would
    // completely solve this IE9 bug), but Sebastian+Ben seemed to like this solution.
    // The value can be a boolean or object so that's why it's forced to be a string.
    var hostProps = _assign({}, props, {
      value: undefined,
      defaultValue: undefined,
      children: '' + inst._wrapperState.initialValue,
      onChange: inst._wrapperState.onChange
    });

    return hostProps;
  },

  mountWrapper: function (inst, props) {
    var value = LinkedValueUtils.getValue(props);
    var initialValue = value;

    // Only bother fetching default value if we're going to use it
    if (value == null) {
      var defaultValue = props.defaultValue;
      // TODO (yungsters): Remove support for children content in <textarea>.
      var children = props.children;
      if (children != null) {
        !(defaultValue == null) ? _prodInvariant('92') : void 0;
        if (Array.isArray(children)) {
          !(children.length <= 1) ? _prodInvariant('93') : void 0;
          children = children[0];
        }

        defaultValue = '' + children;
      }
      if (defaultValue == null) {
        defaultValue = '';
      }
      initialValue = defaultValue;
    }

    inst._wrapperState = {
      initialValue: '' + initialValue,
      listeners: null,
      onChange: _handleChange.bind(inst)
    };
  },

  updateWrapper: function (inst) {
    var props = inst._currentElement.props;

    var node = ReactDOMComponentTree.getNodeFromInstance(inst);
    var value = LinkedValueUtils.getValue(props);
    if (value != null) {
      // Cast `value` to a string to ensure the value is set correctly. While
      // browsers typically do this as necessary, jsdom doesn't.
      var newValue = '' + value;

      // To avoid side effects (such as losing text selection), only set value if changed
      if (newValue !== node.value) {
        node.value = newValue;
      }
      if (props.defaultValue == null) {
        node.defaultValue = newValue;
      }
    }
    if (props.defaultValue != null) {
      node.defaultValue = props.defaultValue;
    }
  },

  postMountWrapper: function (inst) {
    // This is in postMount because we need access to the DOM node, which is not
    // available until after the component has mounted.
    var node = ReactDOMComponentTree.getNodeFromInstance(inst);

    // Warning: node.value may be the empty string at this point (IE11) if placeholder is set.
    node.value = node.textContent; // Detach value from defaultValue
  }
};

function _handleChange(event) {
  var props = this._currentElement.props;
  var returnValue = LinkedValueUtils.executeOnChange(props, event);
  ReactUpdates.asap(forceUpdateIfMounted, this);
  return returnValue;
}

module.exports = ReactDOMTextarea;
},{"./LinkedValueUtils":754,"./ReactDOMComponentTree":764,"./ReactUpdates":801,"./reactProdInvariant":843,"fbjs/lib/invariant":602,"fbjs/lib/warning":607,"object-assign":701}],775:[function(require,module,exports){
/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var invariant = require('fbjs/lib/invariant');

/**
 * Return the lowest common ancestor of A and B, or null if they are in
 * different trees.
 */
function getLowestCommonAncestor(instA, instB) {
  !('_hostNode' in instA) ? _prodInvariant('33') : void 0;
  !('_hostNode' in instB) ? _prodInvariant('33') : void 0;

  var depthA = 0;
  for (var tempA = instA; tempA; tempA = tempA._hostParent) {
    depthA++;
  }
  var depthB = 0;
  for (var tempB = instB; tempB; tempB = tempB._hostParent) {
    depthB++;
  }

  // If A is deeper, crawl up.
  while (depthA - depthB > 0) {
    instA = instA._hostParent;
    depthA--;
  }

  // If B is deeper, crawl up.
  while (depthB - depthA > 0) {
    instB = instB._hostParent;
    depthB--;
  }

  // Walk in lockstep until we find a match.
  var depth = depthA;
  while (depth--) {
    if (instA === instB) {
      return instA;
    }
    instA = instA._hostParent;
    instB = instB._hostParent;
  }
  return null;
}

/**
 * Return if A is an ancestor of B.
 */
function isAncestor(instA, instB) {
  !('_hostNode' in instA) ? _prodInvariant('35') : void 0;
  !('_hostNode' in instB) ? _prodInvariant('35') : void 0;

  while (instB) {
    if (instB === instA) {
      return true;
    }
    instB = instB._hostParent;
  }
  return false;
}

/**
 * Return the parent instance of the passed-in instance.
 */
function getParentInstance(inst) {
  !('_hostNode' in inst) ? _prodInvariant('36') : void 0;

  return inst._hostParent;
}

/**
 * Simulates the traversal of a two-phase, capture/bubble event dispatch.
 */
function traverseTwoPhase(inst, fn, arg) {
  var path = [];
  while (inst) {
    path.push(inst);
    inst = inst._hostParent;
  }
  var i;
  for (i = path.length; i-- > 0;) {
    fn(path[i], 'captured', arg);
  }
  for (i = 0; i < path.length; i++) {
    fn(path[i], 'bubbled', arg);
  }
}

/**
 * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that
 * should would receive a `mouseEnter` or `mouseLeave` event.
 *
 * Does not invoke the callback on the nearest common ancestor because nothing
 * "entered" or "left" that element.
 */
function traverseEnterLeave(from, to, fn, argFrom, argTo) {
  var common = from && to ? getLowestCommonAncestor(from, to) : null;
  var pathFrom = [];
  while (from && from !== common) {
    pathFrom.push(from);
    from = from._hostParent;
  }
  var pathTo = [];
  while (to && to !== common) {
    pathTo.push(to);
    to = to._hostParent;
  }
  var i;
  for (i = 0; i < pathFrom.length; i++) {
    fn(pathFrom[i], 'bubbled', argFrom);
  }
  for (i = pathTo.length; i-- > 0;) {
    fn(pathTo[i], 'captured', argTo);
  }
}

module.exports = {
  isAncestor: isAncestor,
  getLowestCommonAncestor: getLowestCommonAncestor,
  getParentInstance: getParentInstance,
  traverseTwoPhase: traverseTwoPhase,
  traverseEnterLeave: traverseEnterLeave
};
},{"./reactProdInvariant":843,"fbjs/lib/invariant":602}],776:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

var ReactUpdates = require('./ReactUpdates');
var Transaction = require('./Transaction');

var emptyFunction = require('fbjs/lib/emptyFunction');

var RESET_BATCHED_UPDATES = {
  initialize: emptyFunction,
  close: function () {
    ReactDefaultBatchingStrategy.isBatchingUpdates = false;
  }
};

var FLUSH_BATCHED_UPDATES = {
  initialize: emptyFunction,
  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)
};

var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];

function ReactDefaultBatchingStrategyTransaction() {
  this.reinitializeTransaction();
}

_assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, {
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  }
});

var transaction = new ReactDefaultBatchingStrategyTransaction();

var ReactDefaultBatchingStrategy = {
  isBatchingUpdates: false,

  /**
   * Call the provided function in a context within which calls to `setState`
   * and friends are batched such that components aren't updated unnecessarily.
   */
  batchedUpdates: function (callback, a, b, c, d, e) {
    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;

    ReactDefaultBatchingStrategy.isBatchingUpdates = true;

    // The code is written this way to avoid extra allocations
    if (alreadyBatchingUpdates) {
      return callback(a, b, c, d, e);
    } else {
      return transaction.perform(callback, null, a, b, c, d, e);
    }
  }
};

module.exports = ReactDefaultBatchingStrategy;
},{"./ReactUpdates":801,"./Transaction":819,"fbjs/lib/emptyFunction":594,"object-assign":701}],777:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ARIADOMPropertyConfig = require('./ARIADOMPropertyConfig');
var BeforeInputEventPlugin = require('./BeforeInputEventPlugin');
var ChangeEventPlugin = require('./ChangeEventPlugin');
var DefaultEventPluginOrder = require('./DefaultEventPluginOrder');
var EnterLeaveEventPlugin = require('./EnterLeaveEventPlugin');
var HTMLDOMPropertyConfig = require('./HTMLDOMPropertyConfig');
var ReactComponentBrowserEnvironment = require('./ReactComponentBrowserEnvironment');
var ReactDOMComponent = require('./ReactDOMComponent');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactDOMEmptyComponent = require('./ReactDOMEmptyComponent');
var ReactDOMTreeTraversal = require('./ReactDOMTreeTraversal');
var ReactDOMTextComponent = require('./ReactDOMTextComponent');
var ReactDefaultBatchingStrategy = require('./ReactDefaultBatchingStrategy');
var ReactEventListener = require('./ReactEventListener');
var ReactInjection = require('./ReactInjection');
var ReactReconcileTransaction = require('./ReactReconcileTransaction');
var SVGDOMPropertyConfig = require('./SVGDOMPropertyConfig');
var SelectEventPlugin = require('./SelectEventPlugin');
var SimpleEventPlugin = require('./SimpleEventPlugin');

var alreadyInjected = false;

function inject() {
  if (alreadyInjected) {
    // TODO: This is currently true because these injections are shared between
    // the client and the server package. They should be built independently
    // and not share any injection state. Then this problem will be solved.
    return;
  }
  alreadyInjected = true;

  ReactInjection.EventEmitter.injectReactEventListener(ReactEventListener);

  /**
   * Inject modules for resolving DOM hierarchy and plugin ordering.
   */
  ReactInjection.EventPluginHub.injectEventPluginOrder(DefaultEventPluginOrder);
  ReactInjection.EventPluginUtils.injectComponentTree(ReactDOMComponentTree);
  ReactInjection.EventPluginUtils.injectTreeTraversal(ReactDOMTreeTraversal);

  /**
   * Some important event plugins included by default (without having to require
   * them).
   */
  ReactInjection.EventPluginHub.injectEventPluginsByName({
    SimpleEventPlugin: SimpleEventPlugin,
    EnterLeaveEventPlugin: EnterLeaveEventPlugin,
    ChangeEventPlugin: ChangeEventPlugin,
    SelectEventPlugin: SelectEventPlugin,
    BeforeInputEventPlugin: BeforeInputEventPlugin
  });

  ReactInjection.HostComponent.injectGenericComponentClass(ReactDOMComponent);

  ReactInjection.HostComponent.injectTextComponentClass(ReactDOMTextComponent);

  ReactInjection.DOMProperty.injectDOMPropertyConfig(ARIADOMPropertyConfig);
  ReactInjection.DOMProperty.injectDOMPropertyConfig(HTMLDOMPropertyConfig);
  ReactInjection.DOMProperty.injectDOMPropertyConfig(SVGDOMPropertyConfig);

  ReactInjection.EmptyComponent.injectEmptyComponentFactory(function (instantiate) {
    return new ReactDOMEmptyComponent(instantiate);
  });

  ReactInjection.Updates.injectReconcileTransaction(ReactReconcileTransaction);
  ReactInjection.Updates.injectBatchingStrategy(ReactDefaultBatchingStrategy);

  ReactInjection.Component.injectEnvironment(ReactComponentBrowserEnvironment);
}

module.exports = {
  inject: inject
};
},{"./ARIADOMPropertyConfig":732,"./BeforeInputEventPlugin":734,"./ChangeEventPlugin":738,"./DefaultEventPluginOrder":745,"./EnterLeaveEventPlugin":746,"./HTMLDOMPropertyConfig":752,"./ReactComponentBrowserEnvironment":758,"./ReactDOMComponent":762,"./ReactDOMComponentTree":764,"./ReactDOMEmptyComponent":766,"./ReactDOMTextComponent":773,"./ReactDOMTreeTraversal":775,"./ReactDefaultBatchingStrategy":776,"./ReactEventListener":782,"./ReactInjection":785,"./ReactReconcileTransaction":795,"./SVGDOMPropertyConfig":803,"./SelectEventPlugin":804,"./SimpleEventPlugin":805}],778:[function(require,module,exports){
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

// The Symbol used to tag the ReactElement type. If there is no native Symbol
// nor polyfill, then a plain number is used for performance.

var REACT_ELEMENT_TYPE = typeof Symbol === 'function' && Symbol['for'] && Symbol['for']('react.element') || 0xeac7;

module.exports = REACT_ELEMENT_TYPE;
},{}],779:[function(require,module,exports){
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var emptyComponentFactory;

var ReactEmptyComponentInjection = {
  injectEmptyComponentFactory: function (factory) {
    emptyComponentFactory = factory;
  }
};

var ReactEmptyComponent = {
  create: function (instantiate) {
    return emptyComponentFactory(instantiate);
  }
};

ReactEmptyComponent.injection = ReactEmptyComponentInjection;

module.exports = ReactEmptyComponent;
},{}],780:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var caughtError = null;

/**
 * Call a function while guarding against errors that happens within it.
 *
 * @param {String} name of the guard to use for logging or debugging
 * @param {Function} func The function to invoke
 * @param {*} a First argument
 * @param {*} b Second argument
 */
function invokeGuardedCallback(name, func, a) {
  try {
    func(a);
  } catch (x) {
    if (caughtError === null) {
      caughtError = x;
    }
  }
}

var ReactErrorUtils = {
  invokeGuardedCallback: invokeGuardedCallback,

  /**
   * Invoked by ReactTestUtils.Simulate so that any errors thrown by the event
   * handler are sure to be rethrown by rethrowCaughtError.
   */
  invokeGuardedCallbackWithCatch: invokeGuardedCallback,

  /**
   * During execution of guarded functions we will capture the first error which
   * we will rethrow to be handled by the top level error handler.
   */
  rethrowCaughtError: function () {
    if (caughtError) {
      var error = caughtError;
      caughtError = null;
      throw error;
    }
  }
};

module.exports = ReactErrorUtils;
},{}],781:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var EventPluginHub = require('./EventPluginHub');

function runEventQueueInBatch(events) {
  EventPluginHub.enqueueEvents(events);
  EventPluginHub.processEventQueue(false);
}

var ReactEventEmitterMixin = {

  /**
   * Streams a fired top-level event to `EventPluginHub` where plugins have the
   * opportunity to create `ReactEvent`s to be dispatched.
   */
  handleTopLevel: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget);
    runEventQueueInBatch(events);
  }
};

module.exports = ReactEventEmitterMixin;
},{"./EventPluginHub":747}],782:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

var EventListener = require('fbjs/lib/EventListener');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var PooledClass = require('./PooledClass');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactUpdates = require('./ReactUpdates');

var getEventTarget = require('./getEventTarget');
var getUnboundedScrollPosition = require('fbjs/lib/getUnboundedScrollPosition');

/**
 * Find the deepest React component completely containing the root of the
 * passed-in instance (for use when entire React trees are nested within each
 * other). If React trees are not nested, returns null.
 */
function findParent(inst) {
  // TODO: It may be a good idea to cache this to prevent unnecessary DOM
  // traversal, but caching is difficult to do correctly without using a
  // mutation observer to listen for all DOM changes.
  while (inst._hostParent) {
    inst = inst._hostParent;
  }
  var rootNode = ReactDOMComponentTree.getNodeFromInstance(inst);
  var container = rootNode.parentNode;
  return ReactDOMComponentTree.getClosestInstanceFromNode(container);
}

// Used to store ancestor hierarchy in top level callback
function TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {
  this.topLevelType = topLevelType;
  this.nativeEvent = nativeEvent;
  this.ancestors = [];
}
_assign(TopLevelCallbackBookKeeping.prototype, {
  destructor: function () {
    this.topLevelType = null;
    this.nativeEvent = null;
    this.ancestors.length = 0;
  }
});
PooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);

function handleTopLevelImpl(bookKeeping) {
  var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent);
  var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(nativeEventTarget);

  // Loop through the hierarchy, in case there's any nested components.
  // It's important that we build the array of ancestors before calling any
  // event handlers, because event handlers can modify the DOM, leading to
  // inconsistencies with ReactMount's node cache. See #1105.
  var ancestor = targetInst;
  do {
    bookKeeping.ancestors.push(ancestor);
    ancestor = ancestor && findParent(ancestor);
  } while (ancestor);

  for (var i = 0; i < bookKeeping.ancestors.length; i++) {
    targetInst = bookKeeping.ancestors[i];
    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));
  }
}

function scrollValueMonitor(cb) {
  var scrollPosition = getUnboundedScrollPosition(window);
  cb(scrollPosition);
}

var ReactEventListener = {
  _enabled: true,
  _handleTopLevel: null,

  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,

  setHandleTopLevel: function (handleTopLevel) {
    ReactEventListener._handleTopLevel = handleTopLevel;
  },

  setEnabled: function (enabled) {
    ReactEventListener._enabled = !!enabled;
  },

  isEnabled: function () {
    return ReactEventListener._enabled;
  },

  /**
   * Traps top-level events by using event bubbling.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {string} handlerBaseName Event name (e.g. "click").
   * @param {object} element Element on which to attach listener.
   * @return {?object} An object with a remove function which will forcefully
   *                  remove the listener.
   * @internal
   */
  trapBubbledEvent: function (topLevelType, handlerBaseName, element) {
    if (!element) {
      return null;
    }
    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
  },

  /**
   * Traps a top-level event by using event capturing.
   *
   * @param {string} topLevelType Record from `EventConstants`.
   * @param {string} handlerBaseName Event name (e.g. "click").
   * @param {object} element Element on which to attach listener.
   * @return {?object} An object with a remove function which will forcefully
   *                  remove the listener.
   * @internal
   */
  trapCapturedEvent: function (topLevelType, handlerBaseName, element) {
    if (!element) {
      return null;
    }
    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));
  },

  monitorScrollValue: function (refresh) {
    var callback = scrollValueMonitor.bind(null, refresh);
    EventListener.listen(window, 'scroll', callback);
  },

  dispatchEvent: function (topLevelType, nativeEvent) {
    if (!ReactEventListener._enabled) {
      return;
    }

    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);
    try {
      // Event queue being processed in the same cycle allows
      // `preventDefault`.
      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);
    } finally {
      TopLevelCallbackBookKeeping.release(bookKeeping);
    }
  }
};

module.exports = ReactEventListener;
},{"./PooledClass":755,"./ReactDOMComponentTree":764,"./ReactUpdates":801,"./getEventTarget":832,"fbjs/lib/EventListener":587,"fbjs/lib/ExecutionEnvironment":588,"fbjs/lib/getUnboundedScrollPosition":599,"object-assign":701}],783:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var ReactFeatureFlags = {
  // When true, call console.time() before and .timeEnd() after each top-level
  // render (both initial renders and updates). Useful when looking at prod-mode
  // timeline profiles in Chrome, for example.
  logTopLevelRenders: false
};

module.exports = ReactFeatureFlags;
},{}],784:[function(require,module,exports){
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant'),
    _assign = require('object-assign');

var invariant = require('fbjs/lib/invariant');

var genericComponentClass = null;
// This registry keeps track of wrapper classes around host tags.
var tagToComponentClass = {};
var textComponentClass = null;

var ReactHostComponentInjection = {
  // This accepts a class that receives the tag string. This is a catch all
  // that can render any kind of tag.
  injectGenericComponentClass: function (componentClass) {
    genericComponentClass = componentClass;
  },
  // This accepts a text component class that takes the text string to be
  // rendered as props.
  injectTextComponentClass: function (componentClass) {
    textComponentClass = componentClass;
  },
  // This accepts a keyed object with classes as values. Each key represents a
  // tag. That particular tag will use this class instead of the generic one.
  injectComponentClasses: function (componentClasses) {
    _assign(tagToComponentClass, componentClasses);
  }
};

/**
 * Get a host internal component class for a specific tag.
 *
 * @param {ReactElement} element The element to create.
 * @return {function} The internal class constructor function.
 */
function createInternalComponent(element) {
  !genericComponentClass ? _prodInvariant('111', element.type) : void 0;
  return new genericComponentClass(element);
}

/**
 * @param {ReactText} text
 * @return {ReactComponent}
 */
function createInstanceForText(text) {
  return new textComponentClass(text);
}

/**
 * @param {ReactComponent} component
 * @return {boolean}
 */
function isTextComponent(component) {
  return component instanceof textComponentClass;
}

var ReactHostComponent = {
  createInternalComponent: createInternalComponent,
  createInstanceForText: createInstanceForText,
  isTextComponent: isTextComponent,
  injection: ReactHostComponentInjection
};

module.exports = ReactHostComponent;
},{"./reactProdInvariant":843,"fbjs/lib/invariant":602,"object-assign":701}],785:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var DOMProperty = require('./DOMProperty');
var EventPluginHub = require('./EventPluginHub');
var EventPluginUtils = require('./EventPluginUtils');
var ReactComponentEnvironment = require('./ReactComponentEnvironment');
var ReactEmptyComponent = require('./ReactEmptyComponent');
var ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');
var ReactHostComponent = require('./ReactHostComponent');
var ReactUpdates = require('./ReactUpdates');

var ReactInjection = {
  Component: ReactComponentEnvironment.injection,
  DOMProperty: DOMProperty.injection,
  EmptyComponent: ReactEmptyComponent.injection,
  EventPluginHub: EventPluginHub.injection,
  EventPluginUtils: EventPluginUtils.injection,
  EventEmitter: ReactBrowserEventEmitter.injection,
  HostComponent: ReactHostComponent.injection,
  Updates: ReactUpdates.injection
};

module.exports = ReactInjection;
},{"./DOMProperty":742,"./EventPluginHub":747,"./EventPluginUtils":749,"./ReactBrowserEventEmitter":756,"./ReactComponentEnvironment":759,"./ReactEmptyComponent":779,"./ReactHostComponent":784,"./ReactUpdates":801}],786:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ReactDOMSelection = require('./ReactDOMSelection');

var containsNode = require('fbjs/lib/containsNode');
var focusNode = require('fbjs/lib/focusNode');
var getActiveElement = require('fbjs/lib/getActiveElement');

function isInDocument(node) {
  return containsNode(document.documentElement, node);
}

/**
 * @ReactInputSelection: React input selection module. Based on Selection.js,
 * but modified to be suitable for react and has a couple of bug fixes (doesn't
 * assume buttons have range selections allowed).
 * Input selection module for React.
 */
var ReactInputSelection = {

  hasSelectionCapabilities: function (elem) {
    var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
    return nodeName && (nodeName === 'input' && elem.type === 'text' || nodeName === 'textarea' || elem.contentEditable === 'true');
  },

  getSelectionInformation: function () {
    var focusedElem = getActiveElement();
    return {
      focusedElem: focusedElem,
      selectionRange: ReactInputSelection.hasSelectionCapabilities(focusedElem) ? ReactInputSelection.getSelection(focusedElem) : null
    };
  },

  /**
   * @restoreSelection: If any selection information was potentially lost,
   * restore it. This is useful when performing operations that could remove dom
   * nodes and place them back in, resulting in focus being lost.
   */
  restoreSelection: function (priorSelectionInformation) {
    var curFocusedElem = getActiveElement();
    var priorFocusedElem = priorSelectionInformation.focusedElem;
    var priorSelectionRange = priorSelectionInformation.selectionRange;
    if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
      if (ReactInputSelection.hasSelectionCapabilities(priorFocusedElem)) {
        ReactInputSelection.setSelection(priorFocusedElem, priorSelectionRange);
      }
      focusNode(priorFocusedElem);
    }
  },

  /**
   * @getSelection: Gets the selection bounds of a focused textarea, input or
   * contentEditable node.
   * -@input: Look up selection bounds of this input
   * -@return {start: selectionStart, end: selectionEnd}
   */
  getSelection: function (input) {
    var selection;

    if ('selectionStart' in input) {
      // Modern browser with input or textarea.
      selection = {
        start: input.selectionStart,
        end: input.selectionEnd
      };
    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
      // IE8 input.
      var range = document.selection.createRange();
      // There can only be one selection per document in IE, so it must
      // be in our element.
      if (range.parentElement() === input) {
        selection = {
          start: -range.moveStart('character', -input.value.length),
          end: -range.moveEnd('character', -input.value.length)
        };
      }
    } else {
      // Content editable or old IE textarea.
      selection = ReactDOMSelection.getOffsets(input);
    }

    return selection || { start: 0, end: 0 };
  },

  /**
   * @setSelection: Sets the selection bounds of a textarea or input and focuses
   * the input.
   * -@input     Set selection bounds of this input or textarea
   * -@offsets   Object of same form that is returned from get*
   */
  setSelection: function (input, offsets) {
    var start = offsets.start;
    var end = offsets.end;
    if (end === undefined) {
      end = start;
    }

    if ('selectionStart' in input) {
      input.selectionStart = start;
      input.selectionEnd = Math.min(end, input.value.length);
    } else if (document.selection && input.nodeName && input.nodeName.toLowerCase() === 'input') {
      var range = input.createTextRange();
      range.collapse(true);
      range.moveStart('character', start);
      range.moveEnd('character', end - start);
      range.select();
    } else {
      ReactDOMSelection.setOffsets(input, offsets);
    }
  }
};

module.exports = ReactInputSelection;
},{"./ReactDOMSelection":772,"fbjs/lib/containsNode":591,"fbjs/lib/focusNode":596,"fbjs/lib/getActiveElement":597}],787:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

/**
 * `ReactInstanceMap` maintains a mapping from a public facing stateful
 * instance (key) and the internal representation (value). This allows public
 * methods to accept the user facing instance as an argument and map them back
 * to internal methods.
 */

// TODO: Replace this with ES6: var ReactInstanceMap = new Map();

var ReactInstanceMap = {

  /**
   * This API should be called `delete` but we'd have to make sure to always
   * transform these to strings for IE support. When this transform is fully
   * supported we can rename it.
   */
  remove: function (key) {
    key._reactInternalInstance = undefined;
  },

  get: function (key) {
    return key._reactInternalInstance;
  },

  has: function (key) {
    return key._reactInternalInstance !== undefined;
  },

  set: function (key, value) {
    key._reactInternalInstance = value;
  }

};

module.exports = ReactInstanceMap;
},{}],788:[function(require,module,exports){
/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

// Trust the developer to only use ReactInstrumentation with a __DEV__ check

var debugTool = null;

module.exports = { debugTool: debugTool };
},{}],789:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var adler32 = require('./adler32');

var TAG_END = /\/?>/;
var COMMENT_START = /^<\!\-\-/;

var ReactMarkupChecksum = {
  CHECKSUM_ATTR_NAME: 'data-react-checksum',

  /**
   * @param {string} markup Markup string
   * @return {string} Markup string with checksum attribute attached
   */
  addChecksumToMarkup: function (markup) {
    var checksum = adler32(markup);

    // Add checksum (handle both parent tags, comments and self-closing tags)
    if (COMMENT_START.test(markup)) {
      return markup;
    } else {
      return markup.replace(TAG_END, ' ' + ReactMarkupChecksum.CHECKSUM_ATTR_NAME + '="' + checksum + '"$&');
    }
  },

  /**
   * @param {string} markup to use
   * @param {DOMElement} element root React element
   * @returns {boolean} whether or not the markup is the same
   */
  canReuseMarkup: function (markup, element) {
    var existingChecksum = element.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
    existingChecksum = existingChecksum && parseInt(existingChecksum, 10);
    var markupChecksum = adler32(markup);
    return markupChecksum === existingChecksum;
  }
};

module.exports = ReactMarkupChecksum;
},{"./adler32":822}],790:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var DOMLazyTree = require('./DOMLazyTree');
var DOMProperty = require('./DOMProperty');
var React = require('react/lib/React');
var ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');
var ReactCurrentOwner = require('react/lib/ReactCurrentOwner');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactDOMContainerInfo = require('./ReactDOMContainerInfo');
var ReactDOMFeatureFlags = require('./ReactDOMFeatureFlags');
var ReactFeatureFlags = require('./ReactFeatureFlags');
var ReactInstanceMap = require('./ReactInstanceMap');
var ReactInstrumentation = require('./ReactInstrumentation');
var ReactMarkupChecksum = require('./ReactMarkupChecksum');
var ReactReconciler = require('./ReactReconciler');
var ReactUpdateQueue = require('./ReactUpdateQueue');
var ReactUpdates = require('./ReactUpdates');

var emptyObject = require('fbjs/lib/emptyObject');
var instantiateReactComponent = require('./instantiateReactComponent');
var invariant = require('fbjs/lib/invariant');
var setInnerHTML = require('./setInnerHTML');
var shouldUpdateReactComponent = require('./shouldUpdateReactComponent');
var warning = require('fbjs/lib/warning');

var ATTR_NAME = DOMProperty.ID_ATTRIBUTE_NAME;
var ROOT_ATTR_NAME = DOMProperty.ROOT_ATTRIBUTE_NAME;

var ELEMENT_NODE_TYPE = 1;
var DOC_NODE_TYPE = 9;
var DOCUMENT_FRAGMENT_NODE_TYPE = 11;

var instancesByReactRootID = {};

/**
 * Finds the index of the first character
 * that's not common between the two given strings.
 *
 * @return {number} the index of the character where the strings diverge
 */
function firstDifferenceIndex(string1, string2) {
  var minLen = Math.min(string1.length, string2.length);
  for (var i = 0; i < minLen; i++) {
    if (string1.charAt(i) !== string2.charAt(i)) {
      return i;
    }
  }
  return string1.length === string2.length ? -1 : minLen;
}

/**
 * @param {DOMElement|DOMDocument} container DOM element that may contain
 * a React component
 * @return {?*} DOM element that may have the reactRoot ID, or null.
 */
function getReactRootElementInContainer(container) {
  if (!container) {
    return null;
  }

  if (container.nodeType === DOC_NODE_TYPE) {
    return container.documentElement;
  } else {
    return container.firstChild;
  }
}

function internalGetID(node) {
  // If node is something like a window, document, or text node, none of
  // which support attributes or a .getAttribute method, gracefully return
  // the empty string, as if the attribute were missing.
  return node.getAttribute && node.getAttribute(ATTR_NAME) || '';
}

/**
 * Mounts this component and inserts it into the DOM.
 *
 * @param {ReactComponent} componentInstance The instance to mount.
 * @param {DOMElement} container DOM element to mount into.
 * @param {ReactReconcileTransaction} transaction
 * @param {boolean} shouldReuseMarkup If true, do not insert markup
 */
function mountComponentIntoNode(wrapperInstance, container, transaction, shouldReuseMarkup, context) {
  var markerName;
  if (ReactFeatureFlags.logTopLevelRenders) {
    var wrappedElement = wrapperInstance._currentElement.props.child;
    var type = wrappedElement.type;
    markerName = 'React mount: ' + (typeof type === 'string' ? type : type.displayName || type.name);
    console.time(markerName);
  }

  var markup = ReactReconciler.mountComponent(wrapperInstance, transaction, null, ReactDOMContainerInfo(wrapperInstance, container), context, 0 /* parentDebugID */
  );

  if (markerName) {
    console.timeEnd(markerName);
  }

  wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance;
  ReactMount._mountImageIntoNode(markup, container, wrapperInstance, shouldReuseMarkup, transaction);
}

/**
 * Batched mount.
 *
 * @param {ReactComponent} componentInstance The instance to mount.
 * @param {DOMElement} container DOM element to mount into.
 * @param {boolean} shouldReuseMarkup If true, do not insert markup
 */
function batchedMountComponentIntoNode(componentInstance, container, shouldReuseMarkup, context) {
  var transaction = ReactUpdates.ReactReconcileTransaction.getPooled(
  /* useCreateElement */
  !shouldReuseMarkup && ReactDOMFeatureFlags.useCreateElement);
  transaction.perform(mountComponentIntoNode, null, componentInstance, container, transaction, shouldReuseMarkup, context);
  ReactUpdates.ReactReconcileTransaction.release(transaction);
}

/**
 * Unmounts a component and removes it from the DOM.
 *
 * @param {ReactComponent} instance React component instance.
 * @param {DOMElement} container DOM element to unmount from.
 * @final
 * @internal
 * @see {ReactMount.unmountComponentAtNode}
 */
function unmountComponentFromNode(instance, container, safely) {
  ReactReconciler.unmountComponent(instance, safely);

  if (container.nodeType === DOC_NODE_TYPE) {
    container = container.documentElement;
  }

  // http://jsperf.com/emptying-a-node
  while (container.lastChild) {
    container.removeChild(container.lastChild);
  }
}

/**
 * True if the supplied DOM node has a direct React-rendered child that is
 * not a React root element. Useful for warning in `render`,
 * `unmountComponentAtNode`, etc.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM element contains a direct child that was
 * rendered by React but is not a root element.
 * @internal
 */
function hasNonRootReactChild(container) {
  var rootEl = getReactRootElementInContainer(container);
  if (rootEl) {
    var inst = ReactDOMComponentTree.getInstanceFromNode(rootEl);
    return !!(inst && inst._hostParent);
  }
}

/**
 * True if the supplied DOM node is a React DOM element and
 * it has been rendered by another copy of React.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM has been rendered by another copy of React
 * @internal
 */
function nodeIsRenderedByOtherInstance(container) {
  var rootEl = getReactRootElementInContainer(container);
  return !!(rootEl && isReactNode(rootEl) && !ReactDOMComponentTree.getInstanceFromNode(rootEl));
}

/**
 * True if the supplied DOM node is a valid node element.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM is a valid DOM node.
 * @internal
 */
function isValidContainer(node) {
  return !!(node && (node.nodeType === ELEMENT_NODE_TYPE || node.nodeType === DOC_NODE_TYPE || node.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE));
}

/**
 * True if the supplied DOM node is a valid React node element.
 *
 * @param {?DOMElement} node The candidate DOM node.
 * @return {boolean} True if the DOM is a valid React DOM node.
 * @internal
 */
function isReactNode(node) {
  return isValidContainer(node) && (node.hasAttribute(ROOT_ATTR_NAME) || node.hasAttribute(ATTR_NAME));
}

function getHostRootInstanceInContainer(container) {
  var rootEl = getReactRootElementInContainer(container);
  var prevHostInstance = rootEl && ReactDOMComponentTree.getInstanceFromNode(rootEl);
  return prevHostInstance && !prevHostInstance._hostParent ? prevHostInstance : null;
}

function getTopLevelWrapperInContainer(container) {
  var root = getHostRootInstanceInContainer(container);
  return root ? root._hostContainerInfo._topLevelWrapper : null;
}

/**
 * Temporary (?) hack so that we can store all top-level pending updates on
 * composites instead of having to worry about different types of components
 * here.
 */
var topLevelRootCounter = 1;
var TopLevelWrapper = function () {
  this.rootID = topLevelRootCounter++;
};
TopLevelWrapper.prototype.isReactComponent = {};
TopLevelWrapper.prototype.render = function () {
  return this.props.child;
};
TopLevelWrapper.isReactTopLevelWrapper = true;

/**
 * Mounting is the process of initializing a React component by creating its
 * representative DOM elements and inserting them into a supplied `container`.
 * Any prior content inside `container` is destroyed in the process.
 *
 *   ReactMount.render(
 *     component,
 *     document.getElementById('container')
 *   );
 *
 *   <div id="container">                   <-- Supplied `container`.
 *     <div data-reactid=".3">              <-- Rendered reactRoot of React
 *       // ...                                 component.
 *     </div>
 *   </div>
 *
 * Inside of `container`, the first element rendered is the "reactRoot".
 */
var ReactMount = {

  TopLevelWrapper: TopLevelWrapper,

  /**
   * Used by devtools. The keys are not important.
   */
  _instancesByReactRootID: instancesByReactRootID,

  /**
   * This is a hook provided to support rendering React components while
   * ensuring that the apparent scroll position of its `container` does not
   * change.
   *
   * @param {DOMElement} container The `container` being rendered into.
   * @param {function} renderCallback This must be called once to do the render.
   */
  scrollMonitor: function (container, renderCallback) {
    renderCallback();
  },

  /**
   * Take a component that's already mounted into the DOM and replace its props
   * @param {ReactComponent} prevComponent component instance already in the DOM
   * @param {ReactElement} nextElement component instance to render
   * @param {DOMElement} container container to render into
   * @param {?function} callback function triggered on completion
   */
  _updateRootComponent: function (prevComponent, nextElement, nextContext, container, callback) {
    ReactMount.scrollMonitor(container, function () {
      ReactUpdateQueue.enqueueElementInternal(prevComponent, nextElement, nextContext);
      if (callback) {
        ReactUpdateQueue.enqueueCallbackInternal(prevComponent, callback);
      }
    });

    return prevComponent;
  },

  /**
   * Render a new component into the DOM. Hooked by hooks!
   *
   * @param {ReactElement} nextElement element to render
   * @param {DOMElement} container container to render into
   * @param {boolean} shouldReuseMarkup if we should skip the markup insertion
   * @return {ReactComponent} nextComponent
   */
  _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) {
    // Various parts of our code (such as ReactCompositeComponent's
    // _renderValidatedComponent) assume that calls to render aren't nested;
    // verify that that's the case.
    void 0;

    !isValidContainer(container) ? _prodInvariant('37') : void 0;

    ReactBrowserEventEmitter.ensureScrollValueMonitoring();
    var componentInstance = instantiateReactComponent(nextElement, false);

    // The initial render is synchronous but any updates that happen during
    // rendering, in componentWillMount or componentDidMount, will be batched
    // according to the current batching strategy.

    ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context);

    var wrapperID = componentInstance._instance.rootID;
    instancesByReactRootID[wrapperID] = componentInstance;

    return componentInstance;
  },

  /**
   * Renders a React component into the DOM in the supplied `container`.
   *
   * If the React component was previously rendered into `container`, this will
   * perform an update on it and only mutate the DOM as necessary to reflect the
   * latest React component.
   *
   * @param {ReactComponent} parentComponent The conceptual parent of this render tree.
   * @param {ReactElement} nextElement Component element to render.
   * @param {DOMElement} container DOM element to render into.
   * @param {?function} callback function triggered on completion
   * @return {ReactComponent} Component instance rendered in `container`.
   */
  renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
    !(parentComponent != null && ReactInstanceMap.has(parentComponent)) ? _prodInvariant('38') : void 0;
    return ReactMount._renderSubtreeIntoContainer(parentComponent, nextElement, container, callback);
  },

  _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) {
    ReactUpdateQueue.validateCallback(callback, 'ReactDOM.render');
    !React.isValidElement(nextElement) ? _prodInvariant('39', typeof nextElement === 'string' ? ' Instead of passing a string like \'div\', pass ' + 'React.createElement(\'div\') or <div />.' : typeof nextElement === 'function' ? ' Instead of passing a class like Foo, pass ' + 'React.createElement(Foo) or <Foo />.' : nextElement != null && nextElement.props !== undefined ? ' This may be caused by unintentionally loading two independent ' + 'copies of React.' : '') : void 0;

    void 0;

    var nextWrappedElement = React.createElement(TopLevelWrapper, { child: nextElement });

    var nextContext;
    if (parentComponent) {
      var parentInst = ReactInstanceMap.get(parentComponent);
      nextContext = parentInst._processChildContext(parentInst._context);
    } else {
      nextContext = emptyObject;
    }

    var prevComponent = getTopLevelWrapperInContainer(container);

    if (prevComponent) {
      var prevWrappedElement = prevComponent._currentElement;
      var prevElement = prevWrappedElement.props.child;
      if (shouldUpdateReactComponent(prevElement, nextElement)) {
        var publicInst = prevComponent._renderedComponent.getPublicInstance();
        var updatedCallback = callback && function () {
          callback.call(publicInst);
        };
        ReactMount._updateRootComponent(prevComponent, nextWrappedElement, nextContext, container, updatedCallback);
        return publicInst;
      } else {
        ReactMount.unmountComponentAtNode(container);
      }
    }

    var reactRootElement = getReactRootElementInContainer(container);
    var containerHasReactMarkup = reactRootElement && !!internalGetID(reactRootElement);
    var containerHasNonRootReactChild = hasNonRootReactChild(container);

    var shouldReuseMarkup = containerHasReactMarkup && !prevComponent && !containerHasNonRootReactChild;
    var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, nextContext)._renderedComponent.getPublicInstance();
    if (callback) {
      callback.call(component);
    }
    return component;
  },

  /**
   * Renders a React component into the DOM in the supplied `container`.
   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.render
   *
   * If the React component was previously rendered into `container`, this will
   * perform an update on it and only mutate the DOM as necessary to reflect the
   * latest React component.
   *
   * @param {ReactElement} nextElement Component element to render.
   * @param {DOMElement} container DOM element to render into.
   * @param {?function} callback function triggered on completion
   * @return {ReactComponent} Component instance rendered in `container`.
   */
  render: function (nextElement, container, callback) {
    return ReactMount._renderSubtreeIntoContainer(null, nextElement, container, callback);
  },

  /**
   * Unmounts and destroys the React component rendered in the `container`.
   * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.unmountcomponentatnode
   *
   * @param {DOMElement} container DOM element containing a React component.
   * @return {boolean} True if a component was found in and unmounted from
   *                   `container`
   */
  unmountComponentAtNode: function (container) {
    // Various parts of our code (such as ReactCompositeComponent's
    // _renderValidatedComponent) assume that calls to render aren't nested;
    // verify that that's the case. (Strictly speaking, unmounting won't cause a
    // render but we still don't expect to be in a render call here.)
    void 0;

    !isValidContainer(container) ? _prodInvariant('40') : void 0;

    var prevComponent = getTopLevelWrapperInContainer(container);
    if (!prevComponent) {
      // Check if the node being unmounted was rendered by React, but isn't a
      // root node.
      var containerHasNonRootReactChild = hasNonRootReactChild(container);

      // Check if the container itself is a React root node.
      var isContainerReactRoot = container.nodeType === 1 && container.hasAttribute(ROOT_ATTR_NAME);

      return false;
    }
    delete instancesByReactRootID[prevComponent._instance.rootID];
    ReactUpdates.batchedUpdates(unmountComponentFromNode, prevComponent, container, false);
    return true;
  },

  _mountImageIntoNode: function (markup, container, instance, shouldReuseMarkup, transaction) {
    !isValidContainer(container) ? _prodInvariant('41') : void 0;

    if (shouldReuseMarkup) {
      var rootElement = getReactRootElementInContainer(container);
      if (ReactMarkupChecksum.canReuseMarkup(markup, rootElement)) {
        ReactDOMComponentTree.precacheNode(instance, rootElement);
        return;
      } else {
        var checksum = rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);
        rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);

        var rootMarkup = rootElement.outerHTML;
        rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME, checksum);

        var normalizedMarkup = markup;

        var diffIndex = firstDifferenceIndex(normalizedMarkup, rootMarkup);
        var difference = ' (client) ' + normalizedMarkup.substring(diffIndex - 20, diffIndex + 20) + '\n (server) ' + rootMarkup.substring(diffIndex - 20, diffIndex + 20);

        !(container.nodeType !== DOC_NODE_TYPE) ? _prodInvariant('42', difference) : void 0;
      }
    }

    !(container.nodeType !== DOC_NODE_TYPE) ? _prodInvariant('43') : void 0;

    if (transaction.useCreateElement) {
      while (container.lastChild) {
        container.removeChild(container.lastChild);
      }
      DOMLazyTree.insertTreeBefore(container, markup, null);
    } else {
      setInnerHTML(container, markup);
      ReactDOMComponentTree.precacheNode(instance, container.firstChild);
    }
  }
};

module.exports = ReactMount;
},{"./DOMLazyTree":740,"./DOMProperty":742,"./ReactBrowserEventEmitter":756,"./ReactDOMComponentTree":764,"./ReactDOMContainerInfo":765,"./ReactDOMFeatureFlags":767,"./ReactFeatureFlags":783,"./ReactInstanceMap":787,"./ReactInstrumentation":788,"./ReactMarkupChecksum":789,"./ReactReconciler":796,"./ReactUpdateQueue":800,"./ReactUpdates":801,"./instantiateReactComponent":839,"./reactProdInvariant":843,"./setInnerHTML":845,"./shouldUpdateReactComponent":847,"fbjs/lib/emptyObject":595,"fbjs/lib/invariant":602,"fbjs/lib/warning":607,"react/lib/React":852,"react/lib/ReactCurrentOwner":860}],791:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactComponentEnvironment = require('./ReactComponentEnvironment');
var ReactInstanceMap = require('./ReactInstanceMap');
var ReactInstrumentation = require('./ReactInstrumentation');

var ReactCurrentOwner = require('react/lib/ReactCurrentOwner');
var ReactReconciler = require('./ReactReconciler');
var ReactChildReconciler = require('./ReactChildReconciler');

var emptyFunction = require('fbjs/lib/emptyFunction');
var flattenChildren = require('./flattenChildren');
var invariant = require('fbjs/lib/invariant');

/**
 * Make an update for markup to be rendered and inserted at a supplied index.
 *
 * @param {string} markup Markup that renders into an element.
 * @param {number} toIndex Destination index.
 * @private
 */
function makeInsertMarkup(markup, afterNode, toIndex) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'INSERT_MARKUP',
    content: markup,
    fromIndex: null,
    fromNode: null,
    toIndex: toIndex,
    afterNode: afterNode
  };
}

/**
 * Make an update for moving an existing element to another index.
 *
 * @param {number} fromIndex Source index of the existing element.
 * @param {number} toIndex Destination index of the element.
 * @private
 */
function makeMove(child, afterNode, toIndex) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'MOVE_EXISTING',
    content: null,
    fromIndex: child._mountIndex,
    fromNode: ReactReconciler.getHostNode(child),
    toIndex: toIndex,
    afterNode: afterNode
  };
}

/**
 * Make an update for removing an element at an index.
 *
 * @param {number} fromIndex Index of the element to remove.
 * @private
 */
function makeRemove(child, node) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'REMOVE_NODE',
    content: null,
    fromIndex: child._mountIndex,
    fromNode: node,
    toIndex: null,
    afterNode: null
  };
}

/**
 * Make an update for setting the markup of a node.
 *
 * @param {string} markup Markup that renders into an element.
 * @private
 */
function makeSetMarkup(markup) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'SET_MARKUP',
    content: markup,
    fromIndex: null,
    fromNode: null,
    toIndex: null,
    afterNode: null
  };
}

/**
 * Make an update for setting the text content.
 *
 * @param {string} textContent Text content to set.
 * @private
 */
function makeTextContent(textContent) {
  // NOTE: Null values reduce hidden classes.
  return {
    type: 'TEXT_CONTENT',
    content: textContent,
    fromIndex: null,
    fromNode: null,
    toIndex: null,
    afterNode: null
  };
}

/**
 * Push an update, if any, onto the queue. Creates a new queue if none is
 * passed and always returns the queue. Mutative.
 */
function enqueue(queue, update) {
  if (update) {
    queue = queue || [];
    queue.push(update);
  }
  return queue;
}

/**
 * Processes any enqueued updates.
 *
 * @private
 */
function processQueue(inst, updateQueue) {
  ReactComponentEnvironment.processChildrenUpdates(inst, updateQueue);
}

var setChildrenForInstrumentation = emptyFunction;

/**
 * ReactMultiChild are capable of reconciling multiple children.
 *
 * @class ReactMultiChild
 * @internal
 */
var ReactMultiChild = {

  /**
   * Provides common functionality for components that must reconcile multiple
   * children. This is used by `ReactDOMComponent` to mount, update, and
   * unmount child components.
   *
   * @lends {ReactMultiChild.prototype}
   */
  Mixin: {

    _reconcilerInstantiateChildren: function (nestedChildren, transaction, context) {
      return ReactChildReconciler.instantiateChildren(nestedChildren, transaction, context);
    },

    _reconcilerUpdateChildren: function (prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context) {
      var nextChildren;
      var selfDebugID = 0;
      nextChildren = flattenChildren(nextNestedChildrenElements, selfDebugID);
      ReactChildReconciler.updateChildren(prevChildren, nextChildren, mountImages, removedNodes, transaction, this, this._hostContainerInfo, context, selfDebugID);
      return nextChildren;
    },

    /**
     * Generates a "mount image" for each of the supplied children. In the case
     * of `ReactDOMComponent`, a mount image is a string of markup.
     *
     * @param {?object} nestedChildren Nested child maps.
     * @return {array} An array of mounted representations.
     * @internal
     */
    mountChildren: function (nestedChildren, transaction, context) {
      var children = this._reconcilerInstantiateChildren(nestedChildren, transaction, context);
      this._renderedChildren = children;

      var mountImages = [];
      var index = 0;
      for (var name in children) {
        if (children.hasOwnProperty(name)) {
          var child = children[name];
          var selfDebugID = 0;
          var mountImage = ReactReconciler.mountComponent(child, transaction, this, this._hostContainerInfo, context, selfDebugID);
          child._mountIndex = index++;
          mountImages.push(mountImage);
        }
      }

      return mountImages;
    },

    /**
     * Replaces any rendered children with a text content string.
     *
     * @param {string} nextContent String of content.
     * @internal
     */
    updateTextContent: function (nextContent) {
      var prevChildren = this._renderedChildren;
      // Remove any rendered children.
      ReactChildReconciler.unmountChildren(prevChildren, false);
      for (var name in prevChildren) {
        if (prevChildren.hasOwnProperty(name)) {
          _prodInvariant('118');
        }
      }
      // Set new text content.
      var updates = [makeTextContent(nextContent)];
      processQueue(this, updates);
    },

    /**
     * Replaces any rendered children with a markup string.
     *
     * @param {string} nextMarkup String of markup.
     * @internal
     */
    updateMarkup: function (nextMarkup) {
      var prevChildren = this._renderedChildren;
      // Remove any rendered children.
      ReactChildReconciler.unmountChildren(prevChildren, false);
      for (var name in prevChildren) {
        if (prevChildren.hasOwnProperty(name)) {
          _prodInvariant('118');
        }
      }
      var updates = [makeSetMarkup(nextMarkup)];
      processQueue(this, updates);
    },

    /**
     * Updates the rendered children with new children.
     *
     * @param {?object} nextNestedChildrenElements Nested child element maps.
     * @param {ReactReconcileTransaction} transaction
     * @internal
     */
    updateChildren: function (nextNestedChildrenElements, transaction, context) {
      // Hook used by React ART
      this._updateChildren(nextNestedChildrenElements, transaction, context);
    },

    /**
     * @param {?object} nextNestedChildrenElements Nested child element maps.
     * @param {ReactReconcileTransaction} transaction
     * @final
     * @protected
     */
    _updateChildren: function (nextNestedChildrenElements, transaction, context) {
      var prevChildren = this._renderedChildren;
      var removedNodes = {};
      var mountImages = [];
      var nextChildren = this._reconcilerUpdateChildren(prevChildren, nextNestedChildrenElements, mountImages, removedNodes, transaction, context);
      if (!nextChildren && !prevChildren) {
        return;
      }
      var updates = null;
      var name;
      // `nextIndex` will increment for each child in `nextChildren`, but
      // `lastIndex` will be the last index visited in `prevChildren`.
      var nextIndex = 0;
      var lastIndex = 0;
      // `nextMountIndex` will increment for each newly mounted child.
      var nextMountIndex = 0;
      var lastPlacedNode = null;
      for (name in nextChildren) {
        if (!nextChildren.hasOwnProperty(name)) {
          continue;
        }
        var prevChild = prevChildren && prevChildren[name];
        var nextChild = nextChildren[name];
        if (prevChild === nextChild) {
          updates = enqueue(updates, this.moveChild(prevChild, lastPlacedNode, nextIndex, lastIndex));
          lastIndex = Math.max(prevChild._mountIndex, lastIndex);
          prevChild._mountIndex = nextIndex;
        } else {
          if (prevChild) {
            // Update `lastIndex` before `_mountIndex` gets unset by unmounting.
            lastIndex = Math.max(prevChild._mountIndex, lastIndex);
            // The `removedNodes` loop below will actually remove the child.
          }
          // The child must be instantiated before it's mounted.
          updates = enqueue(updates, this._mountChildAtIndex(nextChild, mountImages[nextMountIndex], lastPlacedNode, nextIndex, transaction, context));
          nextMountIndex++;
        }
        nextIndex++;
        lastPlacedNode = ReactReconciler.getHostNode(nextChild);
      }
      // Remove children that are no longer present.
      for (name in removedNodes) {
        if (removedNodes.hasOwnProperty(name)) {
          updates = enqueue(updates, this._unmountChild(prevChildren[name], removedNodes[name]));
        }
      }
      if (updates) {
        processQueue(this, updates);
      }
      this._renderedChildren = nextChildren;
    },

    /**
     * Unmounts all rendered children. This should be used to clean up children
     * when this component is unmounted. It does not actually perform any
     * backend operations.
     *
     * @internal
     */
    unmountChildren: function (safely) {
      var renderedChildren = this._renderedChildren;
      ReactChildReconciler.unmountChildren(renderedChildren, safely);
      this._renderedChildren = null;
    },

    /**
     * Moves a child component to the supplied index.
     *
     * @param {ReactComponent} child Component to move.
     * @param {number} toIndex Destination index of the element.
     * @param {number} lastIndex Last index visited of the siblings of `child`.
     * @protected
     */
    moveChild: function (child, afterNode, toIndex, lastIndex) {
      // If the index of `child` is less than `lastIndex`, then it needs to
      // be moved. Otherwise, we do not need to move it because a child will be
      // inserted or moved before `child`.
      if (child._mountIndex < lastIndex) {
        return makeMove(child, afterNode, toIndex);
      }
    },

    /**
     * Creates a child component.
     *
     * @param {ReactComponent} child Component to create.
     * @param {string} mountImage Markup to insert.
     * @protected
     */
    createChild: function (child, afterNode, mountImage) {
      return makeInsertMarkup(mountImage, afterNode, child._mountIndex);
    },

    /**
     * Removes a child component.
     *
     * @param {ReactComponent} child Child to remove.
     * @protected
     */
    removeChild: function (child, node) {
      return makeRemove(child, node);
    },

    /**
     * Mounts a child with the supplied name.
     *
     * NOTE: This is part of `updateChildren` and is here for readability.
     *
     * @param {ReactComponent} child Component to mount.
     * @param {string} name Name of the child.
     * @param {number} index Index at which to insert the child.
     * @param {ReactReconcileTransaction} transaction
     * @private
     */
    _mountChildAtIndex: function (child, mountImage, afterNode, index, transaction, context) {
      child._mountIndex = index;
      return this.createChild(child, afterNode, mountImage);
    },

    /**
     * Unmounts a rendered child.
     *
     * NOTE: This is part of `updateChildren` and is here for readability.
     *
     * @param {ReactComponent} child Component to unmount.
     * @private
     */
    _unmountChild: function (child, node) {
      var update = this.removeChild(child, node);
      child._mountIndex = null;
      return update;
    }

  }

};

module.exports = ReactMultiChild;
},{"./ReactChildReconciler":757,"./ReactComponentEnvironment":759,"./ReactInstanceMap":787,"./ReactInstrumentation":788,"./ReactReconciler":796,"./flattenChildren":827,"./reactProdInvariant":843,"fbjs/lib/emptyFunction":594,"fbjs/lib/invariant":602,"react/lib/ReactCurrentOwner":860}],792:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var React = require('react/lib/React');

var invariant = require('fbjs/lib/invariant');

var ReactNodeTypes = {
  HOST: 0,
  COMPOSITE: 1,
  EMPTY: 2,

  getType: function (node) {
    if (node === null || node === false) {
      return ReactNodeTypes.EMPTY;
    } else if (React.isValidElement(node)) {
      if (typeof node.type === 'function') {
        return ReactNodeTypes.COMPOSITE;
      } else {
        return ReactNodeTypes.HOST;
      }
    }
    _prodInvariant('26', node);
  }
};

module.exports = ReactNodeTypes;
},{"./reactProdInvariant":843,"fbjs/lib/invariant":602,"react/lib/React":852}],793:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var invariant = require('fbjs/lib/invariant');

/**
 * @param {?object} object
 * @return {boolean} True if `object` is a valid owner.
 * @final
 */
function isValidOwner(object) {
  return !!(object && typeof object.attachRef === 'function' && typeof object.detachRef === 'function');
}

/**
 * ReactOwners are capable of storing references to owned components.
 *
 * All components are capable of //being// referenced by owner components, but
 * only ReactOwner components are capable of //referencing// owned components.
 * The named reference is known as a "ref".
 *
 * Refs are available when mounted and updated during reconciliation.
 *
 *   var MyComponent = React.createClass({
 *     render: function() {
 *       return (
 *         <div onClick={this.handleClick}>
 *           <CustomComponent ref="custom" />
 *         </div>
 *       );
 *     },
 *     handleClick: function() {
 *       this.refs.custom.handleClick();
 *     },
 *     componentDidMount: function() {
 *       this.refs.custom.initialize();
 *     }
 *   });
 *
 * Refs should rarely be used. When refs are used, they should only be done to
 * control data that is not handled by React's data flow.
 *
 * @class ReactOwner
 */
var ReactOwner = {
  /**
   * Adds a component by ref to an owner component.
   *
   * @param {ReactComponent} component Component to reference.
   * @param {string} ref Name by which to refer to the component.
   * @param {ReactOwner} owner Component on which to record the ref.
   * @final
   * @internal
   */
  addComponentAsRefTo: function (component, ref, owner) {
    !isValidOwner(owner) ? _prodInvariant('119') : void 0;
    owner.attachRef(ref, component);
  },

  /**
   * Removes a component by ref from an owner component.
   *
   * @param {ReactComponent} component Component to dereference.
   * @param {string} ref Name of the ref to remove.
   * @param {ReactOwner} owner Component on which the ref is recorded.
   * @final
   * @internal
   */
  removeComponentAsRefFrom: function (component, ref, owner) {
    !isValidOwner(owner) ? _prodInvariant('120') : void 0;
    var ownerPublicInstance = owner.getPublicInstance();
    // Check that `component`'s owner is still alive and that `component` is still the current ref
    // because we do not want to detach the ref if another component stole it.
    if (ownerPublicInstance && ownerPublicInstance.refs[ref] === component.getPublicInstance()) {
      owner.detachRef(ref);
    }
  }

};

module.exports = ReactOwner;
},{"./reactProdInvariant":843,"fbjs/lib/invariant":602}],794:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;
},{}],795:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

var CallbackQueue = require('./CallbackQueue');
var PooledClass = require('./PooledClass');
var ReactBrowserEventEmitter = require('./ReactBrowserEventEmitter');
var ReactInputSelection = require('./ReactInputSelection');
var ReactInstrumentation = require('./ReactInstrumentation');
var Transaction = require('./Transaction');
var ReactUpdateQueue = require('./ReactUpdateQueue');

/**
 * Ensures that, when possible, the selection range (currently selected text
 * input) is not disturbed by performing the transaction.
 */
var SELECTION_RESTORATION = {
  /**
   * @return {Selection} Selection information.
   */
  initialize: ReactInputSelection.getSelectionInformation,
  /**
   * @param {Selection} sel Selection information returned from `initialize`.
   */
  close: ReactInputSelection.restoreSelection
};

/**
 * Suppresses events (blur/focus) that could be inadvertently dispatched due to
 * high level DOM manipulations (like temporarily removing a text input from the
 * DOM).
 */
var EVENT_SUPPRESSION = {
  /**
   * @return {boolean} The enabled status of `ReactBrowserEventEmitter` before
   * the reconciliation.
   */
  initialize: function () {
    var currentlyEnabled = ReactBrowserEventEmitter.isEnabled();
    ReactBrowserEventEmitter.setEnabled(false);
    return currentlyEnabled;
  },

  /**
   * @param {boolean} previouslyEnabled Enabled status of
   *   `ReactBrowserEventEmitter` before the reconciliation occurred. `close`
   *   restores the previous value.
   */
  close: function (previouslyEnabled) {
    ReactBrowserEventEmitter.setEnabled(previouslyEnabled);
  }
};

/**
 * Provides a queue for collecting `componentDidMount` and
 * `componentDidUpdate` callbacks during the transaction.
 */
var ON_DOM_READY_QUEUEING = {
  /**
   * Initializes the internal `onDOMReady` queue.
   */
  initialize: function () {
    this.reactMountReady.reset();
  },

  /**
   * After DOM is flushed, invoke all registered `onDOMReady` callbacks.
   */
  close: function () {
    this.reactMountReady.notifyAll();
  }
};

/**
 * Executed within the scope of the `Transaction` instance. Consider these as
 * being member methods, but with an implied ordering while being isolated from
 * each other.
 */
var TRANSACTION_WRAPPERS = [SELECTION_RESTORATION, EVENT_SUPPRESSION, ON_DOM_READY_QUEUEING];

/**
 * Currently:
 * - The order that these are listed in the transaction is critical:
 * - Suppresses events.
 * - Restores selection range.
 *
 * Future:
 * - Restore document/overflow scroll positions that were unintentionally
 *   modified via DOM insertions above the top viewport boundary.
 * - Implement/integrate with customized constraint based layout system and keep
 *   track of which dimensions must be remeasured.
 *
 * @class ReactReconcileTransaction
 */
function ReactReconcileTransaction(useCreateElement) {
  this.reinitializeTransaction();
  // Only server-side rendering really needs this option (see
  // `ReactServerRendering`), but server-side uses
  // `ReactServerRenderingTransaction` instead. This option is here so that it's
  // accessible and defaults to false when `ReactDOMComponent` and
  // `ReactDOMTextComponent` checks it in `mountComponent`.`
  this.renderToStaticMarkup = false;
  this.reactMountReady = CallbackQueue.getPooled(null);
  this.useCreateElement = useCreateElement;
}

var Mixin = {
  /**
   * @see Transaction
   * @abstract
   * @final
   * @return {array<object>} List of operation wrap procedures.
   *   TODO: convert to array<TransactionWrapper>
   */
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  },

  /**
   * @return {object} The queue to collect `onDOMReady` callbacks with.
   */
  getReactMountReady: function () {
    return this.reactMountReady;
  },

  /**
   * @return {object} The queue to collect React async events.
   */
  getUpdateQueue: function () {
    return ReactUpdateQueue;
  },

  /**
   * Save current transaction state -- if the return value from this method is
   * passed to `rollback`, the transaction will be reset to that state.
   */
  checkpoint: function () {
    // reactMountReady is the our only stateful wrapper
    return this.reactMountReady.checkpoint();
  },

  rollback: function (checkpoint) {
    this.reactMountReady.rollback(checkpoint);
  },

  /**
   * `PooledClass` looks for this, and will invoke this before allowing this
   * instance to be reused.
   */
  destructor: function () {
    CallbackQueue.release(this.reactMountReady);
    this.reactMountReady = null;
  }
};

_assign(ReactReconcileTransaction.prototype, Transaction, Mixin);

PooledClass.addPoolingTo(ReactReconcileTransaction);

module.exports = ReactReconcileTransaction;
},{"./CallbackQueue":737,"./PooledClass":755,"./ReactBrowserEventEmitter":756,"./ReactInputSelection":786,"./ReactInstrumentation":788,"./ReactUpdateQueue":800,"./Transaction":819,"object-assign":701}],796:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ReactRef = require('./ReactRef');
var ReactInstrumentation = require('./ReactInstrumentation');

var warning = require('fbjs/lib/warning');

/**
 * Helper to call ReactRef.attachRefs with this composite component, split out
 * to avoid allocations in the transaction mount-ready queue.
 */
function attachRefs() {
  ReactRef.attachRefs(this, this._currentElement);
}

var ReactReconciler = {

  /**
   * Initializes the component, renders markup, and registers event listeners.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactReconcileTransaction|ReactServerRenderingTransaction} transaction
   * @param {?object} the containing host component instance
   * @param {?object} info about the host container
   * @return {?string} Rendered markup to be inserted into the DOM.
   * @final
   * @internal
   */
  mountComponent: function (internalInstance, transaction, hostParent, hostContainerInfo, context, parentDebugID // 0 in production and for roots
  ) {
    var markup = internalInstance.mountComponent(transaction, hostParent, hostContainerInfo, context, parentDebugID);
    if (internalInstance._currentElement && internalInstance._currentElement.ref != null) {
      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
    }
    return markup;
  },

  /**
   * Returns a value that can be passed to
   * ReactComponentEnvironment.replaceNodeWithMarkup.
   */
  getHostNode: function (internalInstance) {
    return internalInstance.getHostNode();
  },

  /**
   * Releases any resources allocated by `mountComponent`.
   *
   * @final
   * @internal
   */
  unmountComponent: function (internalInstance, safely) {
    ReactRef.detachRefs(internalInstance, internalInstance._currentElement);
    internalInstance.unmountComponent(safely);
  },

  /**
   * Update a component using a new element.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactElement} nextElement
   * @param {ReactReconcileTransaction} transaction
   * @param {object} context
   * @internal
   */
  receiveComponent: function (internalInstance, nextElement, transaction, context) {
    var prevElement = internalInstance._currentElement;

    if (nextElement === prevElement && context === internalInstance._context) {
      // Since elements are immutable after the owner is rendered,
      // we can do a cheap identity compare here to determine if this is a
      // superfluous reconcile. It's possible for state to be mutable but such
      // change should trigger an update of the owner which would recreate
      // the element. We explicitly check for the existence of an owner since
      // it's possible for an element created outside a composite to be
      // deeply mutated and reused.

      // TODO: Bailing out early is just a perf optimization right?
      // TODO: Removing the return statement should affect correctness?
      return;
    }

    var refsChanged = ReactRef.shouldUpdateRefs(prevElement, nextElement);

    if (refsChanged) {
      ReactRef.detachRefs(internalInstance, prevElement);
    }

    internalInstance.receiveComponent(nextElement, transaction, context);

    if (refsChanged && internalInstance._currentElement && internalInstance._currentElement.ref != null) {
      transaction.getReactMountReady().enqueue(attachRefs, internalInstance);
    }
  },

  /**
   * Flush any dirty changes in a component.
   *
   * @param {ReactComponent} internalInstance
   * @param {ReactReconcileTransaction} transaction
   * @internal
   */
  performUpdateIfNecessary: function (internalInstance, transaction, updateBatchNumber) {
    if (internalInstance._updateBatchNumber !== updateBatchNumber) {
      // The component's enqueued batch number should always be the current
      // batch or the following one.
      void 0;
      return;
    }
    internalInstance.performUpdateIfNecessary(transaction);
  }

};

module.exports = ReactReconciler;
},{"./ReactInstrumentation":788,"./ReactRef":797,"fbjs/lib/warning":607}],797:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var ReactOwner = require('./ReactOwner');

var ReactRef = {};

function attachRef(ref, component, owner) {
  if (typeof ref === 'function') {
    ref(component.getPublicInstance());
  } else {
    // Legacy ref
    ReactOwner.addComponentAsRefTo(component, ref, owner);
  }
}

function detachRef(ref, component, owner) {
  if (typeof ref === 'function') {
    ref(null);
  } else {
    // Legacy ref
    ReactOwner.removeComponentAsRefFrom(component, ref, owner);
  }
}

ReactRef.attachRefs = function (instance, element) {
  if (element === null || typeof element !== 'object') {
    return;
  }
  var ref = element.ref;
  if (ref != null) {
    attachRef(ref, instance, element._owner);
  }
};

ReactRef.shouldUpdateRefs = function (prevElement, nextElement) {
  // If either the owner or a `ref` has changed, make sure the newest owner
  // has stored a reference to `this`, and the previous owner (if different)
  // has forgotten the reference to `this`. We use the element instead
  // of the public this.props because the post processing cannot determine
  // a ref. The ref conceptually lives on the element.

  // TODO: Should this even be possible? The owner cannot change because
  // it's forbidden by shouldUpdateReactComponent. The ref can change
  // if you swap the keys of but not the refs. Reconsider where this check
  // is made. It probably belongs where the key checking and
  // instantiateReactComponent is done.

  var prevRef = null;
  var prevOwner = null;
  if (prevElement !== null && typeof prevElement === 'object') {
    prevRef = prevElement.ref;
    prevOwner = prevElement._owner;
  }

  var nextRef = null;
  var nextOwner = null;
  if (nextElement !== null && typeof nextElement === 'object') {
    nextRef = nextElement.ref;
    nextOwner = nextElement._owner;
  }

  return prevRef !== nextRef ||
  // If owner changes but we have an unchanged function ref, don't update refs
  typeof nextRef === 'string' && nextOwner !== prevOwner;
};

ReactRef.detachRefs = function (instance, element) {
  if (element === null || typeof element !== 'object') {
    return;
  }
  var ref = element.ref;
  if (ref != null) {
    detachRef(ref, instance, element._owner);
  }
};

module.exports = ReactRef;
},{"./ReactOwner":793}],798:[function(require,module,exports){
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

var PooledClass = require('./PooledClass');
var Transaction = require('./Transaction');
var ReactInstrumentation = require('./ReactInstrumentation');
var ReactServerUpdateQueue = require('./ReactServerUpdateQueue');

/**
 * Executed within the scope of the `Transaction` instance. Consider these as
 * being member methods, but with an implied ordering while being isolated from
 * each other.
 */
var TRANSACTION_WRAPPERS = [];

var noopCallbackQueue = {
  enqueue: function () {}
};

/**
 * @class ReactServerRenderingTransaction
 * @param {boolean} renderToStaticMarkup
 */
function ReactServerRenderingTransaction(renderToStaticMarkup) {
  this.reinitializeTransaction();
  this.renderToStaticMarkup = renderToStaticMarkup;
  this.useCreateElement = false;
  this.updateQueue = new ReactServerUpdateQueue(this);
}

var Mixin = {
  /**
   * @see Transaction
   * @abstract
   * @final
   * @return {array} Empty list of operation wrap procedures.
   */
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  },

  /**
   * @return {object} The queue to collect `onDOMReady` callbacks with.
   */
  getReactMountReady: function () {
    return noopCallbackQueue;
  },

  /**
   * @return {object} The queue to collect React async events.
   */
  getUpdateQueue: function () {
    return this.updateQueue;
  },

  /**
   * `PooledClass` looks for this, and will invoke this before allowing this
   * instance to be reused.
   */
  destructor: function () {},

  checkpoint: function () {},

  rollback: function () {}
};

_assign(ReactServerRenderingTransaction.prototype, Transaction, Mixin);

PooledClass.addPoolingTo(ReactServerRenderingTransaction);

module.exports = ReactServerRenderingTransaction;
},{"./PooledClass":755,"./ReactInstrumentation":788,"./ReactServerUpdateQueue":799,"./Transaction":819,"object-assign":701}],799:[function(require,module,exports){
/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ReactUpdateQueue = require('./ReactUpdateQueue');

var warning = require('fbjs/lib/warning');

function warnNoop(publicInstance, callerName) {}

/**
 * This is the update queue used for server rendering.
 * It delegates to ReactUpdateQueue while server rendering is in progress and
 * switches to ReactNoopUpdateQueue after the transaction has completed.
 * @class ReactServerUpdateQueue
 * @param {Transaction} transaction
 */

var ReactServerUpdateQueue = function () {
  function ReactServerUpdateQueue(transaction) {
    _classCallCheck(this, ReactServerUpdateQueue);

    this.transaction = transaction;
  }

  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */


  ReactServerUpdateQueue.prototype.isMounted = function isMounted(publicInstance) {
    return false;
  };

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @internal
   */


  ReactServerUpdateQueue.prototype.enqueueCallback = function enqueueCallback(publicInstance, callback, callerName) {
    if (this.transaction.isInTransaction()) {
      ReactUpdateQueue.enqueueCallback(publicInstance, callback, callerName);
    }
  };

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */


  ReactServerUpdateQueue.prototype.enqueueForceUpdate = function enqueueForceUpdate(publicInstance) {
    if (this.transaction.isInTransaction()) {
      ReactUpdateQueue.enqueueForceUpdate(publicInstance);
    } else {
      warnNoop(publicInstance, 'forceUpdate');
    }
  };

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object|function} completeState Next state.
   * @internal
   */


  ReactServerUpdateQueue.prototype.enqueueReplaceState = function enqueueReplaceState(publicInstance, completeState) {
    if (this.transaction.isInTransaction()) {
      ReactUpdateQueue.enqueueReplaceState(publicInstance, completeState);
    } else {
      warnNoop(publicInstance, 'replaceState');
    }
  };

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object|function} partialState Next partial state to be merged with state.
   * @internal
   */


  ReactServerUpdateQueue.prototype.enqueueSetState = function enqueueSetState(publicInstance, partialState) {
    if (this.transaction.isInTransaction()) {
      ReactUpdateQueue.enqueueSetState(publicInstance, partialState);
    } else {
      warnNoop(publicInstance, 'setState');
    }
  };

  return ReactServerUpdateQueue;
}();

module.exports = ReactServerUpdateQueue;
},{"./ReactUpdateQueue":800,"fbjs/lib/warning":607}],800:[function(require,module,exports){
/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactCurrentOwner = require('react/lib/ReactCurrentOwner');
var ReactInstanceMap = require('./ReactInstanceMap');
var ReactInstrumentation = require('./ReactInstrumentation');
var ReactUpdates = require('./ReactUpdates');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

function enqueueUpdate(internalInstance) {
  ReactUpdates.enqueueUpdate(internalInstance);
}

function formatUnexpectedArgument(arg) {
  var type = typeof arg;
  if (type !== 'object') {
    return type;
  }
  var displayName = arg.constructor && arg.constructor.name || type;
  var keys = Object.keys(arg);
  if (keys.length > 0 && keys.length < 20) {
    return displayName + ' (keys: ' + keys.join(', ') + ')';
  }
  return displayName;
}

function getInternalInstanceReadyForUpdate(publicInstance, callerName) {
  var internalInstance = ReactInstanceMap.get(publicInstance);
  if (!internalInstance) {
    return null;
  }

  return internalInstance;
}

/**
 * ReactUpdateQueue allows for state updates to be scheduled into a later
 * reconciliation step.
 */
var ReactUpdateQueue = {

  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    var internalInstance = ReactInstanceMap.get(publicInstance);
    if (internalInstance) {
      // During componentWillMount and render this will still be null but after
      // that will always render to something. At least for now. So we can use
      // this hack.
      return !!internalInstance._renderedComponent;
    } else {
      return false;
    }
  },

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @param {string} callerName Name of the calling function in the public API.
   * @internal
   */
  enqueueCallback: function (publicInstance, callback, callerName) {
    ReactUpdateQueue.validateCallback(callback, callerName);
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);

    // Previously we would throw an error if we didn't have an internal
    // instance. Since we want to make it a no-op instead, we mirror the same
    // behavior we have in other enqueue* methods.
    // We also need to ignore callbacks in componentWillMount. See
    // enqueueUpdates.
    if (!internalInstance) {
      return null;
    }

    if (internalInstance._pendingCallbacks) {
      internalInstance._pendingCallbacks.push(callback);
    } else {
      internalInstance._pendingCallbacks = [callback];
    }
    // TODO: The callback here is ignored when setState is called from
    // componentWillMount. Either fix it or disallow doing so completely in
    // favor of getInitialState. Alternatively, we can disallow
    // componentWillMount during server-side rendering.
    enqueueUpdate(internalInstance);
  },

  enqueueCallbackInternal: function (internalInstance, callback) {
    if (internalInstance._pendingCallbacks) {
      internalInstance._pendingCallbacks.push(callback);
    } else {
      internalInstance._pendingCallbacks = [callback];
    }
    enqueueUpdate(internalInstance);
  },

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');

    if (!internalInstance) {
      return;
    }

    internalInstance._pendingForceUpdate = true;

    enqueueUpdate(internalInstance);
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');

    if (!internalInstance) {
      return;
    }

    internalInstance._pendingStateQueue = [completeState];
    internalInstance._pendingReplaceState = true;

    enqueueUpdate(internalInstance);
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState) {
    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');

    if (!internalInstance) {
      return;
    }

    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);
    queue.push(partialState);

    enqueueUpdate(internalInstance);
  },

  enqueueElementInternal: function (internalInstance, nextElement, nextContext) {
    internalInstance._pendingElement = nextElement;
    // TODO: introduce _pendingContext instead of setting it directly.
    internalInstance._context = nextContext;
    enqueueUpdate(internalInstance);
  },

  validateCallback: function (callback, callerName) {
    !(!callback || typeof callback === 'function') ? _prodInvariant('122', callerName, formatUnexpectedArgument(callback)) : void 0;
  }

};

module.exports = ReactUpdateQueue;
},{"./ReactInstanceMap":787,"./ReactInstrumentation":788,"./ReactUpdates":801,"./reactProdInvariant":843,"fbjs/lib/invariant":602,"fbjs/lib/warning":607,"react/lib/ReactCurrentOwner":860}],801:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant'),
    _assign = require('object-assign');

var CallbackQueue = require('./CallbackQueue');
var PooledClass = require('./PooledClass');
var ReactFeatureFlags = require('./ReactFeatureFlags');
var ReactReconciler = require('./ReactReconciler');
var Transaction = require('./Transaction');

var invariant = require('fbjs/lib/invariant');

var dirtyComponents = [];
var updateBatchNumber = 0;
var asapCallbackQueue = CallbackQueue.getPooled();
var asapEnqueued = false;

var batchingStrategy = null;

function ensureInjected() {
  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? _prodInvariant('123') : void 0;
}

var NESTED_UPDATES = {
  initialize: function () {
    this.dirtyComponentsLength = dirtyComponents.length;
  },
  close: function () {
    if (this.dirtyComponentsLength !== dirtyComponents.length) {
      // Additional updates were enqueued by componentDidUpdate handlers or
      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run
      // these new updates so that if A's componentDidUpdate calls setState on
      // B, B will update before the callback A's updater provided when calling
      // setState.
      dirtyComponents.splice(0, this.dirtyComponentsLength);
      flushBatchedUpdates();
    } else {
      dirtyComponents.length = 0;
    }
  }
};

var UPDATE_QUEUEING = {
  initialize: function () {
    this.callbackQueue.reset();
  },
  close: function () {
    this.callbackQueue.notifyAll();
  }
};

var TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];

function ReactUpdatesFlushTransaction() {
  this.reinitializeTransaction();
  this.dirtyComponentsLength = null;
  this.callbackQueue = CallbackQueue.getPooled();
  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled(
  /* useCreateElement */true);
}

_assign(ReactUpdatesFlushTransaction.prototype, Transaction, {
  getTransactionWrappers: function () {
    return TRANSACTION_WRAPPERS;
  },

  destructor: function () {
    this.dirtyComponentsLength = null;
    CallbackQueue.release(this.callbackQueue);
    this.callbackQueue = null;
    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);
    this.reconcileTransaction = null;
  },

  perform: function (method, scope, a) {
    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`
    // with this transaction's wrappers around it.
    return Transaction.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);
  }
});

PooledClass.addPoolingTo(ReactUpdatesFlushTransaction);

function batchedUpdates(callback, a, b, c, d, e) {
  ensureInjected();
  return batchingStrategy.batchedUpdates(callback, a, b, c, d, e);
}

/**
 * Array comparator for ReactComponents by mount ordering.
 *
 * @param {ReactComponent} c1 first component you're comparing
 * @param {ReactComponent} c2 second component you're comparing
 * @return {number} Return value usable by Array.prototype.sort().
 */
function mountOrderComparator(c1, c2) {
  return c1._mountOrder - c2._mountOrder;
}

function runBatchedUpdates(transaction) {
  var len = transaction.dirtyComponentsLength;
  !(len === dirtyComponents.length) ? _prodInvariant('124', len, dirtyComponents.length) : void 0;

  // Since reconciling a component higher in the owner hierarchy usually (not
  // always -- see shouldComponentUpdate()) will reconcile children, reconcile
  // them before their children by sorting the array.
  dirtyComponents.sort(mountOrderComparator);

  // Any updates enqueued while reconciling must be performed after this entire
  // batch. Otherwise, if dirtyComponents is [A, B] where A has children B and
  // C, B could update twice in a single batch if C's render enqueues an update
  // to B (since B would have already updated, we should skip it, and the only
  // way we can know to do so is by checking the batch counter).
  updateBatchNumber++;

  for (var i = 0; i < len; i++) {
    // If a component is unmounted before pending changes apply, it will still
    // be here, but we assume that it has cleared its _pendingCallbacks and
    // that performUpdateIfNecessary is a noop.
    var component = dirtyComponents[i];

    // If performUpdateIfNecessary happens to enqueue any new updates, we
    // shouldn't execute the callbacks until the next render happens, so
    // stash the callbacks first
    var callbacks = component._pendingCallbacks;
    component._pendingCallbacks = null;

    var markerName;
    if (ReactFeatureFlags.logTopLevelRenders) {
      var namedComponent = component;
      // Duck type TopLevelWrapper. This is probably always true.
      if (component._currentElement.type.isReactTopLevelWrapper) {
        namedComponent = component._renderedComponent;
      }
      markerName = 'React update: ' + namedComponent.getName();
      console.time(markerName);
    }

    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction, updateBatchNumber);

    if (markerName) {
      console.timeEnd(markerName);
    }

    if (callbacks) {
      for (var j = 0; j < callbacks.length; j++) {
        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());
      }
    }
  }
}

var flushBatchedUpdates = function () {
  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents
  // array and perform any updates enqueued by mount-ready handlers (i.e.,
  // componentDidUpdate) but we need to check here too in order to catch
  // updates enqueued by setState callbacks and asap calls.
  while (dirtyComponents.length || asapEnqueued) {
    if (dirtyComponents.length) {
      var transaction = ReactUpdatesFlushTransaction.getPooled();
      transaction.perform(runBatchedUpdates, null, transaction);
      ReactUpdatesFlushTransaction.release(transaction);
    }

    if (asapEnqueued) {
      asapEnqueued = false;
      var queue = asapCallbackQueue;
      asapCallbackQueue = CallbackQueue.getPooled();
      queue.notifyAll();
      CallbackQueue.release(queue);
    }
  }
};

/**
 * Mark a component as needing a rerender, adding an optional callback to a
 * list of functions which will be executed once the rerender occurs.
 */
function enqueueUpdate(component) {
  ensureInjected();

  // Various parts of our code (such as ReactCompositeComponent's
  // _renderValidatedComponent) assume that calls to render aren't nested;
  // verify that that's the case. (This is called by each top-level update
  // function, like setState, forceUpdate, etc.; creation and
  // destruction of top-level components is guarded in ReactMount.)

  if (!batchingStrategy.isBatchingUpdates) {
    batchingStrategy.batchedUpdates(enqueueUpdate, component);
    return;
  }

  dirtyComponents.push(component);
  if (component._updateBatchNumber == null) {
    component._updateBatchNumber = updateBatchNumber + 1;
  }
}

/**
 * Enqueue a callback to be run at the end of the current batching cycle. Throws
 * if no updates are currently being performed.
 */
function asap(callback, context) {
  !batchingStrategy.isBatchingUpdates ? _prodInvariant('125') : void 0;
  asapCallbackQueue.enqueue(callback, context);
  asapEnqueued = true;
}

var ReactUpdatesInjection = {
  injectReconcileTransaction: function (ReconcileTransaction) {
    !ReconcileTransaction ? _prodInvariant('126') : void 0;
    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;
  },

  injectBatchingStrategy: function (_batchingStrategy) {
    !_batchingStrategy ? _prodInvariant('127') : void 0;
    !(typeof _batchingStrategy.batchedUpdates === 'function') ? _prodInvariant('128') : void 0;
    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? _prodInvariant('129') : void 0;
    batchingStrategy = _batchingStrategy;
  }
};

var ReactUpdates = {
  /**
   * React references `ReactReconcileTransaction` using this property in order
   * to allow dependency injection.
   *
   * @internal
   */
  ReactReconcileTransaction: null,

  batchedUpdates: batchedUpdates,
  enqueueUpdate: enqueueUpdate,
  flushBatchedUpdates: flushBatchedUpdates,
  injection: ReactUpdatesInjection,
  asap: asap
};

module.exports = ReactUpdates;
},{"./CallbackQueue":737,"./PooledClass":755,"./ReactFeatureFlags":783,"./ReactReconciler":796,"./Transaction":819,"./reactProdInvariant":843,"fbjs/lib/invariant":602,"object-assign":701}],802:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

module.exports = '15.4.1';
},{}],803:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var NS = {
  xlink: 'http://www.w3.org/1999/xlink',
  xml: 'http://www.w3.org/XML/1998/namespace'
};

// We use attributes for everything SVG so let's avoid some duplication and run
// code instead.
// The following are all specified in the HTML config already so we exclude here.
// - class (as className)
// - color
// - height
// - id
// - lang
// - max
// - media
// - method
// - min
// - name
// - style
// - target
// - type
// - width
var ATTRS = {
  accentHeight: 'accent-height',
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 'alignment-baseline',
  allowReorder: 'allowReorder',
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 'arabic-form',
  ascent: 0,
  attributeName: 'attributeName',
  attributeType: 'attributeType',
  autoReverse: 'autoReverse',
  azimuth: 0,
  baseFrequency: 'baseFrequency',
  baseProfile: 'baseProfile',
  baselineShift: 'baseline-shift',
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 'calcMode',
  capHeight: 'cap-height',
  clip: 0,
  clipPath: 'clip-path',
  clipRule: 'clip-rule',
  clipPathUnits: 'clipPathUnits',
  colorInterpolation: 'color-interpolation',
  colorInterpolationFilters: 'color-interpolation-filters',
  colorProfile: 'color-profile',
  colorRendering: 'color-rendering',
  contentScriptType: 'contentScriptType',
  contentStyleType: 'contentStyleType',
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 'diffuseConstant',
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 'dominant-baseline',
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 'edgeMode',
  elevation: 0,
  enableBackground: 'enable-background',
  end: 0,
  exponent: 0,
  externalResourcesRequired: 'externalResourcesRequired',
  fill: 0,
  fillOpacity: 'fill-opacity',
  fillRule: 'fill-rule',
  filter: 0,
  filterRes: 'filterRes',
  filterUnits: 'filterUnits',
  floodColor: 'flood-color',
  floodOpacity: 'flood-opacity',
  focusable: 0,
  fontFamily: 'font-family',
  fontSize: 'font-size',
  fontSizeAdjust: 'font-size-adjust',
  fontStretch: 'font-stretch',
  fontStyle: 'font-style',
  fontVariant: 'font-variant',
  fontWeight: 'font-weight',
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 'glyph-name',
  glyphOrientationHorizontal: 'glyph-orientation-horizontal',
  glyphOrientationVertical: 'glyph-orientation-vertical',
  glyphRef: 'glyphRef',
  gradientTransform: 'gradientTransform',
  gradientUnits: 'gradientUnits',
  hanging: 0,
  horizAdvX: 'horiz-adv-x',
  horizOriginX: 'horiz-origin-x',
  ideographic: 0,
  imageRendering: 'image-rendering',
  'in': 0,
  in2: 0,
  intercept: 0,
  k: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  kernelMatrix: 'kernelMatrix',
  kernelUnitLength: 'kernelUnitLength',
  kerning: 0,
  keyPoints: 'keyPoints',
  keySplines: 'keySplines',
  keyTimes: 'keyTimes',
  lengthAdjust: 'lengthAdjust',
  letterSpacing: 'letter-spacing',
  lightingColor: 'lighting-color',
  limitingConeAngle: 'limitingConeAngle',
  local: 0,
  markerEnd: 'marker-end',
  markerMid: 'marker-mid',
  markerStart: 'marker-start',
  markerHeight: 'markerHeight',
  markerUnits: 'markerUnits',
  markerWidth: 'markerWidth',
  mask: 0,
  maskContentUnits: 'maskContentUnits',
  maskUnits: 'maskUnits',
  mathematical: 0,
  mode: 0,
  numOctaves: 'numOctaves',
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 'overline-position',
  overlineThickness: 'overline-thickness',
  paintOrder: 'paint-order',
  panose1: 'panose-1',
  pathLength: 'pathLength',
  patternContentUnits: 'patternContentUnits',
  patternTransform: 'patternTransform',
  patternUnits: 'patternUnits',
  pointerEvents: 'pointer-events',
  points: 0,
  pointsAtX: 'pointsAtX',
  pointsAtY: 'pointsAtY',
  pointsAtZ: 'pointsAtZ',
  preserveAlpha: 'preserveAlpha',
  preserveAspectRatio: 'preserveAspectRatio',
  primitiveUnits: 'primitiveUnits',
  r: 0,
  radius: 0,
  refX: 'refX',
  refY: 'refY',
  renderingIntent: 'rendering-intent',
  repeatCount: 'repeatCount',
  repeatDur: 'repeatDur',
  requiredExtensions: 'requiredExtensions',
  requiredFeatures: 'requiredFeatures',
  restart: 0,
  result: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  seed: 0,
  shapeRendering: 'shape-rendering',
  slope: 0,
  spacing: 0,
  specularConstant: 'specularConstant',
  specularExponent: 'specularExponent',
  speed: 0,
  spreadMethod: 'spreadMethod',
  startOffset: 'startOffset',
  stdDeviation: 'stdDeviation',
  stemh: 0,
  stemv: 0,
  stitchTiles: 'stitchTiles',
  stopColor: 'stop-color',
  stopOpacity: 'stop-opacity',
  strikethroughPosition: 'strikethrough-position',
  strikethroughThickness: 'strikethrough-thickness',
  string: 0,
  stroke: 0,
  strokeDasharray: 'stroke-dasharray',
  strokeDashoffset: 'stroke-dashoffset',
  strokeLinecap: 'stroke-linecap',
  strokeLinejoin: 'stroke-linejoin',
  strokeMiterlimit: 'stroke-miterlimit',
  strokeOpacity: 'stroke-opacity',
  strokeWidth: 'stroke-width',
  surfaceScale: 'surfaceScale',
  systemLanguage: 'systemLanguage',
  tableValues: 'tableValues',
  targetX: 'targetX',
  targetY: 'targetY',
  textAnchor: 'text-anchor',
  textDecoration: 'text-decoration',
  textRendering: 'text-rendering',
  textLength: 'textLength',
  to: 0,
  transform: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 'underline-position',
  underlineThickness: 'underline-thickness',
  unicode: 0,
  unicodeBidi: 'unicode-bidi',
  unicodeRange: 'unicode-range',
  unitsPerEm: 'units-per-em',
  vAlphabetic: 'v-alphabetic',
  vHanging: 'v-hanging',
  vIdeographic: 'v-ideographic',
  vMathematical: 'v-mathematical',
  values: 0,
  vectorEffect: 'vector-effect',
  version: 0,
  vertAdvY: 'vert-adv-y',
  vertOriginX: 'vert-origin-x',
  vertOriginY: 'vert-origin-y',
  viewBox: 'viewBox',
  viewTarget: 'viewTarget',
  visibility: 0,
  widths: 0,
  wordSpacing: 'word-spacing',
  writingMode: 'writing-mode',
  x: 0,
  xHeight: 'x-height',
  x1: 0,
  x2: 0,
  xChannelSelector: 'xChannelSelector',
  xlinkActuate: 'xlink:actuate',
  xlinkArcrole: 'xlink:arcrole',
  xlinkHref: 'xlink:href',
  xlinkRole: 'xlink:role',
  xlinkShow: 'xlink:show',
  xlinkTitle: 'xlink:title',
  xlinkType: 'xlink:type',
  xmlBase: 'xml:base',
  xmlns: 0,
  xmlnsXlink: 'xmlns:xlink',
  xmlLang: 'xml:lang',
  xmlSpace: 'xml:space',
  y: 0,
  y1: 0,
  y2: 0,
  yChannelSelector: 'yChannelSelector',
  z: 0,
  zoomAndPan: 'zoomAndPan'
};

var SVGDOMPropertyConfig = {
  Properties: {},
  DOMAttributeNamespaces: {
    xlinkActuate: NS.xlink,
    xlinkArcrole: NS.xlink,
    xlinkHref: NS.xlink,
    xlinkRole: NS.xlink,
    xlinkShow: NS.xlink,
    xlinkTitle: NS.xlink,
    xlinkType: NS.xlink,
    xmlBase: NS.xml,
    xmlLang: NS.xml,
    xmlSpace: NS.xml
  },
  DOMAttributeNames: {}
};

Object.keys(ATTRS).forEach(function (key) {
  SVGDOMPropertyConfig.Properties[key] = 0;
  if (ATTRS[key]) {
    SVGDOMPropertyConfig.DOMAttributeNames[key] = ATTRS[key];
  }
});

module.exports = SVGDOMPropertyConfig;
},{}],804:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var EventPropagators = require('./EventPropagators');
var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactInputSelection = require('./ReactInputSelection');
var SyntheticEvent = require('./SyntheticEvent');

var getActiveElement = require('fbjs/lib/getActiveElement');
var isTextInputElement = require('./isTextInputElement');
var shallowEqual = require('fbjs/lib/shallowEqual');

var skipSelectionChangeEvent = ExecutionEnvironment.canUseDOM && 'documentMode' in document && document.documentMode <= 11;

var eventTypes = {
  select: {
    phasedRegistrationNames: {
      bubbled: 'onSelect',
      captured: 'onSelectCapture'
    },
    dependencies: ['topBlur', 'topContextMenu', 'topFocus', 'topKeyDown', 'topKeyUp', 'topMouseDown', 'topMouseUp', 'topSelectionChange']
  }
};

var activeElement = null;
var activeElementInst = null;
var lastSelection = null;
var mouseDown = false;

// Track whether a listener exists for this plugin. If none exist, we do
// not extract events. See #3639.
var hasListener = false;

/**
 * Get an object which is a unique representation of the current selection.
 *
 * The return value will not be consistent across nodes or browsers, but
 * two identical selections on the same node will return identical objects.
 *
 * @param {DOMElement} node
 * @return {object}
 */
function getSelection(node) {
  if ('selectionStart' in node && ReactInputSelection.hasSelectionCapabilities(node)) {
    return {
      start: node.selectionStart,
      end: node.selectionEnd
    };
  } else if (window.getSelection) {
    var selection = window.getSelection();
    return {
      anchorNode: selection.anchorNode,
      anchorOffset: selection.anchorOffset,
      focusNode: selection.focusNode,
      focusOffset: selection.focusOffset
    };
  } else if (document.selection) {
    var range = document.selection.createRange();
    return {
      parentElement: range.parentElement(),
      text: range.text,
      top: range.boundingTop,
      left: range.boundingLeft
    };
  }
}

/**
 * Poll selection to see whether it's changed.
 *
 * @param {object} nativeEvent
 * @return {?SyntheticEvent}
 */
function constructSelectEvent(nativeEvent, nativeEventTarget) {
  // Ensure we have the right element, and that the user is not dragging a
  // selection (this matches native `select` event behavior). In HTML5, select
  // fires only on input and textarea thus if there's no focused element we
  // won't dispatch.
  if (mouseDown || activeElement == null || activeElement !== getActiveElement()) {
    return null;
  }

  // Only fire when selection has actually changed.
  var currentSelection = getSelection(activeElement);
  if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
    lastSelection = currentSelection;

    var syntheticEvent = SyntheticEvent.getPooled(eventTypes.select, activeElementInst, nativeEvent, nativeEventTarget);

    syntheticEvent.type = 'select';
    syntheticEvent.target = activeElement;

    EventPropagators.accumulateTwoPhaseDispatches(syntheticEvent);

    return syntheticEvent;
  }

  return null;
}

/**
 * This plugin creates an `onSelect` event that normalizes select events
 * across form elements.
 *
 * Supported elements are:
 * - input (see `isTextInputElement`)
 * - textarea
 * - contentEditable
 *
 * This differs from native browser implementations in the following ways:
 * - Fires on contentEditable fields as well as inputs.
 * - Fires for collapsed selection.
 * - Fires after user input.
 */
var SelectEventPlugin = {

  eventTypes: eventTypes,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    if (!hasListener) {
      return null;
    }

    var targetNode = targetInst ? ReactDOMComponentTree.getNodeFromInstance(targetInst) : window;

    switch (topLevelType) {
      // Track the input node that has focus.
      case 'topFocus':
        if (isTextInputElement(targetNode) || targetNode.contentEditable === 'true') {
          activeElement = targetNode;
          activeElementInst = targetInst;
          lastSelection = null;
        }
        break;
      case 'topBlur':
        activeElement = null;
        activeElementInst = null;
        lastSelection = null;
        break;

      // Don't fire the event while the user is dragging. This matches the
      // semantics of the native select event.
      case 'topMouseDown':
        mouseDown = true;
        break;
      case 'topContextMenu':
      case 'topMouseUp':
        mouseDown = false;
        return constructSelectEvent(nativeEvent, nativeEventTarget);

      // Chrome and IE fire non-standard event when selection is changed (and
      // sometimes when it hasn't). IE's event fires out of order with respect
      // to key and input events on deletion, so we discard it.
      //
      // Firefox doesn't support selectionchange, so check selection status
      // after each key entry. The selection changes after keydown and before
      // keyup, but we check on keydown as well in the case of holding down a
      // key, when multiple keydown events are fired but only one keyup is.
      // This is also our approach for IE handling, for the reason above.
      case 'topSelectionChange':
        if (skipSelectionChangeEvent) {
          break;
        }
      // falls through
      case 'topKeyDown':
      case 'topKeyUp':
        return constructSelectEvent(nativeEvent, nativeEventTarget);
    }

    return null;
  },

  didPutListener: function (inst, registrationName, listener) {
    if (registrationName === 'onSelect') {
      hasListener = true;
    }
  }
};

module.exports = SelectEventPlugin;
},{"./EventPropagators":750,"./ReactDOMComponentTree":764,"./ReactInputSelection":786,"./SyntheticEvent":810,"./isTextInputElement":841,"fbjs/lib/ExecutionEnvironment":588,"fbjs/lib/getActiveElement":597,"fbjs/lib/shallowEqual":606}],805:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var EventListener = require('fbjs/lib/EventListener');
var EventPropagators = require('./EventPropagators');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var SyntheticAnimationEvent = require('./SyntheticAnimationEvent');
var SyntheticClipboardEvent = require('./SyntheticClipboardEvent');
var SyntheticEvent = require('./SyntheticEvent');
var SyntheticFocusEvent = require('./SyntheticFocusEvent');
var SyntheticKeyboardEvent = require('./SyntheticKeyboardEvent');
var SyntheticMouseEvent = require('./SyntheticMouseEvent');
var SyntheticDragEvent = require('./SyntheticDragEvent');
var SyntheticTouchEvent = require('./SyntheticTouchEvent');
var SyntheticTransitionEvent = require('./SyntheticTransitionEvent');
var SyntheticUIEvent = require('./SyntheticUIEvent');
var SyntheticWheelEvent = require('./SyntheticWheelEvent');

var emptyFunction = require('fbjs/lib/emptyFunction');
var getEventCharCode = require('./getEventCharCode');
var invariant = require('fbjs/lib/invariant');

/**
 * Turns
 * ['abort', ...]
 * into
 * eventTypes = {
 *   'abort': {
 *     phasedRegistrationNames: {
 *       bubbled: 'onAbort',
 *       captured: 'onAbortCapture',
 *     },
 *     dependencies: ['topAbort'],
 *   },
 *   ...
 * };
 * topLevelEventsToDispatchConfig = {
 *   'topAbort': { sameConfig }
 * };
 */
var eventTypes = {};
var topLevelEventsToDispatchConfig = {};
['abort', 'animationEnd', 'animationIteration', 'animationStart', 'blur', 'canPlay', 'canPlayThrough', 'click', 'contextMenu', 'copy', 'cut', 'doubleClick', 'drag', 'dragEnd', 'dragEnter', 'dragExit', 'dragLeave', 'dragOver', 'dragStart', 'drop', 'durationChange', 'emptied', 'encrypted', 'ended', 'error', 'focus', 'input', 'invalid', 'keyDown', 'keyPress', 'keyUp', 'load', 'loadedData', 'loadedMetadata', 'loadStart', 'mouseDown', 'mouseMove', 'mouseOut', 'mouseOver', 'mouseUp', 'paste', 'pause', 'play', 'playing', 'progress', 'rateChange', 'reset', 'scroll', 'seeked', 'seeking', 'stalled', 'submit', 'suspend', 'timeUpdate', 'touchCancel', 'touchEnd', 'touchMove', 'touchStart', 'transitionEnd', 'volumeChange', 'waiting', 'wheel'].forEach(function (event) {
  var capitalizedEvent = event[0].toUpperCase() + event.slice(1);
  var onEvent = 'on' + capitalizedEvent;
  var topEvent = 'top' + capitalizedEvent;

  var type = {
    phasedRegistrationNames: {
      bubbled: onEvent,
      captured: onEvent + 'Capture'
    },
    dependencies: [topEvent]
  };
  eventTypes[event] = type;
  topLevelEventsToDispatchConfig[topEvent] = type;
});

var onClickListeners = {};

function getDictionaryKey(inst) {
  // Prevents V8 performance issue:
  // https://github.com/facebook/react/pull/7232
  return '.' + inst._rootNodeID;
}

function isInteractive(tag) {
  return tag === 'button' || tag === 'input' || tag === 'select' || tag === 'textarea';
}

var SimpleEventPlugin = {

  eventTypes: eventTypes,

  extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) {
    var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType];
    if (!dispatchConfig) {
      return null;
    }
    var EventConstructor;
    switch (topLevelType) {
      case 'topAbort':
      case 'topCanPlay':
      case 'topCanPlayThrough':
      case 'topDurationChange':
      case 'topEmptied':
      case 'topEncrypted':
      case 'topEnded':
      case 'topError':
      case 'topInput':
      case 'topInvalid':
      case 'topLoad':
      case 'topLoadedData':
      case 'topLoadedMetadata':
      case 'topLoadStart':
      case 'topPause':
      case 'topPlay':
      case 'topPlaying':
      case 'topProgress':
      case 'topRateChange':
      case 'topReset':
      case 'topSeeked':
      case 'topSeeking':
      case 'topStalled':
      case 'topSubmit':
      case 'topSuspend':
      case 'topTimeUpdate':
      case 'topVolumeChange':
      case 'topWaiting':
        // HTML Events
        // @see http://www.w3.org/TR/html5/index.html#events-0
        EventConstructor = SyntheticEvent;
        break;
      case 'topKeyPress':
        // Firefox creates a keypress event for function keys too. This removes
        // the unwanted keypress events. Enter is however both printable and
        // non-printable. One would expect Tab to be as well (but it isn't).
        if (getEventCharCode(nativeEvent) === 0) {
          return null;
        }
      /* falls through */
      case 'topKeyDown':
      case 'topKeyUp':
        EventConstructor = SyntheticKeyboardEvent;
        break;
      case 'topBlur':
      case 'topFocus':
        EventConstructor = SyntheticFocusEvent;
        break;
      case 'topClick':
        // Firefox creates a click event on right mouse clicks. This removes the
        // unwanted click events.
        if (nativeEvent.button === 2) {
          return null;
        }
      /* falls through */
      case 'topDoubleClick':
      case 'topMouseDown':
      case 'topMouseMove':
      case 'topMouseUp':
      // TODO: Disabled elements should not respond to mouse events
      /* falls through */
      case 'topMouseOut':
      case 'topMouseOver':
      case 'topContextMenu':
        EventConstructor = SyntheticMouseEvent;
        break;
      case 'topDrag':
      case 'topDragEnd':
      case 'topDragEnter':
      case 'topDragExit':
      case 'topDragLeave':
      case 'topDragOver':
      case 'topDragStart':
      case 'topDrop':
        EventConstructor = SyntheticDragEvent;
        break;
      case 'topTouchCancel':
      case 'topTouchEnd':
      case 'topTouchMove':
      case 'topTouchStart':
        EventConstructor = SyntheticTouchEvent;
        break;
      case 'topAnimationEnd':
      case 'topAnimationIteration':
      case 'topAnimationStart':
        EventConstructor = SyntheticAnimationEvent;
        break;
      case 'topTransitionEnd':
        EventConstructor = SyntheticTransitionEvent;
        break;
      case 'topScroll':
        EventConstructor = SyntheticUIEvent;
        break;
      case 'topWheel':
        EventConstructor = SyntheticWheelEvent;
        break;
      case 'topCopy':
      case 'topCut':
      case 'topPaste':
        EventConstructor = SyntheticClipboardEvent;
        break;
    }
    !EventConstructor ? _prodInvariant('86', topLevelType) : void 0;
    var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget);
    EventPropagators.accumulateTwoPhaseDispatches(event);
    return event;
  },

  didPutListener: function (inst, registrationName, listener) {
    // Mobile Safari does not fire properly bubble click events on
    // non-interactive elements, which means delegated click listeners do not
    // fire. The workaround for this bug involves attaching an empty click
    // listener on the target node.
    // http://www.quirksmode.org/blog/archives/2010/09/click_event_del.html
    if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
      var key = getDictionaryKey(inst);
      var node = ReactDOMComponentTree.getNodeFromInstance(inst);
      if (!onClickListeners[key]) {
        onClickListeners[key] = EventListener.listen(node, 'click', emptyFunction);
      }
    }
  },

  willDeleteListener: function (inst, registrationName) {
    if (registrationName === 'onClick' && !isInteractive(inst._tag)) {
      var key = getDictionaryKey(inst);
      onClickListeners[key].remove();
      delete onClickListeners[key];
    }
  }

};

module.exports = SimpleEventPlugin;
},{"./EventPropagators":750,"./ReactDOMComponentTree":764,"./SyntheticAnimationEvent":806,"./SyntheticClipboardEvent":807,"./SyntheticDragEvent":809,"./SyntheticEvent":810,"./SyntheticFocusEvent":811,"./SyntheticKeyboardEvent":813,"./SyntheticMouseEvent":814,"./SyntheticTouchEvent":815,"./SyntheticTransitionEvent":816,"./SyntheticUIEvent":817,"./SyntheticWheelEvent":818,"./getEventCharCode":829,"./reactProdInvariant":843,"fbjs/lib/EventListener":587,"fbjs/lib/emptyFunction":594,"fbjs/lib/invariant":602}],806:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var SyntheticEvent = require('./SyntheticEvent');

/**
 * @interface Event
 * @see http://www.w3.org/TR/css3-animations/#AnimationEvent-interface
 * @see https://developer.mozilla.org/en-US/docs/Web/API/AnimationEvent
 */
var AnimationEventInterface = {
  animationName: null,
  elapsedTime: null,
  pseudoElement: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticAnimationEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticAnimationEvent, AnimationEventInterface);

module.exports = SyntheticAnimationEvent;
},{"./SyntheticEvent":810}],807:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var SyntheticEvent = require('./SyntheticEvent');

/**
 * @interface Event
 * @see http://www.w3.org/TR/clipboard-apis/
 */
var ClipboardEventInterface = {
  clipboardData: function (event) {
    return 'clipboardData' in event ? event.clipboardData : window.clipboardData;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticClipboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticClipboardEvent, ClipboardEventInterface);

module.exports = SyntheticClipboardEvent;
},{"./SyntheticEvent":810}],808:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var SyntheticEvent = require('./SyntheticEvent');

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#events-compositionevents
 */
var CompositionEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticCompositionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticCompositionEvent, CompositionEventInterface);

module.exports = SyntheticCompositionEvent;
},{"./SyntheticEvent":810}],809:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var SyntheticMouseEvent = require('./SyntheticMouseEvent');

/**
 * @interface DragEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var DragEventInterface = {
  dataTransfer: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticDragEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent.augmentClass(SyntheticDragEvent, DragEventInterface);

module.exports = SyntheticDragEvent;
},{"./SyntheticMouseEvent":814}],810:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

var PooledClass = require('./PooledClass');

var emptyFunction = require('fbjs/lib/emptyFunction');
var warning = require('fbjs/lib/warning');

var didWarnForAddedNewProperty = false;
var isProxySupported = typeof Proxy === 'function';

var shouldBeReleasedProperties = ['dispatchConfig', '_targetInst', 'nativeEvent', 'isDefaultPrevented', 'isPropagationStopped', '_dispatchListeners', '_dispatchInstances'];

/**
 * @interface Event
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var EventInterface = {
  type: null,
  target: null,
  // currentTarget is set when dispatching; no use in copying it here
  currentTarget: emptyFunction.thatReturnsNull,
  eventPhase: null,
  bubbles: null,
  cancelable: null,
  timeStamp: function (event) {
    return event.timeStamp || Date.now();
  },
  defaultPrevented: null,
  isTrusted: null
};

/**
 * Synthetic events are dispatched by event plugins, typically in response to a
 * top-level event delegation handler.
 *
 * These systems should generally use pooling to reduce the frequency of garbage
 * collection. The system should check `isPersistent` to determine whether the
 * event should be released into the pool after being dispatched. Users that
 * need a persisted event should invoke `persist`.
 *
 * Synthetic events (and subclasses) implement the DOM Level 3 Events API by
 * normalizing browser quirks. Subclasses do not necessarily have to implement a
 * DOM interface; custom application-specific events can also subclass this.
 *
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {*} targetInst Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @param {DOMEventTarget} nativeEventTarget Target node.
 */
function SyntheticEvent(dispatchConfig, targetInst, nativeEvent, nativeEventTarget) {
  this.dispatchConfig = dispatchConfig;
  this._targetInst = targetInst;
  this.nativeEvent = nativeEvent;

  var Interface = this.constructor.Interface;
  for (var propName in Interface) {
    if (!Interface.hasOwnProperty(propName)) {
      continue;
    }
    var normalize = Interface[propName];
    if (normalize) {
      this[propName] = normalize(nativeEvent);
    } else {
      if (propName === 'target') {
        this.target = nativeEventTarget;
      } else {
        this[propName] = nativeEvent[propName];
      }
    }
  }

  var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
  if (defaultPrevented) {
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  } else {
    this.isDefaultPrevented = emptyFunction.thatReturnsFalse;
  }
  this.isPropagationStopped = emptyFunction.thatReturnsFalse;
  return this;
}

_assign(SyntheticEvent.prototype, {

  preventDefault: function () {
    this.defaultPrevented = true;
    var event = this.nativeEvent;
    if (!event) {
      return;
    }

    if (event.preventDefault) {
      event.preventDefault();
    } else if (typeof event.returnValue !== 'unknown') {
      // eslint-disable-line valid-typeof
      event.returnValue = false;
    }
    this.isDefaultPrevented = emptyFunction.thatReturnsTrue;
  },

  stopPropagation: function () {
    var event = this.nativeEvent;
    if (!event) {
      return;
    }

    if (event.stopPropagation) {
      event.stopPropagation();
    } else if (typeof event.cancelBubble !== 'unknown') {
      // eslint-disable-line valid-typeof
      // The ChangeEventPlugin registers a "propertychange" event for
      // IE. This event does not support bubbling or cancelling, and
      // any references to cancelBubble throw "Member not found".  A
      // typeof check of "unknown" circumvents this issue (and is also
      // IE specific).
      event.cancelBubble = true;
    }

    this.isPropagationStopped = emptyFunction.thatReturnsTrue;
  },

  /**
   * We release all dispatched `SyntheticEvent`s after each event loop, adding
   * them back into the pool. This allows a way to hold onto a reference that
   * won't be added back into the pool.
   */
  persist: function () {
    this.isPersistent = emptyFunction.thatReturnsTrue;
  },

  /**
   * Checks if this event should be released back into the pool.
   *
   * @return {boolean} True if this should not be released, false otherwise.
   */
  isPersistent: emptyFunction.thatReturnsFalse,

  /**
   * `PooledClass` looks for `destructor` on each instance it releases.
   */
  destructor: function () {
    var Interface = this.constructor.Interface;
    for (var propName in Interface) {
      {
        this[propName] = null;
      }
    }
    for (var i = 0; i < shouldBeReleasedProperties.length; i++) {
      this[shouldBeReleasedProperties[i]] = null;
    }
  }

});

SyntheticEvent.Interface = EventInterface;

/**
 * Helper to reduce boilerplate when creating subclasses.
 *
 * @param {function} Class
 * @param {?object} Interface
 */
SyntheticEvent.augmentClass = function (Class, Interface) {
  var Super = this;

  var E = function () {};
  E.prototype = Super.prototype;
  var prototype = new E();

  _assign(prototype, Class.prototype);
  Class.prototype = prototype;
  Class.prototype.constructor = Class;

  Class.Interface = _assign({}, Super.Interface, Interface);
  Class.augmentClass = Super.augmentClass;

  PooledClass.addPoolingTo(Class, PooledClass.fourArgumentPooler);
};

PooledClass.addPoolingTo(SyntheticEvent, PooledClass.fourArgumentPooler);

module.exports = SyntheticEvent;

/**
  * Helper to nullify syntheticEvent instance properties when destructing
  *
  * @param {object} SyntheticEvent
  * @param {String} propName
  * @return {object} defineProperty object
  */
function getPooledWarningPropertyDefinition(propName, getVal) {
  var isFunction = typeof getVal === 'function';
  return {
    configurable: true,
    set: set,
    get: get
  };

  function set(val) {
    var action = isFunction ? 'setting the method' : 'setting the property';
    warn(action, 'This is effectively a no-op');
    return val;
  }

  function get() {
    var action = isFunction ? 'accessing the method' : 'accessing the property';
    var result = isFunction ? 'This is a no-op function' : 'This is set to null';
    warn(action, result);
    return getVal;
  }

  function warn(action, result) {
    var warningCondition = false;
    void 0;
  }
}
},{"./PooledClass":755,"fbjs/lib/emptyFunction":594,"fbjs/lib/warning":607,"object-assign":701}],811:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var SyntheticUIEvent = require('./SyntheticUIEvent');

/**
 * @interface FocusEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var FocusEventInterface = {
  relatedTarget: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticFocusEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticFocusEvent, FocusEventInterface);

module.exports = SyntheticFocusEvent;
},{"./SyntheticUIEvent":817}],812:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var SyntheticEvent = require('./SyntheticEvent');

/**
 * @interface Event
 * @see http://www.w3.org/TR/2013/WD-DOM-Level-3-Events-20131105
 *      /#events-inputevents
 */
var InputEventInterface = {
  data: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticInputEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticInputEvent, InputEventInterface);

module.exports = SyntheticInputEvent;
},{"./SyntheticEvent":810}],813:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var SyntheticUIEvent = require('./SyntheticUIEvent');

var getEventCharCode = require('./getEventCharCode');
var getEventKey = require('./getEventKey');
var getEventModifierState = require('./getEventModifierState');

/**
 * @interface KeyboardEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var KeyboardEventInterface = {
  key: getEventKey,
  location: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  repeat: null,
  locale: null,
  getModifierState: getEventModifierState,
  // Legacy Interface
  charCode: function (event) {
    // `charCode` is the result of a KeyPress event and represents the value of
    // the actual printable character.

    // KeyPress is deprecated, but its replacement is not yet final and not
    // implemented in any major browser. Only KeyPress has charCode.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    return 0;
  },
  keyCode: function (event) {
    // `keyCode` is the result of a KeyDown/Up event and represents the value of
    // physical keyboard key.

    // The actual meaning of the value depends on the users' keyboard layout
    // which cannot be detected. Assuming that it is a US keyboard layout
    // provides a surprisingly accurate mapping for US and European users.
    // Due to this, it is left to the user to implement at this time.
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  },
  which: function (event) {
    // `which` is an alias for either `keyCode` or `charCode` depending on the
    // type of the event.
    if (event.type === 'keypress') {
      return getEventCharCode(event);
    }
    if (event.type === 'keydown' || event.type === 'keyup') {
      return event.keyCode;
    }
    return 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticKeyboardEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticKeyboardEvent, KeyboardEventInterface);

module.exports = SyntheticKeyboardEvent;
},{"./SyntheticUIEvent":817,"./getEventCharCode":829,"./getEventKey":830,"./getEventModifierState":831}],814:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var SyntheticUIEvent = require('./SyntheticUIEvent');
var ViewportMetrics = require('./ViewportMetrics');

var getEventModifierState = require('./getEventModifierState');

/**
 * @interface MouseEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var MouseEventInterface = {
  screenX: null,
  screenY: null,
  clientX: null,
  clientY: null,
  ctrlKey: null,
  shiftKey: null,
  altKey: null,
  metaKey: null,
  getModifierState: getEventModifierState,
  button: function (event) {
    // Webkit, Firefox, IE9+
    // which:  1 2 3
    // button: 0 1 2 (standard)
    var button = event.button;
    if ('which' in event) {
      return button;
    }
    // IE<9
    // which:  undefined
    // button: 0 0 0
    // button: 1 4 2 (onmouseup)
    return button === 2 ? 2 : button === 4 ? 1 : 0;
  },
  buttons: null,
  relatedTarget: function (event) {
    return event.relatedTarget || (event.fromElement === event.srcElement ? event.toElement : event.fromElement);
  },
  // "Proprietary" Interface.
  pageX: function (event) {
    return 'pageX' in event ? event.pageX : event.clientX + ViewportMetrics.currentScrollLeft;
  },
  pageY: function (event) {
    return 'pageY' in event ? event.pageY : event.clientY + ViewportMetrics.currentScrollTop;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticMouseEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticMouseEvent, MouseEventInterface);

module.exports = SyntheticMouseEvent;
},{"./SyntheticUIEvent":817,"./ViewportMetrics":820,"./getEventModifierState":831}],815:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var SyntheticUIEvent = require('./SyntheticUIEvent');

var getEventModifierState = require('./getEventModifierState');

/**
 * @interface TouchEvent
 * @see http://www.w3.org/TR/touch-events/
 */
var TouchEventInterface = {
  touches: null,
  targetTouches: null,
  changedTouches: null,
  altKey: null,
  metaKey: null,
  ctrlKey: null,
  shiftKey: null,
  getModifierState: getEventModifierState
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticUIEvent}
 */
function SyntheticTouchEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticUIEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticUIEvent.augmentClass(SyntheticTouchEvent, TouchEventInterface);

module.exports = SyntheticTouchEvent;
},{"./SyntheticUIEvent":817,"./getEventModifierState":831}],816:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var SyntheticEvent = require('./SyntheticEvent');

/**
 * @interface Event
 * @see http://www.w3.org/TR/2009/WD-css3-transitions-20090320/#transition-events-
 * @see https://developer.mozilla.org/en-US/docs/Web/API/TransitionEvent
 */
var TransitionEventInterface = {
  propertyName: null,
  elapsedTime: null,
  pseudoElement: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticTransitionEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticTransitionEvent, TransitionEventInterface);

module.exports = SyntheticTransitionEvent;
},{"./SyntheticEvent":810}],817:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var SyntheticEvent = require('./SyntheticEvent');

var getEventTarget = require('./getEventTarget');

/**
 * @interface UIEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var UIEventInterface = {
  view: function (event) {
    if (event.view) {
      return event.view;
    }

    var target = getEventTarget(event);
    if (target.window === target) {
      // target is a window object
      return target;
    }

    var doc = target.ownerDocument;
    // TODO: Figure out why `ownerDocument` is sometimes undefined in IE8.
    if (doc) {
      return doc.defaultView || doc.parentWindow;
    } else {
      return window;
    }
  },
  detail: function (event) {
    return event.detail || 0;
  }
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticEvent}
 */
function SyntheticUIEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticEvent.augmentClass(SyntheticUIEvent, UIEventInterface);

module.exports = SyntheticUIEvent;
},{"./SyntheticEvent":810,"./getEventTarget":832}],818:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var SyntheticMouseEvent = require('./SyntheticMouseEvent');

/**
 * @interface WheelEvent
 * @see http://www.w3.org/TR/DOM-Level-3-Events/
 */
var WheelEventInterface = {
  deltaX: function (event) {
    return 'deltaX' in event ? event.deltaX :
    // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
    'wheelDeltaX' in event ? -event.wheelDeltaX : 0;
  },
  deltaY: function (event) {
    return 'deltaY' in event ? event.deltaY :
    // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
    'wheelDeltaY' in event ? -event.wheelDeltaY :
    // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
    'wheelDelta' in event ? -event.wheelDelta : 0;
  },
  deltaZ: null,

  // Browsers without "deltaMode" is reporting in raw wheel delta where one
  // notch on the scroll is always +/- 120, roughly equivalent to pixels.
  // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
  // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
  deltaMode: null
};

/**
 * @param {object} dispatchConfig Configuration used to dispatch this event.
 * @param {string} dispatchMarker Marker identifying the event target.
 * @param {object} nativeEvent Native browser event.
 * @extends {SyntheticMouseEvent}
 */
function SyntheticWheelEvent(dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget) {
  return SyntheticMouseEvent.call(this, dispatchConfig, dispatchMarker, nativeEvent, nativeEventTarget);
}

SyntheticMouseEvent.augmentClass(SyntheticWheelEvent, WheelEventInterface);

module.exports = SyntheticWheelEvent;
},{"./SyntheticMouseEvent":814}],819:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var invariant = require('fbjs/lib/invariant');

var OBSERVED_ERROR = {};

/**
 * `Transaction` creates a black box that is able to wrap any method such that
 * certain invariants are maintained before and after the method is invoked
 * (Even if an exception is thrown while invoking the wrapped method). Whoever
 * instantiates a transaction can provide enforcers of the invariants at
 * creation time. The `Transaction` class itself will supply one additional
 * automatic invariant for you - the invariant that any transaction instance
 * should not be run while it is already being run. You would typically create a
 * single instance of a `Transaction` for reuse multiple times, that potentially
 * is used to wrap several different methods. Wrappers are extremely simple -
 * they only require implementing two methods.
 *
 * <pre>
 *                       wrappers (injected at creation time)
 *                                      +        +
 *                                      |        |
 *                    +-----------------|--------|--------------+
 *                    |                 v        |              |
 *                    |      +---------------+   |              |
 *                    |   +--|    wrapper1   |---|----+         |
 *                    |   |  +---------------+   v    |         |
 *                    |   |          +-------------+  |         |
 *                    |   |     +----|   wrapper2  |--------+   |
 *                    |   |     |    +-------------+  |     |   |
 *                    |   |     |                     |     |   |
 *                    |   v     v                     v     v   | wrapper
 *                    | +---+ +---+   +---------+   +---+ +---+ | invariants
 * perform(anyMethod) | |   | |   |   |         |   |   | |   | | maintained
 * +----------------->|-|---|-|---|-->|anyMethod|---|---|-|---|-|-------->
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | |   | |   |   |         |   |   | |   | |
 *                    | +---+ +---+   +---------+   +---+ +---+ |
 *                    |  initialize                    close    |
 *                    +-----------------------------------------+
 * </pre>
 *
 * Use cases:
 * - Preserving the input selection ranges before/after reconciliation.
 *   Restoring selection even in the event of an unexpected error.
 * - Deactivating events while rearranging the DOM, preventing blurs/focuses,
 *   while guaranteeing that afterwards, the event system is reactivated.
 * - Flushing a queue of collected DOM mutations to the main UI thread after a
 *   reconciliation takes place in a worker thread.
 * - Invoking any collected `componentDidUpdate` callbacks after rendering new
 *   content.
 * - (Future use case): Wrapping particular flushes of the `ReactWorker` queue
 *   to preserve the `scrollTop` (an automatic scroll aware DOM).
 * - (Future use case): Layout calculations before and after DOM updates.
 *
 * Transactional plugin API:
 * - A module that has an `initialize` method that returns any precomputation.
 * - and a `close` method that accepts the precomputation. `close` is invoked
 *   when the wrapped process is completed, or has failed.
 *
 * @param {Array<TransactionalWrapper>} transactionWrapper Wrapper modules
 * that implement `initialize` and `close`.
 * @return {Transaction} Single transaction for reuse in thread.
 *
 * @class Transaction
 */
var TransactionImpl = {
  /**
   * Sets up this instance so that it is prepared for collecting metrics. Does
   * so such that this setup method may be used on an instance that is already
   * initialized, in a way that does not consume additional memory upon reuse.
   * That can be useful if you decide to make your subclass of this mixin a
   * "PooledClass".
   */
  reinitializeTransaction: function () {
    this.transactionWrappers = this.getTransactionWrappers();
    if (this.wrapperInitData) {
      this.wrapperInitData.length = 0;
    } else {
      this.wrapperInitData = [];
    }
    this._isInTransaction = false;
  },

  _isInTransaction: false,

  /**
   * @abstract
   * @return {Array<TransactionWrapper>} Array of transaction wrappers.
   */
  getTransactionWrappers: null,

  isInTransaction: function () {
    return !!this._isInTransaction;
  },

  /**
   * Executes the function within a safety window. Use this for the top level
   * methods that result in large amounts of computation/mutations that would
   * need to be safety checked. The optional arguments helps prevent the need
   * to bind in many cases.
   *
   * @param {function} method Member of scope to call.
   * @param {Object} scope Scope to invoke from.
   * @param {Object?=} a Argument to pass to the method.
   * @param {Object?=} b Argument to pass to the method.
   * @param {Object?=} c Argument to pass to the method.
   * @param {Object?=} d Argument to pass to the method.
   * @param {Object?=} e Argument to pass to the method.
   * @param {Object?=} f Argument to pass to the method.
   *
   * @return {*} Return value from `method`.
   */
  perform: function (method, scope, a, b, c, d, e, f) {
    !!this.isInTransaction() ? _prodInvariant('27') : void 0;
    var errorThrown;
    var ret;
    try {
      this._isInTransaction = true;
      // Catching errors makes debugging more difficult, so we start with
      // errorThrown set to true before setting it to false after calling
      // close -- if it's still set to true in the finally block, it means
      // one of these calls threw.
      errorThrown = true;
      this.initializeAll(0);
      ret = method.call(scope, a, b, c, d, e, f);
      errorThrown = false;
    } finally {
      try {
        if (errorThrown) {
          // If `method` throws, prefer to show that stack trace over any thrown
          // by invoking `closeAll`.
          try {
            this.closeAll(0);
          } catch (err) {}
        } else {
          // Since `method` didn't throw, we don't want to silence the exception
          // here.
          this.closeAll(0);
        }
      } finally {
        this._isInTransaction = false;
      }
    }
    return ret;
  },

  initializeAll: function (startIndex) {
    var transactionWrappers = this.transactionWrappers;
    for (var i = startIndex; i < transactionWrappers.length; i++) {
      var wrapper = transactionWrappers[i];
      try {
        // Catching errors makes debugging more difficult, so we start with the
        // OBSERVED_ERROR state before overwriting it with the real return value
        // of initialize -- if it's still set to OBSERVED_ERROR in the finally
        // block, it means wrapper.initialize threw.
        this.wrapperInitData[i] = OBSERVED_ERROR;
        this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null;
      } finally {
        if (this.wrapperInitData[i] === OBSERVED_ERROR) {
          // The initializer for wrapper i threw an error; initialize the
          // remaining wrappers but silence any exceptions from them to ensure
          // that the first error is the one to bubble up.
          try {
            this.initializeAll(i + 1);
          } catch (err) {}
        }
      }
    }
  },

  /**
   * Invokes each of `this.transactionWrappers.close[i]` functions, passing into
   * them the respective return values of `this.transactionWrappers.init[i]`
   * (`close`rs that correspond to initializers that failed will not be
   * invoked).
   */
  closeAll: function (startIndex) {
    !this.isInTransaction() ? _prodInvariant('28') : void 0;
    var transactionWrappers = this.transactionWrappers;
    for (var i = startIndex; i < transactionWrappers.length; i++) {
      var wrapper = transactionWrappers[i];
      var initData = this.wrapperInitData[i];
      var errorThrown;
      try {
        // Catching errors makes debugging more difficult, so we start with
        // errorThrown set to true before setting it to false after calling
        // close -- if it's still set to true in the finally block, it means
        // wrapper.close threw.
        errorThrown = true;
        if (initData !== OBSERVED_ERROR && wrapper.close) {
          wrapper.close.call(this, initData);
        }
        errorThrown = false;
      } finally {
        if (errorThrown) {
          // The closer for wrapper i threw an error; close the remaining
          // wrappers but silence any exceptions from them to ensure that the
          // first error is the one to bubble up.
          try {
            this.closeAll(i + 1);
          } catch (e) {}
        }
      }
    }
    this.wrapperInitData.length = 0;
  }
};

module.exports = TransactionImpl;
},{"./reactProdInvariant":843,"fbjs/lib/invariant":602}],820:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ViewportMetrics = {

  currentScrollLeft: 0,

  currentScrollTop: 0,

  refreshScrollValues: function (scrollPosition) {
    ViewportMetrics.currentScrollLeft = scrollPosition.x;
    ViewportMetrics.currentScrollTop = scrollPosition.y;
  }

};

module.exports = ViewportMetrics;
},{}],821:[function(require,module,exports){
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var invariant = require('fbjs/lib/invariant');

/**
 * Accumulates items that must not be null or undefined into the first one. This
 * is used to conserve memory by avoiding array allocations, and thus sacrifices
 * API cleanness. Since `current` can be null before being passed in and not
 * null after this function, make sure to assign it back to `current`:
 *
 * `a = accumulateInto(a, b);`
 *
 * This API should be sparingly used. Try `accumulate` for something cleaner.
 *
 * @return {*|array<*>} An accumulation of items.
 */

function accumulateInto(current, next) {
  !(next != null) ? _prodInvariant('30') : void 0;

  if (current == null) {
    return next;
  }

  // Both are not empty. Warning: Never call x.concat(y) when you are not
  // certain that x is an Array (x could be a string with concat method).
  if (Array.isArray(current)) {
    if (Array.isArray(next)) {
      current.push.apply(current, next);
      return current;
    }
    current.push(next);
    return current;
  }

  if (Array.isArray(next)) {
    // A bit too dangerous to mutate `next`.
    return [current].concat(next);
  }

  return [current, next];
}

module.exports = accumulateInto;
},{"./reactProdInvariant":843,"fbjs/lib/invariant":602}],822:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var MOD = 65521;

// adler32 is not cryptographically strong, and is only used to sanity check that
// markup generated on the server matches the markup generated on the client.
// This implementation (a modified version of the SheetJS version) has been optimized
// for our use case, at the expense of conforming to the adler32 specification
// for non-ascii inputs.
function adler32(data) {
  var a = 1;
  var b = 0;
  var i = 0;
  var l = data.length;
  var m = l & ~0x3;
  while (i < m) {
    var n = Math.min(i + 4096, m);
    for (; i < n; i += 4) {
      b += (a += data.charCodeAt(i)) + (a += data.charCodeAt(i + 1)) + (a += data.charCodeAt(i + 2)) + (a += data.charCodeAt(i + 3));
    }
    a %= MOD;
    b %= MOD;
  }
  for (; i < l; i++) {
    b += a += data.charCodeAt(i);
  }
  a %= MOD;
  b %= MOD;
  return a | b << 16;
}

module.exports = adler32;
},{}],823:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

/* globals MSApp */

'use strict';

/**
 * Create a function which has 'unsafe' privileges (required by windows8 apps)
 */

var createMicrosoftUnsafeLocalFunction = function (func) {
  if (typeof MSApp !== 'undefined' && MSApp.execUnsafeLocalFunction) {
    return function (arg0, arg1, arg2, arg3) {
      MSApp.execUnsafeLocalFunction(function () {
        return func(arg0, arg1, arg2, arg3);
      });
    };
  } else {
    return func;
  }
};

module.exports = createMicrosoftUnsafeLocalFunction;
},{}],824:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var CSSProperty = require('./CSSProperty');
var warning = require('fbjs/lib/warning');

var isUnitlessNumber = CSSProperty.isUnitlessNumber;
var styleWarnings = {};

/**
 * Convert a value into the proper css writable value. The style name `name`
 * should be logical (no hyphens), as specified
 * in `CSSProperty.isUnitlessNumber`.
 *
 * @param {string} name CSS property name such as `topMargin`.
 * @param {*} value CSS property value such as `10px`.
 * @param {ReactDOMComponent} component
 * @return {string} Normalized style value with dimensions applied.
 */
function dangerousStyleValue(name, value, component) {
  // Note that we've removed escapeTextForBrowser() calls here since the
  // whole string will be escaped when the attribute is injected into
  // the markup. If you provide unsafe user data here they can inject
  // arbitrary CSS which may be problematic (I couldn't repro this):
  // https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet
  // http://www.thespanner.co.uk/2007/11/26/ultimate-xss-css-injection/
  // This is not an XSS hole but instead a potential CSS injection issue
  // which has lead to a greater discussion about how we're going to
  // trust URLs moving forward. See #2115901

  var isEmpty = value == null || typeof value === 'boolean' || value === '';
  if (isEmpty) {
    return '';
  }

  var isNonNumeric = isNaN(value);
  if (isNonNumeric || value === 0 || isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name]) {
    return '' + value; // cast to string
  }

  if (typeof value === 'string') {
    value = value.trim();
  }
  return value + 'px';
}

module.exports = dangerousStyleValue;
},{"./CSSProperty":735,"fbjs/lib/warning":607}],825:[function(require,module,exports){
/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * Based on the escape-html library, which is used under the MIT License below:
 *
 * Copyright (c) 2012-2013 TJ Holowaychuk
 * Copyright (c) 2015 Andreas Lubbe
 * Copyright (c) 2015 Tiancheng "Timothy" Gu
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * 'Software'), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
 * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
 * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */

'use strict';

// code copied and modified from escape-html
/**
 * Module variables.
 * @private
 */

var matchHtmlRegExp = /["'&<>]/;

/**
 * Escape special characters in the given string of html.
 *
 * @param  {string} string The string to escape for inserting into HTML
 * @return {string}
 * @public
 */

function escapeHtml(string) {
  var str = '' + string;
  var match = matchHtmlRegExp.exec(str);

  if (!match) {
    return str;
  }

  var escape;
  var html = '';
  var index = 0;
  var lastIndex = 0;

  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34:
        // "
        escape = '&quot;';
        break;
      case 38:
        // &
        escape = '&amp;';
        break;
      case 39:
        // '
        escape = '&#x27;'; // modified from escape-html; used to be '&#39'
        break;
      case 60:
        // <
        escape = '&lt;';
        break;
      case 62:
        // >
        escape = '&gt;';
        break;
      default:
        continue;
    }

    if (lastIndex !== index) {
      html += str.substring(lastIndex, index);
    }

    lastIndex = index + 1;
    html += escape;
  }

  return lastIndex !== index ? html + str.substring(lastIndex, index) : html;
}
// end code copied and modified from escape-html


/**
 * Escapes text to prevent scripting attacks.
 *
 * @param {*} text Text value to escape.
 * @return {string} An escaped string.
 */
function escapeTextContentForBrowser(text) {
  if (typeof text === 'boolean' || typeof text === 'number') {
    // this shortcircuit helps perf for types that we know will never have
    // special characters, especially given that this function is used often
    // for numeric dom ids.
    return '' + text;
  }
  return escapeHtml(text);
}

module.exports = escapeTextContentForBrowser;
},{}],826:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactCurrentOwner = require('react/lib/ReactCurrentOwner');
var ReactDOMComponentTree = require('./ReactDOMComponentTree');
var ReactInstanceMap = require('./ReactInstanceMap');

var getHostComponentFromComposite = require('./getHostComponentFromComposite');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

/**
 * Returns the DOM node rendered by this element.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#reactdom.finddomnode
 *
 * @param {ReactComponent|DOMElement} componentOrElement
 * @return {?DOMElement} The root node of this element.
 */
function findDOMNode(componentOrElement) {
  if (componentOrElement == null) {
    return null;
  }
  if (componentOrElement.nodeType === 1) {
    return componentOrElement;
  }

  var inst = ReactInstanceMap.get(componentOrElement);
  if (inst) {
    inst = getHostComponentFromComposite(inst);
    return inst ? ReactDOMComponentTree.getNodeFromInstance(inst) : null;
  }

  if (typeof componentOrElement.render === 'function') {
    _prodInvariant('44');
  } else {
    _prodInvariant('45', Object.keys(componentOrElement));
  }
}

module.exports = findDOMNode;
},{"./ReactDOMComponentTree":764,"./ReactInstanceMap":787,"./getHostComponentFromComposite":833,"./reactProdInvariant":843,"fbjs/lib/invariant":602,"fbjs/lib/warning":607,"react/lib/ReactCurrentOwner":860}],827:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var KeyEscapeUtils = require('./KeyEscapeUtils');
var traverseAllChildren = require('./traverseAllChildren');
var warning = require('fbjs/lib/warning');

var ReactComponentTreeHook;

if (typeof process !== 'undefined' && process.env && "production" === 'test') {
  // Temporary hack.
  // Inline requires don't work well with Jest:
  // https://github.com/facebook/react/issues/7240
  // Remove the inline requires when we don't need them anymore:
  // https://github.com/facebook/react/pull/7178
  ReactComponentTreeHook = require('react/lib/ReactComponentTreeHook');
}

/**
 * @param {function} traverseContext Context passed through traversal.
 * @param {?ReactComponent} child React child component.
 * @param {!string} name String name of key path to child.
 * @param {number=} selfDebugID Optional debugID of the current internal instance.
 */
function flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID) {
  // We found a component instance.
  if (traverseContext && typeof traverseContext === 'object') {
    var result = traverseContext;
    var keyUnique = result[name] === undefined;
    if (keyUnique && child != null) {
      result[name] = child;
    }
  }
}

/**
 * Flattens children that are typically specified as `props.children`. Any null
 * children will not be included in the resulting object.
 * @return {!object} flattened children keyed by name.
 */
function flattenChildren(children, selfDebugID) {
  if (children == null) {
    return children;
  }
  var result = {};

  {
    traverseAllChildren(children, flattenSingleChildIntoContext, result);
  }
  return result;
}

module.exports = flattenChildren;
}).call(this,require('_process'))
},{"./KeyEscapeUtils":753,"./traverseAllChildren":848,"_process":702,"fbjs/lib/warning":607,"react/lib/ReactComponentTreeHook":859}],828:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

/**
 * @param {array} arr an "accumulation" of items which is either an Array or
 * a single item. Useful when paired with the `accumulate` module. This is a
 * simple utility that allows us to reason about a collection of items, but
 * handling the case when there is exactly one item (and we do not need to
 * allocate an array).
 */

function forEachAccumulated(arr, cb, scope) {
  if (Array.isArray(arr)) {
    arr.forEach(cb, scope);
  } else if (arr) {
    cb.call(scope, arr);
  }
}

module.exports = forEachAccumulated;
},{}],829:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

/**
 * `charCode` represents the actual "character code" and is safe to use with
 * `String.fromCharCode`. As such, only keys that correspond to printable
 * characters produce a valid `charCode`, the only exception to this is Enter.
 * The Tab-key is considered non-printable and does not have a `charCode`,
 * presumably because it does not produce a tab-character in browsers.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {number} Normalized `charCode` property.
 */

function getEventCharCode(nativeEvent) {
  var charCode;
  var keyCode = nativeEvent.keyCode;

  if ('charCode' in nativeEvent) {
    charCode = nativeEvent.charCode;

    // FF does not set `charCode` for the Enter-key, check against `keyCode`.
    if (charCode === 0 && keyCode === 13) {
      charCode = 13;
    }
  } else {
    // IE8 does not implement `charCode`, but `keyCode` has the correct value.
    charCode = keyCode;
  }

  // Some non-printable keys are reported in `charCode`/`keyCode`, discard them.
  // Must not discard the (non-)printable Enter-key.
  if (charCode >= 32 || charCode === 13) {
    return charCode;
  }

  return 0;
}

module.exports = getEventCharCode;
},{}],830:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var getEventCharCode = require('./getEventCharCode');

/**
 * Normalization of deprecated HTML5 `key` values
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var normalizeKey = {
  'Esc': 'Escape',
  'Spacebar': ' ',
  'Left': 'ArrowLeft',
  'Up': 'ArrowUp',
  'Right': 'ArrowRight',
  'Down': 'ArrowDown',
  'Del': 'Delete',
  'Win': 'OS',
  'Menu': 'ContextMenu',
  'Apps': 'ContextMenu',
  'Scroll': 'ScrollLock',
  'MozPrintableKey': 'Unidentified'
};

/**
 * Translation from legacy `keyCode` to HTML5 `key`
 * Only special keys supported, all others depend on keyboard layout or browser
 * @see https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent#Key_names
 */
var translateToKey = {
  8: 'Backspace',
  9: 'Tab',
  12: 'Clear',
  13: 'Enter',
  16: 'Shift',
  17: 'Control',
  18: 'Alt',
  19: 'Pause',
  20: 'CapsLock',
  27: 'Escape',
  32: ' ',
  33: 'PageUp',
  34: 'PageDown',
  35: 'End',
  36: 'Home',
  37: 'ArrowLeft',
  38: 'ArrowUp',
  39: 'ArrowRight',
  40: 'ArrowDown',
  45: 'Insert',
  46: 'Delete',
  112: 'F1', 113: 'F2', 114: 'F3', 115: 'F4', 116: 'F5', 117: 'F6',
  118: 'F7', 119: 'F8', 120: 'F9', 121: 'F10', 122: 'F11', 123: 'F12',
  144: 'NumLock',
  145: 'ScrollLock',
  224: 'Meta'
};

/**
 * @param {object} nativeEvent Native browser event.
 * @return {string} Normalized `key` property.
 */
function getEventKey(nativeEvent) {
  if (nativeEvent.key) {
    // Normalize inconsistent values reported by browsers due to
    // implementations of a working draft specification.

    // FireFox implements `key` but returns `MozPrintableKey` for all
    // printable characters (normalized to `Unidentified`), ignore it.
    var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
    if (key !== 'Unidentified') {
      return key;
    }
  }

  // Browser does not implement `key`, polyfill as much of it as we can.
  if (nativeEvent.type === 'keypress') {
    var charCode = getEventCharCode(nativeEvent);

    // The enter-key is technically both printable and non-printable and can
    // thus be captured by `keypress`, no other non-printable key should.
    return charCode === 13 ? 'Enter' : String.fromCharCode(charCode);
  }
  if (nativeEvent.type === 'keydown' || nativeEvent.type === 'keyup') {
    // While user keyboard layout determines the actual meaning of each
    // `keyCode` value, almost all function keys have a universal value.
    return translateToKey[nativeEvent.keyCode] || 'Unidentified';
  }
  return '';
}

module.exports = getEventKey;
},{"./getEventCharCode":829}],831:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

/**
 * Translation from modifier key to the associated property in the event.
 * @see http://www.w3.org/TR/DOM-Level-3-Events/#keys-Modifiers
 */

var modifierKeyToProp = {
  'Alt': 'altKey',
  'Control': 'ctrlKey',
  'Meta': 'metaKey',
  'Shift': 'shiftKey'
};

// IE8 does not implement getModifierState so we simply map it to the only
// modifier keys exposed by the event itself, does not support Lock-keys.
// Currently, all major browsers except Chrome seems to support Lock-keys.
function modifierStateGetter(keyArg) {
  var syntheticEvent = this;
  var nativeEvent = syntheticEvent.nativeEvent;
  if (nativeEvent.getModifierState) {
    return nativeEvent.getModifierState(keyArg);
  }
  var keyProp = modifierKeyToProp[keyArg];
  return keyProp ? !!nativeEvent[keyProp] : false;
}

function getEventModifierState(nativeEvent) {
  return modifierStateGetter;
}

module.exports = getEventModifierState;
},{}],832:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

/**
 * Gets the target node from a native browser event by accounting for
 * inconsistencies in browser DOM APIs.
 *
 * @param {object} nativeEvent Native browser event.
 * @return {DOMEventTarget} Target node.
 */

function getEventTarget(nativeEvent) {
  var target = nativeEvent.target || nativeEvent.srcElement || window;

  // Normalize SVG <use> element events #4963
  if (target.correspondingUseElement) {
    target = target.correspondingUseElement;
  }

  // Safari may fire events on text nodes (Node.TEXT_NODE is 3).
  // @see http://www.quirksmode.org/js/events_properties.html
  return target.nodeType === 3 ? target.parentNode : target;
}

module.exports = getEventTarget;
},{}],833:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ReactNodeTypes = require('./ReactNodeTypes');

function getHostComponentFromComposite(inst) {
  var type;

  while ((type = inst._renderedNodeType) === ReactNodeTypes.COMPOSITE) {
    inst = inst._renderedComponent;
  }

  if (type === ReactNodeTypes.HOST) {
    return inst._renderedComponent;
  } else if (type === ReactNodeTypes.EMPTY) {
    return null;
  }
}

module.exports = getHostComponentFromComposite;
},{"./ReactNodeTypes":792}],834:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

/* global Symbol */

var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

/**
 * Returns the iterator method function contained on the iterable object.
 *
 * Be sure to invoke the function with the iterable as context:
 *
 *     var iteratorFn = getIteratorFn(myIterable);
 *     if (iteratorFn) {
 *       var iterator = iteratorFn.call(myIterable);
 *       ...
 *     }
 *
 * @param {?object} maybeIterable
 * @return {?function}
 */
function getIteratorFn(maybeIterable) {
  var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
  if (typeof iteratorFn === 'function') {
    return iteratorFn;
  }
}

module.exports = getIteratorFn;
},{}],835:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var nextDebugID = 1;

function getNextDebugID() {
  return nextDebugID++;
}

module.exports = getNextDebugID;
},{}],836:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

/**
 * Given any node return the first leaf node without children.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {DOMElement|DOMTextNode}
 */

function getLeafNode(node) {
  while (node && node.firstChild) {
    node = node.firstChild;
  }
  return node;
}

/**
 * Get the next sibling within a container. This will walk up the
 * DOM if a node's siblings have been exhausted.
 *
 * @param {DOMElement|DOMTextNode} node
 * @return {?DOMElement|DOMTextNode}
 */
function getSiblingNode(node) {
  while (node) {
    if (node.nextSibling) {
      return node.nextSibling;
    }
    node = node.parentNode;
  }
}

/**
 * Get object describing the nodes which contain characters at offset.
 *
 * @param {DOMElement|DOMTextNode} root
 * @param {number} offset
 * @return {?object}
 */
function getNodeForCharacterOffset(root, offset) {
  var node = getLeafNode(root);
  var nodeStart = 0;
  var nodeEnd = 0;

  while (node) {
    if (node.nodeType === 3) {
      nodeEnd = nodeStart + node.textContent.length;

      if (nodeStart <= offset && nodeEnd >= offset) {
        return {
          node: node,
          offset: offset - nodeStart
        };
      }

      nodeStart = nodeEnd;
    }

    node = getLeafNode(getSiblingNode(node));
  }
}

module.exports = getNodeForCharacterOffset;
},{}],837:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var contentKey = null;

/**
 * Gets the key used to access text content on a DOM node.
 *
 * @return {?string} Key used to access text content.
 * @internal
 */
function getTextContentAccessor() {
  if (!contentKey && ExecutionEnvironment.canUseDOM) {
    // Prefer textContent to innerText because many browsers support both but
    // SVG <text> elements don't support innerText even when <div> does.
    contentKey = 'textContent' in document.documentElement ? 'textContent' : 'innerText';
  }
  return contentKey;
}

module.exports = getTextContentAccessor;
},{"fbjs/lib/ExecutionEnvironment":588}],838:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

/**
 * Generate a mapping of standard vendor prefixes using the defined style property and event name.
 *
 * @param {string} styleProp
 * @param {string} eventName
 * @returns {object}
 */
function makePrefixMap(styleProp, eventName) {
  var prefixes = {};

  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes['Webkit' + styleProp] = 'webkit' + eventName;
  prefixes['Moz' + styleProp] = 'moz' + eventName;
  prefixes['ms' + styleProp] = 'MS' + eventName;
  prefixes['O' + styleProp] = 'o' + eventName.toLowerCase();

  return prefixes;
}

/**
 * A list of event names to a configurable list of vendor prefixes.
 */
var vendorPrefixes = {
  animationend: makePrefixMap('Animation', 'AnimationEnd'),
  animationiteration: makePrefixMap('Animation', 'AnimationIteration'),
  animationstart: makePrefixMap('Animation', 'AnimationStart'),
  transitionend: makePrefixMap('Transition', 'TransitionEnd')
};

/**
 * Event names that have already been detected and prefixed (if applicable).
 */
var prefixedEventNames = {};

/**
 * Element to check for prefixes on.
 */
var style = {};

/**
 * Bootstrap if a DOM exists.
 */
if (ExecutionEnvironment.canUseDOM) {
  style = document.createElement('div').style;

  // On some platforms, in particular some releases of Android 4.x,
  // the un-prefixed "animation" and "transition" properties are defined on the
  // style object but the events that fire will still be prefixed, so we need
  // to check if the un-prefixed events are usable, and if not remove them from the map.
  if (!('AnimationEvent' in window)) {
    delete vendorPrefixes.animationend.animation;
    delete vendorPrefixes.animationiteration.animation;
    delete vendorPrefixes.animationstart.animation;
  }

  // Same as above
  if (!('TransitionEvent' in window)) {
    delete vendorPrefixes.transitionend.transition;
  }
}

/**
 * Attempts to determine the correct vendor prefixed event name.
 *
 * @param {string} eventName
 * @returns {string}
 */
function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) {
    return prefixedEventNames[eventName];
  } else if (!vendorPrefixes[eventName]) {
    return eventName;
  }

  var prefixMap = vendorPrefixes[eventName];

  for (var styleProp in prefixMap) {
    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
      return prefixedEventNames[eventName] = prefixMap[styleProp];
    }
  }

  return '';
}

module.exports = getVendorPrefixedEventName;
},{"fbjs/lib/ExecutionEnvironment":588}],839:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant'),
    _assign = require('object-assign');

var ReactCompositeComponent = require('./ReactCompositeComponent');
var ReactEmptyComponent = require('./ReactEmptyComponent');
var ReactHostComponent = require('./ReactHostComponent');

var getNextDebugID = require('./getNextDebugID');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

// To avoid a cyclic dependency, we create the final class in this module
var ReactCompositeComponentWrapper = function (element) {
  this.construct(element);
};
_assign(ReactCompositeComponentWrapper.prototype, ReactCompositeComponent, {
  _instantiateReactComponent: instantiateReactComponent
});

function getDeclarationErrorAddendum(owner) {
  if (owner) {
    var name = owner.getName();
    if (name) {
      return ' Check the render method of `' + name + '`.';
    }
  }
  return '';
}

/**
 * Check if the type reference is a known internal type. I.e. not a user
 * provided composite type.
 *
 * @param {function} type
 * @return {boolean} Returns true if this is a valid internal type.
 */
function isInternalComponentType(type) {
  return typeof type === 'function' && typeof type.prototype !== 'undefined' && typeof type.prototype.mountComponent === 'function' && typeof type.prototype.receiveComponent === 'function';
}

/**
 * Given a ReactNode, create an instance that will actually be mounted.
 *
 * @param {ReactNode} node
 * @param {boolean} shouldHaveDebugID
 * @return {object} A new instance of the element's constructor.
 * @protected
 */
function instantiateReactComponent(node, shouldHaveDebugID) {
  var instance;

  if (node === null || node === false) {
    instance = ReactEmptyComponent.create(instantiateReactComponent);
  } else if (typeof node === 'object') {
    var element = node;
    !(element && (typeof element.type === 'function' || typeof element.type === 'string')) ? _prodInvariant('130', element.type == null ? element.type : typeof element.type, getDeclarationErrorAddendum(element._owner)) : void 0;

    // Special case string values
    if (typeof element.type === 'string') {
      instance = ReactHostComponent.createInternalComponent(element);
    } else if (isInternalComponentType(element.type)) {
      // This is temporarily available for custom components that are not string
      // representations. I.e. ART. Once those are updated to use the string
      // representation, we can drop this code path.
      instance = new element.type(element);

      // We renamed this. Allow the old name for compat. :(
      if (!instance.getHostNode) {
        instance.getHostNode = instance.getNativeNode;
      }
    } else {
      instance = new ReactCompositeComponentWrapper(element);
    }
  } else if (typeof node === 'string' || typeof node === 'number') {
    instance = ReactHostComponent.createInstanceForText(node);
  } else {
    _prodInvariant('131', typeof node);
  }

  // These two fields are used by the DOM and ART diffing algorithms
  // respectively. Instead of using expandos on components, we should be
  // storing the state needed by the diffing algorithms elsewhere.
  instance._mountIndex = 0;
  instance._mountImage = null;

  return instance;
}

module.exports = instantiateReactComponent;
},{"./ReactCompositeComponent":760,"./ReactEmptyComponent":779,"./ReactHostComponent":784,"./getNextDebugID":835,"./reactProdInvariant":843,"fbjs/lib/invariant":602,"fbjs/lib/warning":607,"object-assign":701}],840:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var useHasFeature;
if (ExecutionEnvironment.canUseDOM) {
  useHasFeature = document.implementation && document.implementation.hasFeature &&
  // always returns true in newer browsers as per the standard.
  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
  document.implementation.hasFeature('', '') !== true;
}

/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */
function isEventSupported(eventNameSuffix, capture) {
  if (!ExecutionEnvironment.canUseDOM || capture && !('addEventListener' in document)) {
    return false;
  }

  var eventName = 'on' + eventNameSuffix;
  var isSupported = eventName in document;

  if (!isSupported) {
    var element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
    // This is the only way to test support for the `wheel` event in IE9+.
    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
  }

  return isSupported;
}

module.exports = isEventSupported;
},{"fbjs/lib/ExecutionEnvironment":588}],841:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

/**
 * @see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary
 */

var supportedInputTypes = {
  'color': true,
  'date': true,
  'datetime': true,
  'datetime-local': true,
  'email': true,
  'month': true,
  'number': true,
  'password': true,
  'range': true,
  'search': true,
  'tel': true,
  'text': true,
  'time': true,
  'url': true,
  'week': true
};

function isTextInputElement(elem) {
  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();

  if (nodeName === 'input') {
    return !!supportedInputTypes[elem.type];
  }

  if (nodeName === 'textarea') {
    return true;
  }

  return false;
}

module.exports = isTextInputElement;
},{}],842:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var escapeTextContentForBrowser = require('./escapeTextContentForBrowser');

/**
 * Escapes attribute value to prevent scripting attacks.
 *
 * @param {*} value Value to escape.
 * @return {string} An escaped string.
 */
function quoteAttributeValueForBrowser(value) {
  return '"' + escapeTextContentForBrowser(value) + '"';
}

module.exports = quoteAttributeValueForBrowser;
},{"./escapeTextContentForBrowser":825}],843:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */
'use strict';

/**
 * WARNING: DO NOT manually require this module.
 * This is a replacement for `invariant(...)` used by the error code system
 * and will _only_ be required by the corresponding babel pass.
 * It always throws.
 */

function reactProdInvariant(code) {
  var argCount = arguments.length - 1;

  var message = 'Minified React error #' + code + '; visit ' + 'http://facebook.github.io/react/docs/error-decoder.html?invariant=' + code;

  for (var argIdx = 0; argIdx < argCount; argIdx++) {
    message += '&args[]=' + encodeURIComponent(arguments[argIdx + 1]);
  }

  message += ' for the full message or use the non-minified dev environment' + ' for full errors and additional helpful warnings.';

  var error = new Error(message);
  error.name = 'Invariant Violation';
  error.framesToPop = 1; // we don't care about reactProdInvariant's own frame

  throw error;
}

module.exports = reactProdInvariant;
},{}],844:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ReactMount = require('./ReactMount');

module.exports = ReactMount.renderSubtreeIntoContainer;
},{"./ReactMount":790}],845:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var DOMNamespaces = require('./DOMNamespaces');

var WHITESPACE_TEST = /^[ \r\n\t\f]/;
var NONVISIBLE_TEST = /<(!--|link|noscript|meta|script|style)[ \r\n\t\f\/>]/;

var createMicrosoftUnsafeLocalFunction = require('./createMicrosoftUnsafeLocalFunction');

// SVG temp container for IE lacking innerHTML
var reusableSVGContainer;

/**
 * Set the innerHTML property of a node, ensuring that whitespace is preserved
 * even in IE8.
 *
 * @param {DOMElement} node
 * @param {string} html
 * @internal
 */
var setInnerHTML = createMicrosoftUnsafeLocalFunction(function (node, html) {
  // IE does not have innerHTML for SVG nodes, so instead we inject the
  // new markup in a temp node and then move the child nodes across into
  // the target node
  if (node.namespaceURI === DOMNamespaces.svg && !('innerHTML' in node)) {
    reusableSVGContainer = reusableSVGContainer || document.createElement('div');
    reusableSVGContainer.innerHTML = '<svg>' + html + '</svg>';
    var svgNode = reusableSVGContainer.firstChild;
    while (svgNode.firstChild) {
      node.appendChild(svgNode.firstChild);
    }
  } else {
    node.innerHTML = html;
  }
});

if (ExecutionEnvironment.canUseDOM) {
  // IE8: When updating a just created node with innerHTML only leading
  // whitespace is removed. When updating an existing node with innerHTML
  // whitespace in root TextNodes is also collapsed.
  // @see quirksmode.org/bugreports/archives/2004/11/innerhtml_and_t.html

  // Feature detection; only IE8 is known to behave improperly like this.
  var testElement = document.createElement('div');
  testElement.innerHTML = ' ';
  if (testElement.innerHTML === '') {
    setInnerHTML = function (node, html) {
      // Magic theory: IE8 supposedly differentiates between added and updated
      // nodes when processing innerHTML, innerHTML on updated nodes suffers
      // from worse whitespace behavior. Re-adding a node like this triggers
      // the initial and more favorable whitespace behavior.
      // TODO: What to do on a detached node?
      if (node.parentNode) {
        node.parentNode.replaceChild(node, node);
      }

      // We also implement a workaround for non-visible tags disappearing into
      // thin air on IE8, this only happens if there is no visible text
      // in-front of the non-visible tags. Piggyback on the whitespace fix
      // and simply check if any non-visible tags appear in the source.
      if (WHITESPACE_TEST.test(html) || html[0] === '<' && NONVISIBLE_TEST.test(html)) {
        // Recover leading whitespace by temporarily prepending any character.
        // \uFEFF has the potential advantage of being zero-width/invisible.
        // UglifyJS drops U+FEFF chars when parsing, so use String.fromCharCode
        // in hopes that this is preserved even if "\uFEFF" is transformed to
        // the actual Unicode character (by Babel, for example).
        // https://github.com/mishoo/UglifyJS2/blob/v2.4.20/lib/parse.js#L216
        node.innerHTML = String.fromCharCode(0xFEFF) + html;

        // deleteData leaves an empty `TextNode` which offsets the index of all
        // children. Definitely want to avoid this.
        var textNode = node.firstChild;
        if (textNode.data.length === 1) {
          node.removeChild(textNode);
        } else {
          textNode.deleteData(0, 1);
        }
      } else {
        node.innerHTML = html;
      }
    };
  }
  testElement = null;
}

module.exports = setInnerHTML;
},{"./DOMNamespaces":741,"./createMicrosoftUnsafeLocalFunction":823,"fbjs/lib/ExecutionEnvironment":588}],846:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');
var escapeTextContentForBrowser = require('./escapeTextContentForBrowser');
var setInnerHTML = require('./setInnerHTML');

/**
 * Set the textContent property of a node, ensuring that whitespace is preserved
 * even in IE8. innerText is a poor substitute for textContent and, among many
 * issues, inserts <br> instead of the literal newline chars. innerHTML behaves
 * as it should.
 *
 * @param {DOMElement} node
 * @param {string} text
 * @internal
 */
var setTextContent = function (node, text) {
  if (text) {
    var firstChild = node.firstChild;

    if (firstChild && firstChild === node.lastChild && firstChild.nodeType === 3) {
      firstChild.nodeValue = text;
      return;
    }
  }
  node.textContent = text;
};

if (ExecutionEnvironment.canUseDOM) {
  if (!('textContent' in document.documentElement)) {
    setTextContent = function (node, text) {
      if (node.nodeType === 3) {
        node.nodeValue = text;
        return;
      }
      setInnerHTML(node, escapeTextContentForBrowser(text));
    };
  }
}

module.exports = setTextContent;
},{"./escapeTextContentForBrowser":825,"./setInnerHTML":845,"fbjs/lib/ExecutionEnvironment":588}],847:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

/**
 * Given a `prevElement` and `nextElement`, determines if the existing
 * instance should be updated as opposed to being destroyed or replaced by a new
 * instance. Both arguments are elements. This ensures that this logic can
 * operate on stateless trees without any backing instance.
 *
 * @param {?object} prevElement
 * @param {?object} nextElement
 * @return {boolean} True if the existing instance should be updated.
 * @protected
 */

function shouldUpdateReactComponent(prevElement, nextElement) {
  var prevEmpty = prevElement === null || prevElement === false;
  var nextEmpty = nextElement === null || nextElement === false;
  if (prevEmpty || nextEmpty) {
    return prevEmpty === nextEmpty;
  }

  var prevType = typeof prevElement;
  var nextType = typeof nextElement;
  if (prevType === 'string' || prevType === 'number') {
    return nextType === 'string' || nextType === 'number';
  } else {
    return nextType === 'object' && prevElement.type === nextElement.type && prevElement.key === nextElement.key;
  }
}

module.exports = shouldUpdateReactComponent;
},{}],848:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactCurrentOwner = require('react/lib/ReactCurrentOwner');
var REACT_ELEMENT_TYPE = require('./ReactElementSymbol');

var getIteratorFn = require('./getIteratorFn');
var invariant = require('fbjs/lib/invariant');
var KeyEscapeUtils = require('./KeyEscapeUtils');
var warning = require('fbjs/lib/warning');

var SEPARATOR = '.';
var SUBSEPARATOR = ':';

/**
 * This is inlined from ReactElement since this file is shared between
 * isomorphic and renderers. We could extract this to a
 *
 */

/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */

var didWarnAboutMaps = false;

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey(component, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (component && typeof component === 'object' && component.key != null) {
    // Explicit key
    return KeyEscapeUtils.escape(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  if (children === null || type === 'string' || type === 'number' ||
  // The following is inlined from ReactElement. This means we can optimize
  // some checks. React Fiber also inlines this logic for similar purposes.
  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
    callback(traverseContext, children,
    // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.
  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn(children);
    if (iteratorFn) {
      var iterator = iteratorFn.call(children);
      var step;
      if (iteratorFn !== children.entries) {
        var ii = 0;
        while (!(step = iterator.next()).done) {
          child = step.value;
          nextName = nextNamePrefix + getComponentKey(child, ii++);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        // Iterator will provide entry [k,v] tuples rather than values.
        while (!(step = iterator.next()).done) {
          var entry = step.value;
          if (entry) {
            child = entry[1];
            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        }
      }
    } else if (type === 'object') {
      var addendum = '';
      var childrenString = String(children);
      _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);
    }
  }

  return subtreeCount;
}

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}

module.exports = traverseAllChildren;
},{"./KeyEscapeUtils":753,"./ReactElementSymbol":778,"./getIteratorFn":834,"./reactProdInvariant":843,"fbjs/lib/invariant":602,"fbjs/lib/warning":607,"react/lib/ReactCurrentOwner":860}],849:[function(require,module,exports){
/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

var emptyFunction = require('fbjs/lib/emptyFunction');
var warning = require('fbjs/lib/warning');

var validateDOMNesting = emptyFunction;

module.exports = validateDOMNesting;
},{"fbjs/lib/emptyFunction":594,"fbjs/lib/warning":607,"object-assign":701}],850:[function(require,module,exports){
arguments[4][753][0].apply(exports,arguments)
},{"dup":753}],851:[function(require,module,exports){
arguments[4][755][0].apply(exports,arguments)
},{"./reactProdInvariant":877,"dup":755,"fbjs/lib/invariant":602}],852:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

var ReactChildren = require('./ReactChildren');
var ReactComponent = require('./ReactComponent');
var ReactPureComponent = require('./ReactPureComponent');
var ReactClass = require('./ReactClass');
var ReactDOMFactories = require('./ReactDOMFactories');
var ReactElement = require('./ReactElement');
var ReactPropTypes = require('./ReactPropTypes');
var ReactVersion = require('./ReactVersion');

var onlyChild = require('./onlyChild');
var warning = require('fbjs/lib/warning');

var createElement = ReactElement.createElement;
var createFactory = ReactElement.createFactory;
var cloneElement = ReactElement.cloneElement;

var __spread = _assign;

var React = {

  // Modern

  Children: {
    map: ReactChildren.map,
    forEach: ReactChildren.forEach,
    count: ReactChildren.count,
    toArray: ReactChildren.toArray,
    only: onlyChild
  },

  Component: ReactComponent,
  PureComponent: ReactPureComponent,

  createElement: createElement,
  cloneElement: cloneElement,
  isValidElement: ReactElement.isValidElement,

  // Classic

  PropTypes: ReactPropTypes,
  createClass: ReactClass.createClass,
  createFactory: createFactory,
  createMixin: function (mixin) {
    // Currently a noop. Will be used to validate and trace mixins.
    return mixin;
  },

  // This looks DOM specific but these are actually isomorphic helpers
  // since they are just generating DOM strings.
  DOM: ReactDOMFactories,

  version: ReactVersion,

  // Deprecated hook for JSX spread, don't use this for anything.
  __spread: __spread
};

module.exports = React;
},{"./ReactChildren":856,"./ReactClass":857,"./ReactComponent":858,"./ReactDOMFactories":861,"./ReactElement":862,"./ReactPropTypes":866,"./ReactPureComponent":868,"./ReactVersion":872,"./onlyChild":876,"fbjs/lib/warning":607,"object-assign":701}],853:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ReactDOM = require('react-dom/lib/ReactDOM');
var ReactInstanceMap = require('react-dom/lib/ReactInstanceMap');

exports.getReactDOM = function () {
  return ReactDOM;
};

exports.getReactInstanceMap = function () {
  return ReactInstanceMap;
};
},{"react-dom/lib/ReactDOM":761,"react-dom/lib/ReactInstanceMap":787}],854:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var React = require('./React');

var ReactTransitionGroup = require('./ReactTransitionGroup');
var ReactCSSTransitionGroupChild = require('./ReactCSSTransitionGroupChild');

function createTransitionTimeoutPropValidator(transitionType) {
  var timeoutPropName = 'transition' + transitionType + 'Timeout';
  var enabledPropName = 'transition' + transitionType;

  return function (props) {
    // If the transition is enabled
    if (props[enabledPropName]) {
      // If no timeout duration is provided
      if (props[timeoutPropName] == null) {
        return new Error(timeoutPropName + ' wasn\'t supplied to ReactCSSTransitionGroup: ' + 'this can cause unreliable animations and won\'t be supported in ' + 'a future version of React. See ' + 'https://fb.me/react-animation-transition-group-timeout for more ' + 'information.');

        // If the duration isn't a number
      } else if (typeof props[timeoutPropName] !== 'number') {
        return new Error(timeoutPropName + ' must be a number (in milliseconds)');
      }
    }
  };
}

/**
 * An easy way to perform CSS transitions and animations when a React component
 * enters or leaves the DOM.
 * See https://facebook.github.io/react/docs/animation.html#high-level-api-reactcsstransitiongroup
 */

var ReactCSSTransitionGroup = function (_React$Component) {
  _inherits(ReactCSSTransitionGroup, _React$Component);

  function ReactCSSTransitionGroup() {
    var _temp, _this, _ret;

    _classCallCheck(this, ReactCSSTransitionGroup);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this._wrapChild = function (child) {
      // We need to provide this childFactory so that
      // ReactCSSTransitionGroupChild can receive updates to name, enter, and
      // leave while it is leaving.
      return React.createElement(ReactCSSTransitionGroupChild, {
        name: _this.props.transitionName,
        appear: _this.props.transitionAppear,
        enter: _this.props.transitionEnter,
        leave: _this.props.transitionLeave,
        appearTimeout: _this.props.transitionAppearTimeout,
        enterTimeout: _this.props.transitionEnterTimeout,
        leaveTimeout: _this.props.transitionLeaveTimeout
      }, child);
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  ReactCSSTransitionGroup.prototype.render = function render() {
    return React.createElement(ReactTransitionGroup, _assign({}, this.props, { childFactory: this._wrapChild }));
  };

  return ReactCSSTransitionGroup;
}(React.Component);

ReactCSSTransitionGroup.displayName = 'ReactCSSTransitionGroup';
ReactCSSTransitionGroup.propTypes = {
  transitionName: ReactCSSTransitionGroupChild.propTypes.name,

  transitionAppear: React.PropTypes.bool,
  transitionEnter: React.PropTypes.bool,
  transitionLeave: React.PropTypes.bool,
  transitionAppearTimeout: createTransitionTimeoutPropValidator('Appear'),
  transitionEnterTimeout: createTransitionTimeoutPropValidator('Enter'),
  transitionLeaveTimeout: createTransitionTimeoutPropValidator('Leave')
};
ReactCSSTransitionGroup.defaultProps = {
  transitionAppear: false,
  transitionEnter: true,
  transitionLeave: true
};


module.exports = ReactCSSTransitionGroup;
},{"./React":852,"./ReactCSSTransitionGroupChild":855,"./ReactTransitionGroup":871,"object-assign":701}],855:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var React = require('./React');
var ReactAddonsDOMDependencies = require('./ReactAddonsDOMDependencies');

var CSSCore = require('fbjs/lib/CSSCore');
var ReactTransitionEvents = require('./ReactTransitionEvents');

var onlyChild = require('./onlyChild');

var TICK = 17;

var ReactCSSTransitionGroupChild = React.createClass({
  displayName: 'ReactCSSTransitionGroupChild',

  propTypes: {
    name: React.PropTypes.oneOfType([React.PropTypes.string, React.PropTypes.shape({
      enter: React.PropTypes.string,
      leave: React.PropTypes.string,
      active: React.PropTypes.string
    }), React.PropTypes.shape({
      enter: React.PropTypes.string,
      enterActive: React.PropTypes.string,
      leave: React.PropTypes.string,
      leaveActive: React.PropTypes.string,
      appear: React.PropTypes.string,
      appearActive: React.PropTypes.string
    })]).isRequired,

    // Once we require timeouts to be specified, we can remove the
    // boolean flags (appear etc.) and just accept a number
    // or a bool for the timeout flags (appearTimeout etc.)
    appear: React.PropTypes.bool,
    enter: React.PropTypes.bool,
    leave: React.PropTypes.bool,
    appearTimeout: React.PropTypes.number,
    enterTimeout: React.PropTypes.number,
    leaveTimeout: React.PropTypes.number
  },

  transition: function (animationType, finishCallback, userSpecifiedDelay) {
    var node = ReactAddonsDOMDependencies.getReactDOM().findDOMNode(this);

    if (!node) {
      if (finishCallback) {
        finishCallback();
      }
      return;
    }

    var className = this.props.name[animationType] || this.props.name + '-' + animationType;
    var activeClassName = this.props.name[animationType + 'Active'] || className + '-active';
    var timeout = null;

    var endListener = function (e) {
      if (e && e.target !== node) {
        return;
      }

      clearTimeout(timeout);

      CSSCore.removeClass(node, className);
      CSSCore.removeClass(node, activeClassName);

      ReactTransitionEvents.removeEndEventListener(node, endListener);

      // Usually this optional callback is used for informing an owner of
      // a leave animation and telling it to remove the child.
      if (finishCallback) {
        finishCallback();
      }
    };

    CSSCore.addClass(node, className);

    // Need to do this to actually trigger a transition.
    this.queueClassAndNode(activeClassName, node);

    // If the user specified a timeout delay.
    if (userSpecifiedDelay) {
      // Clean-up the animation after the specified delay
      timeout = setTimeout(endListener, userSpecifiedDelay);
      this.transitionTimeouts.push(timeout);
    } else {
      // DEPRECATED: this listener will be removed in a future version of react
      ReactTransitionEvents.addEndEventListener(node, endListener);
    }
  },

  queueClassAndNode: function (className, node) {
    this.classNameAndNodeQueue.push({
      className: className,
      node: node
    });

    if (!this.timeout) {
      this.timeout = setTimeout(this.flushClassNameAndNodeQueue, TICK);
    }
  },

  flushClassNameAndNodeQueue: function () {
    if (this.isMounted()) {
      this.classNameAndNodeQueue.forEach(function (obj) {
        CSSCore.addClass(obj.node, obj.className);
      });
    }
    this.classNameAndNodeQueue.length = 0;
    this.timeout = null;
  },

  componentWillMount: function () {
    this.classNameAndNodeQueue = [];
    this.transitionTimeouts = [];
  },

  componentWillUnmount: function () {
    if (this.timeout) {
      clearTimeout(this.timeout);
    }
    this.transitionTimeouts.forEach(function (timeout) {
      clearTimeout(timeout);
    });

    this.classNameAndNodeQueue.length = 0;
  },

  componentWillAppear: function (done) {
    if (this.props.appear) {
      this.transition('appear', done, this.props.appearTimeout);
    } else {
      done();
    }
  },

  componentWillEnter: function (done) {
    if (this.props.enter) {
      this.transition('enter', done, this.props.enterTimeout);
    } else {
      done();
    }
  },

  componentWillLeave: function (done) {
    if (this.props.leave) {
      this.transition('leave', done, this.props.leaveTimeout);
    } else {
      done();
    }
  },

  render: function () {
    return onlyChild(this.props.children);
  }
});

module.exports = ReactCSSTransitionGroupChild;
},{"./React":852,"./ReactAddonsDOMDependencies":853,"./ReactTransitionEvents":870,"./onlyChild":876,"fbjs/lib/CSSCore":586}],856:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var PooledClass = require('./PooledClass');
var ReactElement = require('./ReactElement');

var emptyFunction = require('fbjs/lib/emptyFunction');
var traverseAllChildren = require('./traverseAllChildren');

var twoArgumentPooler = PooledClass.twoArgumentPooler;
var fourArgumentPooler = PooledClass.fourArgumentPooler;

var userProvidedKeyEscapeRegex = /\/+/g;
function escapeUserProvidedKey(text) {
  return ('' + text).replace(userProvidedKeyEscapeRegex, '$&/');
}

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * traversal. Allows avoiding binding callbacks.
 *
 * @constructor ForEachBookKeeping
 * @param {!function} forEachFunction Function to perform traversal with.
 * @param {?*} forEachContext Context to perform context with.
 */
function ForEachBookKeeping(forEachFunction, forEachContext) {
  this.func = forEachFunction;
  this.context = forEachContext;
  this.count = 0;
}
ForEachBookKeeping.prototype.destructor = function () {
  this.func = null;
  this.context = null;
  this.count = 0;
};
PooledClass.addPoolingTo(ForEachBookKeeping, twoArgumentPooler);

function forEachSingleChild(bookKeeping, child, name) {
  var func = bookKeeping.func,
      context = bookKeeping.context;

  func.call(context, child, bookKeeping.count++);
}

/**
 * Iterates through children that are typically specified as `props.children`.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.foreach
 *
 * The provided forEachFunc(child, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} forEachFunc
 * @param {*} forEachContext Context for forEachContext.
 */
function forEachChildren(children, forEachFunc, forEachContext) {
  if (children == null) {
    return children;
  }
  var traverseContext = ForEachBookKeeping.getPooled(forEachFunc, forEachContext);
  traverseAllChildren(children, forEachSingleChild, traverseContext);
  ForEachBookKeeping.release(traverseContext);
}

/**
 * PooledClass representing the bookkeeping associated with performing a child
 * mapping. Allows avoiding binding callbacks.
 *
 * @constructor MapBookKeeping
 * @param {!*} mapResult Object containing the ordered map of results.
 * @param {!function} mapFunction Function to perform mapping with.
 * @param {?*} mapContext Context to perform mapping with.
 */
function MapBookKeeping(mapResult, keyPrefix, mapFunction, mapContext) {
  this.result = mapResult;
  this.keyPrefix = keyPrefix;
  this.func = mapFunction;
  this.context = mapContext;
  this.count = 0;
}
MapBookKeeping.prototype.destructor = function () {
  this.result = null;
  this.keyPrefix = null;
  this.func = null;
  this.context = null;
  this.count = 0;
};
PooledClass.addPoolingTo(MapBookKeeping, fourArgumentPooler);

function mapSingleChildIntoContext(bookKeeping, child, childKey) {
  var result = bookKeeping.result,
      keyPrefix = bookKeeping.keyPrefix,
      func = bookKeeping.func,
      context = bookKeeping.context;


  var mappedChild = func.call(context, child, bookKeeping.count++);
  if (Array.isArray(mappedChild)) {
    mapIntoWithKeyPrefixInternal(mappedChild, result, childKey, emptyFunction.thatReturnsArgument);
  } else if (mappedChild != null) {
    if (ReactElement.isValidElement(mappedChild)) {
      mappedChild = ReactElement.cloneAndReplaceKey(mappedChild,
      // Keep both the (mapped) and old keys if they differ, just as
      // traverseAllChildren used to do for objects as children
      keyPrefix + (mappedChild.key && (!child || child.key !== mappedChild.key) ? escapeUserProvidedKey(mappedChild.key) + '/' : '') + childKey);
    }
    result.push(mappedChild);
  }
}

function mapIntoWithKeyPrefixInternal(children, array, prefix, func, context) {
  var escapedPrefix = '';
  if (prefix != null) {
    escapedPrefix = escapeUserProvidedKey(prefix) + '/';
  }
  var traverseContext = MapBookKeeping.getPooled(array, escapedPrefix, func, context);
  traverseAllChildren(children, mapSingleChildIntoContext, traverseContext);
  MapBookKeeping.release(traverseContext);
}

/**
 * Maps children that are typically specified as `props.children`.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.map
 *
 * The provided mapFunction(child, key, index) will be called for each
 * leaf child.
 *
 * @param {?*} children Children tree container.
 * @param {function(*, int)} func The map function.
 * @param {*} context Context for mapFunction.
 * @return {object} Object containing the ordered map of results.
 */
function mapChildren(children, func, context) {
  if (children == null) {
    return children;
  }
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, func, context);
  return result;
}

function forEachSingleChildDummy(traverseContext, child, name) {
  return null;
}

/**
 * Count the number of children that are typically specified as
 * `props.children`.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.count
 *
 * @param {?*} children Children tree container.
 * @return {number} The number of children.
 */
function countChildren(children, context) {
  return traverseAllChildren(children, forEachSingleChildDummy, null);
}

/**
 * Flatten a children object (typically specified as `props.children`) and
 * return an array with appropriately re-keyed children.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.toarray
 */
function toArray(children) {
  var result = [];
  mapIntoWithKeyPrefixInternal(children, result, null, emptyFunction.thatReturnsArgument);
  return result;
}

var ReactChildren = {
  forEach: forEachChildren,
  map: mapChildren,
  mapIntoWithKeyPrefixInternal: mapIntoWithKeyPrefixInternal,
  count: countChildren,
  toArray: toArray
};

module.exports = ReactChildren;
},{"./PooledClass":851,"./ReactElement":862,"./traverseAllChildren":878,"fbjs/lib/emptyFunction":594}],857:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant'),
    _assign = require('object-assign');

var ReactComponent = require('./ReactComponent');
var ReactElement = require('./ReactElement');
var ReactPropTypeLocationNames = require('./ReactPropTypeLocationNames');
var ReactNoopUpdateQueue = require('./ReactNoopUpdateQueue');

var emptyObject = require('fbjs/lib/emptyObject');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

var MIXINS_KEY = 'mixins';

// Helper function to allow the creation of anonymous functions which do not
// have .name set to the name of the variable being assigned to.
function identity(fn) {
  return fn;
}

/**
 * Policies that describe methods in `ReactClassInterface`.
 */


var injectedMixins = [];

/**
 * Composite components are higher-level components that compose other composite
 * or host components.
 *
 * To create a new type of `ReactClass`, pass a specification of
 * your new class to `React.createClass`. The only requirement of your class
 * specification is that you implement a `render` method.
 *
 *   var MyComponent = React.createClass({
 *     render: function() {
 *       return <div>Hello World</div>;
 *     }
 *   });
 *
 * The class specification supports a specific protocol of methods that have
 * special meaning (e.g. `render`). See `ReactClassInterface` for
 * more the comprehensive protocol. Any other properties and methods in the
 * class specification will be available on the prototype.
 *
 * @interface ReactClassInterface
 * @internal
 */
var ReactClassInterface = {

  /**
   * An array of Mixin objects to include when defining your component.
   *
   * @type {array}
   * @optional
   */
  mixins: 'DEFINE_MANY',

  /**
   * An object containing properties and methods that should be defined on
   * the component's constructor instead of its prototype (static methods).
   *
   * @type {object}
   * @optional
   */
  statics: 'DEFINE_MANY',

  /**
   * Definition of prop types for this component.
   *
   * @type {object}
   * @optional
   */
  propTypes: 'DEFINE_MANY',

  /**
   * Definition of context types for this component.
   *
   * @type {object}
   * @optional
   */
  contextTypes: 'DEFINE_MANY',

  /**
   * Definition of context types this component sets for its children.
   *
   * @type {object}
   * @optional
   */
  childContextTypes: 'DEFINE_MANY',

  // ==== Definition methods ====

  /**
   * Invoked when the component is mounted. Values in the mapping will be set on
   * `this.props` if that prop is not specified (i.e. using an `in` check).
   *
   * This method is invoked before `getInitialState` and therefore cannot rely
   * on `this.state` or use `this.setState`.
   *
   * @return {object}
   * @optional
   */
  getDefaultProps: 'DEFINE_MANY_MERGED',

  /**
   * Invoked once before the component is mounted. The return value will be used
   * as the initial value of `this.state`.
   *
   *   getInitialState: function() {
   *     return {
   *       isOn: false,
   *       fooBaz: new BazFoo()
   *     }
   *   }
   *
   * @return {object}
   * @optional
   */
  getInitialState: 'DEFINE_MANY_MERGED',

  /**
   * @return {object}
   * @optional
   */
  getChildContext: 'DEFINE_MANY_MERGED',

  /**
   * Uses props from `this.props` and state from `this.state` to render the
   * structure of the component.
   *
   * No guarantees are made about when or how often this method is invoked, so
   * it must not have side effects.
   *
   *   render: function() {
   *     var name = this.props.name;
   *     return <div>Hello, {name}!</div>;
   *   }
   *
   * @return {ReactComponent}
   * @nosideeffects
   * @required
   */
  render: 'DEFINE_ONCE',

  // ==== Delegate methods ====

  /**
   * Invoked when the component is initially created and about to be mounted.
   * This may have side effects, but any external subscriptions or data created
   * by this method must be cleaned up in `componentWillUnmount`.
   *
   * @optional
   */
  componentWillMount: 'DEFINE_MANY',

  /**
   * Invoked when the component has been mounted and has a DOM representation.
   * However, there is no guarantee that the DOM node is in the document.
   *
   * Use this as an opportunity to operate on the DOM when the component has
   * been mounted (initialized and rendered) for the first time.
   *
   * @param {DOMElement} rootNode DOM element representing the component.
   * @optional
   */
  componentDidMount: 'DEFINE_MANY',

  /**
   * Invoked before the component receives new props.
   *
   * Use this as an opportunity to react to a prop transition by updating the
   * state using `this.setState`. Current props are accessed via `this.props`.
   *
   *   componentWillReceiveProps: function(nextProps, nextContext) {
   *     this.setState({
   *       likesIncreasing: nextProps.likeCount > this.props.likeCount
   *     });
   *   }
   *
   * NOTE: There is no equivalent `componentWillReceiveState`. An incoming prop
   * transition may cause a state change, but the opposite is not true. If you
   * need it, you are probably looking for `componentWillUpdate`.
   *
   * @param {object} nextProps
   * @optional
   */
  componentWillReceiveProps: 'DEFINE_MANY',

  /**
   * Invoked while deciding if the component should be updated as a result of
   * receiving new props, state and/or context.
   *
   * Use this as an opportunity to `return false` when you're certain that the
   * transition to the new props/state/context will not require a component
   * update.
   *
   *   shouldComponentUpdate: function(nextProps, nextState, nextContext) {
   *     return !equal(nextProps, this.props) ||
   *       !equal(nextState, this.state) ||
   *       !equal(nextContext, this.context);
   *   }
   *
   * @param {object} nextProps
   * @param {?object} nextState
   * @param {?object} nextContext
   * @return {boolean} True if the component should update.
   * @optional
   */
  shouldComponentUpdate: 'DEFINE_ONCE',

  /**
   * Invoked when the component is about to update due to a transition from
   * `this.props`, `this.state` and `this.context` to `nextProps`, `nextState`
   * and `nextContext`.
   *
   * Use this as an opportunity to perform preparation before an update occurs.
   *
   * NOTE: You **cannot** use `this.setState()` in this method.
   *
   * @param {object} nextProps
   * @param {?object} nextState
   * @param {?object} nextContext
   * @param {ReactReconcileTransaction} transaction
   * @optional
   */
  componentWillUpdate: 'DEFINE_MANY',

  /**
   * Invoked when the component's DOM representation has been updated.
   *
   * Use this as an opportunity to operate on the DOM when the component has
   * been updated.
   *
   * @param {object} prevProps
   * @param {?object} prevState
   * @param {?object} prevContext
   * @param {DOMElement} rootNode DOM element representing the component.
   * @optional
   */
  componentDidUpdate: 'DEFINE_MANY',

  /**
   * Invoked when the component is about to be removed from its parent and have
   * its DOM representation destroyed.
   *
   * Use this as an opportunity to deallocate any external resources.
   *
   * NOTE: There is no `componentDidUnmount` since your component will have been
   * destroyed by that point.
   *
   * @optional
   */
  componentWillUnmount: 'DEFINE_MANY',

  // ==== Advanced methods ====

  /**
   * Updates the component's currently mounted DOM representation.
   *
   * By default, this implements React's rendering and reconciliation algorithm.
   * Sophisticated clients may wish to override this.
   *
   * @param {ReactReconcileTransaction} transaction
   * @internal
   * @overridable
   */
  updateComponent: 'OVERRIDE_BASE'

};

/**
 * Mapping from class specification keys to special processing functions.
 *
 * Although these are declared like instance properties in the specification
 * when defining classes using `React.createClass`, they are actually static
 * and are accessible on the constructor instead of the prototype. Despite
 * being static, they must be defined outside of the "statics" key under
 * which all other static methods are defined.
 */
var RESERVED_SPEC_KEYS = {
  displayName: function (Constructor, displayName) {
    Constructor.displayName = displayName;
  },
  mixins: function (Constructor, mixins) {
    if (mixins) {
      for (var i = 0; i < mixins.length; i++) {
        mixSpecIntoComponent(Constructor, mixins[i]);
      }
    }
  },
  childContextTypes: function (Constructor, childContextTypes) {
    Constructor.childContextTypes = _assign({}, Constructor.childContextTypes, childContextTypes);
  },
  contextTypes: function (Constructor, contextTypes) {
    Constructor.contextTypes = _assign({}, Constructor.contextTypes, contextTypes);
  },
  /**
   * Special case getDefaultProps which should move into statics but requires
   * automatic merging.
   */
  getDefaultProps: function (Constructor, getDefaultProps) {
    if (Constructor.getDefaultProps) {
      Constructor.getDefaultProps = createMergedResultFunction(Constructor.getDefaultProps, getDefaultProps);
    } else {
      Constructor.getDefaultProps = getDefaultProps;
    }
  },
  propTypes: function (Constructor, propTypes) {
    Constructor.propTypes = _assign({}, Constructor.propTypes, propTypes);
  },
  statics: function (Constructor, statics) {
    mixStaticSpecIntoComponent(Constructor, statics);
  },
  autobind: function () {} };

function validateTypeDef(Constructor, typeDef, location) {
  for (var propName in typeDef) {
    if (typeDef.hasOwnProperty(propName)) {
      // use a warning instead of an invariant so components
      // don't show up in prod but only in __DEV__
      void 0;
    }
  }
}

function validateMethodOverride(isAlreadyDefined, name) {
  var specPolicy = ReactClassInterface.hasOwnProperty(name) ? ReactClassInterface[name] : null;

  // Disallow overriding of base class methods unless explicitly allowed.
  if (ReactClassMixin.hasOwnProperty(name)) {
    !(specPolicy === 'OVERRIDE_BASE') ? _prodInvariant('73', name) : void 0;
  }

  // Disallow defining methods more than once unless explicitly allowed.
  if (isAlreadyDefined) {
    !(specPolicy === 'DEFINE_MANY' || specPolicy === 'DEFINE_MANY_MERGED') ? _prodInvariant('74', name) : void 0;
  }
}

/**
 * Mixin helper which handles policy validation and reserved
 * specification keys when building React classes.
 */
function mixSpecIntoComponent(Constructor, spec) {
  if (!spec) {
    return;
  }

  !(typeof spec !== 'function') ? _prodInvariant('75') : void 0;
  !!ReactElement.isValidElement(spec) ? _prodInvariant('76') : void 0;

  var proto = Constructor.prototype;
  var autoBindPairs = proto.__reactAutoBindPairs;

  // By handling mixins before any other properties, we ensure the same
  // chaining order is applied to methods with DEFINE_MANY policy, whether
  // mixins are listed before or after these methods in the spec.
  if (spec.hasOwnProperty(MIXINS_KEY)) {
    RESERVED_SPEC_KEYS.mixins(Constructor, spec.mixins);
  }

  for (var name in spec) {
    if (!spec.hasOwnProperty(name)) {
      continue;
    }

    if (name === MIXINS_KEY) {
      // We have already handled mixins in a special case above.
      continue;
    }

    var property = spec[name];
    var isAlreadyDefined = proto.hasOwnProperty(name);
    validateMethodOverride(isAlreadyDefined, name);

    if (RESERVED_SPEC_KEYS.hasOwnProperty(name)) {
      RESERVED_SPEC_KEYS[name](Constructor, property);
    } else {
      // Setup methods on prototype:
      // The following member methods should not be automatically bound:
      // 1. Expected ReactClass methods (in the "interface").
      // 2. Overridden methods (that were mixed in).
      var isReactClassMethod = ReactClassInterface.hasOwnProperty(name);
      var isFunction = typeof property === 'function';
      var shouldAutoBind = isFunction && !isReactClassMethod && !isAlreadyDefined && spec.autobind !== false;

      if (shouldAutoBind) {
        autoBindPairs.push(name, property);
        proto[name] = property;
      } else {
        if (isAlreadyDefined) {
          var specPolicy = ReactClassInterface[name];

          // These cases should already be caught by validateMethodOverride.
          !(isReactClassMethod && (specPolicy === 'DEFINE_MANY_MERGED' || specPolicy === 'DEFINE_MANY')) ? _prodInvariant('77', specPolicy, name) : void 0;

          // For methods which are defined more than once, call the existing
          // methods before calling the new property, merging if appropriate.
          if (specPolicy === 'DEFINE_MANY_MERGED') {
            proto[name] = createMergedResultFunction(proto[name], property);
          } else if (specPolicy === 'DEFINE_MANY') {
            proto[name] = createChainedFunction(proto[name], property);
          }
        } else {
          proto[name] = property;
        }
      }
    }
  }
}

function mixStaticSpecIntoComponent(Constructor, statics) {
  if (!statics) {
    return;
  }
  for (var name in statics) {
    var property = statics[name];
    if (!statics.hasOwnProperty(name)) {
      continue;
    }

    var isReserved = name in RESERVED_SPEC_KEYS;
    !!isReserved ? _prodInvariant('78', name) : void 0;

    var isInherited = name in Constructor;
    !!isInherited ? _prodInvariant('79', name) : void 0;
    Constructor[name] = property;
  }
}

/**
 * Merge two objects, but throw if both contain the same key.
 *
 * @param {object} one The first object, which is mutated.
 * @param {object} two The second object
 * @return {object} one after it has been mutated to contain everything in two.
 */
function mergeIntoWithNoDuplicateKeys(one, two) {
  !(one && two && typeof one === 'object' && typeof two === 'object') ? _prodInvariant('80') : void 0;

  for (var key in two) {
    if (two.hasOwnProperty(key)) {
      !(one[key] === undefined) ? _prodInvariant('81', key) : void 0;
      one[key] = two[key];
    }
  }
  return one;
}

/**
 * Creates a function that invokes two functions and merges their return values.
 *
 * @param {function} one Function to invoke first.
 * @param {function} two Function to invoke second.
 * @return {function} Function that invokes the two argument functions.
 * @private
 */
function createMergedResultFunction(one, two) {
  return function mergedResult() {
    var a = one.apply(this, arguments);
    var b = two.apply(this, arguments);
    if (a == null) {
      return b;
    } else if (b == null) {
      return a;
    }
    var c = {};
    mergeIntoWithNoDuplicateKeys(c, a);
    mergeIntoWithNoDuplicateKeys(c, b);
    return c;
  };
}

/**
 * Creates a function that invokes two functions and ignores their return vales.
 *
 * @param {function} one Function to invoke first.
 * @param {function} two Function to invoke second.
 * @return {function} Function that invokes the two argument functions.
 * @private
 */
function createChainedFunction(one, two) {
  return function chainedFunction() {
    one.apply(this, arguments);
    two.apply(this, arguments);
  };
}

/**
 * Binds a method to the component.
 *
 * @param {object} component Component whose method is going to be bound.
 * @param {function} method Method to be bound.
 * @return {function} The bound method.
 */
function bindAutoBindMethod(component, method) {
  var boundMethod = method.bind(component);
  return boundMethod;
}

/**
 * Binds all auto-bound methods in a component.
 *
 * @param {object} component Component whose method is going to be bound.
 */
function bindAutoBindMethods(component) {
  var pairs = component.__reactAutoBindPairs;
  for (var i = 0; i < pairs.length; i += 2) {
    var autoBindKey = pairs[i];
    var method = pairs[i + 1];
    component[autoBindKey] = bindAutoBindMethod(component, method);
  }
}

/**
 * Add more to the ReactClass base class. These are all legacy features and
 * therefore not already part of the modern ReactComponent.
 */
var ReactClassMixin = {

  /**
   * TODO: This will be deprecated because state should always keep a consistent
   * type signature and the only use case for this, is to avoid that.
   */
  replaceState: function (newState, callback) {
    this.updater.enqueueReplaceState(this, newState);
    if (callback) {
      this.updater.enqueueCallback(this, callback, 'replaceState');
    }
  },

  /**
   * Checks whether or not this composite component is mounted.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function () {
    return this.updater.isMounted(this);
  }
};

var ReactClassComponent = function () {};
_assign(ReactClassComponent.prototype, ReactComponent.prototype, ReactClassMixin);

/**
 * Module for creating composite components.
 *
 * @class ReactClass
 */
var ReactClass = {

  /**
   * Creates a composite component class given a class specification.
   * See https://facebook.github.io/react/docs/top-level-api.html#react.createclass
   *
   * @param {object} spec Class specification (which must define `render`).
   * @return {function} Component constructor function.
   * @public
   */
  createClass: function (spec) {
    // To keep our warnings more understandable, we'll use a little hack here to
    // ensure that Constructor.name !== 'Constructor'. This makes sure we don't
    // unnecessarily identify a class without displayName as 'Constructor'.
    var Constructor = identity(function (props, context, updater) {
      // Wire up auto-binding
      if (this.__reactAutoBindPairs.length) {
        bindAutoBindMethods(this);
      }

      this.props = props;
      this.context = context;
      this.refs = emptyObject;
      this.updater = updater || ReactNoopUpdateQueue;

      this.state = null;

      // ReactClasses doesn't have constructors. Instead, they use the
      // getInitialState and componentWillMount methods for initialization.

      var initialState = this.getInitialState ? this.getInitialState() : null;
      !(typeof initialState === 'object' && !Array.isArray(initialState)) ? _prodInvariant('82', Constructor.displayName || 'ReactCompositeComponent') : void 0;

      this.state = initialState;
    });
    Constructor.prototype = new ReactClassComponent();
    Constructor.prototype.constructor = Constructor;
    Constructor.prototype.__reactAutoBindPairs = [];

    injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor));

    mixSpecIntoComponent(Constructor, spec);

    // Initialize the defaultProps property after all mixins have been merged.
    if (Constructor.getDefaultProps) {
      Constructor.defaultProps = Constructor.getDefaultProps();
    }

    !Constructor.prototype.render ? _prodInvariant('83') : void 0;

    // Reduce time spent doing lookups by setting these on the prototype.
    for (var methodName in ReactClassInterface) {
      if (!Constructor.prototype[methodName]) {
        Constructor.prototype[methodName] = null;
      }
    }

    return Constructor;
  },

  injection: {
    injectMixin: function (mixin) {
      injectedMixins.push(mixin);
    }
  }

};

module.exports = ReactClass;
},{"./ReactComponent":858,"./ReactElement":862,"./ReactNoopUpdateQueue":864,"./ReactPropTypeLocationNames":865,"./reactProdInvariant":877,"fbjs/lib/emptyObject":595,"fbjs/lib/invariant":602,"fbjs/lib/warning":607,"object-assign":701}],858:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactNoopUpdateQueue = require('./ReactNoopUpdateQueue');

var canDefineProperty = require('./canDefineProperty');
var emptyObject = require('fbjs/lib/emptyObject');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

/**
 * Base class helpers for the updating state of a component.
 */
function ReactComponent(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

ReactComponent.prototype.isReactComponent = {};

/**
 * Sets a subset of the state. Always use this to mutate
 * state. You should treat `this.state` as immutable.
 *
 * There is no guarantee that `this.state` will be immediately updated, so
 * accessing `this.state` after calling this method may return the old value.
 *
 * There is no guarantee that calls to `setState` will run synchronously,
 * as they may eventually be batched together.  You can provide an optional
 * callback that will be executed when the call to setState is actually
 * completed.
 *
 * When a function is provided to setState, it will be called at some point in
 * the future (not synchronously). It will be called with the up to date
 * component arguments (state, props, context). These values can be different
 * from this.* because your function may be called after receiveProps but before
 * shouldComponentUpdate, and this new state, props, and context will not yet be
 * assigned to this.
 *
 * @param {object|function} partialState Next partial state or function to
 *        produce next partial state to be merged with current state.
 * @param {?function} callback Called after state is updated.
 * @final
 * @protected
 */
ReactComponent.prototype.setState = function (partialState, callback) {
  !(typeof partialState === 'object' || typeof partialState === 'function' || partialState == null) ? _prodInvariant('85') : void 0;
  this.updater.enqueueSetState(this, partialState);
  if (callback) {
    this.updater.enqueueCallback(this, callback, 'setState');
  }
};

/**
 * Forces an update. This should only be invoked when it is known with
 * certainty that we are **not** in a DOM transaction.
 *
 * You may want to call this when you know that some deeper aspect of the
 * component's state has changed but `setState` was not called.
 *
 * This will not invoke `shouldComponentUpdate`, but it will invoke
 * `componentWillUpdate` and `componentDidUpdate`.
 *
 * @param {?function} callback Called after update is complete.
 * @final
 * @protected
 */
ReactComponent.prototype.forceUpdate = function (callback) {
  this.updater.enqueueForceUpdate(this);
  if (callback) {
    this.updater.enqueueCallback(this, callback, 'forceUpdate');
  }
};

module.exports = ReactComponent;
},{"./ReactNoopUpdateQueue":864,"./canDefineProperty":873,"./reactProdInvariant":877,"fbjs/lib/emptyObject":595,"fbjs/lib/invariant":602,"fbjs/lib/warning":607}],859:[function(require,module,exports){
/**
 * Copyright 2016-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactCurrentOwner = require('./ReactCurrentOwner');

var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');

function isNative(fn) {
  // Based on isNative() from Lodash
  var funcToString = Function.prototype.toString;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var reIsNative = RegExp('^' + funcToString
  // Take an example native function source for comparison
  .call(hasOwnProperty)
  // Strip regex characters so we can use it for regex
  .replace(/[\\^$.*+?()[\]{}|]/g, '\\$&')
  // Remove hasOwnProperty from the template to make it generic
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');
  try {
    var source = funcToString.call(fn);
    return reIsNative.test(source);
  } catch (err) {
    return false;
  }
}

var canUseCollections =
// Array.from
typeof Array.from === 'function' &&
// Map
typeof Map === 'function' && isNative(Map) &&
// Map.prototype.keys
Map.prototype != null && typeof Map.prototype.keys === 'function' && isNative(Map.prototype.keys) &&
// Set
typeof Set === 'function' && isNative(Set) &&
// Set.prototype.keys
Set.prototype != null && typeof Set.prototype.keys === 'function' && isNative(Set.prototype.keys);

var setItem;
var getItem;
var removeItem;
var getItemIDs;
var addRoot;
var removeRoot;
var getRootIDs;

if (canUseCollections) {
  var itemMap = new Map();
  var rootIDSet = new Set();

  setItem = function (id, item) {
    itemMap.set(id, item);
  };
  getItem = function (id) {
    return itemMap.get(id);
  };
  removeItem = function (id) {
    itemMap['delete'](id);
  };
  getItemIDs = function () {
    return Array.from(itemMap.keys());
  };

  addRoot = function (id) {
    rootIDSet.add(id);
  };
  removeRoot = function (id) {
    rootIDSet['delete'](id);
  };
  getRootIDs = function () {
    return Array.from(rootIDSet.keys());
  };
} else {
  var itemByKey = {};
  var rootByKey = {};

  // Use non-numeric keys to prevent V8 performance issues:
  // https://github.com/facebook/react/pull/7232
  var getKeyFromID = function (id) {
    return '.' + id;
  };
  var getIDFromKey = function (key) {
    return parseInt(key.substr(1), 10);
  };

  setItem = function (id, item) {
    var key = getKeyFromID(id);
    itemByKey[key] = item;
  };
  getItem = function (id) {
    var key = getKeyFromID(id);
    return itemByKey[key];
  };
  removeItem = function (id) {
    var key = getKeyFromID(id);
    delete itemByKey[key];
  };
  getItemIDs = function () {
    return Object.keys(itemByKey).map(getIDFromKey);
  };

  addRoot = function (id) {
    var key = getKeyFromID(id);
    rootByKey[key] = true;
  };
  removeRoot = function (id) {
    var key = getKeyFromID(id);
    delete rootByKey[key];
  };
  getRootIDs = function () {
    return Object.keys(rootByKey).map(getIDFromKey);
  };
}

var unmountedIDs = [];

function purgeDeep(id) {
  var item = getItem(id);
  if (item) {
    var childIDs = item.childIDs;

    removeItem(id);
    childIDs.forEach(purgeDeep);
  }
}

function describeComponentFrame(name, source, ownerName) {
  return '\n    in ' + (name || 'Unknown') + (source ? ' (at ' + source.fileName.replace(/^.*[\\\/]/, '') + ':' + source.lineNumber + ')' : ownerName ? ' (created by ' + ownerName + ')' : '');
}

function getDisplayName(element) {
  if (element == null) {
    return '#empty';
  } else if (typeof element === 'string' || typeof element === 'number') {
    return '#text';
  } else if (typeof element.type === 'string') {
    return element.type;
  } else {
    return element.type.displayName || element.type.name || 'Unknown';
  }
}

function describeID(id) {
  var name = ReactComponentTreeHook.getDisplayName(id);
  var element = ReactComponentTreeHook.getElement(id);
  var ownerID = ReactComponentTreeHook.getOwnerID(id);
  var ownerName;
  if (ownerID) {
    ownerName = ReactComponentTreeHook.getDisplayName(ownerID);
  }
  void 0;
  return describeComponentFrame(name, element && element._source, ownerName);
}

var ReactComponentTreeHook = {
  onSetChildren: function (id, nextChildIDs) {
    var item = getItem(id);
    !item ? _prodInvariant('144') : void 0;
    item.childIDs = nextChildIDs;

    for (var i = 0; i < nextChildIDs.length; i++) {
      var nextChildID = nextChildIDs[i];
      var nextChild = getItem(nextChildID);
      !nextChild ? _prodInvariant('140') : void 0;
      !(nextChild.childIDs != null || typeof nextChild.element !== 'object' || nextChild.element == null) ? _prodInvariant('141') : void 0;
      !nextChild.isMounted ? _prodInvariant('71') : void 0;
      if (nextChild.parentID == null) {
        nextChild.parentID = id;
        // TODO: This shouldn't be necessary but mounting a new root during in
        // componentWillMount currently causes not-yet-mounted components to
        // be purged from our tree data so their parent id is missing.
      }
      !(nextChild.parentID === id) ? _prodInvariant('142', nextChildID, nextChild.parentID, id) : void 0;
    }
  },
  onBeforeMountComponent: function (id, element, parentID) {
    var item = {
      element: element,
      parentID: parentID,
      text: null,
      childIDs: [],
      isMounted: false,
      updateCount: 0
    };
    setItem(id, item);
  },
  onBeforeUpdateComponent: function (id, element) {
    var item = getItem(id);
    if (!item || !item.isMounted) {
      // We may end up here as a result of setState() in componentWillUnmount().
      // In this case, ignore the element.
      return;
    }
    item.element = element;
  },
  onMountComponent: function (id) {
    var item = getItem(id);
    !item ? _prodInvariant('144') : void 0;
    item.isMounted = true;
    var isRoot = item.parentID === 0;
    if (isRoot) {
      addRoot(id);
    }
  },
  onUpdateComponent: function (id) {
    var item = getItem(id);
    if (!item || !item.isMounted) {
      // We may end up here as a result of setState() in componentWillUnmount().
      // In this case, ignore the element.
      return;
    }
    item.updateCount++;
  },
  onUnmountComponent: function (id) {
    var item = getItem(id);
    if (item) {
      // We need to check if it exists.
      // `item` might not exist if it is inside an error boundary, and a sibling
      // error boundary child threw while mounting. Then this instance never
      // got a chance to mount, but it still gets an unmounting event during
      // the error boundary cleanup.
      item.isMounted = false;
      var isRoot = item.parentID === 0;
      if (isRoot) {
        removeRoot(id);
      }
    }
    unmountedIDs.push(id);
  },
  purgeUnmountedComponents: function () {
    if (ReactComponentTreeHook._preventPurging) {
      // Should only be used for testing.
      return;
    }

    for (var i = 0; i < unmountedIDs.length; i++) {
      var id = unmountedIDs[i];
      purgeDeep(id);
    }
    unmountedIDs.length = 0;
  },
  isMounted: function (id) {
    var item = getItem(id);
    return item ? item.isMounted : false;
  },
  getCurrentStackAddendum: function (topElement) {
    var info = '';
    if (topElement) {
      var name = getDisplayName(topElement);
      var owner = topElement._owner;
      info += describeComponentFrame(name, topElement._source, owner && owner.getName());
    }

    var currentOwner = ReactCurrentOwner.current;
    var id = currentOwner && currentOwner._debugID;

    info += ReactComponentTreeHook.getStackAddendumByID(id);
    return info;
  },
  getStackAddendumByID: function (id) {
    var info = '';
    while (id) {
      info += describeID(id);
      id = ReactComponentTreeHook.getParentID(id);
    }
    return info;
  },
  getChildIDs: function (id) {
    var item = getItem(id);
    return item ? item.childIDs : [];
  },
  getDisplayName: function (id) {
    var element = ReactComponentTreeHook.getElement(id);
    if (!element) {
      return null;
    }
    return getDisplayName(element);
  },
  getElement: function (id) {
    var item = getItem(id);
    return item ? item.element : null;
  },
  getOwnerID: function (id) {
    var element = ReactComponentTreeHook.getElement(id);
    if (!element || !element._owner) {
      return null;
    }
    return element._owner._debugID;
  },
  getParentID: function (id) {
    var item = getItem(id);
    return item ? item.parentID : null;
  },
  getSource: function (id) {
    var item = getItem(id);
    var element = item ? item.element : null;
    var source = element != null ? element._source : null;
    return source;
  },
  getText: function (id) {
    var element = ReactComponentTreeHook.getElement(id);
    if (typeof element === 'string') {
      return element;
    } else if (typeof element === 'number') {
      return '' + element;
    } else {
      return null;
    }
  },
  getUpdateCount: function (id) {
    var item = getItem(id);
    return item ? item.updateCount : 0;
  },


  getRootIDs: getRootIDs,
  getRegisteredIDs: getItemIDs
};

module.exports = ReactComponentTreeHook;
},{"./ReactCurrentOwner":860,"./reactProdInvariant":877,"fbjs/lib/invariant":602,"fbjs/lib/warning":607}],860:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

/**
 * Keeps track of the current owner.
 *
 * The current owner is the component who should own any components that are
 * currently being constructed.
 */
var ReactCurrentOwner = {

  /**
   * @internal
   * @type {ReactComponent}
   */
  current: null

};

module.exports = ReactCurrentOwner;
},{}],861:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ReactElement = require('./ReactElement');

/**
 * Create a factory that creates HTML tag elements.
 *
 * @private
 */
var createDOMFactory = ReactElement.createFactory;

/**
 * Creates a mapping from supported HTML tags to `ReactDOMComponent` classes.
 * This is also accessible via `React.DOM`.
 *
 * @public
 */
var ReactDOMFactories = {
  a: createDOMFactory('a'),
  abbr: createDOMFactory('abbr'),
  address: createDOMFactory('address'),
  area: createDOMFactory('area'),
  article: createDOMFactory('article'),
  aside: createDOMFactory('aside'),
  audio: createDOMFactory('audio'),
  b: createDOMFactory('b'),
  base: createDOMFactory('base'),
  bdi: createDOMFactory('bdi'),
  bdo: createDOMFactory('bdo'),
  big: createDOMFactory('big'),
  blockquote: createDOMFactory('blockquote'),
  body: createDOMFactory('body'),
  br: createDOMFactory('br'),
  button: createDOMFactory('button'),
  canvas: createDOMFactory('canvas'),
  caption: createDOMFactory('caption'),
  cite: createDOMFactory('cite'),
  code: createDOMFactory('code'),
  col: createDOMFactory('col'),
  colgroup: createDOMFactory('colgroup'),
  data: createDOMFactory('data'),
  datalist: createDOMFactory('datalist'),
  dd: createDOMFactory('dd'),
  del: createDOMFactory('del'),
  details: createDOMFactory('details'),
  dfn: createDOMFactory('dfn'),
  dialog: createDOMFactory('dialog'),
  div: createDOMFactory('div'),
  dl: createDOMFactory('dl'),
  dt: createDOMFactory('dt'),
  em: createDOMFactory('em'),
  embed: createDOMFactory('embed'),
  fieldset: createDOMFactory('fieldset'),
  figcaption: createDOMFactory('figcaption'),
  figure: createDOMFactory('figure'),
  footer: createDOMFactory('footer'),
  form: createDOMFactory('form'),
  h1: createDOMFactory('h1'),
  h2: createDOMFactory('h2'),
  h3: createDOMFactory('h3'),
  h4: createDOMFactory('h4'),
  h5: createDOMFactory('h5'),
  h6: createDOMFactory('h6'),
  head: createDOMFactory('head'),
  header: createDOMFactory('header'),
  hgroup: createDOMFactory('hgroup'),
  hr: createDOMFactory('hr'),
  html: createDOMFactory('html'),
  i: createDOMFactory('i'),
  iframe: createDOMFactory('iframe'),
  img: createDOMFactory('img'),
  input: createDOMFactory('input'),
  ins: createDOMFactory('ins'),
  kbd: createDOMFactory('kbd'),
  keygen: createDOMFactory('keygen'),
  label: createDOMFactory('label'),
  legend: createDOMFactory('legend'),
  li: createDOMFactory('li'),
  link: createDOMFactory('link'),
  main: createDOMFactory('main'),
  map: createDOMFactory('map'),
  mark: createDOMFactory('mark'),
  menu: createDOMFactory('menu'),
  menuitem: createDOMFactory('menuitem'),
  meta: createDOMFactory('meta'),
  meter: createDOMFactory('meter'),
  nav: createDOMFactory('nav'),
  noscript: createDOMFactory('noscript'),
  object: createDOMFactory('object'),
  ol: createDOMFactory('ol'),
  optgroup: createDOMFactory('optgroup'),
  option: createDOMFactory('option'),
  output: createDOMFactory('output'),
  p: createDOMFactory('p'),
  param: createDOMFactory('param'),
  picture: createDOMFactory('picture'),
  pre: createDOMFactory('pre'),
  progress: createDOMFactory('progress'),
  q: createDOMFactory('q'),
  rp: createDOMFactory('rp'),
  rt: createDOMFactory('rt'),
  ruby: createDOMFactory('ruby'),
  s: createDOMFactory('s'),
  samp: createDOMFactory('samp'),
  script: createDOMFactory('script'),
  section: createDOMFactory('section'),
  select: createDOMFactory('select'),
  small: createDOMFactory('small'),
  source: createDOMFactory('source'),
  span: createDOMFactory('span'),
  strong: createDOMFactory('strong'),
  style: createDOMFactory('style'),
  sub: createDOMFactory('sub'),
  summary: createDOMFactory('summary'),
  sup: createDOMFactory('sup'),
  table: createDOMFactory('table'),
  tbody: createDOMFactory('tbody'),
  td: createDOMFactory('td'),
  textarea: createDOMFactory('textarea'),
  tfoot: createDOMFactory('tfoot'),
  th: createDOMFactory('th'),
  thead: createDOMFactory('thead'),
  time: createDOMFactory('time'),
  title: createDOMFactory('title'),
  tr: createDOMFactory('tr'),
  track: createDOMFactory('track'),
  u: createDOMFactory('u'),
  ul: createDOMFactory('ul'),
  'var': createDOMFactory('var'),
  video: createDOMFactory('video'),
  wbr: createDOMFactory('wbr'),

  // SVG
  circle: createDOMFactory('circle'),
  clipPath: createDOMFactory('clipPath'),
  defs: createDOMFactory('defs'),
  ellipse: createDOMFactory('ellipse'),
  g: createDOMFactory('g'),
  image: createDOMFactory('image'),
  line: createDOMFactory('line'),
  linearGradient: createDOMFactory('linearGradient'),
  mask: createDOMFactory('mask'),
  path: createDOMFactory('path'),
  pattern: createDOMFactory('pattern'),
  polygon: createDOMFactory('polygon'),
  polyline: createDOMFactory('polyline'),
  radialGradient: createDOMFactory('radialGradient'),
  rect: createDOMFactory('rect'),
  stop: createDOMFactory('stop'),
  svg: createDOMFactory('svg'),
  text: createDOMFactory('text'),
  tspan: createDOMFactory('tspan')
};

module.exports = ReactDOMFactories;
},{"./ReactElement":862}],862:[function(require,module,exports){
/**
 * Copyright 2014-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

var ReactCurrentOwner = require('./ReactCurrentOwner');

var warning = require('fbjs/lib/warning');
var canDefineProperty = require('./canDefineProperty');
var hasOwnProperty = Object.prototype.hasOwnProperty;

var REACT_ELEMENT_TYPE = require('./ReactElementSymbol');

var RESERVED_PROPS = {
  key: true,
  ref: true,
  __self: true,
  __source: true
};

var specialPropKeyWarningShown, specialPropRefWarningShown;

function hasValidRef(config) {
  return config.ref !== undefined;
}

function hasValidKey(config) {
  return config.key !== undefined;
}

function defineKeyPropWarningGetter(props, displayName) {
  var warnAboutAccessingKey = function () {
    if (!specialPropKeyWarningShown) {
      specialPropKeyWarningShown = true;
      void 0;
    }
  };
  warnAboutAccessingKey.isReactWarning = true;
  Object.defineProperty(props, 'key', {
    get: warnAboutAccessingKey,
    configurable: true
  });
}

function defineRefPropWarningGetter(props, displayName) {
  var warnAboutAccessingRef = function () {
    if (!specialPropRefWarningShown) {
      specialPropRefWarningShown = true;
      void 0;
    }
  };
  warnAboutAccessingRef.isReactWarning = true;
  Object.defineProperty(props, 'ref', {
    get: warnAboutAccessingRef,
    configurable: true
  });
}

/**
 * Factory method to create a new React element. This no longer adheres to
 * the class pattern, so do not use new to call it. Also, no instanceof check
 * will work. Instead test $$typeof field against Symbol.for('react.element') to check
 * if something is a React Element.
 *
 * @param {*} type
 * @param {*} key
 * @param {string|object} ref
 * @param {*} self A *temporary* helper to detect places where `this` is
 * different from the `owner` when React.createElement is called, so that we
 * can warn. We want to get rid of owner and replace string `ref`s with arrow
 * functions, and as long as `this` and owner are the same, there will be no
 * change in behavior.
 * @param {*} source An annotation object (added by a transpiler or otherwise)
 * indicating filename, line number, and/or other information.
 * @param {*} owner
 * @param {*} props
 * @internal
 */
var ReactElement = function (type, key, ref, self, source, owner, props) {
  var element = {
    // This tag allow us to uniquely identify this as a React Element
    $$typeof: REACT_ELEMENT_TYPE,

    // Built-in properties that belong on the element
    type: type,
    key: key,
    ref: ref,
    props: props,

    // Record the component responsible for creating this element.
    _owner: owner
  };

  return element;
};

/**
 * Create and return a new ReactElement of the given type.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.createelement
 */
ReactElement.createElement = function (type, config, children) {
  var propName;

  // Reserved names are extracted
  var props = {};

  var key = null;
  var ref = null;
  var self = null;
  var source = null;

  if (config != null) {
    if (hasValidRef(config)) {
      ref = config.ref;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    self = config.__self === undefined ? null : config.__self;
    source = config.__source === undefined ? null : config.__source;
    // Remaining properties are added to a new props object
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        props[propName] = config[propName];
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  // Resolve default props
  if (type && type.defaultProps) {
    var defaultProps = type.defaultProps;
    for (propName in defaultProps) {
      if (props[propName] === undefined) {
        props[propName] = defaultProps[propName];
      }
    }
  }
  return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
};

/**
 * Return a function that produces ReactElements of a given type.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.createfactory
 */
ReactElement.createFactory = function (type) {
  var factory = ReactElement.createElement.bind(null, type);
  // Expose the type on the factory and the prototype so that it can be
  // easily accessed on elements. E.g. `<Foo />.type === Foo`.
  // This should not be named `constructor` since this may not be the function
  // that created the element, and it may not even be a constructor.
  // Legacy hook TODO: Warn if this is accessed
  factory.type = type;
  return factory;
};

ReactElement.cloneAndReplaceKey = function (oldElement, newKey) {
  var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);

  return newElement;
};

/**
 * Clone and return a new ReactElement using element as the starting point.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.cloneelement
 */
ReactElement.cloneElement = function (element, config, children) {
  var propName;

  // Original props are copied
  var props = _assign({}, element.props);

  // Reserved names are extracted
  var key = element.key;
  var ref = element.ref;
  // Self is preserved since the owner is preserved.
  var self = element._self;
  // Source is preserved since cloneElement is unlikely to be targeted by a
  // transpiler, and the original source is probably a better indicator of the
  // true owner.
  var source = element._source;

  // Owner will be preserved, unless ref is overridden
  var owner = element._owner;

  if (config != null) {
    if (hasValidRef(config)) {
      // Silently steal the ref from the parent.
      ref = config.ref;
      owner = ReactCurrentOwner.current;
    }
    if (hasValidKey(config)) {
      key = '' + config.key;
    }

    // Remaining properties override existing props
    var defaultProps;
    if (element.type && element.type.defaultProps) {
      defaultProps = element.type.defaultProps;
    }
    for (propName in config) {
      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
        if (config[propName] === undefined && defaultProps !== undefined) {
          // Resolve default props
          props[propName] = defaultProps[propName];
        } else {
          props[propName] = config[propName];
        }
      }
    }
  }

  // Children can be more than one argument, and those are transferred onto
  // the newly allocated props object.
  var childrenLength = arguments.length - 2;
  if (childrenLength === 1) {
    props.children = children;
  } else if (childrenLength > 1) {
    var childArray = Array(childrenLength);
    for (var i = 0; i < childrenLength; i++) {
      childArray[i] = arguments[i + 2];
    }
    props.children = childArray;
  }

  return ReactElement(element.type, key, ref, self, source, owner, props);
};

/**
 * Verifies the object is a ReactElement.
 * See https://facebook.github.io/react/docs/top-level-api.html#react.isvalidelement
 * @param {?object} object
 * @return {boolean} True if `object` is a valid component.
 * @final
 */
ReactElement.isValidElement = function (object) {
  return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
};

module.exports = ReactElement;
},{"./ReactCurrentOwner":860,"./ReactElementSymbol":863,"./canDefineProperty":873,"fbjs/lib/warning":607,"object-assign":701}],863:[function(require,module,exports){
arguments[4][778][0].apply(exports,arguments)
},{"dup":778}],864:[function(require,module,exports){
/**
 * Copyright 2015-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var warning = require('fbjs/lib/warning');

function warnNoop(publicInstance, callerName) {}

/**
 * This is the abstract API for an update queue.
 */
var ReactNoopUpdateQueue = {

  /**
   * Checks whether or not this composite component is mounted.
   * @param {ReactClass} publicInstance The instance we want to test.
   * @return {boolean} True if mounted, false otherwise.
   * @protected
   * @final
   */
  isMounted: function (publicInstance) {
    return false;
  },

  /**
   * Enqueue a callback that will be executed after all the pending updates
   * have processed.
   *
   * @param {ReactClass} publicInstance The instance to use as `this` context.
   * @param {?function} callback Called after state is updated.
   * @internal
   */
  enqueueCallback: function (publicInstance, callback) {},

  /**
   * Forces an update. This should only be invoked when it is known with
   * certainty that we are **not** in a DOM transaction.
   *
   * You may want to call this when you know that some deeper aspect of the
   * component's state has changed but `setState` was not called.
   *
   * This will not invoke `shouldComponentUpdate`, but it will invoke
   * `componentWillUpdate` and `componentDidUpdate`.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @internal
   */
  enqueueForceUpdate: function (publicInstance) {
    warnNoop(publicInstance, 'forceUpdate');
  },

  /**
   * Replaces all of the state. Always use this or `setState` to mutate state.
   * You should treat `this.state` as immutable.
   *
   * There is no guarantee that `this.state` will be immediately updated, so
   * accessing `this.state` after calling this method may return the old value.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} completeState Next state.
   * @internal
   */
  enqueueReplaceState: function (publicInstance, completeState) {
    warnNoop(publicInstance, 'replaceState');
  },

  /**
   * Sets a subset of the state. This only exists because _pendingState is
   * internal. This provides a merging strategy that is not available to deep
   * properties which is confusing. TODO: Expose pendingState or don't use it
   * during the merge.
   *
   * @param {ReactClass} publicInstance The instance that should rerender.
   * @param {object} partialState Next partial state to be merged with state.
   * @internal
   */
  enqueueSetState: function (publicInstance, partialState) {
    warnNoop(publicInstance, 'setState');
  }
};

module.exports = ReactNoopUpdateQueue;
},{"fbjs/lib/warning":607}],865:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var ReactPropTypeLocationNames = {};

module.exports = ReactPropTypeLocationNames;
},{}],866:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ReactElement = require('./ReactElement');
var ReactPropTypeLocationNames = require('./ReactPropTypeLocationNames');
var ReactPropTypesSecret = require('./ReactPropTypesSecret');

var emptyFunction = require('fbjs/lib/emptyFunction');
var getIteratorFn = require('./getIteratorFn');
var warning = require('fbjs/lib/warning');

/**
 * Collection of methods that allow declaration and validation of props that are
 * supplied to React components. Example usage:
 *
 *   var Props = require('ReactPropTypes');
 *   var MyArticle = React.createClass({
 *     propTypes: {
 *       // An optional string prop named "description".
 *       description: Props.string,
 *
 *       // A required enum prop named "category".
 *       category: Props.oneOf(['News','Photos']).isRequired,
 *
 *       // A prop named "dialog" that requires an instance of Dialog.
 *       dialog: Props.instanceOf(Dialog).isRequired
 *     },
 *     render: function() { ... }
 *   });
 *
 * A more formal specification of how these methods are used:
 *
 *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
 *   decl := ReactPropTypes.{type}(.isRequired)?
 *
 * Each and every declaration produces a function with the same signature. This
 * allows the creation of custom validation functions. For example:
 *
 *  var MyLink = React.createClass({
 *    propTypes: {
 *      // An optional string or URI prop named "href".
 *      href: function(props, propName, componentName) {
 *        var propValue = props[propName];
 *        if (propValue != null && typeof propValue !== 'string' &&
 *            !(propValue instanceof URI)) {
 *          return new Error(
 *            'Expected a string or an URI for ' + propName + ' in ' +
 *            componentName
 *          );
 *        }
 *      }
 *    },
 *    render: function() {...}
 *  });
 *
 * @internal
 */

var ANONYMOUS = '<<anonymous>>';

var ReactPropTypes = {
  array: createPrimitiveTypeChecker('array'),
  bool: createPrimitiveTypeChecker('boolean'),
  func: createPrimitiveTypeChecker('function'),
  number: createPrimitiveTypeChecker('number'),
  object: createPrimitiveTypeChecker('object'),
  string: createPrimitiveTypeChecker('string'),
  symbol: createPrimitiveTypeChecker('symbol'),

  any: createAnyTypeChecker(),
  arrayOf: createArrayOfTypeChecker,
  element: createElementTypeChecker(),
  instanceOf: createInstanceTypeChecker,
  node: createNodeChecker(),
  objectOf: createObjectOfTypeChecker,
  oneOf: createEnumTypeChecker,
  oneOfType: createUnionTypeChecker,
  shape: createShapeTypeChecker
};

/**
 * inlined Object.is polyfill to avoid requiring consumers ship their own
 * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
 */
/*eslint-disable no-self-compare*/
function is(x, y) {
  // SameValue algorithm
  if (x === y) {
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    return x !== 0 || 1 / x === 1 / y;
  } else {
    // Step 6.a: NaN == NaN
    return x !== x && y !== y;
  }
}
/*eslint-enable no-self-compare*/

/**
 * We use an Error-like object for backward compatibility as people may call
 * PropTypes directly and inspect their output. However we don't use real
 * Errors anymore. We don't inspect their stack anyway, and creating them
 * is prohibitively expensive if they are created too often, such as what
 * happens in oneOfType() for any type before the one that matched.
 */
function PropTypeError(message) {
  this.message = message;
  this.stack = '';
}
// Make `instanceof Error` still work for returned errors.
PropTypeError.prototype = Error.prototype;

function createChainableTypeChecker(validate) {
  function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
    componentName = componentName || ANONYMOUS;
    propFullName = propFullName || propName;
    if (props[propName] == null) {
      var locationName = ReactPropTypeLocationNames[location];
      if (isRequired) {
        if (props[propName] === null) {
          return new PropTypeError('The ' + locationName + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
        }
        return new PropTypeError('The ' + locationName + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
      }
      return null;
    } else {
      return validate(props, propName, componentName, location, propFullName);
    }
  }

  var chainedCheckType = checkType.bind(null, false);
  chainedCheckType.isRequired = checkType.bind(null, true);

  return chainedCheckType;
}

function createPrimitiveTypeChecker(expectedType) {
  function validate(props, propName, componentName, location, propFullName, secret) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== expectedType) {
      var locationName = ReactPropTypeLocationNames[location];
      // `propValue` being instance of, say, date/regexp, pass the 'object'
      // check, but we can offer a more precise error message here rather than
      // 'of type `object`'.
      var preciseType = getPreciseType(propValue);

      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createAnyTypeChecker() {
  return createChainableTypeChecker(emptyFunction.thatReturns(null));
}

function createArrayOfTypeChecker(typeChecker) {
  function validate(props, propName, componentName, location, propFullName) {
    if (typeof typeChecker !== 'function') {
      return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
    }
    var propValue = props[propName];
    if (!Array.isArray(propValue)) {
      var locationName = ReactPropTypeLocationNames[location];
      var propType = getPropType(propValue);
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
    }
    for (var i = 0; i < propValue.length; i++) {
      var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
      if (error instanceof Error) {
        return error;
      }
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createElementTypeChecker() {
  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    if (!ReactElement.isValidElement(propValue)) {
      var locationName = ReactPropTypeLocationNames[location];
      var propType = getPropType(propValue);
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createInstanceTypeChecker(expectedClass) {
  function validate(props, propName, componentName, location, propFullName) {
    if (!(props[propName] instanceof expectedClass)) {
      var locationName = ReactPropTypeLocationNames[location];
      var expectedClassName = expectedClass.name || ANONYMOUS;
      var actualClassName = getClassName(props[propName]);
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createEnumTypeChecker(expectedValues) {
  if (!Array.isArray(expectedValues)) {
    void 0;
    return emptyFunction.thatReturnsNull;
  }

  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    for (var i = 0; i < expectedValues.length; i++) {
      if (is(propValue, expectedValues[i])) {
        return null;
      }
    }

    var locationName = ReactPropTypeLocationNames[location];
    var valuesString = JSON.stringify(expectedValues);
    return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
  }
  return createChainableTypeChecker(validate);
}

function createObjectOfTypeChecker(typeChecker) {
  function validate(props, propName, componentName, location, propFullName) {
    if (typeof typeChecker !== 'function') {
      return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
    }
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== 'object') {
      var locationName = ReactPropTypeLocationNames[location];
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
    }
    for (var key in propValue) {
      if (propValue.hasOwnProperty(key)) {
        var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createUnionTypeChecker(arrayOfTypeCheckers) {
  if (!Array.isArray(arrayOfTypeCheckers)) {
    void 0;
    return emptyFunction.thatReturnsNull;
  }

  function validate(props, propName, componentName, location, propFullName) {
    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
        return null;
      }
    }

    var locationName = ReactPropTypeLocationNames[location];
    return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
  }
  return createChainableTypeChecker(validate);
}

function createNodeChecker() {
  function validate(props, propName, componentName, location, propFullName) {
    if (!isNode(props[propName])) {
      var locationName = ReactPropTypeLocationNames[location];
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function createShapeTypeChecker(shapeTypes) {
  function validate(props, propName, componentName, location, propFullName) {
    var propValue = props[propName];
    var propType = getPropType(propValue);
    if (propType !== 'object') {
      var locationName = ReactPropTypeLocationNames[location];
      return new PropTypeError('Invalid ' + locationName + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
    }
    for (var key in shapeTypes) {
      var checker = shapeTypes[key];
      if (!checker) {
        continue;
      }
      var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
      if (error) {
        return error;
      }
    }
    return null;
  }
  return createChainableTypeChecker(validate);
}

function isNode(propValue) {
  switch (typeof propValue) {
    case 'number':
    case 'string':
    case 'undefined':
      return true;
    case 'boolean':
      return !propValue;
    case 'object':
      if (Array.isArray(propValue)) {
        return propValue.every(isNode);
      }
      if (propValue === null || ReactElement.isValidElement(propValue)) {
        return true;
      }

      var iteratorFn = getIteratorFn(propValue);
      if (iteratorFn) {
        var iterator = iteratorFn.call(propValue);
        var step;
        if (iteratorFn !== propValue.entries) {
          while (!(step = iterator.next()).done) {
            if (!isNode(step.value)) {
              return false;
            }
          }
        } else {
          // Iterator will provide entry [k,v] tuples rather than values.
          while (!(step = iterator.next()).done) {
            var entry = step.value;
            if (entry) {
              if (!isNode(entry[1])) {
                return false;
              }
            }
          }
        }
      } else {
        return false;
      }

      return true;
    default:
      return false;
  }
}

function isSymbol(propType, propValue) {
  // Native Symbol.
  if (propType === 'symbol') {
    return true;
  }

  // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
  if (propValue['@@toStringTag'] === 'Symbol') {
    return true;
  }

  // Fallback for non-spec compliant Symbols which are polyfilled.
  if (typeof Symbol === 'function' && propValue instanceof Symbol) {
    return true;
  }

  return false;
}

// Equivalent of `typeof` but with special handling for array and regexp.
function getPropType(propValue) {
  var propType = typeof propValue;
  if (Array.isArray(propValue)) {
    return 'array';
  }
  if (propValue instanceof RegExp) {
    // Old webkits (at least until Android 4.0) return 'function' rather than
    // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
    // passes PropTypes.object.
    return 'object';
  }
  if (isSymbol(propType, propValue)) {
    return 'symbol';
  }
  return propType;
}

// This handles more types than `getPropType`. Only used for error messages.
// See `createPrimitiveTypeChecker`.
function getPreciseType(propValue) {
  var propType = getPropType(propValue);
  if (propType === 'object') {
    if (propValue instanceof Date) {
      return 'date';
    } else if (propValue instanceof RegExp) {
      return 'regexp';
    }
  }
  return propType;
}

// Returns class name of the object, if any.
function getClassName(propValue) {
  if (!propValue.constructor || !propValue.constructor.name) {
    return ANONYMOUS;
  }
  return propValue.constructor.name;
}

module.exports = ReactPropTypes;
},{"./ReactElement":862,"./ReactPropTypeLocationNames":865,"./ReactPropTypesSecret":867,"./getIteratorFn":875,"fbjs/lib/emptyFunction":594,"fbjs/lib/warning":607}],867:[function(require,module,exports){
arguments[4][794][0].apply(exports,arguments)
},{"dup":794}],868:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

var ReactComponent = require('./ReactComponent');
var ReactNoopUpdateQueue = require('./ReactNoopUpdateQueue');

var emptyObject = require('fbjs/lib/emptyObject');

/**
 * Base class helpers for the updating state of a component.
 */
function ReactPureComponent(props, context, updater) {
  // Duplicated from ReactComponent.
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

function ComponentDummy() {}
ComponentDummy.prototype = ReactComponent.prototype;
ReactPureComponent.prototype = new ComponentDummy();
ReactPureComponent.prototype.constructor = ReactPureComponent;
// Avoid an extra prototype jump for these methods.
_assign(ReactPureComponent.prototype, ReactComponent.prototype);
ReactPureComponent.prototype.isPureReactComponent = true;

module.exports = ReactPureComponent;
},{"./ReactComponent":858,"./ReactNoopUpdateQueue":864,"fbjs/lib/emptyObject":595,"object-assign":701}],869:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var flattenChildren = require('./flattenChildren');

var ReactTransitionChildMapping = {
  /**
   * Given `this.props.children`, return an object mapping key to child. Just
   * simple syntactic sugar around flattenChildren().
   *
   * @param {*} children `this.props.children`
   * @param {number=} selfDebugID Optional debugID of the current internal instance.
   * @return {object} Mapping of key to child
   */
  getChildMapping: function (children, selfDebugID) {
    if (!children) {
      return children;
    }

    return flattenChildren(children);
  },

  /**
   * When you're adding or removing children some may be added or removed in the
   * same render pass. We want to show *both* since we want to simultaneously
   * animate elements in and out. This function takes a previous set of keys
   * and a new set of keys and merges them with its best guess of the correct
   * ordering. In the future we may expose some of the utilities in
   * ReactMultiChild to make this easy, but for now React itself does not
   * directly have this concept of the union of prevChildren and nextChildren
   * so we implement it here.
   *
   * @param {object} prev prev children as returned from
   * `ReactTransitionChildMapping.getChildMapping()`.
   * @param {object} next next children as returned from
   * `ReactTransitionChildMapping.getChildMapping()`.
   * @return {object} a key set that contains all keys in `prev` and all keys
   * in `next` in a reasonable order.
   */
  mergeChildMappings: function (prev, next) {
    prev = prev || {};
    next = next || {};

    function getValueForKey(key) {
      if (next.hasOwnProperty(key)) {
        return next[key];
      } else {
        return prev[key];
      }
    }

    // For each key of `next`, the list of keys to insert before that key in
    // the combined list
    var nextKeysPending = {};

    var pendingKeys = [];
    for (var prevKey in prev) {
      if (next.hasOwnProperty(prevKey)) {
        if (pendingKeys.length) {
          nextKeysPending[prevKey] = pendingKeys;
          pendingKeys = [];
        }
      } else {
        pendingKeys.push(prevKey);
      }
    }

    var i;
    var childMapping = {};
    for (var nextKey in next) {
      if (nextKeysPending.hasOwnProperty(nextKey)) {
        for (i = 0; i < nextKeysPending[nextKey].length; i++) {
          var pendingNextKey = nextKeysPending[nextKey][i];
          childMapping[nextKeysPending[nextKey][i]] = getValueForKey(pendingNextKey);
        }
      }
      childMapping[nextKey] = getValueForKey(nextKey);
    }

    // Finally, add the keys which didn't appear before any key in `next`
    for (i = 0; i < pendingKeys.length; i++) {
      childMapping[pendingKeys[i]] = getValueForKey(pendingKeys[i]);
    }

    return childMapping;
  }
};

module.exports = ReactTransitionChildMapping;
},{"./flattenChildren":874}],870:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');

var getVendorPrefixedEventName = require('react-dom/lib/getVendorPrefixedEventName');

var endEvents = [];

function detectEvents() {
  var animEnd = getVendorPrefixedEventName('animationend');
  var transEnd = getVendorPrefixedEventName('transitionend');

  if (animEnd) {
    endEvents.push(animEnd);
  }

  if (transEnd) {
    endEvents.push(transEnd);
  }
}

if (ExecutionEnvironment.canUseDOM) {
  detectEvents();
}

// We use the raw {add|remove}EventListener() call because EventListener
// does not know how to remove event listeners and we really should
// clean up. Also, these events are not triggered in older browsers
// so we should be A-OK here.

function addEventListener(node, eventName, eventListener) {
  node.addEventListener(eventName, eventListener, false);
}

function removeEventListener(node, eventName, eventListener) {
  node.removeEventListener(eventName, eventListener, false);
}

var ReactTransitionEvents = {
  addEndEventListener: function (node, eventListener) {
    if (endEvents.length === 0) {
      // If CSS transitions are not supported, trigger an "end animation"
      // event immediately.
      window.setTimeout(eventListener, 0);
      return;
    }
    endEvents.forEach(function (endEvent) {
      addEventListener(node, endEvent, eventListener);
    });
  },

  removeEndEventListener: function (node, eventListener) {
    if (endEvents.length === 0) {
      return;
    }
    endEvents.forEach(function (endEvent) {
      removeEventListener(node, endEvent, eventListener);
    });
  }
};

module.exports = ReactTransitionEvents;
},{"fbjs/lib/ExecutionEnvironment":588,"react-dom/lib/getVendorPrefixedEventName":838}],871:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _assign = require('object-assign');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var React = require('./React');
var ReactAddonsDOMDependencies = require('./ReactAddonsDOMDependencies');
var ReactTransitionChildMapping = require('./ReactTransitionChildMapping');

var emptyFunction = require('fbjs/lib/emptyFunction');

/**
 * A basis for animations. When children are declaratively added or removed,
 * special lifecycle hooks are called.
 * See https://facebook.github.io/react/docs/animation.html#low-level-api-reacttransitiongroup
 */

var ReactTransitionGroup = function (_React$Component) {
  _inherits(ReactTransitionGroup, _React$Component);

  function ReactTransitionGroup() {
    var _temp, _this, _ret;

    _classCallCheck(this, ReactTransitionGroup);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = _possibleConstructorReturn(this, _React$Component.call.apply(_React$Component, [this].concat(args))), _this), _this.state = {
      // TODO: can we get useful debug information to show at this point?
      children: ReactTransitionChildMapping.getChildMapping(_this.props.children)
    }, _this.performAppear = function (key) {
      _this.currentlyTransitioningKeys[key] = true;

      var component = _this.refs[key];

      if (component.componentWillAppear) {
        component.componentWillAppear(_this._handleDoneAppearing.bind(_this, key));
      } else {
        _this._handleDoneAppearing(key);
      }
    }, _this._handleDoneAppearing = function (key) {
      var component = _this.refs[key];
      if (component.componentDidAppear) {
        component.componentDidAppear();
      }

      delete _this.currentlyTransitioningKeys[key];

      var currentChildMapping;
      {
        currentChildMapping = ReactTransitionChildMapping.getChildMapping(_this.props.children);
      }

      if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {
        // This was removed before it had fully appeared. Remove it.
        _this.performLeave(key);
      }
    }, _this.performEnter = function (key) {
      _this.currentlyTransitioningKeys[key] = true;

      var component = _this.refs[key];

      if (component.componentWillEnter) {
        component.componentWillEnter(_this._handleDoneEntering.bind(_this, key));
      } else {
        _this._handleDoneEntering(key);
      }
    }, _this._handleDoneEntering = function (key) {
      var component = _this.refs[key];
      if (component.componentDidEnter) {
        component.componentDidEnter();
      }

      delete _this.currentlyTransitioningKeys[key];

      var currentChildMapping;
      {
        currentChildMapping = ReactTransitionChildMapping.getChildMapping(_this.props.children);
      }

      if (!currentChildMapping || !currentChildMapping.hasOwnProperty(key)) {
        // This was removed before it had fully entered. Remove it.
        _this.performLeave(key);
      }
    }, _this.performLeave = function (key) {
      _this.currentlyTransitioningKeys[key] = true;

      var component = _this.refs[key];
      if (component.componentWillLeave) {
        component.componentWillLeave(_this._handleDoneLeaving.bind(_this, key));
      } else {
        // Note that this is somewhat dangerous b/c it calls setState()
        // again, effectively mutating the component before all the work
        // is done.
        _this._handleDoneLeaving(key);
      }
    }, _this._handleDoneLeaving = function (key) {
      var component = _this.refs[key];

      if (component.componentDidLeave) {
        component.componentDidLeave();
      }

      delete _this.currentlyTransitioningKeys[key];

      var currentChildMapping;
      {
        currentChildMapping = ReactTransitionChildMapping.getChildMapping(_this.props.children);
      }

      if (currentChildMapping && currentChildMapping.hasOwnProperty(key)) {
        // This entered again before it fully left. Add it again.
        _this.performEnter(key);
      } else {
        _this.setState(function (state) {
          var newChildren = _assign({}, state.children);
          delete newChildren[key];
          return { children: newChildren };
        });
      }
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }

  ReactTransitionGroup.prototype.componentWillMount = function componentWillMount() {
    this.currentlyTransitioningKeys = {};
    this.keysToEnter = [];
    this.keysToLeave = [];
  };

  ReactTransitionGroup.prototype.componentDidMount = function componentDidMount() {
    var initialChildMapping = this.state.children;
    for (var key in initialChildMapping) {
      if (initialChildMapping[key]) {
        this.performAppear(key);
      }
    }
  };

  ReactTransitionGroup.prototype.componentWillReceiveProps = function componentWillReceiveProps(nextProps) {
    var nextChildMapping;
    {
      nextChildMapping = ReactTransitionChildMapping.getChildMapping(nextProps.children);
    }
    var prevChildMapping = this.state.children;

    this.setState({
      children: ReactTransitionChildMapping.mergeChildMappings(prevChildMapping, nextChildMapping)
    });

    var key;

    for (key in nextChildMapping) {
      var hasPrev = prevChildMapping && prevChildMapping.hasOwnProperty(key);
      if (nextChildMapping[key] && !hasPrev && !this.currentlyTransitioningKeys[key]) {
        this.keysToEnter.push(key);
      }
    }

    for (key in prevChildMapping) {
      var hasNext = nextChildMapping && nextChildMapping.hasOwnProperty(key);
      if (prevChildMapping[key] && !hasNext && !this.currentlyTransitioningKeys[key]) {
        this.keysToLeave.push(key);
      }
    }

    // If we want to someday check for reordering, we could do it here.
  };

  ReactTransitionGroup.prototype.componentDidUpdate = function componentDidUpdate() {
    var keysToEnter = this.keysToEnter;
    this.keysToEnter = [];
    keysToEnter.forEach(this.performEnter);

    var keysToLeave = this.keysToLeave;
    this.keysToLeave = [];
    keysToLeave.forEach(this.performLeave);
  };

  ReactTransitionGroup.prototype.render = function render() {
    // TODO: we could get rid of the need for the wrapper node
    // by cloning a single child
    var childrenToRender = [];
    for (var key in this.state.children) {
      var child = this.state.children[key];
      if (child) {
        // You may need to apply reactive updates to a child as it is leaving.
        // The normal React way to do it won't work since the child will have
        // already been removed. In case you need this behavior you can provide
        // a childFactory function to wrap every child, even the ones that are
        // leaving.
        childrenToRender.push(React.cloneElement(this.props.childFactory(child), { ref: key, key: key }));
      }
    }

    // Do not forward ReactTransitionGroup props to primitive DOM nodes
    var props = _assign({}, this.props);
    delete props.transitionLeave;
    delete props.transitionName;
    delete props.transitionAppear;
    delete props.transitionEnter;
    delete props.childFactory;
    delete props.transitionLeaveTimeout;
    delete props.transitionEnterTimeout;
    delete props.transitionAppearTimeout;
    delete props.component;

    return React.createElement(this.props.component, props, childrenToRender);
  };

  return ReactTransitionGroup;
}(React.Component);

ReactTransitionGroup.displayName = 'ReactTransitionGroup';
ReactTransitionGroup.propTypes = {
  component: React.PropTypes.any,
  childFactory: React.PropTypes.func
};
ReactTransitionGroup.defaultProps = {
  component: 'span',
  childFactory: emptyFunction.thatReturnsArgument
};


module.exports = ReactTransitionGroup;
},{"./React":852,"./ReactAddonsDOMDependencies":853,"./ReactTransitionChildMapping":869,"fbjs/lib/emptyFunction":594,"object-assign":701}],872:[function(require,module,exports){
arguments[4][802][0].apply(exports,arguments)
},{"dup":802}],873:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var canDefineProperty = false;

module.exports = canDefineProperty;
},{}],874:[function(require,module,exports){
(function (process){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * 
 */

'use strict';

var KeyEscapeUtils = require('./KeyEscapeUtils');
var traverseAllChildren = require('./traverseAllChildren');
var warning = require('fbjs/lib/warning');

var ReactComponentTreeHook;

if (typeof process !== 'undefined' && process.env && "production" === 'test') {
  // Temporary hack.
  // Inline requires don't work well with Jest:
  // https://github.com/facebook/react/issues/7240
  // Remove the inline requires when we don't need them anymore:
  // https://github.com/facebook/react/pull/7178
  ReactComponentTreeHook = require('./ReactComponentTreeHook');
}

/**
 * @param {function} traverseContext Context passed through traversal.
 * @param {?ReactComponent} child React child component.
 * @param {!string} name String name of key path to child.
 * @param {number=} selfDebugID Optional debugID of the current internal instance.
 */
function flattenSingleChildIntoContext(traverseContext, child, name, selfDebugID) {
  // We found a component instance.
  if (traverseContext && typeof traverseContext === 'object') {
    var result = traverseContext;
    var keyUnique = result[name] === undefined;
    if (keyUnique && child != null) {
      result[name] = child;
    }
  }
}

/**
 * Flattens children that are typically specified as `props.children`. Any null
 * children will not be included in the resulting object.
 * @return {!object} flattened children keyed by name.
 */
function flattenChildren(children, selfDebugID) {
  if (children == null) {
    return children;
  }
  var result = {};

  {
    traverseAllChildren(children, flattenSingleChildIntoContext, result);
  }
  return result;
}

module.exports = flattenChildren;
}).call(this,require('_process'))
},{"./KeyEscapeUtils":850,"./ReactComponentTreeHook":859,"./traverseAllChildren":878,"_process":702,"fbjs/lib/warning":607}],875:[function(require,module,exports){
arguments[4][834][0].apply(exports,arguments)
},{"dup":834}],876:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */
'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactElement = require('./ReactElement');

var invariant = require('fbjs/lib/invariant');

/**
 * Returns the first child in a collection of children and verifies that there
 * is only one child in the collection.
 *
 * See https://facebook.github.io/react/docs/top-level-api.html#react.children.only
 *
 * The current implementation of this function assumes that a single child gets
 * passed without a wrapper, but the purpose of this helper function is to
 * abstract away the particular structure of children.
 *
 * @param {?object} children Child collection structure.
 * @return {ReactElement} The first and only `ReactElement` contained in the
 * structure.
 */
function onlyChild(children) {
  !ReactElement.isValidElement(children) ? _prodInvariant('143') : void 0;
  return children;
}

module.exports = onlyChild;
},{"./ReactElement":862,"./reactProdInvariant":877,"fbjs/lib/invariant":602}],877:[function(require,module,exports){
arguments[4][843][0].apply(exports,arguments)
},{"dup":843}],878:[function(require,module,exports){
/**
 * Copyright 2013-present, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 */

'use strict';

var _prodInvariant = require('./reactProdInvariant');

var ReactCurrentOwner = require('./ReactCurrentOwner');
var REACT_ELEMENT_TYPE = require('./ReactElementSymbol');

var getIteratorFn = require('./getIteratorFn');
var invariant = require('fbjs/lib/invariant');
var KeyEscapeUtils = require('./KeyEscapeUtils');
var warning = require('fbjs/lib/warning');

var SEPARATOR = '.';
var SUBSEPARATOR = ':';

/**
 * This is inlined from ReactElement since this file is shared between
 * isomorphic and renderers. We could extract this to a
 *
 */

/**
 * TODO: Test that a single child and an array with one item have the same key
 * pattern.
 */

var didWarnAboutMaps = false;

/**
 * Generate a key string that identifies a component within a set.
 *
 * @param {*} component A component that could contain a manual key.
 * @param {number} index Index that is used if a manual key is not provided.
 * @return {string}
 */
function getComponentKey(component, index) {
  // Do some typechecking here since we call this blindly. We want to ensure
  // that we don't block potential future ES APIs.
  if (component && typeof component === 'object' && component.key != null) {
    // Explicit key
    return KeyEscapeUtils.escape(component.key);
  }
  // Implicit key determined by the index in the set
  return index.toString(36);
}

/**
 * @param {?*} children Children tree container.
 * @param {!string} nameSoFar Name of the key path so far.
 * @param {!function} callback Callback to invoke with each child found.
 * @param {?*} traverseContext Used to pass information throughout the traversal
 * process.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildrenImpl(children, nameSoFar, callback, traverseContext) {
  var type = typeof children;

  if (type === 'undefined' || type === 'boolean') {
    // All of the above are perceived as null.
    children = null;
  }

  if (children === null || type === 'string' || type === 'number' ||
  // The following is inlined from ReactElement. This means we can optimize
  // some checks. React Fiber also inlines this logic for similar purposes.
  type === 'object' && children.$$typeof === REACT_ELEMENT_TYPE) {
    callback(traverseContext, children,
    // If it's the only child, treat the name as if it was wrapped in an array
    // so that it's consistent if the number of children grows.
    nameSoFar === '' ? SEPARATOR + getComponentKey(children, 0) : nameSoFar);
    return 1;
  }

  var child;
  var nextName;
  var subtreeCount = 0; // Count of children found in the current subtree.
  var nextNamePrefix = nameSoFar === '' ? SEPARATOR : nameSoFar + SUBSEPARATOR;

  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      child = children[i];
      nextName = nextNamePrefix + getComponentKey(child, i);
      subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
    }
  } else {
    var iteratorFn = getIteratorFn(children);
    if (iteratorFn) {
      var iterator = iteratorFn.call(children);
      var step;
      if (iteratorFn !== children.entries) {
        var ii = 0;
        while (!(step = iterator.next()).done) {
          child = step.value;
          nextName = nextNamePrefix + getComponentKey(child, ii++);
          subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
        }
      } else {
        // Iterator will provide entry [k,v] tuples rather than values.
        while (!(step = iterator.next()).done) {
          var entry = step.value;
          if (entry) {
            child = entry[1];
            nextName = nextNamePrefix + KeyEscapeUtils.escape(entry[0]) + SUBSEPARATOR + getComponentKey(child, 0);
            subtreeCount += traverseAllChildrenImpl(child, nextName, callback, traverseContext);
          }
        }
      }
    } else if (type === 'object') {
      var addendum = '';
      var childrenString = String(children);
      _prodInvariant('31', childrenString === '[object Object]' ? 'object with keys {' + Object.keys(children).join(', ') + '}' : childrenString, addendum);
    }
  }

  return subtreeCount;
}

/**
 * Traverses children that are typically specified as `props.children`, but
 * might also be specified through attributes:
 *
 * - `traverseAllChildren(this.props.children, ...)`
 * - `traverseAllChildren(this.props.leftPanelChildren, ...)`
 *
 * The `traverseContext` is an optional argument that is passed through the
 * entire traversal. It can be used to store accumulations or anything else that
 * the callback might find relevant.
 *
 * @param {?*} children Children tree object.
 * @param {!function} callback To invoke upon traversing each child.
 * @param {?*} traverseContext Context for traversal.
 * @return {!number} The number of children in this subtree.
 */
function traverseAllChildren(children, callback, traverseContext) {
  if (children == null) {
    return 0;
  }

  return traverseAllChildrenImpl(children, '', callback, traverseContext);
}

module.exports = traverseAllChildren;
},{"./KeyEscapeUtils":850,"./ReactCurrentOwner":860,"./ReactElementSymbol":863,"./getIteratorFn":875,"./reactProdInvariant":877,"fbjs/lib/invariant":602,"fbjs/lib/warning":607}],879:[function(require,module,exports){
'use strict';

module.exports = require('./lib/React');

},{"./lib/React":852}],880:[function(require,module,exports){
(function(){var g={};
(function(window){var k,aa=this;aa.bd=!0;function l(a,b){var c=a.split("."),d=aa;c[0]in d||!d.execScript||d.execScript("var "+c[0]);for(var e;c.length&&(e=c.shift());)c.length||void 0===b?d[e]?d=d[e]:d=d[e]={}:d[e]=b}function ba(a){var b=p;function c(){}c.prototype=b.prototype;a.jd=b.prototype;a.prototype=new c;a.prototype.constructor=a;a.cd=function(a,c,f){return b.prototype[c].apply(a,Array.prototype.slice.call(arguments,2))}};/*

 Copyright 2016 Google Inc.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/
function ca(a){this.c=Math.exp(Math.log(.5)/a);this.a=this.b=0}function da(a,b,c){var d=Math.pow(a.c,b);a.b=c*(1-d)+d*a.b;a.a+=b}function ea(a){return a.b/(1-Math.pow(a.c,a.a))};function fa(){this.a=new ca(3);this.c=new ca(10);this.b=5E5}function ga(a){return.5>a.a.a?a.b:Math.min(ea(a.a),ea(a.c))};function ha(){}function ia(){};function ja(){this.h=null;this.f=!1;this.c=new fa;this.g={};this.a={};this.i=!1;this.b=null}l("shaka.abr.SimpleAbrManager",ja);k=ja.prototype;k.stop=function(){this.h=null;this.f=!1;this.g={};this.a={};this.b=null};k.init=function(a){this.h=a};
k.chooseStreams=function(a){for(var b in a)this.g[b]=a[b];b={};if("audio"in a){var c=ka(this);c?(b.audio=c,this.a.audio=c):delete this.a.audio}"video"in a&&((c=la(this))?(b.video=c,this.a.video=c):delete this.a.video);"text"in a&&(b.text=a.text.streams[0]);this.b=Date.now();return b};k.enable=function(){this.f=!0};k.disable=function(){this.f=!1};
k.segmentDownloaded=function(a,b,c){var d=this.c;a=b-a;65536>c||(a=Math.max(a,50),c=8E3*c/a,a/=1E3,da(d.a,a,c),da(d.c,a,c));if(null!=this.b&&this.f)a:{d=Date.now()-this.b;if(!this.i){if(4E3>d)break a;this.i=!0}else if(8E3>d)break a;d=this.a.video;c={};if(a=ka(this))c.audio=a,this.a.audio=a;if(a=la(this))c.video=a,this.a.video=a;this.b=Date.now();a=void 0;d&&c.video&&c.video.bandwidth>d.bandwidth&&(a=10);this.h(c,a)}};k.getBandwidthEstimate=function(){return ga(this.c)};
k.setDefaultEstimate=function(a){this.c.b=a};function ka(a){a=a.g.audio;if(!a)return null;a=ma(a);return a[Math.floor(a.length/2)]}function la(a){var b=a.g.video;if(!b)return null;var b=ma(b),c=a.a.audio,c=c&&c.bandwidth||0;a=ga(a.c);for(var d=b[0],e=0;e<b.length;++e){var f=b[e],g=e+1<b.length?b[e+1]:{bandwidth:Infinity};f.bandwidth&&(g=(g.bandwidth+c)/.85,a>=(f.bandwidth+c)/.95&&a<=g&&(d=f))}return d}
function ma(a){return a.streams.slice(0).filter(function(a){return a.allowedByApplication&&a.allowedByKeySystem}).sort(function(a,c){return a.bandwidth-c.bandwidth})};var na=/^(?:([^:/?#.]+):)?(?:\/\/(?:([^/?#]*)@)?([^/#?]*?)(?::([0-9]+))?(?=[/#?]|$))?([^?#]+)?(?:\?([^#]*))?(?:#(.*))?$/;function oa(a){var b;a instanceof oa?(pa(this,a.R),this.la=a.la,this.T=a.T,qa(this,a.wa),this.O=a.O,ra(this,sa(a.a)),this.ea=a.ea):a&&(b=String(a).match(na))?(pa(this,b[1]||"",!0),this.la=ta(b[2]||""),this.T=ta(b[3]||"",!0),qa(this,b[4]),this.O=ta(b[5]||"",!0),ra(this,b[6]||"",!0),this.ea=ta(b[7]||"")):this.a=new ua(null)}k=oa.prototype;k.R="";k.la="";k.T="";k.wa=null;k.O="";k.ea="";
k.toString=function(){var a=[],b=this.R;b&&a.push(va(b,wa,!0),":");if(b=this.T){a.push("//");var c=this.la;c&&a.push(va(c,wa,!0),"@");a.push(encodeURIComponent(b).replace(/%25([0-9a-fA-F]{2})/g,"%$1"));b=this.wa;null!=b&&a.push(":",String(b))}if(b=this.O)this.T&&"/"!=b.charAt(0)&&a.push("/"),a.push(va(b,"/"==b.charAt(0)?xa:ya,!0));(b=this.a.toString())&&a.push("?",b);(b=this.ea)&&a.push("#",va(b,za));return a.join("")};
k.resolve=function(a){var b=new oa(this);"data"===b.R&&(b=new oa);var c=!!a.R;c?pa(b,a.R):c=!!a.la;c?b.la=a.la:c=!!a.T;c?b.T=a.T:c=null!=a.wa;var d=a.O;if(c)qa(b,a.wa);else if(c=!!a.O){if("/"!=d.charAt(0))if(this.T&&!this.O)d="/"+d;else{var e=b.O.lastIndexOf("/");-1!=e&&(d=b.O.substr(0,e+1)+d)}if(".."==d||"."==d)d="";else if(-1!=d.indexOf("./")||-1!=d.indexOf("/.")){for(var e=!d.lastIndexOf("/",0),d=d.split("/"),f=[],g=0;g<d.length;){var h=d[g++];"."==h?e&&g==d.length&&f.push(""):".."==h?((1<f.length||
1==f.length&&""!=f[0])&&f.pop(),e&&g==d.length&&f.push("")):(f.push(h),e=!0)}d=f.join("/")}}c?b.O=d:c=""!==a.a.toString();c?ra(b,sa(a.a)):c=!!a.ea;c&&(b.ea=a.ea);return b};function pa(a,b,c){a.R=c?ta(b,!0):b;a.R&&(a.R=a.R.replace(/:$/,""))}function qa(a,b){if(b){b=Number(b);if(isNaN(b)||0>b)throw Error("Bad port number "+b);a.wa=b}else a.wa=null}function ra(a,b,c){b instanceof ua?a.a=b:(c||(b=va(b,Aa)),a.a=new ua(b))}function ta(a,b){return a?b?decodeURI(a):decodeURIComponent(a):""}
function va(a,b,c){return"string"==typeof a?(a=encodeURI(a).replace(b,Ba),c&&(a=a.replace(/%25([0-9a-fA-F]{2})/g,"%$1")),a):null}function Ba(a){a=a.charCodeAt(0);return"%"+(a>>4&15).toString(16)+(a&15).toString(16)}var wa=/[#\/\?@]/g,ya=/[\#\?:]/g,xa=/[\#\?]/g,Aa=/[\#\?@]/g,za=/#/g;function ua(a){this.b=a||null}ua.prototype.a=null;ua.prototype.c=null;
ua.prototype.toString=function(){if(this.b)return this.b;if(!this.a)return"";var a=[],b;for(b in this.a)for(var c=encodeURIComponent(b),d=this.a[b],e=0;e<d.length;e++){var f=c;""!==d[e]&&(f+="="+encodeURIComponent(d[e]));a.push(f)}return this.b=a.join("&")};function sa(a){var b=new ua;b.b=a.b;if(a.a){var c={},d;for(d in a.a)c[d]=a.a[d].concat();b.a=c;b.c=a.c}return b};function q(a,b,c){this.category=a;this.code=b;this.data=Array.prototype.slice.call(arguments,2)}l("shaka.util.Error",q);q.prototype.toString=function(){return"shaka.util.Error "+JSON.stringify(this,null,"  ")};q.Category={NETWORK:1,TEXT:2,MEDIA:3,MANIFEST:4,STREAMING:5,DRM:6,PLAYER:7,CAST:8,STORAGE:9};
q.Code={UNSUPPORTED_SCHEME:1E3,BAD_HTTP_STATUS:1001,HTTP_ERROR:1002,TIMEOUT:1003,MALFORMED_DATA_URI:1004,UNKNOWN_DATA_URI_ENCODING:1005,INVALID_TEXT_HEADER:2E3,INVALID_TEXT_CUE:2001,INVALID_TEXT_SETTINGS:2002,UNABLE_TO_DETECT_ENCODING:2003,BAD_ENCODING:2004,INVALID_XML:2005,INVALID_TTML:2006,INVALID_MP4_TTML:2007,INVALID_MP4_VTT:2008,BUFFER_READ_OUT_OF_BOUNDS:3E3,JS_INTEGER_OVERFLOW:3001,EBML_OVERFLOW:3002,EBML_BAD_FLOATING_POINT_SIZE:3003,MP4_SIDX_WRONG_BOX_TYPE:3004,MP4_SIDX_INVALID_TIMESCALE:3005,
MP4_SIDX_TYPE_NOT_SUPPORTED:3006,WEBM_CUES_ELEMENT_MISSING:3007,WEBM_EBML_HEADER_ELEMENT_MISSING:3008,WEBM_SEGMENT_ELEMENT_MISSING:3009,WEBM_INFO_ELEMENT_MISSING:3010,WEBM_DURATION_ELEMENT_MISSING:3011,WEBM_CUE_TRACK_POSITIONS_ELEMENT_MISSING:3012,WEBM_CUE_TIME_ELEMENT_MISSING:3013,MEDIA_SOURCE_OPERATION_FAILED:3014,MEDIA_SOURCE_OPERATION_THREW:3015,VIDEO_ERROR:3016,QUOTA_EXCEEDED_ERROR:3017,UNABLE_TO_GUESS_MANIFEST_TYPE:4E3,DASH_INVALID_XML:4001,DASH_NO_SEGMENT_INFO:4002,DASH_EMPTY_ADAPTATION_SET:4003,
DASH_EMPTY_PERIOD:4004,DASH_WEBM_MISSING_INIT:4005,DASH_UNSUPPORTED_CONTAINER:4006,DASH_PSSH_BAD_ENCODING:4007,DASH_NO_COMMON_KEY_SYSTEM:4008,DASH_MULTIPLE_KEY_IDS_NOT_SUPPORTED:4009,DASH_CONFLICTING_KEY_IDS:4010,UNPLAYABLE_PERIOD:4011,RESTRICTIONS_CANNOT_BE_MET:4012,INTERNAL_ERROR_KEY_STATUS:4013,INVALID_STREAMS_CHOSEN:5005,NO_RECOGNIZED_KEY_SYSTEMS:6E3,REQUESTED_KEY_SYSTEM_CONFIG_UNAVAILABLE:6001,FAILED_TO_CREATE_CDM:6002,FAILED_TO_ATTACH_TO_VIDEO:6003,INVALID_SERVER_CERTIFICATE:6004,FAILED_TO_CREATE_SESSION:6005,
FAILED_TO_GENERATE_LICENSE_REQUEST:6006,LICENSE_REQUEST_FAILED:6007,LICENSE_RESPONSE_REJECTED:6008,ENCRYPTED_CONTENT_WITHOUT_DRM_INFO:6010,NO_LICENSE_SERVER_GIVEN:6012,OFFLINE_SESSION_REMOVED:6013,EXPIRED:6014,LOAD_INTERRUPTED:7E3,CAST_API_UNAVAILABLE:8E3,NO_CAST_RECEIVERS:8001,ALREADY_CASTING:8002,UNEXPECTED_CAST_ERROR:8003,CAST_CANCELED_BY_USER:8004,CAST_CONNECTION_TIMED_OUT:8005,CAST_RECEIVER_APP_UNAVAILABLE:8006,INDEXED_DB_NOT_SUPPORTED:9E3,INDEXED_DB_ERROR:9001,OPERATION_ABORTED:9002,REQUESTED_ITEM_NOT_FOUND:9003,
MALFORMED_OFFLINE_URI:9004,CANNOT_STORE_LIVE_OFFLINE:9005,STORE_ALREADY_IN_PROGRESS:9006,NO_INIT_DATA_FOR_OFFLINE:9007};function Ca(a,b){return a.reduce(function(a,b,e){return b["catch"](a.bind(null,e))}.bind(null,b),Promise.reject())}function t(a,b){return a.concat(b)}function v(){}function Da(a){return null!=a}function Ea(a){return function(b){return b!=a}};function w(){var a,b,c=new Promise(function(c,e){a=c;b=e});c.resolve=a;c.reject=b;return c};function y(a){this.f=!1;this.a=[];this.b=[];this.c=[];this.h=a||null}l("shaka.net.NetworkingEngine.RequestType",{MANIFEST:0,SEGMENT:1,LICENSE:2});var Fa={};l("shaka.net.NetworkingEngine.registerScheme",function(a,b){Fa[a]=b});l("shaka.net.NetworkingEngine.unregisterScheme",function(a){delete Fa[a]});y.prototype.vc=function(a){this.b.push(a)};y.prototype.registerRequestFilter=y.prototype.vc;y.prototype.Xc=function(a){var b=this.b;a=b.indexOf(a);0<=a&&b.splice(a,1)};
y.prototype.unregisterRequestFilter=y.prototype.Xc;y.prototype.Ob=function(){this.b=[]};y.prototype.clearAllRequestFilters=y.prototype.Ob;y.prototype.yb=function(a){this.c.push(a)};y.prototype.registerResponseFilter=y.prototype.yb;y.prototype.Jb=function(a){var b=this.c;a=b.indexOf(a);0<=a&&b.splice(a,1)};y.prototype.unregisterResponseFilter=y.prototype.Jb;y.prototype.Pb=function(){this.c=[]};y.prototype.clearAllResponseFilters=y.prototype.Pb;
function Ga(){return{maxAttempts:2,baseDelay:1E3,backoffFactor:2,fuzzFactor:.5,timeout:0}}function Ha(a,b){return{uris:a,method:"GET",body:null,headers:{},allowCrossSiteCredentials:!1,retryParameters:b}}y.prototype.o=function(){this.f=!0;this.b=[];this.c=[];for(var a=[],b=0;b<this.a.length;++b)a.push(this.a[b]["catch"](v));return Promise.all(a)};
y.prototype.request=function(a,b){if(this.f)return Promise.reject();for(var c=Date.now(),d=this.b,e=0;e<d.length;e++)try{d[e](a,b)}catch(m){return Promise.reject(m)}for(var e=b.retryParameters||{},d=e.maxAttempts||1,f=e.backoffFactor||2,g=null==e.baseDelay?1E3:e.baseDelay,h=this.g(a,b,0),e=1;e<d;e++)h=h["catch"](this.i.bind(this,a,b,g,e%b.uris.length)),g*=f;this.a.push(h);return h.then(function(b){this.a.splice(this.a.indexOf(h),1);var d=Date.now();this.h&&1==a&&this.h(c,d,b.data.byteLength);return b}.bind(this))["catch"](function(a){this.a.splice(this.a.indexOf(h),
1);return Promise.reject(a)}.bind(this))};y.prototype.request=y.prototype.request;y.prototype.g=function(a,b,c){if(this.f)return Promise.reject();var d=new oa(b.uris[c]),e=d.R;e||(e=location.protocol,e=e.slice(0,-1),pa(d,e),b.uris[c]=d.toString());return(e=Fa[e])?e(b.uris[c],b).then(function(b){for(var c=this.c,d=0;d<c.length;d++)c[d](a,b);return b}.bind(this)):Promise.reject(new q(1,1E3,d))};
y.prototype.i=function(a,b,c,d){var e=new w,f=b.retryParameters||{};window.setTimeout(e.resolve,c*(1+(2*Math.random()-1)*(null==f.fuzzFactor?.5:f.fuzzFactor)));return e.then(this.g.bind(this,a,b,d))};function Ia(a,b,c){for(var d=0;d<a.length;++d)if(c(a[d],b))return d;return-1};function Ja(){this.a={}}k=Ja.prototype;k.push=function(a,b){this.a.hasOwnProperty(a)?this.a[a].push(b):this.a[a]=[b]};k.set=function(a,b){this.a[a]=b};k.has=function(a){return this.a.hasOwnProperty(a)};k.get=function(a){return(a=this.a[a])?a.slice():null};k.remove=function(a,b){var c=this.a[a];if(c)for(var d=0;d<c.length;++d)c[d]==b&&(c.splice(d,1),--d)};k.keys=function(){var a=[],b;for(b in this.a)a.push(b);return a};k.clear=function(){this.a={}};function z(){this.a=new Ja}z.prototype.o=function(){Ka(this);this.a=null;return Promise.resolve()};function B(a,b,c,d){b=new La(b,c,d);a.a.push(c,b)}z.prototype.ka=function(a,b){for(var c=this.a.get(b)||[],d=0;d<c.length;++d){var e=c[d];e.target==a&&(e.ka(),this.a.remove(b,e))}};function Ka(a){var b=a.a,c=[],d;for(d in b.a)c.push.apply(c,b.a[d]);for(b=0;b<c.length;++b)c[b].ka();a.a.clear()}function La(a,b,c){this.target=a;this.type=b;this.a=c;this.target.addEventListener(b,c,!1)}
La.prototype.ka=function(){this.target&&(this.target.removeEventListener(this.type,this.a,!1),this.a=this.target=null)};function Ma(a){return!a||!Object.keys(a).length}function C(a){return Object.keys(a).map(function(b){return a[b]})}function Na(a,b){return Object.keys(a).reduce(function(c,d){c[d]=b(a[d],d);return c},{})}function Oa(a,b){return Object.keys(a).every(function(c){return b(c,a[c])})};function D(a){if(!a)return"";a=new Uint8Array(a);239==a[0]&&187==a[1]&&191==a[2]&&(a=a.subarray(3));a=escape(Pa(a));try{return decodeURIComponent(a)}catch(b){throw new q(2,2004);}}function Qa(a,b){if(!a)return"";if(a.byteLength%2)throw new q(2,2004);var c;if(a instanceof ArrayBuffer)c=a;else{var d=new Uint8Array(a.byteLength);d.set(new Uint8Array(a));c=d.buffer}var d=a.byteLength/2,e=new Uint16Array(d);c=new DataView(c);for(var f=0;f<d;f++)e[f]=c.getUint16(2*f,b);return Pa(e)}
function Ra(a){var b=new Uint8Array(a);if(239==b[0]&&187==b[1]&&191==b[2])return D(b);if(254==b[0]&&255==b[1])return Qa(b.subarray(2),!1);if(255==b[0]&&254==b[1])return Qa(b.subarray(2),!0);var c=function(a,b){return a.byteLength<=b||32<=a[b]&&126>=a[b]}.bind(null,b);if(b[0]||b[2]){if(!b[1]&&!b[3])return Qa(a,!0);if(c(0)&&c(1)&&c(2)&&c(3))return D(a)}else return Qa(a,!1);throw new q(2,2003);}
function Sa(a){a=unescape(encodeURIComponent(a));for(var b=new Uint8Array(a.length),c=0;c<a.length;++c)b[c]=a.charCodeAt(c);return b.buffer}function Pa(a){for(var b="",c=0;c<a.length;c+=16E3)b+=String.fromCharCode.apply(null,a.subarray(c,c+16E3));return b};function Ta(a){this.a=null;this.b=function(){this.a=null;a()}.bind(this)}function Ua(a){null!=a.a&&(clearTimeout(a.a),a.a=null)}function Va(a){Ua(a);a.a=setTimeout(a.b,100)};function Wa(a){return window.btoa(String.fromCharCode.apply(null,a)).replace(/\+/g,"-").replace(/\//g,"_").replace(/=*$/,"")}function Xa(a){a=window.atob(a.replace(/-/g,"+").replace(/_/g,"/"));for(var b=new Uint8Array(a.length),c=0;c<a.length;++c)b[c]=a.charCodeAt(c);return b}function Ya(a){for(var b=new Uint8Array(a.length/2),c=0;c<a.length;c+=2)b[c/2]=window.parseInt(a.substr(c,2),16);return b}
function Za(a){for(var b="",c=0;c<a.length;++c){var d=a[c].toString(16);1==d.length&&(d="0"+d);b+=d}return b}function $a(a,b){if(!a&&!b)return!0;if(!a||!b||a.length!=b.length)return!1;for(var c=0;c<a.length;++c)if(a[c]!=b[c])return!1;return!0};function ab(a,b,c){this.l=this.h=this.m=null;this.A=!1;this.b=null;this.g=new z;this.a=[];this.s=[];this.j=new w;this.G=a;this.i=null;this.f=function(a){this.j.reject(a);b(a)}.bind(this);this.w={};this.J=c;this.v=new Ta(this.uc.bind(this));this.C=this.c=!1;this.j["catch"](function(){})}k=ab.prototype;
k.o=function(){this.c=!0;var a=this.a.map(function(a){a.ya.close()["catch"](v);return a.ya.closed});this.j.reject();this.g&&a.push(this.g.o());this.l&&a.push(this.l.setMediaKeys(null)["catch"](v));this.v&&Ua(this.v);this.g=this.l=this.h=this.m=this.b=this.v=null;this.a=[];this.s=[];this.f=this.i=this.G=null;return Promise.all(a)};k.configure=function(a){this.i=a};
k.init=function(a,b){var c={},d=[];this.C=b;this.s=a.offlineSessionIds;bb(this,a,b||0<a.offlineSessionIds.length,c,d);return d.length?cb(this,c,d):(this.A=!0,Promise.resolve())};
function db(a,b){if(!a.h)return B(a.g,b,"encrypted",function(){this.g.ka(b,"encrypted");this.f(new q(6,6010))}.bind(a)),Promise.resolve();a.l=b;var c=a.l.setMediaKeys(a.h),c=c["catch"](function(a){return Promise.reject(new q(6,6003,a.message))}),d=null;a.b.serverCertificate&&(d=a.h.setServerCertificate(a.b.serverCertificate),d=d["catch"](function(a){return Promise.reject(new q(6,6004,a.message))}));return Promise.all([c,d]).then(function(){if(this.c)return Promise.reject();eb(this);this.b.initData.length||
this.s.length||B(this.g,this.l,"encrypted",this.bc.bind(this))}.bind(a))["catch"](function(a){return this.c?Promise.resolve():Promise.reject(a)}.bind(a))}function fb(a,b){return Promise.all(b.map(function(a){return gb(this,a).then(function(a){if(a)return a.remove()})}.bind(a)))}function eb(a){var b=a.b?a.b.initData:[];b.forEach(function(a){hb(this,a.initDataType,a.initData)}.bind(a));a.s.forEach(function(a){gb(this,a)}.bind(a));b.length||a.s.length||a.j.resolve();return a.j}
k.keySystem=function(){return this.b?this.b.keySystem:""};function ib(a){return a.a.map(function(a){return a.ya.sessionId})}
function bb(a,b,c,d,e){var f=kb(a),g=0<=navigator.userAgent.indexOf("Edge/");b.periods.forEach(function(a){a.streamSets.forEach(function(a){"text"!=a.type&&(f&&(a.drmInfos=[f]),a.drmInfos.forEach(function(b){lb(this,b);var f=d[b.keySystem];f||(f={audioCapabilities:[],videoCapabilities:[],distinctiveIdentifier:"optional",persistentState:c?"required":"optional",sessionTypes:[c?"persistent-license":"temporary"],label:b.keySystem,drmInfos:[]},d[b.keySystem]=f,e.push(b.keySystem));f.drmInfos.push(b);b.distinctiveIdentifierRequired&&
(f.distinctiveIdentifier="required");b.persistentStateRequired&&(f.persistentState="required");var h="video"==a.type?f.videoCapabilities:f.audioCapabilities,A=("video"==a.type?b.videoRobustness:b.audioRobustness)||"";a.streams.forEach(function(a){var c=a.mimeType;a.codecs&&(c+='; codecs="'+a.codecs+'"');g&&"com.microsoft.playready"==b.keySystem&&h.length||h.push({robustness:A,contentType:c})}.bind(this))}.bind(this)))}.bind(this))}.bind(a))}
function cb(a,b,c){if(1==c.length&&""==c[0])return Promise.reject(new q(6,6E3));var d=new w,e=d;[!0,!1].forEach(function(a){c.forEach(function(c){var d=b[c];d.drmInfos.some(function(a){return!!a.licenseServerUri})==a&&(d.audioCapabilities.length||delete d.audioCapabilities,d.videoCapabilities.length||delete d.videoCapabilities,e=e["catch"](function(){return this.c?Promise.reject():navigator.requestMediaKeySystemAccess(c,[d])}.bind(this)))}.bind(this))}.bind(a));e=e["catch"](function(){return Promise.reject(new q(6,
6001))});e=e.then(function(a){if(this.c)return Promise.reject();var c=a.getConfiguration();this.m=(c.audioCapabilities||[]).concat(c.videoCapabilities||[]).map(function(a){return a.contentType});this.m.length||(this.m=null);c=b[a.keySystem];mb(this,a.keySystem,c,c.drmInfos);return this.b.licenseServerUri?a.createMediaKeys():Promise.reject(new q(6,6012))}.bind(a)).then(function(a){if(this.c)return Promise.reject();this.h=a;this.A=!0}.bind(a))["catch"](function(a){if(this.c)return Promise.resolve();
this.m=this.b=null;return a instanceof q?Promise.reject(a):Promise.reject(new q(6,6002,a.message))}.bind(a));d.reject();return e}
function lb(a,b){var c=b.keySystem;if(c){if(!b.licenseServerUri){var d=a.i.servers[c];d&&(b.licenseServerUri=d)}if(c=a.i.advanced[c])b.distinctiveIdentifierRequired||(b.distinctiveIdentifierRequired=c.distinctiveIdentifierRequired),b.persistentStateRequired||(b.persistentStateRequired=c.persistentStateRequired),b.videoRobustness||(b.videoRobustness=c.videoRobustness),b.audioRobustness||(b.audioRobustness=c.audioRobustness),b.serverCertificate||(b.serverCertificate=c.serverCertificate)}}
function kb(a){if(Ma(a.i.clearKeys))return null;var b=[],c=[],d;for(d in a.i.clearKeys){var e=a.i.clearKeys[d],f=Ya(d),e=Ya(e),f={kty:"oct",kid:Wa(f),k:Wa(e)};b.push(f);c.push(f.kid)}a=JSON.stringify({keys:b});c=JSON.stringify({kids:c});c=[{initData:new Uint8Array(Sa(c)),initDataType:"keyids"}];return{keySystem:"org.w3.clearkey",licenseServerUri:"data:application/json;base64,"+window.btoa(a),distinctiveIdentifierRequired:!1,persistentStateRequired:!1,audioRobustness:"",videoRobustness:"",serverCertificate:null,
initData:c}}function mb(a,b,c,d){var e=[],f=[],g=[];nb(d,e,f,g);a.b={keySystem:b,licenseServerUri:e[0],distinctiveIdentifierRequired:"required"==c.distinctiveIdentifier,persistentStateRequired:"required"==c.persistentState,audioRobustness:c.audioCapabilities?c.audioCapabilities[0].robustness:"",videoRobustness:c.videoCapabilities?c.videoCapabilities[0].robustness:"",serverCertificate:f[0],initData:g}}
function nb(a,b,c,d){function e(a,b){return a.initDataType==b.initDataType&&$a(a.initData,b.initData)}a.forEach(function(a){-1==b.indexOf(a.licenseServerUri)&&b.push(a.licenseServerUri);a.serverCertificate&&-1==Ia(c,a.serverCertificate,$a)&&c.push(a.serverCertificate);a.initData&&a.initData.forEach(function(a){-1==Ia(d,a,e)&&d.push(a)})})}k.bc=function(a){for(var b=new Uint8Array(a.initData),c=0;c<this.a.length;++c)if($a(b,this.a[c].initData))return;hb(this,a.initDataType,b)};
function gb(a,b){var c;try{c=a.h.createSession("persistent-license")}catch(f){var d=new q(6,6005,f.message);a.f(d);return Promise.reject(d)}B(a.g,c,"message",a.vb.bind(a));B(a.g,c,"keystatuseschange",a.qb.bind(a));var e={initData:null,ya:c,loaded:!1};a.a.push(e);return c.load(b).then(function(a){if(!this.c){if(a)return e.loaded=!0,this.a.every(function(a){return a.loaded})&&this.j.resolve(),c;this.a.splice(this.a.indexOf(e),1);this.f(new q(6,6013))}}.bind(a),function(a){this.c||(this.a.splice(this.a.indexOf(e),
1),this.f(new q(6,6005,a.message)))}.bind(a))}function hb(a,b,c){var d;try{d=a.C?a.h.createSession("persistent-license"):a.h.createSession()}catch(e){a.f(new q(6,6005,e.message));return}B(a.g,d,"message",a.vb.bind(a));B(a.g,d,"keystatuseschange",a.qb.bind(a));a.a.push({initData:c,ya:d,loaded:!1});d.generateRequest(b,c.buffer)["catch"](function(a){if(!this.c){for(var b=0;b<this.a.length;++b)if(this.a[b].ya==d){this.a.splice(b,1);break}this.f(new q(6,6006,a.message))}}.bind(a))}
k.vb=function(a){var b=a.target,c=Ha([this.b.licenseServerUri],this.i.retryParameters);c.body=a.message;c.method="POST";"com.microsoft.playready"==this.b.keySystem&&pb(c);this.G.request(2,c).then(function(a){return this.c?Promise.reject():b.update(a.data)}.bind(this),function(a){if(this.c)return Promise.resolve();this.f(new q(6,6007,a))}.bind(this))["catch"](function(a){if(this.c)return Promise.resolve();this.f(new q(6,6008,a.message))}.bind(this))};
function pb(a){for(var b=Qa(a.body,!0),b=(new DOMParser).parseFromString(b,"application/xml"),c=b.getElementsByTagName("HttpHeader"),d=0;d<c.length;++d)a.headers[c[d].querySelector("name").textContent]=c[d].querySelector("value").textContent;a.body=Xa(b.querySelector("Challenge").textContent).buffer}
k.qb=function(a){a=a.target;var b;for(b=0;b<this.a.length&&this.a[b].ya!=a;++b);if(b!=this.a.length){var c=a.keyStatuses,d=!1;c.forEach||(c=[]);c.forEach(function(a,c){if("string"==typeof c){var g=c;c=a;a=g}if("com.microsoft.playready"==this.b.keySystem&&16==c.byteLength){var g=new DataView(c),h=g.getUint32(0,!0),m=g.getUint16(4,!0),n=g.getUint16(6,!0);g.setUint32(0,h,!1);g.setUint16(4,m,!1);g.setUint16(6,n,!1)}"com.microsoft.playready"==this.b.keySystem&&"status-pending"==a&&(a="usable");"status-pending"!=
a&&"internal-error"!=a&&(this.a[b].loaded=!0,this.a.every(function(a){return a.loaded})&&this.j.resolve());"expired"==a&&(d=!0);g=Za(new Uint8Array(c));"internal-error"==a&&this.f(new q(6,4013,g));this.w[g]=a}.bind(this));c=a.expiration-Date.now();if(0>c||d&&1E3>c)this.a.splice(b,1),a.close();Va(this.v)}};k.uc=function(){Oa(this.w,function(a,b){return"expired"==b})&&this.f(new q(6,6014));this.J(this.w)};
function qb(){var a=[],b=[{contentType:'video/mp4; codecs="avc1.42E01E"'}],c=[{videoCapabilities:b,persistentState:"required",sessionTypes:["persistent-license"]},{videoCapabilities:b}],d={};"org.w3.clearkey com.widevine.alpha com.microsoft.playready com.apple.fps.2_0 com.apple.fps.1_0 com.apple.fps com.adobe.primetime".split(" ").forEach(function(b){var f=navigator.requestMediaKeySystemAccess(b,c).then(function(a){return a.createMediaKeys()}).then(function(a){var c=!1;try{a.createSession("persistent-license"),
c=!0}catch(f){}d[b]={persistentState:c}},function(){d[b]=null});a.push(f)});return Promise.all(a).then(function(){return d})};var rb={},sb={};l("shaka.media.ManifestParser.registerParserByExtension",function(a,b){sb[a]=b});l("shaka.media.ManifestParser.registerParserByMime",function(a,b){rb[a]=b});function tb(){var a={},b;for(b in rb)a[b]=!0;for(b in sb)a[b]=!0;["application/dash+xml","application/x-mpegurl","application/vnd.apple.mpegurl","application/vnd.ms-sstr+xml"].forEach(function(b){a[b]=!!rb[b]});["mpd","m3u8","ism"].forEach(function(b){a[b]=!!sb[b]});return a}
function ub(a,b,c,d){var e=d;e||(d=(new oa(a)).O.split("/").pop().split("."),1<d.length&&(d=d.pop().toLowerCase(),e=sb[d]));if(e)return Promise.resolve(e);c=Ha([a],c);c.method="HEAD";return b.request(0,c).then(function(b){(b=b.headers["content-type"])&&(b=b.toLowerCase());return(e=rb[b])?e:Promise.reject(new q(4,4E3,a))},function(){return Promise.reject(new q(4,4E3,a))})};function vb(a,b){this.g=E[b];this.c=a;this.h=0;this.f=Infinity;this.a=this.b=null}var E={};l("shaka.media.TextEngine.registerParser",function(a,b){E[a]=b});l("shaka.media.TextEngine.unregisterParser",function(a){delete E[a]});function wb(a,b,c){return a>=b?null:new xb(a,b,c)}l("shaka.media.TextEngine.makeCue",wb);var xb=window.VTTCue||window.TextTrackCue;vb.prototype.o=function(){this.c&&yb(this,function(){return!0});this.c=this.g=null;return Promise.resolve()};
function zb(a,b,c,d){var e=a.h;return Promise.resolve().then(function(){var a=this.g(b,e,c,d);if(null!=c&&null!=d){for(var g=0;g<a.length&&!(a[g].startTime>=this.f);++g)this.c.addCue(a[g]);null==this.b&&(this.b=c);this.a=Math.min(d,this.f)}}.bind(a))}
vb.prototype.remove=function(a,b){return Promise.resolve().then(function(){yb(this,function(c){return c.startTime>=b||c.endTime<=a?!1:!0});null==this.b||b<=this.b||a>=this.a||(a<=this.b&&b>=this.a?this.b=this.a=null:a<=this.b&&b<this.a?this.b=b:a>this.b&&b>=this.a&&(this.a=a))}.bind(this))};function Ab(a,b){return null==a.a||a.a<b||b<a.b?0:a.a-b}function yb(a,b){for(var c=a.c.cues,d=[],e=0;e<c.length;++e)b(c[e])&&d.push(c[e]);for(e=0;e<d.length;++e)a.c.removeCue(d[e])};function Bb(a,b){var c=0;if(!a||1==a.length&&1E-6>a.end(0)-a.start(0))return c;for(var d=!1,e=0;e<a.length;++e)if(b+1E-4>=a.start(e)&&b<a.end(e))c+=a.end(e)-b,d=!0;else if(d&&.04>=a.start(e)-a.end(e-1))c+=a.end(e)-a.start(e),c+=a.start(e)-a.end(e-1);else if(0<e&&b+1E-4<a.start(e)&&b+1E-4>=a.end(e-1))if(.04>=a.start(e)-b)c+=a.end(e)-b,d=!0;else break;else d=!1;return c};function Cb(a,b,c){this.i=a;this.f=b;this.j=c;this.c={};this.b=null;this.a={};this.g=new z;this.h=!1}
function Db(){var a={};'video/mp4; codecs="avc1.42E01E",audio/mp4; codecs="mp4a.40.2",video/webm; codecs="vp8",video/webm; codecs="vp9",audio/webm; codecs="vorbis",audio/webm; codecs="opus",video/mp2t; codecs="avc1.42E01E",video/mp2t; codecs="mp4a.40.2",text/vtt,application/mp4; codecs="wvtt",application/ttml+xml,application/mp4; codecs="stpp"'.split(",").forEach(function(b){a[b]=!!E[b]||MediaSource.isTypeSupported(b);var c=b.split(";")[0];a[c]=a[c]||a[b]});return a}k=Cb.prototype;
k.o=function(){this.h=!0;var a=[],b;for(b in this.a){var c=this.a[b],d=c[0];this.a[b]=c.slice(0,1);d&&a.push(d.p["catch"](v));for(d=1;d<c.length;++d)c[d].p["catch"](v),c[d].p.reject()}this.b&&a.push(this.b.o());return Promise.all(a).then(function(){this.g.o();this.b=this.j=this.f=this.i=this.g=null;this.c={};this.a={}}.bind(this))};
k.init=function(a){for(var b in a){var c=a[b];"text"==b?this.b=new vb(this.j,c):(c=this.f.addSourceBuffer(c),B(this.g,c,"error",this.Rc.bind(this,b)),B(this.g,c,"updateend",this.Fa.bind(this,b)),this.c[b]=c,this.a[b]=[])}};function Eb(a,b){var c;"text"==b?c=a.b.b:(c=Fb(a,b),c=!c||1==c.length&&1E-6>c.end(0)-c.start(0)?null:c.length?c.start(0):null);return c}function Gb(a,b,c){"text"==b?(b=Ab(a.b,c),b||(b=Ab(a.b,c+.1))&&(b+=.1)):(a=Fb(a,b),b=Bb(a,c),b||(b=Bb(a,c+.1))&&(b+=.1));return b}
function Fb(a,b){try{return a.c[b].buffered}catch(c){return null}}function Hb(a,b,c,d,e){return"text"==b?zb(a.b,c,d,e):Ib(a,b,a.Qc.bind(a,b,c))}k.remove=function(a,b,c){return"text"==a?this.b.remove(b,c):Promise.all([Ib(this,a,this.Ab.bind(this,a,b,c)),Ib(this,a,this.ib.bind(this,a))])};k.clear=function(a){return"text"==a?this.b.remove(0,Infinity):Ib(this,a,this.Ab.bind(this,a,0,this.f.duration))};function Jb(a,b,c){return"text"==b?(a.b.h=c,Promise.resolve()):Ib(a,b,a.Gc.bind(a,b,c))}
function Kb(a,b,c){return"text"==b?(a.b.f=c,Promise.resolve()):Promise.all([Ib(a,b,a.ib.bind(a,b)),Ib(a,b,a.Ec.bind(a,b,c))])}k.endOfStream=function(a){return Lb(this,function(){a?this.f.endOfStream(a):this.f.endOfStream()}.bind(this))};k.za=function(a){return Lb(this,function(){this.f.duration=a}.bind(this))};k.Z=function(){return this.f.duration};k.Qc=function(a,b){this.c[a].appendBuffer(b)};k.Ab=function(a,b,c){c<=b?this.Fa(a):this.c[a].remove(b,c)};
k.ib=function(a){var b=this.c[a].appendWindowEnd;this.c[a].abort();this.c[a].appendWindowEnd=b;this.Fa(a)};k.Gc=function(a,b){this.c[a].timestampOffset=b;this.Fa(a)};k.Ec=function(a,b){this.c[a].appendWindowEnd=b+.04;this.Fa(a)};k.Rc=function(a){this.a[a][0].p.reject(new q(3,3014,this.i.error?this.i.error.code:0))};k.Fa=function(a){var b=this.a[a][0];b&&(b.p.resolve(),Mb(this,a))};
function Ib(a,b,c){if(a.h)return Promise.reject();c={start:c,p:new w};a.a[b].push(c);if(1==a.a[b].length)try{c.start()}catch(d){"QuotaExceededError"==d.name?c.p.reject(new q(3,3017,b)):c.p.reject(new q(3,3015,d)),Mb(a,b)}return c.p}
function Lb(a,b){if(a.h)return Promise.reject();var c=[],d;for(d in a.c){var e=new w,f={start:function(a){a.resolve()}.bind(null,e),p:e};a.a[d].push(f);c.push(e);1==a.a[d].length&&f.start()}return Promise.all(c).then(function(){var a,c;try{b()}catch(d){c=Promise.reject(new q(3,3015,d))}for(a in this.c)Mb(this,a);return c}.bind(a),function(){return Promise.reject()}.bind(a))}function Mb(a,b){a.a[b].shift();var c=a.a[b][0];if(c)try{c.start()}catch(d){c.p.reject(new q(3,3015,d)),Mb(a,b)}};function F(a,b){this.j=a;this.i=b;this.c=this.a=Infinity;this.b=1;this.h=this.f=0;this.g=!0}l("shaka.media.PresentationTimeline",F);F.prototype.Z=function(){return this.a};F.prototype.getDuration=F.prototype.Z;F.prototype.za=function(a){this.a=a};F.prototype.setDuration=F.prototype.za;F.prototype.Eb=function(a){this.h=a};F.prototype.setClockOffset=F.prototype.Eb;F.prototype.Hb=function(a){this.g=a};F.prototype.setStatic=F.prototype.Hb;F.prototype.Ub=function(){return this.c};
F.prototype.getSegmentAvailabilityDuration=F.prototype.Ub;F.prototype.Gb=function(a){this.c=a};F.prototype.setSegmentAvailabilityDuration=F.prototype.Gb;F.prototype.Ea=function(a,b){b.length&&(this.b=b.reduce(function(a,b){return Math.max(a,b.endTime-b.startTime)},this.b),a||(this.f=Math.max(this.f,b[0].startTime)))};F.prototype.notifySegments=F.prototype.Ea;F.prototype.Xa=function(a){this.b=Math.max(this.b,a)};F.prototype.notifyMaxSegmentDuration=F.prototype.Xa;
F.prototype.U=function(){return Infinity==this.a&&!this.g};F.prototype.isLive=F.prototype.U;F.prototype.ga=function(){return Infinity!=this.a&&!this.g};F.prototype.isInProgress=F.prototype.ga;F.prototype.ra=function(){return Math.max(Math.min(this.f,this.fa()),this.sa())};F.prototype.getEarliestStart=F.prototype.ra;F.prototype.sa=function(){return Infinity==this.c?0:Math.max(0,this.fa()-this.c-this.i)};F.prototype.getSegmentAvailabilityStart=F.prototype.sa;
F.prototype.fa=function(){return this.U()||this.ga()?Math.min(Math.max(0,(Date.now()+this.h)/1E3-this.b-this.j),this.a):this.a};F.prototype.getSegmentAvailabilityEnd=F.prototype.fa;F.prototype.Ta=function(){return Math.max(0,this.fa()-(this.U()||this.ga()?this.i:0))};F.prototype.getSeekRangeEnd=F.prototype.Ta;function Nb(a,b,c,d,e,f){this.a=a;this.c=b;this.i=c;this.m=d;this.j=e;this.l=f;this.b=new z;this.h=!1;this.g=1;this.f=null;0<a.readyState?this.rb():B(this.b,a,"loadedmetadata",this.rb.bind(this));B(this.b,a,"ratechange",this.ic.bind(this))}k=Nb.prototype;k.o=function(){var a=this.b.o();this.b=null;null!=this.f&&(window.clearInterval(this.f),this.f=null);this.l=this.j=this.c=this.a=null;return a};function Ob(a){return 0<a.a.readyState?Pb(a,a.a.currentTime):Qb(a)}
function Qb(a){return a.m?Pb(a,a.m):Infinity>a.c.Z()?a.c.ra():Math.max(a.c.Ta(),a.c.ra())}function Rb(a,b){b!=a.h&&(a.h=b,Sb(a,a.g),a.j(b))}k.Sa=function(){return this.g};function Sb(a,b){null!=a.f&&(window.clearInterval(a.f),a.f=null);a.g=b;a.a.playbackRate=a.h||0>b?0:b;!a.h&&0>b&&(a.f=window.setInterval(function(){this.a.currentTime+=b/4}.bind(a),250))}k.ic=function(){this.a.playbackRate!=(this.h||0>this.g?0:this.g)&&Sb(this,this.a.playbackRate)};
k.rb=function(){this.b.ka(this.a,"loadedmetadata");var a=Qb(this);.001>Math.abs(this.a.currentTime-a)?(B(this.b,this.a,"seeking",this.tb.bind(this)),B(this.b,this.a,"playing",this.sb.bind(this))):(B(this.b,this.a,"seeking",this.kc.bind(this)),this.a.currentTime=a)};k.kc=function(){this.b.ka(this.a,"seeking");B(this.b,this.a,"seeking",this.tb.bind(this));B(this.b,this.a,"playing",this.sb.bind(this))};k.tb=function(){var a=this.a.currentTime,b=Tb(this,a);.001<Math.abs(b-a)?Ub(this,a,b):this.l()};
k.sb=function(){var a=this.a.currentTime,b=Tb(this,a);.001<Math.abs(b-a)&&Ub(this,a,b)};function Tb(a,b){var c=a.c,d=c.ra(),e=c.fa();if(!c.U()||Infinity==c.c)return b<d?d:b>e?e:b;c=d+1;d=c+a.i;return b>=d&&b<=e||Bb(a.a.buffered,b)&&b>=c&&b<=e?b:b>e?e:e<d&&b>=c&&b<=e?b:Math.min(d+2,e)}function Ub(a,b,c){a.a.currentTime=c;var d=0,e=function(){!this.a||10<=d++||this.a.currentTime!=b||(this.a.currentTime=c,setTimeout(e,100))}.bind(a);setTimeout(e,100)}
function Pb(a,b){var c=a.c.ra();if(b<c)return c;c=a.c.fa();return b>c?c:b};function Vb(a,b,c){this.a=a;this.L=b;this.D=c}l("shaka.media.InitSegmentReference",Vb);function G(a,b,c,d,e,f){this.position=a;this.startTime=b;this.endTime=c;this.a=d;this.L=e;this.D=f}l("shaka.media.SegmentReference",G);function Wb(a,b,c,d,e,f,g,h,m){this.i=a;this.c=b;this.S=c;this.a=d;this.J=e;this.w=f;this.l=g;this.A=h||null;this.C=m||null;this.g=null;this.j=1;this.G=Promise.resolve();this.h=[];this.m={};this.b={};this.f=this.s=this.v=!1}Wb.prototype.o=function(){for(var a in this.b)Xb(this.b[a]);this.g=this.b=this.m=this.h=this.C=this.A=this.l=this.w=this.J=this.G=this.a=this.S=this.c=this.i=null;this.f=!0;return Promise.resolve()};
Wb.prototype.configure=function(a){this.g=a;this.i.i=this.j*Math.max(this.a.minBufferTime||0,this.g.rebufferingGoal)};Wb.prototype.init=function(){var a=this.J(this.a.periods[Yb(this,Ob(this.i))]);return Ma(a)?Promise.reject(new q(5,5005)):Zb(this,a).then(function(){this.A&&this.A()}.bind(this))};function $b(a){return a.a.periods[Yb(a,Ob(a.i))]}function ac(a){return Na(a.b,function(a){return a.stream})}function bc(a,b){var c={};c.text=b;return Zb(a,c)}
function cc(a,b,c,d){var e=a.b[b];!e&&"text"==b&&a.g.ignoreTextStreamFailures?bc(a,c):e&&(b=a.h[dc(a,c)])&&b.xa&&(b=a.m[c.id])&&b.xa&&e.stream!=c&&(e.stream=c,e.La=!0,void 0==d||e.ca||e.da||(e.ha?ec(e,d):(Xb(e),fc(a,e,d))))}function ec(a,b){a.ca?a.Ka=Math.min(a.Ka,b):(a.ca=!0,a.Ka=b)}
function Zb(a,b){var c=Yb(a,Ob(a.i)),d=Na(b,function(a){return a.mimeType+(a.codecs?'; codecs="'+a.codecs+'"':"")});a.c.init(d);gc(a);d=C(b);return hc(a,d).then(function(){if(!this.f)for(var a in b){var d=b[a];this.b[a]||(this.b[a]={stream:d,type:a,ta:null,V:null,La:!0,va:!1,Ma:c,endOfStream:!1,ha:!1,ba:null,ca:!1,Ka:0,da:!1,ab:!1},ic(this,this.b[a],0))}}.bind(a))}
function jc(a,b){var c=a.h[b];if(c)return c.I;c={I:new w,xa:!1};a.h[b]=c;var d=a.a.periods[b].streamSets.map(function(a){return a.streams}).reduce(t,[]);a.G=a.G.then(function(){if(!this.f)return hc(this,d)}.bind(a)).then(function(){this.f||(this.h[b].I.resolve(),this.h[b].xa=!0)}.bind(a))["catch"](function(a){this.f||(this.h[b].I.reject(),delete this.h[b],this.l(a))}.bind(a));return c.I}
function hc(a,b){for(var c=[],d=0;d<b.length;++d){var e=b[d],f=a.m[e.id];f?c.push(f.I):(a.m[e.id]={I:new w,xa:!1},c.push(e.createSegmentIndex()))}return Promise.all(c).then(function(){if(!this.f)for(var a=0;a<b.length;++a){var c=this.m[b[a].id];c.xa||(c.I.resolve(),c.xa=!0)}}.bind(a))["catch"](function(a){if(!this.f)return this.m[e.id].I.reject(),delete this.m[e.id],Promise.reject(a)}.bind(a))}function gc(a){var b=a.a.presentationTimeline.Z();Infinity>b?a.c.za(b):a.c.za(Math.pow(2,32))}
Wb.prototype.X=function(a){if(!this.f&&!a.ha&&null!=a.ba&&!a.da)if(a.ba=null,a.ca)fc(this,a,a.Ka);else{try{var b=kc(this,a);null!=b&&ic(this,a,b)}catch(c){this.l(c);return}b=C(this.b);Rb(this.i,b.some(function(a){return a.va}));lc(this,a);b.every(function(a){return a.endOfStream})&&this.c.endOfStream()}};
function kc(a,b){var c=Ob(a.i),d;d=a.c;var e=b.type;"text"==e?d=d.b.a:(d=Fb(d,e),d=!d||1==d.length&&1E-6>d.end(0)-d.start(0)?null:d.length?d.end(d.length-1):null);var f=b.ta&&b.V?a.a.periods[dc(a,b.ta)].startTime+b.V.endTime:c,e=Yb(a,f),g=a.a.periods[e],h=mc(a,b,c,d,e),h=h?g.startTime+h.startTime-c:Gb(a.c,b.type,c),g=a.j*Math.max(a.a.minBufferTime||0,a.g.rebufferingGoal);if(h>=Math.max(g,a.j*a.g.bufferingGoal))return b.va=!1,.5;if(f>=a.a.presentationTimeline.Z())return b.va=!1,b.endOfStream=!0,null;
b.endOfStream=!1;!a.v&&h<g||1>=h?b.va=!0:h>=g&&(b.va=!1);f=dc(a,b.stream);if(e!=f)return b.Ma=e,null;h=mc(a,b,c,d,f);if(!h)return 1;nc(a,b,c,f,h);return null}
function mc(a,b,c,d,e){if(b.V&&b.stream==b.ta)return c=b.V.position+1,oc(a,b,e,c);c=b.V?b.stream.findSegmentPosition(Math.max(0,a.a.periods[dc(a,b.ta)].startTime+b.V.endTime-a.a.periods[e].startTime)):b.stream.findSegmentPosition(Math.max(0,(d||c)-a.a.periods[e].startTime));if(null==c)return null;var f=null;null==d&&(f=oc(a,b,e,Math.max(0,c-1)));return f||oc(a,b,e,c)}
function oc(a,b,c,d){c=a.a.periods[c];b=b.stream.getSegmentReference(d);if(!b)return null;a=a.a.presentationTimeline;d=a.fa();return c.startTime+b.endTime<a.sa()||c.startTime+b.startTime>d?null:b}
function nc(a,b,c,d,e){var f=a.a.periods[d],g=b.stream,h=a.a.periods[d+1],m=null,m=h?h.startTime:a.a.presentationTimeline.Z();d=pc(a,b,d,m);b.ha=!0;b.La=!1;h=qc(a,e);Promise.all([d,h]).then(function(a){if(!this.f&&!this.s)return rc(this,b,c,f,g,e,a[1])}.bind(a)).then(function(){this.f||this.s||(b.ha=!1,b.ab=!1,ic(this,b,0),sc(this,g))}.bind(a))["catch"](function(a){this.f||this.s||(b.ha=!1,1001==a.code||1002==a.code||1003==a.code?"text"==b.type&&this.g.ignoreTextStreamFailures&&1001==a.code?delete this.b.text:
(this.l(a),ic(this,b,4)):3017==a.code?tc(this,b,a):this.l(a))}.bind(a))}function tc(a,b,c){if(!C(a.b).some(function(a){return a!=b&&a.ab})){var d=Math.round(100*a.j);if(20<d)a.j-=.2;else if(4<d)a.j-=.04;else{a.s=!0;a.l(c);return}b.ab=!0}ic(a,b,b.va?0:4)}
function pc(a,b,c,d){if(!b.La)return Promise.resolve();c=Jb(a.c,b.type,a.a.periods[c].startTime-b.stream.presentationTimeOffset);d=null!=d?Kb(a.c,b.type,d):Promise.resolve();if(!b.stream.initSegmentReference)return Promise.all([c,d]);a=qc(a,b.stream.initSegmentReference).then(function(a){if(!this.f)return Hb(this.c,b.type,a,null,null)}.bind(a))["catch"](function(a){b.La=!0;return Promise.reject(a)});return Promise.all([c,d,a])}
function rc(a,b,c,d,e,f,g){return uc(a,b,c).then(function(){if(!this.f)return Hb(this.c,b.type,g,f.startTime+d.startTime,f.endTime+d.startTime)}.bind(a)).then(function(){if(!this.f)return b.ta=e,b.V=f,Promise.resolve()}.bind(a))}function uc(a,b,c){var d=Eb(a.c,b.type);if(null==d)return Promise.resolve();c=c-d-a.g.bufferBehind;return 0>=c?Promise.resolve():a.c.remove(b.type,d,d+c).then(function(){}.bind(a))}
function sc(a,b){if(!a.v&&(a.v=C(a.b).every(function(a){return!a.ca&&!a.da&&a.V}),a.v)){var c=dc(a,b);a.h[c]||jc(a,c).then(function(){this.w()}.bind(a))["catch"](v);for(c=0;c<a.a.periods.length;++c)jc(a,c)["catch"](v);a.C&&a.C()}}
function lc(a,b){if(b.Ma!=dc(a,b.stream)){var c=b.Ma,d=C(a.b);d.every(function(a){return a.Ma==c})&&d.every(vc)&&jc(a,c).then(function(){if(!this.f){var a=this.J(this.a.periods[c]),b;for(b in this.b)if(!a[b]){this.l(new q(5,5005));return}for(b in a)if(!(this.b[b]||"text"==b&&this.g.ignoreTextStreamFailures)){this.l(new q(5,5005));return}for(b in this.b){cc(this,b,a[b]);var d=this.b[b];vc(d)&&ic(this,d,0)}this.w()}}.bind(a))["catch"](v)}}function vc(a){return!a.ha&&null==a.ba&&!a.ca&&!a.da}
function Yb(a,b){for(var c=a.a.periods.length-1;0<c;--c)if(b>=a.a.periods[c].startTime)return c;return 0}function dc(a,b){for(var c=0;c<a.a.periods.length;++c)for(var d=a.a.periods[c],e=0;e<d.streamSets.length;++e)if(0<=d.streamSets[e].streams.indexOf(b))return c;return-1}function qc(a,b){var c=Ha(b.a(),a.g.retryParameters);if(b.L||null!=b.D){var d="bytes="+b.L+"-";null!=b.D&&(d+=b.D);c.headers.Range=d}return a.S.request(1,c).then(function(a){return a.data})}
function fc(a,b,c){b.ca=!1;b.da=!0;var d=Ob(a.i)+c,e=a.c.Z();(c?a.c.remove(b.type,d,e):a.c.clear(b.type)).then(function(){this.f||(b.ta=null,b.V=null,b.da=!1,ic(this,b,0))}.bind(a))}function ic(a,b,c){b.ba=window.setTimeout(a.X.bind(a,b),1E3*c)}function Xb(a){null!=a.ba&&(window.clearTimeout(a.ba),a.ba=null)};function wc(){this.a=Promise.resolve();this.c=this.b=this.f=!1;this.g=new Promise(function(a){this.h=a}.bind(this))}wc.prototype.then=function(a){this.a=this.a.then(a).then(function(a){return this.c?(this.h(),Promise.reject(this.i)):Promise.resolve(a)}.bind(this));return this};function xc(a){a.f||(a.a=a.a.then(function(a){this.b=!0;return Promise.resolve(a)}.bind(a),function(a){this.b=!0;return Promise.reject(a)}.bind(a)));a.f=!0;return a.a}
function yc(a,b){if(a.b)return Promise.resolve();a.c=!0;a.i=b;return a.g};function zc(a,b,c,d,e){var f=e in d,g;for(g in b){var h=e+"."+g,m=f?d[e]:c[g],n=!!{".abr.manager":!0}[h];if(f||g in a)void 0===b[g]?void 0===m||f?delete a[g]:a[g]=m:n?a[g]=b[g]:"object"==typeof a[g]&&"object"==typeof b[g]?zc(a[g],b[g],m,d,h):typeof b[g]==typeof m&&(a[g]=b[g])}};function H(a,b){var c=b||{},d;for(d in c)this[d]=c[d];this.defaultPrevented=this.cancelable=this.bubbles=!1;this.timeStamp=window.performance?window.performance.now():Date.now();this.type=a;this.isTrusted=!1;this.target=this.currentTarget=null;this.a=!1}H.prototype.preventDefault=function(){};H.prototype.stopImmediatePropagation=function(){this.a=!0};H.prototype.stopPropagation=function(){};function p(){this.Aa=new Ja;this.S=this}p.prototype.addEventListener=function(a,b){this.Aa.push(a,b)};p.prototype.removeEventListener=function(a,b){this.Aa.remove(a,b)};p.prototype.dispatchEvent=function(a){for(var b=this.Aa.get(a.type)||[],c=0;c<b.length;++c){a.target=this.S;a.currentTarget=this.S;var d=b[c];try{d.handleEvent?d.handleEvent(a):d.call(this,a)}catch(e){}if(a.a)break}return a.defaultPrevented};function Ac(a,b,c){return c==b||a>=Bc&&c==b.split("-")[0]||a>=Cc&&c.split("-")[0]==b.split("-")[0]?!0:!1}var Bc=1,Cc=2;function Dc(a){a=a.toLowerCase().split("-");var b=Ec[a[0]];b&&(a[0]=b);return a.join("-")}
var Ec={aar:"aa",abk:"ab",afr:"af",aka:"ak",alb:"sq",amh:"am",ara:"ar",arg:"an",arm:"hy",asm:"as",ava:"av",ave:"ae",aym:"ay",aze:"az",bak:"ba",bam:"bm",baq:"eu",bel:"be",ben:"bn",bih:"bh",bis:"bi",bod:"bo",bos:"bs",bre:"br",bul:"bg",bur:"my",cat:"ca",ces:"cs",cha:"ch",che:"ce",chi:"zh",chu:"cu",chv:"cv",cor:"kw",cos:"co",cre:"cr",cym:"cy",cze:"cs",dan:"da",deu:"de",div:"dv",dut:"nl",dzo:"dz",ell:"el",eng:"en",epo:"eo",est:"et",eus:"eu",ewe:"ee",fao:"fo",fas:"fa",fij:"fj",fin:"fi",fra:"fr",fre:"fr",
fry:"fy",ful:"ff",geo:"ka",ger:"de",gla:"gd",gle:"ga",glg:"gl",glv:"gv",gre:"el",grn:"gn",guj:"gu",hat:"ht",hau:"ha",heb:"he",her:"hz",hin:"hi",hmo:"ho",hrv:"hr",hun:"hu",hye:"hy",ibo:"ig",ice:"is",ido:"io",iii:"ii",iku:"iu",ile:"ie",ina:"ia",ind:"id",ipk:"ik",isl:"is",ita:"it",jav:"jv",jpn:"ja",kal:"kl",kan:"kn",kas:"ks",kat:"ka",kau:"kr",kaz:"kk",khm:"km",kik:"ki",kin:"rw",kir:"ky",kom:"kv",kon:"kg",kor:"ko",kua:"kj",kur:"ku",lao:"lo",lat:"la",lav:"lv",lim:"li",lin:"ln",lit:"lt",ltz:"lb",lub:"lu",
lug:"lg",mac:"mk",mah:"mh",mal:"ml",mao:"mi",mar:"mr",may:"ms",mkd:"mk",mlg:"mg",mlt:"mt",mon:"mn",mri:"mi",msa:"ms",mya:"my",nau:"na",nav:"nv",nbl:"nr",nde:"nd",ndo:"ng",nep:"ne",nld:"nl",nno:"nn",nob:"nb",nor:"no",nya:"ny",oci:"oc",oji:"oj",ori:"or",orm:"om",oss:"os",pan:"pa",per:"fa",pli:"pi",pol:"pl",por:"pt",pus:"ps",que:"qu",roh:"rm",ron:"ro",rum:"ro",run:"rn",rus:"ru",sag:"sg",san:"sa",sin:"si",slk:"sk",slo:"sk",slv:"sl",sme:"se",smo:"sm",sna:"sn",snd:"sd",som:"so",sot:"st",spa:"es",sqi:"sq",
srd:"sc",srp:"sr",ssw:"ss",sun:"su",swa:"sw",swe:"sv",tah:"ty",tam:"ta",tat:"tt",tel:"te",tgk:"tg",tgl:"tl",tha:"th",tib:"bo",tir:"ti",ton:"to",tsn:"tn",tso:"ts",tuk:"tk",tur:"tr",twi:"tw",uig:"ug",ukr:"uk",urd:"ur",uzb:"uz",ven:"ve",vie:"vi",vol:"vo",wel:"cy",wln:"wa",wol:"wo",xho:"xh",yid:"yi",yor:"yo",zha:"za",zho:"zh",zul:"zu"};function Fc(a,b,c){var d=!1;a.streamSets.forEach(function(a){a.streams.forEach(function(f){var g=f.allowedByApplication;f.allowedByApplication=!0;if("video"==a.type){if(f.width<b.minWidth||f.width>b.maxWidth||f.width>c.width||f.height<b.minHeight||f.height>b.maxHeight||f.height>c.height||f.width*f.height<b.minPixels||f.width*f.height>b.maxPixels||f.bandwidth<b.minVideoBandwidth||f.bandwidth>b.maxVideoBandwidth)f.allowedByApplication=!1}else"audio"==a.type&&(f.bandwidth<b.minAudioBandwidth||f.bandwidth>
b.maxAudioBandwidth)&&(f.allowedByApplication=!1);g!=f.allowedByApplication&&(d=!0)})});return d}
function Gc(a,b,c){var d="",e=null;a&&a.A&&(d=a.keySystem(),e=a.m);for(a=0;a<c.streamSets.length;++a){var f=c.streamSets[a];if(d&&f.drmInfos.length&&!f.drmInfos.some(function(a){return a.keySystem==d}))c.streamSets.splice(a,1),--a;else{for(var g=b[f.type],h=0;h<f.streams.length;++h){var m=f.streams[h],n=m.mimeType;m.codecs&&(n+='; codecs="'+m.codecs+'"');E[n]||MediaSource.isTypeSupported(n)?e&&m.encrypted&&0>e.indexOf(n)?(f.streams.splice(h,1),--h):!g||m.mimeType==g.mimeType&&m.codecs.split(".")[0]==
g.codecs.split(".")[0]||(f.streams.splice(h,1),--h):(f.streams.splice(h,1),--h)}f.streams.length||(c.streamSets.splice(a,1),--a)}}}function Hc(a,b){return a.streamSets.map(function(a){var d=b?b[a.type]:null;return a.streams.filter(function(a){return a.allowedByApplication&&a.allowedByKeySystem}).map(function(b){return{id:b.id,active:d==b,type:a.type,bandwidth:b.bandwidth,language:a.language,kind:b.kind||null,width:b.width||null,height:b.height||null}})}).reduce(t,[])}
function Ic(a,b){for(var c=0;c<a.streamSets.length;c++)for(var d=a.streamSets[c],e=0;e<d.streams.length;e++){var f=d.streams[e];if(f.id==b.id)return{stream:f,Tc:d}}return null}function Jc(a){return a.streams.some(function(a){return a.allowedByApplication&&a.allowedByKeySystem})}
function Kc(a,b,c){var d={};a.streamSets.forEach(function(a){!Jc(a)||a.type in d||(d[a.type]=a)});var e=0;a.streamSets.forEach(function(a){if(Jc(a)&&"video"==a.type){var b=Lc(a);b>e?(e=b,d.video=a):b==e&&Mc(a)<Mc(d.video)&&(d.video=a)}});a.streamSets.forEach(function(a){Jc(a)&&a.primary&&(d[a.type].primary?Mc(a)<Mc(d[a.type])&&(d[a.type]=a):d[a.type]=a)});[Cc,Bc,0].forEach(function(e){a.streamSets.forEach(function(a){if(Jc(a)){var h;"audio"==a.type?h=b.preferredAudioLanguage:"text"==a.type&&(h=b.preferredTextLanguage);
if(h){h=Dc(h);var m=Dc(a.language);Ac(e,h,m)&&(a.language==d[a.type].language?Mc(a)<Mc(d[a.type])&&(d[a.type]=a):d[a.type]=a,c&&(c[a.type]=!0))}}})});return d}function Mc(a){var b=0;if(!a||1>a.streams.length)return b;a.streams.forEach(function(a){b+=a.bandwidth});return b/a.streams.length}function Lc(a){var b=0;if(!a)return b;a.streams.forEach(function(a){a.height>b&&(b=a.height)});return b};function I(a,b){p.call(this);this.w=!1;this.f=a;this.m=null;this.v=new z;this.hb=new ja;this.na=this.c=this.l=this.b=this.i=this.oa=this.G=this.A=this.g=this.h=null;this.Kb=1E9;this.ma=[];this.Pa=!1;this.qa=!0;this.j=null;this.s={};this.a=Nc(this);this.Ba={width:Infinity,height:Infinity};this.C=[];this.X=this.J=this.pa=0;b&&b(this);this.h=new y(this.Lc.bind(this));this.oa=Oc(this);for(var c=0;c<this.f.textTracks.length;++c){var d=this.f.textTracks[c];d.mode="disabled";"Shaka Player TextTrack"==d.label&&
(this.m=d)}this.m||(this.m=this.f.addTextTrack("subtitles","Shaka Player TextTrack"));this.m.mode="hidden";B(this.v,this.f,"error",this.lc.bind(this))}ba(I);l("shaka.Player",I);I.prototype.o=function(){this.w=!0;var a=Promise.resolve();this.j&&(a=yc(this.j,new q(7,7E3)));return a.then(function(){var a=Promise.all([Pc(this),this.v?this.v.o():null,this.h?this.h.o():null]);this.a=this.h=this.hb=this.v=this.m=this.f=null;return a}.bind(this))};I.prototype.destroy=I.prototype.o;I.version="v2.0.0";
var Qc={};I.registerSupportPlugin=function(a,b){Qc[a]=b};I.isBrowserSupported=function(){return!!window.Promise&&!!window.Uint8Array&&!!Array.prototype.forEach&&!!window.MediaSource&&!!window.MediaKeys&&!!window.navigator&&!!window.navigator.requestMediaKeySystemAccess&&!!window.MediaKeySystemAccess&&!!window.MediaKeySystemAccess.prototype.getConfiguration};I.probeSupport=function(){return qb().then(function(a){var b=tb(),c=Db();a={manifest:b,media:c,drm:a};for(var d in Qc)a[d]=Qc[d]();return a})};
I.prototype.load=function(a,b,c){var d=this.gb(),e=new wc;this.j=e;this.dispatchEvent(new H("loading"));return xc(e.then(function(){return d}).then(function(){return ub(a,this.h,this.a.manifest.retryParameters,c)}.bind(this)).then(function(b){this.l=new b;this.l.configure(this.a.manifest);return this.l.start(a,this.h,this.Na.bind(this),this.aa.bind(this),this.Ic.bind(this))}.bind(this)).then(function(b){this.c=b;this.na=a;this.g=new ab(this.h,this.aa.bind(this),this.Jc.bind(this));this.g.configure(this.a.drm);
return this.g.init(b,!1)}.bind(this)).then(function(){this.c.periods.forEach(this.Na.bind(this));this.X=Date.now()/1E3;return Promise.all([db(this.g,this.f),this.oa])}.bind(this)).then(function(){this.i=new Nb(this.f,this.c.presentationTimeline,1*Math.max(this.c.minBufferTime||0,this.a.streaming.rebufferingGoal),b||null,this.Ib.bind(this),this.Kc.bind(this));this.G=new Cb(this.f,this.A,this.m);this.b=new Wb(this.i,this.G,this.h,this.c,this.Hc.bind(this),this.Mb.bind(this),this.aa.bind(this));this.b.configure(this.a.streaming);
return this.b.init()}.bind(this)).then(function(){this.c.periods.forEach(this.Na.bind(this));Rc(this);Sc(this);this.a.abr.manager.init(this.eb.bind(this));this.j=null}.bind(this)))["catch"](function(a){this.j==e&&(this.j=null,this.dispatchEvent(new H("unloading")));return Promise.reject(a)}.bind(this))};I.prototype.load=I.prototype.load;function Oc(a){a.A=new MediaSource;var b=new w;B(a.v,a.A,"sourceopen",b.resolve);a.f.src=window.URL.createObjectURL(a.A);return b}
I.prototype.configure=function(a){a.abr&&a.abr.manager&&a.abr.manager!=this.a.abr.manager&&(this.a.abr.manager.stop(),a.abr.manager.init(this.eb.bind(this)));zc(this.a,a,Nc(this),Tc(),"");Uc(this)};I.prototype.configure=I.prototype.configure;
function Uc(a){a.l&&a.l.configure(a.a.manifest);a.g&&a.g.configure(a.a.drm);a.b&&(a.b.configure(a.a.streaming),a.c.periods.forEach(a.Na.bind(a)),Vc(a,$b(a.b)));a.a.abr.enabled&&!a.qa?a.a.abr.manager.enable():a.a.abr.manager.disable();a.a.abr.manager.setDefaultEstimate(a.a.abr.defaultBandwidthEstimate)}I.prototype.getConfiguration=function(){var a=Nc(this);zc(a,this.a,Nc(this),Tc(),"");return a};I.prototype.getConfiguration=I.prototype.getConfiguration;
I.prototype.zc=function(){var a=Nc(this);a.abr&&a.abr.manager&&a.abr.manager!=this.a.abr.manager&&(this.a.abr.manager.stop(),a.abr.manager.init(this.eb.bind(this)));this.a=Nc(this);Uc(this)};I.prototype.resetConfiguration=I.prototype.zc;I.prototype.nb=function(){return this.h};I.prototype.getNetworkingEngine=I.prototype.nb;I.prototype.Sb=function(){return this.na};I.prototype.getManifestUri=I.prototype.Sb;I.prototype.U=function(){return this.c?this.c.presentationTimeline.U():!1};
I.prototype.isLive=I.prototype.U;I.prototype.ga=function(){return this.c?this.c.presentationTimeline.ga():!1};I.prototype.isInProgress=I.prototype.ga;I.prototype.Cc=function(){var a=0,b=0;this.c&&(b=this.c.presentationTimeline,a=b.sa(),b=b.Ta());return{start:a,end:b}};I.prototype.seekRange=I.prototype.Cc;I.prototype.keySystem=function(){return this.g?this.g.keySystem():""};I.prototype.keySystem=I.prototype.keySystem;I.prototype.drmInfo=function(){return this.g?this.g.b:null};I.prototype.drmInfo=I.prototype.drmInfo;
I.prototype.Wb=function(){return this.Pa};I.prototype.isBuffering=I.prototype.Wb;I.prototype.gb=function(){if(this.w)return Promise.resolve();this.dispatchEvent(new H("unloading"));if(this.j){var a=new q(7,7E3);return yc(this.j,a).then(this.Bb.bind(this))}return this.Bb()};I.prototype.unload=I.prototype.gb;I.prototype.Sa=function(){return this.i?this.i.Sa():0};I.prototype.getPlaybackRate=I.prototype.Sa;I.prototype.Wc=function(a){this.i&&Sb(this.i,a)};I.prototype.trickPlay=I.prototype.Wc;
I.prototype.Nb=function(){this.i&&Sb(this.i,1)};I.prototype.cancelTrickPlay=I.prototype.Nb;I.prototype.getTracks=function(){if(!this.b)return[];var a=ac(this.b);return Hc($b(this.b),a).filter(function(a){return 0>this.ma.indexOf(a.id)}.bind(this))};I.prototype.getTracks=I.prototype.getTracks;
I.prototype.Dc=function(a,b){if(this.b){var c=Ic($b(this.b),a);if(c&&(c=c.stream,c.allowedByApplication&&c.allowedByKeySystem)){this.C.push({timestamp:Date.now()/1E3,id:c.id,type:a.type,fromAdaptation:!1});"text"!=a.type&&this.configure({abr:{enabled:!1}});var d={};d[a.type]=c;Wc(this,d,b)}}};I.prototype.selectTrack=I.prototype.Dc;I.prototype.Zb=function(){return"showing"==this.m.mode};I.prototype.isTextTrackVisible=I.prototype.Zb;I.prototype.Fc=function(a){this.m.mode=a?"showing":"hidden";Xc(this)};
I.prototype.setTextTrackVisibility=I.prototype.Fc;
I.prototype.getStats=function(){Yc(this);var a={},b={},c=this.f&&this.f.getVideoPlaybackQuality?this.f.getVideoPlaybackQuality():{};this.b&&(b=ac(this.b),a=b.video||{},b=b.audio||{});return{width:a.width||0,height:a.height||0,streamBandwidth:a.bandwidth+b.bandwidth||0,decodedFrames:Number(c.totalVideoFrames),droppedFrames:Number(c.droppedVideoFrames),estimatedBandwidth:this.a.abr.manager.getBandwidthEstimate(),playTime:this.pa,bufferingTime:this.J,switchHistory:this.C.slice(0)}};
I.prototype.getStats=I.prototype.getStats;
I.prototype.addTextTrack=function(a,b,c,d,e){if(!this.b)return Promise.reject();for(var f=$b(this.b),g,h=0;h<this.c.periods.length;h++)if(this.c.periods[h]==f){if(h==this.c.periods.length-1){if(g=this.c.presentationTimeline.Z()-f.startTime,Infinity==g)return Promise.reject()}else g=this.c.periods[h+1].startTime-f.startTime;break}var m={id:this.Kb++,createSegmentIndex:Promise.resolve.bind(Promise),findSegmentPosition:function(){return 1},getSegmentReference:function(b){return 1!=b?null:new G(1,0,g,
function(){return[a]},0,null)},initSegmentReference:null,presentationTimeOffset:0,mimeType:d,codecs:e||"",bandwidth:0,kind:c,encrypted:!1,keyId:null,language:b,allowedByApplication:!0,allowedByKeySystem:!0};d={language:b,type:"text",primary:!1,drmInfos:[],streams:[m]};this.ma.push(m.id);f.streamSets.push(d);return bc(this.b,m).then(function(){if(!this.w)return this.ma.splice(this.ma.indexOf(m.id),1),Vc(this,f),Rc(this),{id:m.id,active:!1,type:"text",bandwidth:0,language:b,kind:c,width:null,height:null}}.bind(this))};
I.prototype.addTextTrack=I.prototype.addTextTrack;I.prototype.Fb=function(a,b){this.Ba.width=a;this.Ba.height=b};I.prototype.setMaxHardwareResolution=I.prototype.Fb;
function Pc(a){a.v&&a.v.ka(a.A,"sourceopen");a.f&&(a.f.removeAttribute("src"),a.f.load());var b=Promise.all([a.a?a.a.abr.manager.stop():null,a.g?a.g.o():null,a.G?a.G.o():null,a.i?a.i.o():null,a.b?a.b.o():null,a.l?a.l.stop():null]);a.g=null;a.G=null;a.i=null;a.b=null;a.l=null;a.c=null;a.na=null;a.oa=null;a.A=null;a.s={};a.C=[];a.pa=0;a.J=0;return b}k=I.prototype;k.Bb=function(){return this.l?Pc(this).then(function(){this.w||(this.Ib(!1),this.oa=Oc(this))}.bind(this)):Promise.resolve()};
function Tc(){return{".drm.servers":"",".drm.clearKeys":"",".drm.advanced":{distinctiveIdentifierRequired:!1,persistentStateRequired:!1,videoRobustness:"",audioRobustness:"",serverCertificate:null}}}
function Nc(a){return{drm:{retryParameters:Ga(),servers:{},clearKeys:{},advanced:{}},manifest:{retryParameters:Ga(),dash:{customScheme:function(a){if(a)return null},clockSyncUri:""}},streaming:{retryParameters:Ga(),rebufferingGoal:2,bufferingGoal:30,bufferBehind:30,ignoreTextStreamFailures:!1},abr:{manager:a.hb,enabled:!0,defaultBandwidthEstimate:5E5},preferredAudioLanguage:"",preferredTextLanguage:"",restrictions:{minWidth:0,maxWidth:Infinity,minHeight:0,maxHeight:Infinity,minPixels:0,maxPixels:Infinity,
minAudioBandwidth:0,maxAudioBandwidth:Infinity,minVideoBandwidth:0,maxVideoBandwidth:Infinity}}}k.Na=function(a){var b=this.b?ac(this.b):{};Gc(this.g,b,a);b=a.streamSets.some(Jc);Fc(a,this.a.restrictions,this.Ba)&&!this.j&&Rc(this);a=!a.streamSets.some(Jc);b?a&&this.aa(new q(4,4012)):this.aa(new q(4,4011))};function Wc(a,b,c){for(var d in b){var e=b[d],f=c||"text"==d;a.qa?a.s[d]={stream:e,clear:f}:cc(a.b,d,e,f?0:void 0)}}
function Yc(a){if(a.c){var b=Date.now()/1E3;a.Pa?a.J+=b-a.X:a.pa+=b-a.X;a.X=b}}k.Lc=function(a,b,c){this.a.abr.manager.segmentDownloaded(a,b,c)};k.Ib=function(a){Yc(this);this.Pa=a;this.dispatchEvent(new H("buffering",{buffering:a}))};k.Kc=function(){if(this.b){var a=this.b,b;for(b in a.b){var c=a.b[b];c.da||0<Gb(a.c,b,Ob(a.i))||c.ca||(c.ha?ec(c,0):null==Eb(a.c,b)?null==c.ba&&ic(a,c,0):(Xb(c),fc(a,c,0)))}}};
function Zc(a,b,c){if(!C(b).some(Jc))return a.aa(new q(4,4012)),{};var d={};if(c)d=b;else{c=ac(a.b);for(var e in c){var f=c[e];f.allowedByApplication&&f.allowedByKeySystem&&b[e].language==f.language||(d[e]=b[e])}}if(Ma(d))return{};ia(Object.keys(d));var g=a.a.abr.manager.chooseStreams(d);return Oa(d,function(a){return!!g[a]})?g:(a.aa(new q(4,4012)),{})}
function Vc(a,b){var c={audio:!1,text:!1},d=Kc(b,a.a,c),e=Zc(a,d),f;for(f in e)a.C.push({timestamp:Date.now()/1E3,id:e[f].id,type:f,fromAdaptation:!0});Wc(a,e,!0);Sc(a);d.text&&d.audio&&c.text&&d.text.language!=d.audio.language&&(a.m.mode="showing",Xc(a))}k.Hc=function(a){this.qa=!0;this.a.abr.manager.disable();a=Kc(a,this.a);a=Zc(this,a,!0);for(var b in this.s)a[b]=this.s[b].stream;this.s={};for(b in a)this.C.push({timestamp:Date.now()/1E3,id:a[b].id,type:b,fromAdaptation:!0});this.j||Rc(this);return a};
k.Mb=function(){this.qa=!1;this.a.abr.enabled&&this.a.abr.manager.enable();for(var a in this.s){var b=this.s[a];cc(this.b,a,b.stream,b.clear?0:void 0)}this.s={}};k.eb=function(a,b){var c=ac(this.b),d;for(d in a){var e=a[d];c[d]!=e?this.C.push({timestamp:Date.now()/1E3,id:e.id,type:d,fromAdaptation:!0}):delete a[d]}if(!Ma(a)&&this.b){for(d in a)cc(this.b,d,a[d],"video"==d?b:void 0);Sc(this)}};
function Sc(a){Promise.resolve().then(function(){this.w||this.dispatchEvent(new H("adaptation"))}.bind(a))}function Rc(a){Promise.resolve().then(function(){this.w||this.dispatchEvent(new H("trackschanged"))}.bind(a))}function Xc(a){a.dispatchEvent(new H("texttrackvisibility"))}k.aa=function(a){this.dispatchEvent(new H("error",{detail:a}))};k.Ic=function(a){this.dispatchEvent(a)};
k.lc=function(){if(this.f.error){var a=this.f.error.code;if(1!=a){var b=this.f.error.msExtendedCode;b&&(0>b&&(b+=Math.pow(2,32)),b=b.toString(16));this.aa(new q(3,3016,a,b))}}};k.Jc=function(a){var b=$b(this.b),c=!1;b.streamSets.forEach(function(b){b.streams.forEach(function(b){var d=b.allowedByKeySystem;b.keyId&&b.keyId in a&&(b.allowedByKeySystem="output-restricted"!=a[b.keyId]);d!=b.allowedByKeySystem&&(c=!0)})});Vc(this,b);c&&Rc(this)};var $c="ended play playing pause pausing ratechange seeked seeking timeupdate volumechange".split(" "),ad="buffered currentTime duration ended loop muted paused playbackRate seeking videoHeight videoWidth volume".split(" "),cd=["loop","playbackRate"],dd=["pause","play"],ed=["adaptation","buffering","error","texttrackvisibility","trackschanged"],fd="getConfiguration getManifestUri getPlaybackRate getTracks getStats isBuffering isLive isTextTrackVisible seekRange".split(" "),gd=[["getConfiguration",
"configure"]],hd=[["isTextTrackVisible","setTextTrackVisibility"]],id="configure resetConfiguration trickPlay cancelTrickPlay selectTrack setTextTrackVisibility addTextTrack".split(" "),jd=["load","unload"];
function kd(a){return JSON.stringify(a,function(a,c){if("manager"!=a&&"function"!=typeof c){if(c instanceof Event||c instanceof H){var d={},e;for(e in c){var f=c[e];f&&"object"==typeof f||e in Event||(d[e]=f)}return d}if(c instanceof TimeRanges)for(d={__type__:"TimeRanges",length:c.length,start:[],end:[]},e=0;e<c.length;++e)d.start.push(c.start(e)),d.end.push(c.end(e));else d="number"==typeof c?isNaN(c)?"NaN":isFinite(c)?c:0>c?"-Infinity":"Infinity":c;return d}})}
function ld(a){return JSON.parse(a,function(a,c){return"NaN"==c?NaN:"-Infinity"==c?-Infinity:"Infinity"==c?Infinity:c&&"object"==typeof c&&"TimeRanges"==c.__type__?md(c):c})}function md(a){return{length:a.length,start:function(b){return a.start[b]},end:function(b){return a.end[b]}}};function nd(a,b,c,d,e){this.C=a;this.l=b;this.w=c;this.A=d;this.s=e;this.f=this.j=this.h=!1;this.v="";this.a=this.i=null;this.b={video:{},player:{}};this.m=0;this.c={};this.g=null}k=nd.prototype;k.o=function(){od(this);this.a&&(this.a.stop(function(){},function(){}),this.a=null);this.A=this.w=this.l=null;this.f=this.j=this.h=!1;this.g=this.c=this.b=this.a=this.i=null;return Promise.resolve()};k.N=function(){return this.f};k.$a=function(){return this.v};
k.init=function(){if(window.chrome&&chrome.cast&&chrome.cast.isAvailable){delete window.__onGCastApiAvailable;this.h=!0;this.l();var a=new chrome.cast.SessionRequest(this.C),a=new chrome.cast.ApiConfig(a,this.cc.bind(this),this.jc.bind(this),"origin_scoped");chrome.cast.initialize(a,function(){},function(){})}else window.__onGCastApiAvailable=function(a){a&&this.init()}.bind(this)};k.bb=function(a){this.i=a;this.f&&pd(this,{type:"appData",appData:this.i})};
k.cast=function(a){if(!this.h)return Promise.reject(new q(8,8E3));if(!this.j)return Promise.reject(new q(8,8001));if(this.f)return Promise.reject(new q(8,8002));this.g=new w;chrome.cast.requestSession(this.Ya.bind(this,a),this.ob.bind(this));return this.g};
k.get=function(a,b){if("video"==a){if(0<=dd.indexOf(b))return this.zb.bind(this,a,b)}else if("player"==a){if(0<=id.indexOf(b))return this.zb.bind(this,a,b);if(0<=jd.indexOf(b))return this.xc.bind(this,a,b);if(0<=fd.indexOf(b))return this.wb.bind(this,a,b)}return this.wb(a,b)};k.set=function(a,b,c){this.b[a][b]=c;pd(this,{type:"set",targetName:a,property:b,value:c})};
k.Ya=function(a,b){this.a=b;this.a.addUpdateListener(this.pb.bind(this));this.a.addMessageListener("urn:x-cast:com.google.shaka.v2",this.dc.bind(this));this.pb();pd(this,{type:"init",initState:a,appData:this.i});this.g.resolve()};k.ob=function(a){var b=8003;switch(a.code){case "cancel":b=8004;break;case "timeout":b=8005;break;case "receiver_unavailable":b=8006}this.g.reject(new q(8,b,a))};k.wb=function(a,b){return this.b[a][b]};
k.zb=function(a,b){pd(this,{type:"call",targetName:a,methodName:b,args:Array.prototype.slice.call(arguments,2)})};k.xc=function(a,b){var c=Array.prototype.slice.call(arguments,2),d=new w,e=this.m.toString();this.m++;this.c[e]=d;pd(this,{type:"asyncCall",targetName:a,methodName:b,args:c,id:e});return d};k.cc=function(a){var b=this.s();this.g=new w;this.Ya(b,a)};k.jc=function(a){this.j="available"==a;this.l()};
k.pb=function(){var a=this.a?"connected"==this.a.status:!1;if(this.f&&!a){this.A();for(var b in this.b)this.b[b]={};od(this)}this.v=(this.f=a)?this.a.receiver.friendlyName:"";this.l()};function od(a){for(var b in a.c){var c=a.c[b];delete a.c[b];c.reject(new q(7,7E3))}}
k.dc=function(a,b){var c=ld(b);switch(c.type){case "event":var d=c.targetName,e=c.event;this.w(d,new H(e.type,e));break;case "update":e=c.update;for(d in e){var c=this.b[d]||{},f;for(f in e[d])c[f]=e[d][f]}break;case "asyncComplete":if(d=c.id,f=c.error,c=this.c[d],delete this.c[d],c)if(f){d=new q(f.category,f.code);for(e in f)d[e]=f[e];c.reject(d)}else c.resolve()}};function pd(a,b){var c=kd(b);a.a.sendMessage("urn:x-cast:com.google.shaka.v2",c,function(){},ha)};function J(a,b,c){p.call(this);this.c=a;this.b=b;this.h=this.f=this.g=this.i=this.j=null;this.a=new nd(c,this.Mc.bind(this),this.Nc.bind(this),this.Oc.bind(this),this.mb.bind(this));qd(this)}ba(J);l("shaka.cast.CastProxy",J);J.prototype.o=function(){var a=[this.h?this.h.o():null,this.b?this.b.o():null,this.a?this.a.o():null];this.a=this.h=this.i=this.j=this.b=this.c=null;return Promise.all(a)};J.prototype.destroy=J.prototype.o;J.prototype.Vb=function(){return this.j};J.prototype.getVideo=J.prototype.Vb;
J.prototype.Tb=function(){return this.i};J.prototype.getPlayer=J.prototype.Tb;J.prototype.Lb=function(){return this.a?this.a.h&&this.a.j:!1};J.prototype.canCast=J.prototype.Lb;J.prototype.N=function(){return this.a?this.a.N():!1};J.prototype.isCasting=J.prototype.N;J.prototype.$a=function(){return this.a?this.a.$a():""};J.prototype.receiverName=J.prototype.$a;J.prototype.cast=function(){var a=this.mb();return this.a.cast(a).then(function(){return this.b.gb()}.bind(this))};J.prototype.cast=J.prototype.cast;
J.prototype.bb=function(a){this.a.bb(a)};J.prototype.setAppData=J.prototype.bb;J.prototype.Uc=function(){var a=this.a;if(a.f){var b=a.s();chrome.cast.requestSession(a.Ya.bind(a,b),a.ob.bind(a))}};J.prototype.suggestDisconnect=J.prototype.Uc;
function qd(a){a.a.init();a.h=new z;$c.forEach(function(a){B(this.h,this.c,a,this.$c.bind(this))}.bind(a));ed.forEach(function(a){B(this.h,this.b,a,this.tc.bind(this))}.bind(a));a.j={};for(var b in a.c)Object.defineProperty(a.j,b,{configurable:!1,enumerable:!0,get:a.Zc.bind(a,b),set:a.ad.bind(a,b)});a.i={};for(b in a.b)Object.defineProperty(a.i,b,{configurable:!1,enumerable:!0,get:a.sc.bind(a,b)});a.g=new p;a.g.S=a.j;a.f=new p;a.f.S=a.i}k=J.prototype;
k.mb=function(){var a={video:{},player:{},playerAfterLoad:{},manifest:this.b.na,startTime:null};this.c.pause();cd.forEach(function(b){a.video[b]=this.c[b]}.bind(this));this.c.ended||(a.startTime=this.c.currentTime);gd.forEach(function(b){var c=b[1];b=this.b[b[0]]();a.player[c]=b}.bind(this));hd.forEach(function(b){var c=b[1];b=this.b[b[0]]();a.playerAfterLoad[c]=b}.bind(this));return a};k.Mc=function(){this.dispatchEvent(new H("caststatuschanged"))};
k.Oc=function(){gd.forEach(function(a){var b=a[1];a=this.a.get("player",a[0])();this.b[b](a)}.bind(this));var a=this.a.get("player","getManifestUri")(),b=this.a.get("video","ended"),c=Promise.resolve(),d=this.c.autoplay,e=null;b||(e=this.a.get("video","currentTime"));a&&(this.c.autoplay=!1,c=this.b.load(a,e),c["catch"](function(a){this.b.dispatchEvent(new H("error",{detail:a}))}.bind(this)));var f={};cd.forEach(function(a){f[a]=this.a.get("video",a)}.bind(this));c.then(function(){cd.forEach(function(a){this.c[a]=
f[a]}.bind(this));hd.forEach(function(a){var b=a[1];a=this.a.get("player",a[0])();this.b[b](a)}.bind(this));this.c.autoplay=d;a&&this.c.play()}.bind(this))};
k.Zc=function(a){if("addEventListener"==a)return this.g.addEventListener.bind(this.g);if("removeEventListener"==a)return this.g.removeEventListener.bind(this.g);if(this.a.N()&&!Object.keys(this.a.b.video).length){var b=this.c[a];if("function"!=typeof b)return b}return this.a.N()?this.a.get("video",a):(b=this.c[a],"function"==typeof b&&(b=b.bind(this.c)),b)};k.ad=function(a,b){this.a.N()?this.a.set("video",a,b):this.c[a]=b};k.$c=function(a){this.a.N()||this.g.dispatchEvent(new H(a.type,a))};
k.sc=function(a){return"addEventListener"==a?this.f.addEventListener.bind(this.f):"removeEventListener"==a?this.f.removeEventListener.bind(this.f):"getNetworkingEngine"==a?this.b.nb.bind(this.b):this.a.N()&&!Object.keys(this.a.b.video).length&&0<=fd.indexOf(a)||!this.a.N()?(a=this.b[a],a.bind(this.b)):this.a.get("player",a)};k.tc=function(a){this.a.N()||this.f.dispatchEvent(a)};k.Nc=function(a,b){this.a.N()&&("video"==a?this.g.dispatchEvent(b):"player"==a&&this.f.dispatchEvent(b))};function L(a,b,c){p.call(this);this.b=a;this.a=b;this.i={video:a,player:b};this.j=c||function(){};this.h=!1;this.g=!0;this.c=this.f=null;rd(this)}ba(L);l("shaka.cast.CastReceiver",L);L.prototype.Xb=function(){return this.h};L.prototype.isConnected=L.prototype.Xb;L.prototype.Yb=function(){return this.g};L.prototype.isIdle=L.prototype.Yb;
L.prototype.o=function(){var a=this.a?this.a.o():Promise.resolve();null!=this.c&&window.clearTimeout(this.c);this.j=this.i=this.a=this.b=null;this.h=!1;this.g=!0;this.c=this.f=null;return a.then(function(){cast.receiver.CastReceiverManager.getInstance().stop()})};L.prototype.destroy=L.prototype.o;
function rd(a){var b=cast.receiver.CastReceiverManager.getInstance();b.onSenderConnected=a.ub.bind(a);b.onSenderDisconnected=a.ub.bind(a);b.onSystemVolumeChanged=a.Rb.bind(a);a.f=b.getCastMessageBus("urn:x-cast:com.google.shaka.v2");a.f.onMessage=a.ec.bind(a);b.start();$c.forEach(function(a){this.b.addEventListener(a,this.xb.bind(this,"video"))}.bind(a));ed.forEach(function(a){this.a.addEventListener(a,this.xb.bind(this,"player"))}.bind(a));a.a.Fb(1920,1080);a.a.addEventListener("loading",function(){this.g=
!1;sd(this)}.bind(a));a.a.addEventListener("unloading",function(){this.g=!0;sd(this)}.bind(a));a.b.addEventListener("ended",function(){window.setTimeout(function(){this.b&&this.b.ended&&(this.g=!0,sd(this))}.bind(this),5E3)}.bind(a))}k=L.prototype;k.ub=function(){this.h=!!cast.receiver.CastReceiverManager.getInstance().getSenders().length;sd(this)};function sd(a){Promise.resolve().then(function(){this.dispatchEvent(new H("caststatuschanged"))}.bind(a))}
function td(a,b,c){for(var d in b.player)a.a[d](b.player[d]);a.j(c);c=Promise.resolve();var e=a.b.autoplay;b.manifest&&(a.b.autoplay=!1,c=a.a.load(b.manifest,b.startTime),c["catch"](function(a){this.a.dispatchEvent(new H("error",{detail:a}))}.bind(a)));c.then(function(){for(var a in b.video){var c=b.video[a];this.b[a]=c}for(a in b.playerAfterLoad)c=b.playerAfterLoad[a],this.a[a](c);this.b.autoplay=e;b.manifest&&this.b.play()}.bind(a))}
k.xb=function(a,b){this.Za();ud(this,{type:"event",targetName:a,event:b})};k.Za=function(){null!=this.c&&window.clearTimeout(this.c);this.c=window.setTimeout(this.Za.bind(this),500);var a={video:{},player:{}};ad.forEach(function(b){a.video[b]=this.b[b]}.bind(this));fd.forEach(function(b){a.player[b]=this.a[b]()}.bind(this));var b=cast.receiver.CastReceiverManager.getInstance().getSystemVolume();b&&(a.video.volume=b.level,a.video.muted=b.muted);ud(this,{type:"update",update:a})};
k.Rb=function(){var a=cast.receiver.CastReceiverManager.getInstance().getSystemVolume();a&&ud(this,{type:"update",update:{video:{volume:a.level,muted:a.muted}}});ud(this,{type:"event",targetName:"video",event:{type:"volumechange"}})};
k.ec=function(a){var b=ld(a.data);switch(b.type){case "init":td(this,b.initState,b.appData);this.Za();break;case "appData":this.j(b.appData);break;case "set":var c=b.targetName,d=b.property,e=b.value;if("video"==c)if(b=cast.receiver.CastReceiverManager.getInstance(),"volume"==d){b.setSystemVolumeLevel(e);break}else if("muted"==d){b.setSystemVolumeMuted(e);break}this.i[c][d]=e;break;case "call":c=b.targetName;d=b.methodName;e=b.args;c=this.i[c];c[d].apply(c,e);break;case "asyncCall":c=b.targetName,
d=b.methodName,e=b.args,b=b.id,a=a.senderId,c=this.i[c],c[d].apply(c,e).then(this.Db.bind(this,a,b,null),this.Db.bind(this,a,b))}};k.Db=function(a,b,c){ud(this,{type:"asyncComplete",id:b,error:c},a)};function ud(a,b,c){a.h&&(b=kd(b),c?a.f.getCastChannel(c).send(b):a.f.broadcast(b))};function vd(a,b){var c=M(a,b);return 1!=c.length?null:c[0]}function M(a,b){return Array.prototype.filter.call(a.childNodes,function(a){return a.tagName==b})}function wd(a){return(a=a.firstChild)&&a.nodeType==Node.TEXT_NODE?a.nodeValue.trim():null}function N(a,b,c,d){var e=null;a=a.getAttribute(b);null!=a&&(e=c(a));return null==e?void 0!==d?d:null:e}function xd(a){if(!a)return null;a=Date.parse(a);return isNaN(a)?null:Math.floor(a/1E3)}
function O(a){if(!a)return null;a=/^P(?:([0-9]*)Y)?(?:([0-9]*)M)?(?:([0-9]*)D)?(?:T(?:([0-9]*)H)?(?:([0-9]*)M)?(?:([0-9.]*)S)?)?$/.exec(a);if(!a)return null;a=31536E3*Number(a[1]||null)+2592E3*Number(a[2]||null)+86400*Number(a[3]||null)+3600*Number(a[4]||null)+60*Number(a[5]||null)+Number(a[6]||null);return isFinite(a)?a:null}function yd(a){var b=/([0-9]+)-([0-9]+)/.exec(a);if(!b)return null;a=Number(b[1]);if(!isFinite(a))return null;b=Number(b[2]);return isFinite(b)?{start:a,end:b}:null}
function zd(a){a=Number(a);return a%1?null:a}function Ad(a){a=Number(a);return!(a%1)&&0<a?a:null}function Bd(a){a=Number(a);return!(a%1)&&0<=a?a:null};var Cd={"urn:uuid:1077efec-c0b2-4d02-ace3-3c1e52e2fb4b":"org.w3.clearkey","urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed":"com.widevine.alpha","urn:uuid:9a04f079-9840-4286-ab92-e65be0885f95":"com.microsoft.playready","urn:uuid:f239e769-efa3-4850-9c16-a903c6932efb":"com.adobe.primetime"};
function Dd(a,b){var c=Ed(a),d=null,e=c.filter(function(a){return"urn:mpeg:dash:mp4protection:2011"==a.Cb?(d=a.init||d,!1):!0}),f=c.map(function(a){return a.keyId}).filter(Da),g=null;if(0<f.length&&(g=f[0],f.some(Ea(g))))throw new q(4,4010);f=[];0<e.length?(f=Fd(d,b,e),f.length||(f=[Hd("",d)])):0<c.length&&(f=C(Cd).map(function(a){return Hd(a,d)}));return{kb:g,dd:d,drmInfos:f,lb:!0}}
function Id(a,b,c){var d=Dd(a,b);if(c.lb){a=1==c.drmInfos.length&&!c.drmInfos[0].keySystem;b=!d.drmInfos.length;if(!c.drmInfos.length||a&&!b)c.drmInfos=d.drmInfos;c.lb=!1}else if(0<d.drmInfos.length&&(c.drmInfos=c.drmInfos.filter(function(a){return d.drmInfos.some(function(b){return b.keySystem==a.keySystem})}),!c.drmInfos.length))throw new q(4,4008);return d.kb||c.kb}
function Hd(a,b){return{keySystem:a,licenseServerUri:"",distinctiveIdentifierRequired:!1,persistentStateRequired:!1,audioRobustness:"",videoRobustness:"",serverCertificate:null,initData:b||[]}}function Fd(a,b,c){return c.map(function(c){var e=Cd[c.Cb];return e?[Hd(e,c.init||a)]:b(c.node)||[]}).reduce(t,[])}
function Ed(a){return a.map(function(a){var c=a.getAttribute("schemeIdUri"),d=a.getAttribute("cenc:default_KID"),e=M(a,"cenc:pssh").map(wd);if(!c)return null;c=c.toLowerCase();if(d&&(d=d.replace(/-/g,"").toLowerCase(),0<=d.indexOf(" ")))throw new q(4,4009);var f=[];try{f=e.map(function(a){return{initDataType:"cenc",initData:Xa(a)}})}catch(g){throw new q(4,4007);}return{node:a,Cb:c,keyId:d,init:0<f.length?f:null}}).filter(Da)};var Jd=1/15;function Kd(a,b,c,d,e){null!==e&&(e=Math.round(e));var f={RepresentationID:b,Number:c,Bandwidth:d,Time:e};return a.replace(/\$(RepresentationID|Number|Bandwidth|Time)?(?:%0([0-9]+)d)?\$/g,function(a,b,c){if("$$"==a)return"$";var d=f[b];if(null==d)return a;"RepresentationID"==b&&c&&(c=void 0);a=d.toString();c=window.parseInt(c,10)||1;return Array(Math.max(0,c-a.length)+1).join("0")+a})}
function Ld(a,b,c){if(c.length){var d=c[0];d.startTime<=Jd&&(c[0]=new G(d.position,0,d.endTime,d.a,d.L,d.D));a||(a=c[c.length-1],a.startTime>b||(c[c.length-1]=new G(a.position,a.startTime,b,a.a,a.L,a.D)))}}function P(a,b){if(!b.length)return a;var c=b.map(function(a){return new oa(a)});return a.map(function(a){return new oa(a)}).map(function(a){return c.map(a.resolve.bind(a))}).reduce(t,[]).map(function(a){return a.toString()})}
function Md(a,b){var c=Q(a,b,"timescale"),d=1;c&&(d=Ad(c)||1);c=Q(a,b,"duration");(c=Ad(c||""))&&(c/=d);var e=Q(a,b,"startNumber"),f=Q(a,b,"presentationTimeOffset"),g=Bd(e||"");if(null==e||null==g)g=1;var h=Nd(a,b,"SegmentTimeline"),e=null;if(h){for(var e=d,m=Number(f),n=a.H.duration||Infinity,h=M(h,"S"),r=[],u=0,A=0;A<h.length;++A){var x=h[A],K=N(x,"t",Bd),jb=N(x,"d",Bd),x=N(x,"r",zd);null!=K&&(K-=m);if(!jb)break;K=null!=K?K:u;x=x||0;if(0>x)if(A+1<h.length){x=N(h[A+1],"t",Bd);if(null==x)break;else if(K>=
x)break;x=Math.ceil((x-K)/jb)-1}else{if(Infinity==n)break;else if(K/e>=n)break;x=Math.ceil((n*e-K)/jb)-1}0<r.length&&K!=u&&(r[r.length-1].end=K/e);for(var Gd=0;Gd<=x;++Gd)u=K+jb,r.push({start:K/e,end:u/e}),K=u}e=r}return{Ia:d,F:c,ia:g,presentationTimeOffset:Number(f)/d||0,B:e}}function Q(a,b,c){return[b(a.u),b(a.P),b(a.K)].filter(Da).map(function(a){return a.getAttribute(c)}).reduce(function(a,b){return a||b})}
function Nd(a,b,c){return[b(a.u),b(a.P),b(a.K)].filter(Da).map(function(a){return vd(a,c)}).reduce(function(a,b){return a||b})};function Od(a){this.b=a;this.c=0==Pd;this.a=0}var Pd=1;function Qd(a){return a.a<a.b.byteLength}function Rd(a){try{var b=a.b.getUint8(a.a)}catch(c){Sd()}a.a+=1;return b}function Td(a){try{var b=a.b.getUint16(a.a,a.c)}catch(c){Sd()}a.a+=2;return b}function R(a){try{var b=a.b.getUint32(a.a,a.c)}catch(c){Sd()}a.a+=4;return b}
function Ud(a){var b,c;try{a.c?(b=a.b.getUint32(a.a,!0),c=a.b.getUint32(a.a+4,!0)):(c=a.b.getUint32(a.a,!1),b=a.b.getUint32(a.a+4,!1))}catch(d){Sd()}if(2097151<c)throw new q(3,3001);a.a+=8;return c*Math.pow(2,32)+b}function Vd(a,b){a.a+b>a.b.byteLength&&Sd();var c=a.b.buffer.slice(a.a,a.a+b);a.a+=b;return new Uint8Array(c)}function S(a,b){a.a+b>a.b.byteLength&&Sd();a.a+=b}
function Wd(a){var b=a.a;try{for(;Qd(a)&&a.b.getUint8(a.a);)a.a+=1}catch(c){Sd()}b=a.b.buffer.slice(b,a.a);a.a+=1;return D(b)}function Sd(){throw new q(3,3E3);};function Xd(a,b){for(;Qd(b);){var c=b.a,d=R(b),e=R(b);1==d?d=Ud(b):d||(d=b.b.byteLength-c);if(e==a)return d;S(b,d-(b.a-c))}return-1}function Yd(a,b){for(var c=new Od(new DataView(a)),d=[[1836019574,0],[1953653099,0],[1835297121,0],[1835626086,0],[1937007212,0],[1937011556,8],[b,0]],e=-1,f=0;f<d.length;f++){var g=d[f][1],e=Xd(d[f][0],c);if(-1==e)return-1;S(c,g)}return e};function Zd(a,b,c,d){var e=[];a=new Od(new DataView(a));var f=Xd(1936286840,a);if(-1==f)throw new q(3,3004);var g=Rd(a);S(a,3);S(a,4);var h=R(a);if(!h)throw new q(3,3005);var m,n;g?(m=Ud(a),n=Ud(a)):(m=R(a),n=R(a));S(a,2);g=Td(a);d=m-d;b=b+f+n;for(f=0;f<g;f++){m=R(a);n=(m&2147483648)>>>31;m&=2147483647;var r=R(a);S(a,4);if(1==n)throw new q(3,3006);e.push(new G(e.length,d/h,(d+r)/h,function(){return c},b,b+m-1));d+=r;b+=m}return e};function T(a){this.a=a}l("shaka.media.SegmentIndex",T);T.prototype.o=function(){this.a=null;return Promise.resolve()};T.prototype.destroy=T.prototype.o;T.prototype.find=function(a){for(var b=this.a.length-1;0<=b;--b){var c=this.a[b];if(a>=c.startTime&&a<c.endTime)return c.position}return null};T.prototype.find=T.prototype.find;T.prototype.get=function(a){if(!this.a.length)return null;a-=this.a[0].position;return 0>a||a>=this.a.length?null:this.a[a]};T.prototype.get=T.prototype.get;
T.prototype.Wa=function(a){for(var b=[],c=0,d=0;c<this.a.length&&d<a.length;){var e=this.a[c],f=a[d];e.startTime<f.startTime?(b.push(e),c++):(e.startTime>f.startTime||(.1<Math.abs(e.endTime-f.endTime)?b.push(f):b.push(e),c++),d++)}for(;c<this.a.length;)b.push(this.a[c++]);if(b.length)for(c=b[b.length-1].position+1;d<a.length;)f=a[d++],f=new G(c++,f.startTime,f.endTime,f.a,f.L,f.D),b.push(f);else b=a;this.a=b};T.prototype.merge=T.prototype.Wa;
T.prototype.Ra=function(a){for(var b=0;b<this.a.length&&!(this.a[b].endTime>a);++b);this.a.splice(0,b)};T.prototype.evict=T.prototype.Ra;function $d(a){this.b=a;this.a=new Od(a);ae||(ae=[new Uint8Array([255]),new Uint8Array([127,255]),new Uint8Array([63,255,255]),new Uint8Array([31,255,255,255]),new Uint8Array([15,255,255,255,255]),new Uint8Array([7,255,255,255,255,255]),new Uint8Array([3,255,255,255,255,255,255]),new Uint8Array([1,255,255,255,255,255,255,255])])}var ae;
function be(a){var b;b=ce(a);if(7<b.length)throw new q(3,3002);for(var c=0,d=0;d<b.length;d++)c=256*c+b[d];b=c;c=ce(a);a:{for(d=0;d<ae.length;d++)if($a(c,ae[d])){d=!0;break a}d=!1}if(d)c=a.b.byteLength-a.a.a;else{if(8==c.length&&c[1]&224)throw new q(3,3001);for(var d=c[0]&(1<<8-c.length)-1,e=1;e<c.length;e++)d=256*d+c[e];c=d}c=a.a.a+c<=a.b.byteLength?c:a.b.byteLength-a.a.a;d=new DataView(a.b.buffer,a.b.byteOffset+a.a.a,c);S(a.a,c);return new de(b,d)}
function ce(a){var b=Rd(a.a),c;for(c=1;8>=c&&!(b&1<<8-c);c++);if(8<c)throw new q(3,3002);var d=new Uint8Array(c);d[0]=b;for(b=1;b<c;b++)d[b]=Rd(a.a);return d}function de(a,b){this.id=a;this.a=b}function ee(a){if(8<a.a.byteLength)throw new q(3,3002);if(8==a.a.byteLength&&a.a.getUint8(0)&224)throw new q(3,3001);for(var b=0,c=0;c<a.a.byteLength;c++)var d=a.a.getUint8(c),b=256*b+d;return b};function fe(a,b,c,d,e,f){function g(){return e}var h=[];a=new $d(a.a);for(var m=-1,n=-1;Qd(a.a);){var r=be(a);if(187==r.id){var u=ge(r);u&&(r=c*(u.Yc-f),u=b+u.wc,0<=m&&h.push(new G(h.length,m,r,g,n,u-1)),m=r,n=u)}}0<=m&&h.push(new G(h.length,m,d,g,n,null));return h}function ge(a){var b=new $d(a.a);a=be(b);if(179!=a.id)throw new q(3,3013);a=ee(a);b=be(b);if(183!=b.id)throw new q(3,3012);for(var b=new $d(b.a),c=0;Qd(b.a);){var d=be(b);if(241==d.id){c=ee(d);break}}return{Yc:a,wc:c}};function he(a,b){var c=Nd(a,b,"Initialization");if(!c)return null;var d=a.u.M,e=c.getAttribute("sourceURL");e&&(d=P(a.u.M,[e]));var e=0,f=null;if(c=N(c,"range",yd))e=c.start,f=c.end;return new Vb(function(){return d},e,f)}
function ie(a,b){var c=Q(a,je,"presentationTimeOffset"),d=he(a,je),e;e=Number(c);var f=a.u.mimeType.split("/")[1];if("text"!=a.u.contentType&&"mp4"!=f&&"webm"!=f)throw new q(4,4006);if("webm"==f&&!d)throw new q(4,4005);var g=Nd(a,je,"RepresentationIndex"),h=Q(a,je,"indexRange"),m=a.u.M,h=yd(h||"");if(g){var n=g.getAttribute("sourceURL");n&&(m=P(a.u.M,[n]));h=N(g,"range",yd,h)}if(!h)throw new q(4,4002);e=ke(a,b,d,m,h.start,h.end,f,e);return{createSegmentIndex:e.createSegmentIndex,findSegmentPosition:e.findSegmentPosition,
getSegmentReference:e.getSegmentReference,initSegmentReference:d,presentationTimeOffset:Number(c)||0}}
function ke(a,b,c,d,e,f,g,h){var m=a.presentationTimeline,n=a.H.start,r=a.H.duration,u=b,A=null;return{createSegmentIndex:function(){var b=[u(d,e,f),"webm"==g?u(c.a(),c.L,c.D):null];u=null;return Promise.all(b).then(function(b){var c,f=b[0];b=b[1]||null;if("mp4"==g)f=Zd(f,e,d,h);else{b=new $d(new DataView(b));if(440786851!=be(b).id)throw new q(3,3008);var u=be(b);if(408125543!=u.id)throw new q(3,3009);b=u.a.byteOffset;u=new $d(u.a);for(c=null;Qd(u.a);){var x=be(u);if(357149030==x.id){c=x;break}}if(!c)throw new q(3,
3010);u=new $d(c.a);c=1E6;for(x=null;Qd(u.a);){var ob=be(u);if(2807729==ob.id)c=ee(ob);else if(17545==ob.id)if(x=ob,4==x.a.byteLength)x=x.a.getFloat32(0);else if(8==x.a.byteLength)x=x.a.getFloat64(0);else throw new q(3,3003);}if(null==x)throw new q(3,3011);u=c/1E9;c=x*u;f=be(new $d(new DataView(f)));if(475249515!=f.id)throw new q(3,3007);f=fe(f,b,u,c,d,h)}Ld(a.Qa,r,f);m.Ea(n,f);A=new T(f)})},findSegmentPosition:function(a){return A.find(a)},getSegmentReference:function(a){return A.get(a)}}}
function je(a){return a.Ga};function le(a,b){var c=he(a,me),d;d=ne(a);var e=Md(a,me),f=e.ia;f||(f=1);var g=0;e.F?g=e.F*(f-1)-e.presentationTimeOffset:e.B&&0<e.B.length&&(g=e.B[0].start);d={F:e.F,startTime:g,ia:f,presentationTimeOffset:e.presentationTimeOffset,B:e.B,ua:d};if(!d.F&&!d.B&&1<d.ua.length)throw new q(4,4002);if(!d.F&&!a.H.duration&&!d.B&&1==d.ua.length)throw new q(4,4002);if(d.B&&!d.B.length)throw new q(4,4002);f=e=null;a.K.id&&a.u.id&&(f=a.K.id+","+a.u.id,e=b[f]);g=oe(a.H.duration,d.ia,a.u.M,d);Ld(a.Qa,a.H.duration,
g);e?(e.Wa(g),e.Ra(a.presentationTimeline.sa()-a.H.start)):(a.presentationTimeline.Ea(a.H.start,g),e=new T(g),f&&(b[f]=e));return{createSegmentIndex:Promise.resolve.bind(Promise),findSegmentPosition:e.find.bind(e),getSegmentReference:e.get.bind(e),initSegmentReference:c,presentationTimeOffset:d.presentationTimeOffset}}function me(a){return a.$}
function oe(a,b,c,d){var e=d.ua.length;d.B&&d.B.length!=d.ua.length&&(e=Math.min(d.B.length,d.ua.length));for(var f=[],g=d.startTime,h=0;h<e;h++){var m=d.ua[h],n=P(c,[m.ac]),r;r=null!=d.F?g+d.F:d.B?d.B[h].end:g+a;f.push(new G(h+b,g,r,function(a){return a}.bind(null,n),m.start,m.end));g=r}return f}
function ne(a){return[a.u.$,a.P.$,a.K.$].filter(Da).map(function(a){return M(a,"SegmentURL")}).reduce(function(a,c){return 0<a.length?a:c}).map(function(a){var c=a.getAttribute("media");a=N(a,"mediaRange",yd,{start:0,end:null});return{ac:c,start:a.start,end:a.end}})};function pe(a,b,c,d){var e=qe(a),f;f=Md(a,re);var g=Q(a,re,"media"),h=Q(a,re,"index");f={F:f.F,Ia:f.Ia,ia:f.ia,presentationTimeOffset:f.presentationTimeOffset,B:f.B,Va:g,Da:h};g=0+(f.Da?1:0);g+=f.B?1:0;g+=f.F?1:0;if(!g)throw new q(4,4002);1!=g&&(f.Da&&(f.B=null),f.F=null);if(!f.Da&&!f.Va)throw new q(4,4002);if(f.Da){c=a.u.mimeType.split("/")[1];if("mp4"!=c&&"webm"!=c)throw new q(4,4006);if("webm"==c&&!e)throw new q(4,4005);d=Kd(f.Da,a.u.id,null,a.bandwidth||null,null);d=P(a.u.M,[d]);a=ke(a,b,e,d,
0,null,c,f.presentationTimeOffset)}else f.F?(d||a.presentationTimeline.Xa(f.F),a=se(a,f)):(d=b=null,a.K.id&&a.u.id&&(d=a.K.id+","+a.u.id,b=c[d]),g=te(a,f),Ld(a.Qa,a.H.duration,g),b?(b.Wa(g),b.Ra(a.presentationTimeline.sa()-a.H.start)):(a.presentationTimeline.Ea(a.H.start,g),b=new T(g),d&&(c[d]=b)),a={createSegmentIndex:Promise.resolve.bind(Promise),findSegmentPosition:b.find.bind(b),getSegmentReference:b.get.bind(b)});return{createSegmentIndex:a.createSegmentIndex,findSegmentPosition:a.findSegmentPosition,
getSegmentReference:a.getSegmentReference,initSegmentReference:e,presentationTimeOffset:f.presentationTimeOffset}}function re(a){return a.Ha}function se(a,b){var c=a.H.duration,d=b.F,e=b.ia,f=b.Ia,g=b.Va,h=a.bandwidth||null,m=a.u.id,n=a.u.M;return{createSegmentIndex:Promise.resolve.bind(Promise),findSegmentPosition:function(a){return 0>a||c&&a>=c?null:Math.floor(a/d)},getSegmentReference:function(a){var b=a*d;return new G(a,b,b+d,function(){var c=Kd(g,m,a+e,h,b*f);return P(n,[c])},0,null)}}}
function te(a,b){for(var c=[],d=0;d<b.B.length;d++){var e=b.B[d].start,f=d+b.ia;c.push(new G(f,e,b.B[d].end,function(a,b,c,d,e,f){a=Kd(a,b,e,c,f);return P(d,[a]).map(function(a){return a.toString()})}.bind(null,b.Va,a.u.id,a.bandwidth||null,a.u.M,f,(e+b.presentationTimeOffset)*b.Ia),0,null))}return c}function qe(a){var b=Q(a,re,"initialization");if(!b)return null;var c=a.u.id,d=a.bandwidth||null,e=a.u.M;return new Vb(function(){var a=Kd(b,c,null,d,null);return P(e,[a])},0,null)};function ue(){this.m=this.l=this.j=this.c=this.a=null;this.g=[];this.b=null;this.h=[];this.v=1;this.i={};this.s=0;this.f=null;this.Ja=this.Ja.bind(this)}k=ue.prototype;k.configure=function(a){this.c=a};k.start=function(a,b,c,d,e){this.g=[a];this.a=b;this.j=c;this.l=d;this.m=e;return ve(this).then(function(){this.a&&we(this,0);return this.b}.bind(this))};
k.stop=function(){this.a&&this.a.Jb(this.Ja);this.c=this.m=this.l=this.j=this.a=null;this.g=[];this.b=null;this.h=[];this.i={};null!=this.f&&(window.clearTimeout(this.f),this.f=null);return Promise.resolve()};function ve(a){return a.a.request(0,Ha(a.g,a.c.retryParameters)).then(function(a){if(this.a)return xe(this,a.data,a.uri)}.bind(a))}
function xe(a,b,c){var d=D(b),e=new DOMParser,f=null;b=null;try{f=e.parseFromString(d,"text/xml")}catch(A){}f&&"MPD"==f.documentElement.tagName&&(b=f.documentElement);if(!b)throw new q(4,4001);c=[c];d=M(b,"Location").map(wd).filter(Da);0<d.length&&(c=a.g=d);d=M(b,"BaseURL").map(wd);c=P(c,d);var g=N(b,"minBufferTime",O);a.s=N(b,"minimumUpdatePeriod",O,-1);var h=N(b,"availabilityStartTime",xd),d=N(b,"timeShiftBufferDepth",O),m=N(b,"suggestedPresentationDelay",O),e=N(b,"maxSegmentDuration",O),f=b.getAttribute("type")||
"static",n;if(a.b)n=a.b.presentationTimeline;else{var r=Math.max(10,1.5*g);n=new F(h,null!=m?m:r)}var h=ye(a,{Qa:"static"!=f,presentationTimeline:n,K:null,H:null,P:null,u:null,bandwidth:void 0},c,b),m=h.duration,u=h.periods;n.Hb("static"==f);n.za(m||Infinity);n.Gb(null!=d?d:Infinity);n.Xa(e||1);if(a.b)return Promise.resolve();b=M(b,"UTCTiming");d=n.U();h.Y&&a.a.yb(a.Ja);return ze(a,c,b,d).then(function(a){this.a&&(n.Eb(a),this.b={presentationTimeline:n,periods:u,offlineSessionIds:[],minBufferTime:g||
0})}.bind(a))}
function ye(a,b,c,d){var e=N(d,"mediaPresentationDuration",O),f=[],g=0;d=M(d,"Period");for(var h=0;h<d.length;h++){var m=d[h],g=N(m,"start",O,g),n=N(m,"duration",O);if(null==n)if(h+1!=d.length){var r=N(d[h+1],"start",O);null!=r&&(n=r-g)}else null!=e&&(n=e-g);var m={start:g,duration:n,node:m,Y:!1},u=a,A=b,r=m;A.K=Ae(r.node,null,c);A.H=r;A.K.id||(A.K.id="__shaka_period_"+r.start);u=M(r.node,"AdaptationSet").map(u.qc.bind(u,A));if(!u.length)throw new q(4,4004);for(A=0;A<u.length;A++)u[A].Y&&(r.Y=!0);
u=Be(u);r={startTime:r.start,streamSets:u};f.push(r);u=b.K.id;a.h.every(Ea(u))&&(a.j(r),a.h.push(u),a.b&&a.b.periods.push(r));if(null==n){g=null;break}g+=n}return null!=e?{periods:f,duration:e,Y:m.Y}:{periods:f,duration:g,Y:m.Y}}
k.qc=function(a,b){a.P=Ae(b,a.K,null);var c=!1,d=M(b,"Role"),e=void 0;"text"==a.P.contentType&&(e="subtitle");for(var f=0;f<d.length;f++){var g=d[f].getAttribute("schemeIdUri");if(null==g||"urn:mpeg:dash:role:2011"==g)switch(g=d[f].getAttribute("value"),g){case "main":c=!0;break;case "caption":case "subtitle":e=g}}var d=!!vd(b,"InbandEventStream"),h=[];M(b,"SupplementalProperty").forEach(function(a){"http://dashif.org/descriptor/AdaptationSetSwitching"==a.getAttribute("schemeIdURI")&&(a=a.getAttribute("value"))&&
h.push.apply(h,a.split(","))});f=M(b,"ContentProtection");f=Dd(f,this.c.dash.customScheme);g=Dc(b.getAttribute("lang")||"und");e=M(b,"Representation").map(this.rc.bind(this,a,f,e,g)).filter(function(a){return!!a});if(!e.length)throw new q(4,4003);if(!a.P.contentType){var m=e[0].mimeType,n=e[0].codecs,r=m;n&&(r+='; codecs="'+n+'"');a.P.contentType=E[r]?"text":m.split("/")[0]}return{id:a.P.id||"__fake__"+this.v++,contentType:a.P.contentType,language:g,$b:c,streams:e,drmInfos:f.drmInfos,Vc:h,Y:d}};
k.rc=function(a,b,c,d,e){a.u=Ae(e,a.P,null);if(!Ce(a.u))return null;a.bandwidth=N(e,"bandwidth",Ad)||void 0;var f;f=this.yc.bind(this);if(a.u.Ga)f=ie(a,f);else if(a.u.$)f=le(a,this.i);else if(a.u.Ha)f=pe(a,f,this.i,!!this.b);else{var g=a.u.M,h=a.H.duration||0;f={createSegmentIndex:Promise.resolve.bind(Promise),findSegmentPosition:function(a){return 0<=a&&a<h?1:null},getSegmentReference:function(a){return 1!=a?null:new G(1,0,h,function(){return g},0,null)},initSegmentReference:null,presentationTimeOffset:0}}e=
M(e,"ContentProtection");e=Id(e,this.c.dash.customScheme,b);return{id:this.v++,createSegmentIndex:f.createSegmentIndex,findSegmentPosition:f.findSegmentPosition,getSegmentReference:f.getSegmentReference,initSegmentReference:f.initSegmentReference,presentationTimeOffset:f.presentationTimeOffset,mimeType:a.u.mimeType,codecs:a.u.codecs,bandwidth:a.bandwidth,width:a.u.width,height:a.u.height,kind:c,encrypted:0<b.drmInfos.length,keyId:e,language:d,allowedByApplication:!0,allowedByKeySystem:!0}};
k.Pc=function(){this.f=null;var a=Date.now();ve(this).then(function(){this.a&&we(this,(Date.now()-a)/1E3)}.bind(this))["catch"](function(a){this.l(a);this.a&&we(this,0)}.bind(this))};function we(a,b){0>a.s||(a.f=window.setTimeout(a.Pc.bind(a),1E3*Math.max(Math.max(3,a.s)-b,0)))}
function Ae(a,b,c){b=b||{contentType:"",mimeType:"",codecs:""};c=c||b.M;var d=M(a,"BaseURL").map(wd),e=a.getAttribute("contentType")||b.contentType,f=a.getAttribute("mimeType")||b.mimeType;e||(e=f.split("/")[0]);return{M:P(c,d),Ga:vd(a,"SegmentBase")||b.Ga,$:vd(a,"SegmentList")||b.$,Ha:vd(a,"SegmentTemplate")||b.Ha,width:N(a,"width",Bd)||b.width,height:N(a,"height",Bd)||b.height,contentType:e,mimeType:f,codecs:a.getAttribute("codecs")||b.codecs,id:a.getAttribute("id")}}
function Be(a){var b={};a.forEach(function(a){b[a.id]=[a]});a.forEach(function(a){var c=b[a.id];a.Vc.forEach(function(a){(a=b[a])&&a!=c&&(c.push.apply(c,a),a.forEach(function(a){b[a.id]=c}))})});var c=[],d=[];C(b).forEach(function(a){if(!(0<=d.indexOf(a))){d.push(a);var b=new Ja;a.forEach(function(a){b.push(a.contentType||"",a)});b.keys().forEach(function(a){var d=new Ja;b.get(a).forEach(function(a){d.push(a.language,a)});d.keys().forEach(function(b){var e=d.get(b);b={language:b,type:a,primary:e.some(function(a){return a.$b}),
drmInfos:e.map(function(a){return a.drmInfos}).reduce(t,[]),streams:e.map(function(a){return a.streams}).reduce(t,[])};c.push(b)})})}});return c}function Ce(a){var b;b=0+(a.Ga?1:0);b+=a.$?1:0;b+=a.Ha?1:0;if(!b)return"text"==a.contentType||"application"==a.contentType?!0:!1;1!=b&&(a.Ga&&(a.$=null),a.Ha=null);return!0}
function De(a,b,c,d){b=P(b,[c]);b=Ha(b,a.c.retryParameters);b.method=d;return a.a.request(0,b).then(function(a){if("HEAD"==d){if(!a.headers||!a.headers.date)return 0;a=a.headers.date}else a=D(a.data);a=Date.parse(a);return isNaN(a)?0:a-Date.now()})}
function ze(a,b,c,d){c=c.map(function(a){return{scheme:a.getAttribute("schemeIdUri"),value:a.getAttribute("value")}});var e=a.c.dash.clockSyncUri;d&&!c.length&&e&&c.push({scheme:"urn:mpeg:dash:utc:http-head:2014",value:e});return Ca(c,function(a){var c=a.value;switch(a.scheme){case "urn:mpeg:dash:utc:http-head:2014":case "urn:mpeg:dash:utc:http-head:2012":return De(this,b,c,"HEAD");case "urn:mpeg:dash:utc:http-xsdate:2014":case "urn:mpeg:dash:utc:http-iso:2014":case "urn:mpeg:dash:utc:http-xsdate:2012":case "urn:mpeg:dash:utc:http-iso:2012":return De(this,
b,c,"GET");case "urn:mpeg:dash:utc:direct:2014":case "urn:mpeg:dash:utc:direct:2012":return a=Date.parse(c),isNaN(a)?0:a-Date.now();case "urn:mpeg:dash:utc:http-ntp:2014":case "urn:mpeg:dash:utc:ntp:2014":case "urn:mpeg:dash:utc:sntp:2014":return Promise.reject();default:return Promise.reject()}}.bind(a))["catch"](function(){return 0})}k.yc=function(a,b,c){a=Ha(a,this.c.retryParameters);null!=b&&(a.headers.Range="bytes="+b+"-"+(null!=c?c:""));return this.a.request(1,a).then(function(a){return a.data})};
k.Ja=function(a,b){if(1==a){var c=new Od(new DataView(b.data)),d=Xd(1701671783,c);if(-1!=d){var e=c.a-8+d;S(c,4);d=Wd(c);if("urn:mpeg:dash:event:2012"==d)ve(this);else{var f=Wd(c),g=R(c),h=R(c),m=R(c),n=R(c),c=Vd(c,e-c.a);this.m(new H("emsg",{detail:{hd:d,value:f,Ia:g,gd:h,ed:m,id:n,fd:c}}))}}}};sb.mpd=ue;rb["application/dash+xml"]=ue;function U(a,b){var c=D(a),d=[],e=new DOMParser,f=null;try{f=e.parseFromString(c,"text/xml")}catch(n){throw new q(2,2005);}if(f){var g,h;if(c=f.getElementsByTagName("tt")[0])e=c.getAttribute("ttp:frameRate"),f=c.getAttribute("ttp:subFrameRate"),g=c.getAttribute("ttp:frameRateMultiplier"),h=c.getAttribute("ttp:tickRate");else throw new q(2,2006);e=new Ee(e,f,g,h);f=U.b(c.getElementsByTagName("styling")[0]);g=U.b(c.getElementsByTagName("layout")[0]);c=U.b(c.getElementsByTagName("body")[0]);for(h=0;h<
c.length;h++){var m=U.c(c[h],b,e,f,g);m&&d.push(m)}}return d}U.l=/^(\d{2,}):(\d{2}):(\d{2}):(\d{2})\.?(\d+)?$/;U.s=/^(?:(\d{2,}):)?(\d{2}):(\d{2})$/;U.m=/^(?:(\d{2,}):)?(\d{2}):(\d{2}\.\d{2,})$/;U.v=/^(\d*\.?\d*)f$/;U.A=/^(\d*\.?\d*)t$/;U.w=/^(?:(\d*\.?\d*)h)?(?:(\d*\.?\d*)m)?(?:(\d*\.?\d*)s)?(?:(\d*\.?\d*)ms)?$/;U.j=/^(\d{1,2}|100)% (\d{1,2}|100)%$/;
U.b=function(a){var b=[];if(!a)return b;for(var c=a.childNodes,d=0;d<c.length;d++){var e="span"==c[d].nodeName&&"p"==a.nodeName;c[d].nodeType!=Node.ELEMENT_NODE||"br"==c[d].nodeName||e||(e=U.b(c[d]),b=b.concat(e))}b.length||b.push(a);return b};
U.c=function(a,b,c,d,e){if(!a.hasAttribute("begin")&&!a.hasAttribute("end")&&""==a.textContent)return null;var f=U.a(a.getAttribute("begin"),c),g=U.a(a.getAttribute("end"),c);c=U.a(a.getAttribute("dur"),c);var h=a.textContent;null==g&&null!=c&&(g=f+c);if(null==f||null==g)throw new q(2,2001);b=wb(f+b,g+b,h);if(!b)return null;e=U.h(a,"region",e);U.na(b,a,e,d);return b};
U.na=function(a,b,c,d){var e,f=U.f(b,c,d,"tts:textAlign");f&&(a.b=f);if(f=U.f(b,c,d,"tts:extent"))if(e=U.j.exec(f))a.size=Number(e[1]);e=U.f(b,c,d,"tts:writingMode");f=!0;"tb"==e||"tblr"==e?a.c="lr":"tbrl"==e?a.c="rl":f=!1;if(b=U.f(b,c,d,"tts:origin"))if(e=U.j.exec(b))f?(a.position=Number(e[2]),a.a=Number(e[1])):(a.position=Number(e[1]),a.a=Number(e[2]))};
U.f=function(a,b,c,d){for(var e=U.b(b),f=0;f<e.length;f++){var g=e[f].getAttribute(d);if(g)return g}e=U.h;return(a=e(b,"style",c)||e(a,"style",c))?a.getAttribute(d):null};U.h=function(a,b,c){if(!a||1>c.length)return null;var d=null;if(a=U.oa(a,b))for(b=0;b<c.length;b++)if(c[b].getAttribute("xml:id")==a){d=c[b];break}return d};U.oa=function(a,b){for(var c=null;a&&!(c=a.getAttribute(b));){var d=a.parentNode;if(d instanceof Element)a=d;else break}return c};
U.a=function(a,b){var c=null;U.l.test(a)?c=U.pa(b,a):U.s.test(a)?c=U.g(U.s,a):U.m.test(a)?c=U.g(U.m,a):U.v.test(a)?c=U.Aa(b,a):U.A.test(a)?c=U.Ba(b,a):U.w.test(a)&&(c=U.g(U.w,a));return c};U.Aa=function(a,b){var c=U.v.exec(b);return Number(c[1])/a.a};U.Ba=function(a,b){var c=U.A.exec(b);return Number(c[1])/a.b};U.pa=function(a,b){var c=U.l.exec(b),d=Number(c[1]),e=Number(c[2]),f=Number(c[3]),g=Number(c[4]),g=g+(Number(c[5])||0)/a.c,f=f+g/a.a;return f+60*e+3600*d};
U.g=function(a,b){var c=a.exec(b);return c&&""!=c[0]?(Number(c[4])||0)/1E3+(Number(c[3])||0)+60*(Number(c[2])||0)+3600*(Number(c[1])||0):null};function Ee(a,b,c,d){this.a=Number(a)||30;this.c=Number(b)||1;this.b=Number(d);this.b||(this.b=a?this.a*this.c:1);c&&(a=/^(\d+) (\d+)$/g.exec(c))&&(this.a*=a[1]/a[2])}E["application/ttml+xml"]=U;function Fe(a,b){var c=new Od(new DataView(a)),d=Xd(1835295092,c);if(-1!=d)return U(Vd(c,d-8).buffer,b);if(-1!=Yd(a,Fe.J))return[];throw new q(2,2007);}Fe.J=1937010800;E['application/mp4; codecs="stpp"']=Fe;function Ge(a){this.b=a;this.a=0}function He(a,b){var c;b.lastIndex=a.a;c=(c=b.exec(a.b))?{position:c.index,length:c[0].length,Bc:c}:null;if(a.a==a.b.length||!c||c.position!=a.a)return null;a.a+=c.length;return c.Bc}function Ie(a){return a.a==a.b.length?null:(a=He(a,/[^ \t\n]*/gm))?a[0]:null};function V(a,b){var c=D(a),c=c.replace(/\r\n|\r(?=[^\n]|$)/gm,"\n"),c=c.split(/\n{2,}/m);if(!/^WEBVTT($|[ \t\n])/m.test(c[0]))throw new q(2,2E3);for(var d=[],e=1;e<c.length;e++){var f=V.c(c[e].split("\n"),b);f&&d.push(f)}return d}
V.c=function(a,b){if(1==a.length&&!a[0]||/^NOTE($|[ \t])/.test(a[0]))return null;var c=null;0>a[0].indexOf("--\x3e")&&(c=a[0],a.splice(0,1));var d=new Ge(a[0]),e=V.a(d),f=He(d,/[ \t]+--\x3e[ \t]+/g),g=V.a(d);if(null==e||!f||null==g)throw new q(2,2001);e=wb(e+b,g+b,a.slice(1).join("\n").trim());if(!e)return null;He(d,/[ \t]+/gm);for(f=Ie(d);f;){if(!V.i(e,f))throw new q(2,2002);He(d,/[ \t]+/gm);f=Ie(d)}null!=c&&(e.id=c);return e};
V.i=function(a,b){var c;if(c=/^align:(start|middle|end|left|right)$/.exec(b))a.align=c[1];else if(c=/^vertical:(lr|rl)$/.exec(b))a.c=c[1];else if(c=/^size:(\d{1,2}|100)%$/.exec(b))a.size=Number(c[1]);else if(c=/^position:(\d{1,2}|100)%(?:,(line-left|line-right|center|start|end))?$/.exec(b))a.position=Number(c[1]),c[2]&&(a.g=c[2]);else if(c=/^line:(\d{1,2}|100)%(?:,(start|end|center))?$/.exec(b))a.f=!1,a.a=Number(c[1]),c[2]&&(a.b=c[2]);else if(c=/^line:(-?\d+)(?:,(start|end|center))?$/.exec(b))a.f=
!0,a.a=Number(c[1]),c[2]&&(a.b=c[2]);else return!1;return!0};V.a=function(a){a=He(a,/(?:(\d{2,}):)?(\d{2}):(\d{2})\.(\d{3})/g);if(!a)return null;var b=Number(a[2]),c=Number(a[3]);return 59<b||59<c?null:Number(a[4])/1E3+c+60*b+3600*(Number(a[1])||0)};E["text/vtt"]=V;E['text/vtt; codecs="vtt"']=V;function W(a,b,c,d){var e=new Od(new DataView(a)),f=Xd(1835295092,e);if(-1!=f)return W.qa(Vd(e,f-8).buffer,b,c,d);if(-1!=Yd(a,W.ma))return[];throw new q(2,2008);}W.qa=function(a,b,c,d){a=new Od(new DataView(a));c+=b;d+=b;for(b=[];Qd(a);){var e=Xd(W.X,a);if(-1==e)break;(e=W.c(Vd(a,e-8).buffer,c,d))&&b.push(e)}return b};
W.c=function(a,b,c){a=new Od(new DataView(a));for(var d,e,f;Qd(a);){var g=R(a),h=R(a),m=D(Vd(a,g-8).buffer);1==g&&Ud(a);switch(h){case W.G:d=m;break;case W.C:f=m;break;case W.S:e=m}}if(!d)throw new q(2,2008);b=wb(b,c,d);if(!b)return null;f&&(b.id=f);if(e)for(e=new Ge(e),f=Ie(e);f;){if(!V.i(b,f))throw new q(2,2002);He(e,/[ \t]+/gm);f=Ie(e)}return b};W.ma=2004251764;W.X=1987343459;W.G=1885436268;W.C=1768187247;W.S=1937011815;E['application/mp4; codecs="wvtt"']=W;Fa.data=function(a){return new Promise(function(b){var c=a.split(":");if(2>c.length||"data"!=c[0])throw new q(1,1004,a);c=c.slice(1).join(":").split(",");if(2>c.length)throw new q(1,1004,a);var d=c[0],c=window.decodeURIComponent(c.slice(1).join(",")),d=d.split(";"),e=null;1<d.length&&(e=d[1]);if("base64"==e)c=Xa(c).buffer;else{if(e)throw new q(1,1005,a);c=Sa(c)}b({uri:a,data:c,headers:{}})})};function Je(a,b){return new Promise(function(c,d){var e=new XMLHttpRequest;e.open(b.method,a,!0);e.responseType="arraybuffer";e.timeout=b.retryParameters.timeout;e.withCredentials=b.allowCrossSiteCredentials;e.onload=function(b){b=b.target;if(200<=b.status&&299>=b.status){var e=b.getAllResponseHeaders().split("\r\n").reduce(function(a,b){var c=b.split(": ");a[c[0].toLowerCase()]=c.slice(1).join(": ");return a},{});b.Ac&&(a=b.Ac);c({uri:a,data:b.response,headers:e})}else{e=null;try{e=Ra(b.response)}catch(f){}d(new q(1,
1001,a,b.status,e))}};e.onerror=function(){d(new q(1,1002,a))};e.ontimeout=function(){d(new q(1,1003,a))};for(var f in b.headers)e.setRequestHeader(f,b.headers[f]);e.send(b.body)})}Fa.http=Je;Fa.https=Je;function Ke(){this.a=null;this.c=[];this.b={}}k=Ke.prototype;
k.init=function(a){if(!window.indexedDB)return Promise.reject(new q(9,9E3));var b=window.indexedDB.open("shaka_offline_db",1),c=new w;b.onupgradeneeded=function(b){b=b.target.result;for(var c in a)b.createObjectStore(c,{keyPath:a[c]})};b.onsuccess=function(a){this.a=a.target.result;c.resolve()}.bind(this);b.onerror=Le.bind(null,b,c);return c.then(function(){var b=Object.keys(a);return Promise.all(b.map(function(a){return Me(this,a).then(function(b){this.b[a]=b}.bind(this))}.bind(this)))}.bind(this))};
k.o=function(){return Promise.all(this.c.map(function(a){try{a.transaction.abort()}catch(b){}return a.I["catch"](v)})).then(function(){this.a&&(this.a.close(),this.a=null)}.bind(this))};k.get=function(a,b){return Ne(this,a,"readonly",function(a){return a.get(b)})};k.forEach=function(a,b){return Ne(this,a,"readonly",function(a){return a.openCursor()},function(a){a&&(b(a.value),a["continue"]())})};function Oe(a,b,c){return Ne(a,b,"readwrite",function(a){return a.put(c)})}
k.remove=function(a,b){return Ne(this,a,"readwrite",function(a){return a["delete"](b)})};function Pe(a,b){var c=[];return Ne(a,"segment","readwrite",function(a){return a.openCursor()},function(a){if(a){if(b(a.value)){var e=a["delete"](),f=new w;e.onsuccess=f.resolve;e.onerror=Le.bind(null,e,f);c.push(f)}a["continue"]()}}).then(function(){return Promise.all(c)}).then(function(){return c.length})}
function Me(a,b){var c=0;return Ne(a,b,"readonly",function(a){return a.openCursor(null,"prev")},function(a){a&&(c=a.key+1)}).then(function(){return c})}
function Ne(a,b,c,d,e){c=a.a.transaction([b],c);var f=d(c.objectStore(b)),g=new w;e&&(f.onsuccess=function(a){e(a.target.result)});f.onerror=Le.bind(null,f,g);var h={transaction:c,I:g};a.c.push(h);var m=function(){this.c.splice(this.c.indexOf(h),1)}.bind(a);c.oncomplete=function(){m();g.resolve(f.result)};c.onerror=function(a){m();Le(f,g,a)};return g}function Le(a,b,c){"AbortError"==a.error.name?b.reject(new q(9,9002)):b.reject(new q(9,9001,a.error));c.preventDefault()};var Qe={manifest:"key",segment:"key"};function Re(a){return{offlineUri:"offline:"+a.key,originalManifestUri:a.originalManifestUri,duration:a.duration,size:a.size,tracks:a.periods[0].streams.map(function(a){return{id:a.id,active:!1,type:a.contentType,bandwidth:0,language:a.language,kind:a.kind||null,width:a.width,height:a.height}}),appMetadata:a.appMetadata}};function Se(){}Se.prototype.configure=function(){};Se.prototype.start=function(a){var b=/^offline:([0-9]+)$/.exec(a);if(!b)return Promise.reject(new q(1,9004,a));var c=Number(b[1]),d=new Ke;return d.init(Qe).then(function(){return d.get("manifest",c)}).then(function(a){if(!a)throw new q(9,9003,c);return Te(a)}).then(function(a){return d.o().then(function(){return a})},function(a){return d.o().then(function(){throw a;})})};Se.prototype.stop=function(){return Promise.resolve()};
function Te(a){var b=new F(null,0);b.za(a.duration);var c=a.drmInfo?[a.drmInfo]:[];return{presentationTimeline:b,minBufferTime:10,offlineSessionIds:a.sessionIds,periods:a.periods.map(function(a){return{startTime:a.startTime,streamSets:a.streams.map(function(e){var f=e.segments.map(function(a,b){return new G(b,a.startTime,a.endTime,function(){return[a.uri]},0,null)});b.Ea(a.startTime,f);f=new T(f);return{language:e.language,type:e.contentType,primary:e.primary,drmInfos:c,streams:[{id:e.id,createSegmentIndex:Promise.resolve.bind(Promise),
findSegmentPosition:f.find.bind(f),getSegmentReference:f.get.bind(f),initSegmentReference:e.initSegmentUri?new Vb(function(){return[e.initSegmentUri]},0,null):null,presentationTimeOffset:e.presentationTimeOffset,mimeType:e.mimeType,codecs:e.codecs,bandwidth:0,width:e.width||void 0,height:e.height||void 0,kind:e.kind,encrypted:e.encrypted,keyId:e.keyId,allowedByApplication:!0,allowedByKeySystem:!0}]}})}})}}rb["application/x-offline-manifest"]=Se;Fa.offline=function(a){if(/^offline:([0-9]+)$/.exec(a)){var b={uri:a,data:new ArrayBuffer(0),headers:{"content-type":"application/x-offline-manifest"}};return Promise.resolve(b)}if(b=/^offline:[0-9]+\/[0-9]+\/([0-9]+)$/.exec(a)){var c=Number(b[1]),d=new Ke;return d.init(Qe).then(function(){return d.get("segment",c)}).then(function(b){return d.o().then(function(){if(!b)throw new q(9,9003,c);return{uri:a,data:b.data,headers:{}}})})}return Promise.reject(new q(1,9004,a))};function Ue(a,b,c){this.b={};this.i=c;this.m=a;this.l=b;this.j=this.a=null;this.f=this.g=this.h=this.c=0}Ue.prototype.o=function(){var a=this.j||Promise.resolve();this.b={};this.j=this.a=this.l=this.m=this.i=null;return a};function Ve(a,b,c,d,e){a.b[b]=a.b[b]||[];a.b[b].push({uris:c.a(),L:c.L,D:c.D,jb:d,Ca:e})}
function We(a,b){a.c=0;a.h=0;a.g=0;a.f=0;C(a.b).forEach(function(a){a.forEach(function(a){null!=a.D?this.c+=a.D-a.L+1:this.g+=a.jb}.bind(this))}.bind(a));a.a=b;a.a.size=a.c;var c=C(a.b).map(function(a){var b=0,c=function(){if(!this.i)return Promise.reject(new q(9,9002));if(b>=a.length)return Promise.resolve();var g=a[b++];return Xe(this,g).then(c)}.bind(this);return c()}.bind(a));a.b={};return a.j=Promise.all(c)}
function Xe(a,b){var c=Ha(b.uris,a.l);if(b.L||null!=b.D)c.headers.Range="bytes="+b.L+"-"+(null==b.D?"":b.D);var d;return a.m.request(1,c).then(function(a){if(!this.a)return Promise.reject(new q(9,9002));d=a.data.byteLength;return b.Ca(a.data)}.bind(a)).then(function(){if(!this.a)return Promise.reject(new q(9,9002));null==b.D?(this.a.size+=d,this.f+=b.jb):this.h+=d;var a=(this.h+this.f)/(this.c+this.g),c=Re(this.a);this.i.progressCallback(c,a)}.bind(a))};function X(a){this.a=new Ke;this.c=a;this.j=Ye(this);this.g=null;this.v=!1;this.i=null;this.l=[];this.f=-1;this.m=0;this.b=null;this.h=new Ue(a.h,a.getConfiguration().streaming.retryParameters,this.j)}l("shaka.offline.Storage",X);function Ze(){return!!window.indexedDB}X.support=Ze;
X.prototype.o=function(){var a=this.l,b=this.a,c=this.h?this.h.o()["catch"](function(){}).then(function(){return Promise.all(a.map(function(a){return b.remove("segment",a)}))}).then(function(){return b.o()}):Promise.resolve();this.j=this.c=this.h=this.a=null;return c};X.prototype.destroy=X.prototype.o;X.prototype.configure=function(a){zc(this.j,a,Ye(this),{},"")};X.prototype.configure=X.prototype.configure;
X.prototype.Sc=function(a,b,c){function d(a){f=a}if(this.v)return Promise.reject(new q(9,9006));this.v=!0;var e,f=null;return $e(this).then(function(){Y(this);return af(this,a,d,c)}.bind(this)).then(function(c){Y(this);this.b=c.manifest;this.g=c.Qb;if(this.b.presentationTimeline.U()||this.b.presentationTimeline.ga())throw new q(9,9005,a);this.b.periods.forEach(this.s.bind(this));this.f=this.a.b.manifest++;this.m=0;c=this.b.periods.map(this.w.bind(this));var d=this.g.b,f=ib(this.g);if(d){if(!f.length)throw new q(9,
9007,a);d.initData=[]}e={key:this.f,originalManifestUri:a,duration:this.m,size:0,periods:c,sessionIds:f,drmInfo:d,appMetadata:b};return We(this.h,e)}.bind(this)).then(function(){Y(this);if(f)throw f;return Oe(this.a,"manifest",e)}.bind(this)).then(function(){return bf(this)}.bind(this)).then(function(){return Re(e)}.bind(this))["catch"](function(a){return bf(this)["catch"](v).then(function(){throw a;})}.bind(this))};X.prototype.store=X.prototype.Sc;
X.prototype.remove=function(a){function b(a){6013!=a.code&&(e=a)}var c=a.offlineUri,d=/^offline:([0-9]+)$/.exec(c);if(!d)return Promise.reject(new q(9,9004,c));var e=null,f,g,h=Number(d[1]);return $e(this).then(function(){Y(this);return this.a.get("manifest",h)}.bind(this)).then(function(a){Y(this);if(!a)throw new q(9,9003,c);f=a;a=Te(f);g=new ab(this.c.h,b,function(){});g.configure(this.c.getConfiguration().drm);return g.init(a,!0)}.bind(this)).then(function(){return fb(g,f.sessionIds)}.bind(this)).then(function(){return g.o()}.bind(this)).then(function(){Y(this);
if(e)throw e;var b=f.periods.map(function(a){return a.streams.map(function(a){var b=a.segments.map(function(a){return Number(/^offline:[0-9]+\/[0-9]+\/([0-9]+)$/.exec(a.uri)[1])});a.initSegmentUri&&b.push(Number(/^offline:[0-9]+\/[0-9]+\/([0-9]+)$/.exec(a.initSegmentUri)[1]));return b}).reduce(t,[])}).reduce(t,[]),c=0,d=b.length,g=this.j.progressCallback;return Pe(this.a,function(e){e=b.indexOf(e.key);0<=e&&(g(a,c/d),c++);return 0<=e}.bind(this))}.bind(this)).then(function(){Y(this);this.j.progressCallback(a,
1);return this.a.remove("manifest",h)}.bind(this))};X.prototype.remove=X.prototype.remove;X.prototype.list=function(){var a=[];return $e(this).then(function(){Y(this);return this.a.forEach("manifest",function(b){a.push(Re(b))})}.bind(this)).then(function(){return a})};X.prototype.list=X.prototype.list;
function af(a,b,c,d){function e(){}var f=a.c.h,g=a.c.getConfiguration(),h,m,n;return ub(b,f,g.manifest.retryParameters,d).then(function(a){Y(this);n=new a;n.configure(g.manifest);return n.start(b,f,this.s.bind(this),c)}.bind(a)).then(function(a){Y(this);h=a;m=new ab(f,c,e);m.configure(g.drm);return m.init(h,!0)}.bind(a)).then(function(){Y(this);return cf(h)}.bind(a)).then(function(){Y(this);return eb(m)}.bind(a)).then(function(){Y(this);return n.stop()}.bind(a)).then(function(){Y(this);return{manifest:h,
Qb:m}}.bind(a))["catch"](function(a){if(n)return n.stop().then(function(){throw a;});throw a;})}
X.prototype.A=function(a){var b=[],c=a.filter(function(a){return"video"==a.type&&480>=a.height});c.sort(function(a,b){return b.bandwidth-a.bandwidth});c.length&&b.push(c[0]);for(var d=Dc(this.c.getConfiguration().preferredAudioLanguage),c=[0,Bc,Cc],e=a.filter(function(a){return"audio"==a.type}),c=c.map(function(a){return e.filter(function(b){b=Dc(b.language);return Ac(a,d,b)})}),f=e,g=0;g<c.length;g++)c[g].length&&(f=c[g]);f.sort(function(a,b){return a.bandwidth-b.bandwidth});f.length&&b.push(f[Math.floor(f.length/
2)]);var c=Dc(this.c.getConfiguration().preferredTextLanguage),h=Ac.bind(null,Cc,c);b.push.apply(b,a.filter(function(a){var b=Dc(a.language);return"text"==a.type&&h(b)}));return b};function Ye(a){return{trackSelectionCallback:a.A.bind(a),progressCallback:function(a,c){if(a||c)return null}}}function $e(a){return a.a.a?Promise.resolve():a.a.init(Qe)}
X.prototype.s=function(a){function b(a,b,c){b=b.filter(function(a){return a.type==c});return 0==b.length?null:Ic(a,b[0]).stream}var c={};this.i&&(c={video:b(this.b.periods[0],this.i,"video"),audio:b(this.b.periods[0],this.i,"audio")});Gc(this.g,c,a);Fc(a,this.c.getConfiguration().restrictions,{width:Infinity,height:Infinity})};function bf(a){var b=a.g?a.g.o():Promise.resolve();a.g=null;a.b=null;a.v=!1;a.i=null;a.l=[];a.f=-1;return b}
function cf(a){a=a.periods.map(function(a){return a.streamSets}).reduce(t,[]).map(function(a){return a.streams}).reduce(t,[]);return Promise.all(a.map(function(a){return a.createSegmentIndex()}))}
X.prototype.w=function(a){var b=Hc(a,null),b=this.j.trackSelectionCallback(b);this.i||(this.i=b,this.b.periods.forEach(this.s.bind(this)));for(var c=b.length-1;0<c;--c){for(var d=!1,e=c-1;0<=e;--e)if(b[c].type==b[e].type&&b[c].kind==b[e].kind&&b[c].language==b[e].language){d=!0;break}if(d)break}b=b.map(function(b){b=Ic(a,b);return df(this,a,b.Tc,b.stream)}.bind(this));return{startTime:a.startTime,streams:b}};
function df(a,b,c,d){for(var e=[],f=a.b.presentationTimeline.ra(),g=f,h=d.findSegmentPosition(f),m=null!=h?d.getSegmentReference(h):null;m;){var n=a.a.b.segment++;Ve(a.h,c.type,m,(m.endTime-m.startTime)*d.bandwidth/8,function(a,b,c,d){b={key:a,data:d,manifestKey:this.f,streamNumber:c,segmentNumber:b};this.l.push(a);return Oe(this.a,"segment",b)}.bind(a,n,m.position,d.id));e.push({startTime:m.startTime,endTime:m.endTime,uri:"offline:"+a.f+"/"+d.id+"/"+n});g=m.endTime+b.startTime;m=d.getSegmentReference(++h)}a.m=
Math.max(a.m,g-f);b=null;d.initSegmentReference&&(n=a.a.b.segment++,b="offline:"+a.f+"/"+d.id+"/"+n,Ve(a.h,c.type,d.initSegmentReference,0,function(a,b){var c={key:n,data:b,manifestKey:this.f,streamNumber:a,segmentNumber:-1};this.l.push(n);return Oe(this.a,"segment",c)}.bind(a,d.id)));return{id:d.id,primary:c.primary,presentationTimeOffset:d.presentationTimeOffset||0,contentType:c.type,mimeType:d.mimeType,codecs:d.codecs,kind:d.kind,language:c.language,width:d.width||null,height:d.height||null,initSegmentUri:b,
encrypted:d.encrypted,keyId:d.keyId,segments:e}}function Y(a){if(!a.c)throw new q(9,9002);}Qc.offline=Ze;l("shaka.polyfill.installAll",function(){for(var a=0;a<ef.length;++a)ef[a]()});var ef=[];function ff(a){ef.push(a)}l("shaka.polyfill.register",ff);function gf(a){var b=a.type.replace(/^(webkit|moz|MS)/,"").toLowerCase(),b=new Event(b,a);a.target.dispatchEvent(b)}
ff(function(){if(window.Document){var a=Element.prototype;a.requestFullscreen=a.requestFullscreen||a.mozRequestFullScreen||a.msRequestFullscreen||a.webkitRequestFullscreen;a=Document.prototype;a.exitFullscreen=a.exitFullscreen||a.mozCancelFullScreen||a.msExitFullscreen||a.webkitExitFullscreen;"fullscreenElement"in document||Object.defineProperty(document,"fullscreenElement",{get:function(){return document.mozFullScreenElement||document.msFullscreenElement||document.webkitFullscreenElement}});document.addEventListener("webkitfullscreenchange",
gf);document.addEventListener("webkitfullscreenerror",gf);document.addEventListener("mozfullscreenchange",gf);document.addEventListener("mozfullscreenerror",gf);document.addEventListener("MSFullscreenChange",gf);document.addEventListener("MSFullscreenError",gf)}});function hf(a){this.c=[];this.b=[];this.a=[];for(a=new Od(new DataView(a.buffer));Qd(a);){var b=Xd(1886614376,a);if(-1==b)break;var c=a.a-8,d=Rd(a);if(1<d)S(a,b-(a.a-c));else{S(a,3);var e=Za(Vd(a,16)),f=[];if(0<d)for(var d=R(a),g=0;g<d;++g){var h=Za(Vd(a,16));f.push(h)}d=R(a);S(a,d);this.b.push.apply(this.b,f);this.c.push(e);this.a.push({start:c,end:a.a-1});a.a!=c+b&&S(a,b-(a.a-c))}}};function jf(a,b){try{var c=new kf(a,b);return Promise.resolve(c)}catch(d){return Promise.reject(d)}}
function kf(a,b){this.keySystem=a;for(var c=!1,d=0;d<b.length;++d){var e=b[d],f={audioCapabilities:[],videoCapabilities:[],persistentState:"optional",distinctiveIdentifier:"optional",initDataTypes:e.initDataTypes,sessionTypes:["temporary"],label:e.label},g=!1;if(e.audioCapabilities)for(var h=0;h<e.audioCapabilities.length;++h){var m=e.audioCapabilities[h];if(m.contentType){var g=!0,n=m.contentType.split(";")[0];MSMediaKeys.isTypeSupported(this.keySystem,n)&&(f.audioCapabilities.push(m),c=!0)}}if(e.videoCapabilities)for(h=
0;h<e.videoCapabilities.length;++h)m=e.videoCapabilities[h],m.contentType&&(g=!0,n=m.contentType.split(";")[0],MSMediaKeys.isTypeSupported(this.keySystem,n)&&(f.videoCapabilities.push(m),c=!0));g||(c=MSMediaKeys.isTypeSupported(this.keySystem,"video/mp4"));"required"==e.persistentState&&(f.persistentState="required",f.sessionTypes=["persistent-license"]);if(c){this.a=f;return}}c=Error("Unsupported keySystem");c.name="NotSupportedError";c.code=DOMException.NOT_SUPPORTED_ERR;throw c;}
kf.prototype.createMediaKeys=function(){var a=new lf(this.keySystem);return Promise.resolve(a)};kf.prototype.getConfiguration=function(){return this.a};function mf(a){var b=this.mediaKeys;b&&b!=a&&nf(b,null);delete this.mediaKeys;return(this.mediaKeys=a)?nf(a,this):Promise.resolve()}function lf(a){this.a=new MSMediaKeys(a);this.b=new z}lf.prototype.createSession=function(a){if("temporary"!=(a||"temporary"))throw new TypeError("Session type "+a+" is unsupported on this platform.");return new of(this.a)};
lf.prototype.setServerCertificate=function(){return Promise.reject(Error("setServerCertificate not supported on this platform."))};function nf(a,b){function c(){b.msSetMediaKeys(d.a);b.removeEventListener("loadedmetadata",c)}Ka(a.b);if(!b)return Promise.resolve();B(a.b,b,"msneedkey",pf);var d=a;try{return 1<=b.readyState?b.msSetMediaKeys(a.a):b.addEventListener("loadedmetadata",c),Promise.resolve()}catch(e){return Promise.reject(e)}}
function of(a){p.call(this);this.c=null;this.g=a;this.b=this.a=null;this.f=new z;this.sessionId="";this.expiration=NaN;this.closed=new w;this.keyStatuses=new qf}ba(of);k=of.prototype;k.generateRequest=function(a,b){this.a=new w;try{this.c=this.g.createSession("video/mp4",new Uint8Array(b),null),B(this.f,this.c,"mskeymessage",this.hc.bind(this)),B(this.f,this.c,"mskeyadded",this.fc.bind(this)),B(this.f,this.c,"mskeyerror",this.gc.bind(this)),rf(this,"status-pending")}catch(c){this.a.reject(c)}return this.a};
k.load=function(){return Promise.reject(Error("MediaKeySession.load not yet supported"))};k.update=function(a){this.b=new w;try{this.c.update(new Uint8Array(a))}catch(b){this.b.reject(b)}return this.b};k.close=function(){try{this.c.close(),this.closed.resolve(),Ka(this.f)}catch(a){this.closed.reject(a)}return this.closed};k.remove=function(){return Promise.reject(Error("MediaKeySession.remove is only applicable for persistent licenses, which are not supported on this platform"))};
function pf(a){var b=document.createEvent("CustomEvent");b.initCustomEvent("encrypted",!1,!1,null);b.initDataType="cenc";if(a=a.initData){var c=new hf(a);if(!(1>=c.a.length)){for(var d=[],e=0;e<c.a.length;e++)d.push(a.subarray(c.a[e].start,c.a[e].end+1));e=sf;a=[];for(c=0;c<d.length;++c){for(var f=!1,g=0;g<a.length&&!(f=e?e(d[c],a[g]):d[c]===a[g]);++g);f||a.push(d[c])}for(e=d=0;e<a.length;e++)d+=a[e].length;d=new Uint8Array(d);for(e=c=0;e<a.length;e++)d.set(a[e],c),c+=a[e].length;a=d}}b.initData=
a;this.dispatchEvent(b)}function sf(a,b){return $a(a,b)}k.hc=function(a){this.a&&(this.a.resolve(),this.a=null);this.dispatchEvent(new H("message",{messageType:void 0==this.keyStatuses.Ua()?"licenserequest":"licenserenewal",message:a.message.buffer}))};k.fc=function(){this.a?(rf(this,"usable"),this.a.resolve(),this.a=null):this.b&&(rf(this,"usable"),this.b.resolve(),this.b=null)};
k.gc=function(){var a=Error("EME PatchedMediaKeysMs key error");a.errorCode=this.c.error;if(this.a)this.a.reject(a),this.a=null;else if(this.b)this.b.reject(a),this.b=null;else switch(this.c.error.code){case MSMediaKeyError.MS_MEDIA_KEYERR_OUTPUT:case MSMediaKeyError.MS_MEDIA_KEYERR_HARDWARECHANGE:rf(this,"output-not-allowed");default:rf(this,"internal-error")}};function rf(a,b){a.keyStatuses.cb(b);a.dispatchEvent(new H("keystatuseschange"))}function qf(){this.size=0;this.a=void 0}var tf;k=qf.prototype;
k.cb=function(a){this.size=void 0==a?0:1;this.a=a};k.Ua=function(){return this.a};k.forEach=function(a){this.a&&a(this.a,tf)};k.get=function(a){if(this.has(a))return this.a};k.has=function(a){var b=tf;return this.a&&$a(new Uint8Array(a),new Uint8Array(b))?!0:!1};function uf(){return Promise.reject(Error("The key system specified is not supported."))}function vf(a){return a?Promise.reject(Error("MediaKeys not supported.")):Promise.resolve()}function wf(){throw new TypeError("Illegal constructor.");}wf.prototype.createSession=function(){};wf.prototype.setServerCertificate=function(){};function xf(){throw new TypeError("Illegal constructor.");}xf.prototype.getConfiguration=function(){};xf.prototype.createMediaKeys=function(){};function yf(a,b){try{var c=new zf(a,b);return Promise.resolve(c)}catch(d){return Promise.reject(d)}}function Af(a){var b=this.mediaKeys;b&&b!=a&&Bf(b,null);delete this.mediaKeys;(this.mediaKeys=a)&&Bf(a,this);return Promise.resolve()}
function zf(a,b){this.a=this.keySystem=a;var c=!0;"org.w3.clearkey"==a&&(this.a="webkit-org.w3.clearkey",c=!1);var d=!1,e;e=document.getElementsByTagName("video");e=e.length?e[0]:document.createElement("video");for(var f=0;f<b.length;++f){var g=b[f],h={audioCapabilities:[],videoCapabilities:[],persistentState:"optional",distinctiveIdentifier:"optional",initDataTypes:g.initDataTypes,sessionTypes:["temporary"],label:g.label},m=!1;if(g.audioCapabilities)for(var n=0;n<g.audioCapabilities.length;++n){var r=
g.audioCapabilities[n];r.contentType&&(m=!0,e.canPlayType(r.contentType.split(";")[0],this.a)&&(h.audioCapabilities.push(r),d=!0))}if(g.videoCapabilities)for(n=0;n<g.videoCapabilities.length;++n)r=g.videoCapabilities[n],r.contentType&&(m=!0,e.canPlayType(r.contentType,this.a)&&(h.videoCapabilities.push(r),d=!0));m||(d=e.canPlayType("video/mp4",this.a)||e.canPlayType("video/webm",this.a));"required"==g.persistentState&&(c?(h.persistentState="required",h.sessionTypes=["persistent-license"]):d=!1);if(d){this.b=
h;return}}c="Unsupported keySystem";if("org.w3.clearkey"==a||"com.widevine.alpha"==a)c="None of the requested configurations were supported.";c=Error(c);c.name="NotSupportedError";c.code=DOMException.NOT_SUPPORTED_ERR;throw c;}zf.prototype.createMediaKeys=function(){var a=new Cf(this.a);return Promise.resolve(a)};zf.prototype.getConfiguration=function(){return this.b};function Cf(a){this.g=a;this.b=null;this.a=new z;this.c=[];this.f={}}
function Bf(a,b){a.b=b;Ka(a.a);b&&(B(a.a,b,"webkitneedkey",a.pc.bind(a)),B(a.a,b,"webkitkeymessage",a.oc.bind(a)),B(a.a,b,"webkitkeyadded",a.mc.bind(a)),B(a.a,b,"webkitkeyerror",a.nc.bind(a)))}k=Cf.prototype;k.createSession=function(a){var b=a||"temporary";if("temporary"!=b&&"persistent-license"!=b)throw new TypeError("Session type "+a+" is unsupported on this platform.");a=this.b||document.createElement("video");a.src||(a.src="about:blank");b=new Df(a,this.g,b);this.c.push(b);return b};
k.setServerCertificate=function(){return Promise.reject(Error("setServerCertificate not supported on this platform."))};k.pc=function(a){this.b.dispatchEvent(new H("encrypted",{initDataType:"webm",initData:a.initData}))};k.oc=function(a){var b=Ef(this,a.sessionId);b&&(a=new H("message",{messageType:void 0==b.keyStatuses.Ua()?"licenserequest":"licenserenewal",message:a.message}),b.b&&(b.b.resolve(),b.b=null),b.dispatchEvent(a))};
k.mc=function(a){if(a=Ef(this,a.sessionId))Ff(a,"usable"),a.a&&a.a.resolve(),a.a=null};
k.nc=function(a){var b=Ef(this,a.sessionId);if(b){var c=Error("EME v0.1b key error");c.errorCode=a.errorCode;c.errorCode.systemCode=a.systemCode;!a.sessionId&&b.b?(c.method="generateRequest",45==a.systemCode&&(c.message="Unsupported session type."),b.b.reject(c),b.b=null):a.sessionId&&b.a?(c.method="update",b.a.reject(c),b.a=null):(c=a.systemCode,a.errorCode.code==MediaKeyError.MEDIA_KEYERR_OUTPUT?Ff(b,"output-restricted"):1==c?Ff(b,"expired"):Ff(b,"internal-error"))}};
function Ef(a,b){var c=a.f[b];return c?c:(c=a.c.shift())?(c.sessionId=b,a.f[b]=c):null}function Df(a,b,c){p.call(this);this.f=a;this.h=!1;this.a=this.b=null;this.c=b;this.g=c;this.sessionId="";this.expiration=NaN;this.closed=new w;this.keyStatuses=new Gf}ba(Df);
function Hf(a,b,c){if(a.h)return Promise.reject(Error("The session is already initialized."));a.h=!0;var d;try{if("persistent-license"==a.g)if(c)d=new Uint8Array(Sa("LOAD_SESSION|"+c));else{var e=Sa("PERSISTENT|"),f=new Uint8Array(e.byteLength+b.byteLength);f.set(new Uint8Array(e),0);f.set(new Uint8Array(b),e.byteLength);d=f}else d=new Uint8Array(b)}catch(g){return Promise.reject(g)}a.b=new w;try{a.f.webkitGenerateKeyRequest(a.c,d)}catch(g){if("InvalidStateError"!=g.name)return a.b=null,Promise.reject(g);
setTimeout(function(){try{this.f.webkitGenerateKeyRequest(this.c,d)}catch(a){this.b.reject(a),this.b=null}}.bind(a),10)}return a.b}k=Df.prototype;
k.fb=function(a,b){if(this.a)this.a.then(this.fb.bind(this,a,b))["catch"](this.fb.bind(this,a,b));else{this.a=a;var c,d;"webkit-org.w3.clearkey"==this.c?(c=D(b),d=JSON.parse(c),"oct"!=d.keys[0].kty&&(this.a.reject(Error("Response is not a valid JSON Web Key Set.")),this.a=null),c=Xa(d.keys[0].k),d=Xa(d.keys[0].kid)):(c=new Uint8Array(b),d=null);try{this.f.webkitAddKey(this.c,c,d,this.sessionId)}catch(e){this.a.reject(e),this.a=null}}};
function Ff(a,b){a.keyStatuses.cb(b);a.dispatchEvent(new H("keystatuseschange"))}k.generateRequest=function(a,b){return Hf(this,b,null)};k.load=function(a){return"persistent-license"==this.g?Hf(this,null,a):Promise.reject(Error("Not a persistent session."))};k.update=function(a){var b=new w;this.fb(b,a);return b};
k.close=function(){if("persistent-license"!=this.g){if(!this.sessionId)return this.closed.reject(Error("The session is not callable.")),this.closed;this.f.webkitCancelKeyRequest(this.c,this.sessionId)}this.closed.resolve();return this.closed};k.remove=function(){return"persistent-license"!=this.g?Promise.reject(Error("Not a persistent session.")):this.close()};function Gf(){this.size=0;this.a=void 0}var If;k=Gf.prototype;k.cb=function(a){this.size=void 0==a?0:1;this.a=a};k.Ua=function(){return this.a};
k.forEach=function(a){this.a&&a(this.a,If)};k.get=function(a){if(this.has(a))return this.a};k.has=function(a){var b=If;return this.a&&$a(new Uint8Array(a),new Uint8Array(b))?!0:!1};ff(function(){!window.HTMLVideoElement||navigator.requestMediaKeySystemAccess&&MediaKeySystemAccess.prototype.getConfiguration||(HTMLMediaElement.prototype.webkitGenerateKeyRequest?(If=(new Uint8Array([0])).buffer,navigator.requestMediaKeySystemAccess=yf,delete HTMLMediaElement.prototype.mediaKeys,HTMLMediaElement.prototype.mediaKeys=null,HTMLMediaElement.prototype.setMediaKeys=Af,window.MediaKeys=Cf,window.MediaKeySystemAccess=zf):window.MSMediaKeys?(tf=(new Uint8Array([0])).buffer,delete HTMLMediaElement.prototype.mediaKeys,
HTMLMediaElement.prototype.mediaKeys=null,HTMLMediaElement.prototype.setMediaKeys=mf,window.MediaKeys=lf,window.MediaKeySystemAccess=kf,navigator.requestMediaKeySystemAccess=jf):(navigator.requestMediaKeySystemAccess=uf,delete HTMLMediaElement.prototype.mediaKeys,HTMLMediaElement.prototype.mediaKeys=null,HTMLMediaElement.prototype.setMediaKeys=vf,window.MediaKeys=wf,window.MediaKeySystemAccess=xf))});ff(function(){if(window.MediaSource){var a=navigator.vendor,b=navigator.appVersion;if(a&&b&&!(0>a.indexOf("Apple")))if(0<=b.indexOf("Version/8"))window.MediaSource=null;else{var c=MediaSource.prototype.addSourceBuffer;MediaSource.prototype.addSourceBuffer=function(){var a=c.apply(this,arguments);a.abort=function(){};return a}}}});function Z(a){this.c=[];this.b=[];this.ja=Jf;if(a)try{a(this.W.bind(this),this.a.bind(this))}catch(b){this.a(b)}}var Jf=0;function Kf(a){var b=new Z;b.W(a);return b}function Lf(a){var b=new Z;b.a(a);return b}function Mf(a){function b(a,b,c){a.ja==Jf&&(e[b]=c,d++,d==e.length&&a.W(e))}var c=new Z;if(!a.length)return c.W([]),c;for(var d=0,e=Array(a.length),f=c.a.bind(c),g=0;g<a.length;++g)a[g]&&a[g].then?a[g].then(b.bind(null,c,g),f):b(c,g,a[g]);return c}
function Nf(a){for(var b=new Z,c=b.W.bind(b),d=b.a.bind(b),e=0;e<a.length;++e)a[e]&&a[e].then?a[e].then(c,d):c(a[e]);return b}Z.prototype.then=function(a,b){var c=new Z;switch(this.ja){case 1:Of(this,c,a);break;case 2:Of(this,c,b);break;case Jf:this.c.push({I:c,Ca:a}),this.b.push({I:c,Ca:b})}return c};Z.prototype.then=Z.prototype.then;Z.prototype["catch"]=function(a){return this.then(void 0,a)};Z.prototype["catch"]=Z.prototype["catch"];
Z.prototype.W=function(a){if(this.ja==Jf){this.Oa=a;this.ja=1;for(a=0;a<this.c.length;++a)Of(this,this.c[a].I,this.c[a].Ca);this.c=[];this.b=[]}};Z.prototype.a=function(a){if(this.ja==Jf){this.Oa=a;this.ja=2;for(a=0;a<this.b.length;++a)Of(this,this.b[a].I,this.b[a].Ca);this.c=[];this.b=[]}};
function Of(a,b,c){Pf.push(function(){if(c&&"function"==typeof c){try{var a=c(this.Oa)}catch(f){b.a(f);return}var e;try{e=a&&a.then}catch(f){b.a(f);return}a instanceof Z?a==b?b.a(new TypeError("Chaining cycle detected")):a.then(b.W.bind(b),b.a.bind(b)):e?Qf(a,e,b):b.W(a)}else 1==this.ja?b.W(this.Oa):b.a(this.Oa)}.bind(a));null==Rf&&(Rf=Sf(Tf))}
function Qf(a,b,c){try{var d=!1;b.call(a,function(a){if(!d){d=!0;var b;try{b=a&&a.then}catch(g){c.a(g);return}b?Qf(a,b,c):c.W(a)}},c.a.bind(c))}catch(e){c.a(e)}}function Tf(){for(;Pf.length;){null!=Rf&&(Uf(Rf),Rf=null);var a=Pf;Pf=[];for(var b=0;b<a.length;++b)a[b]()}}function Sf(){return 0}function Uf(){}var Rf=null,Pf=[];
ff(function(a){window.setImmediate?(Sf=function(a){return window.setImmediate(a)},Uf=function(a){return window.clearImmediate(a)}):(Sf=function(a){return window.setTimeout(a,0)},Uf=function(a){return window.clearTimeout(a)});if(!window.Promise||a)window.Promise=Z,window.Promise.resolve=Kf,window.Promise.reject=Lf,window.Promise.all=Mf,window.Promise.race=Nf});function Vf(){return{droppedVideoFrames:this.webkitDroppedFrameCount,totalVideoFrames:this.webkitDecodedFrameCount,corruptedVideoFrames:0,creationTime:NaN,totalFrameDelay:0}}ff(function(){if(window.HTMLVideoElement){var a=HTMLVideoElement.prototype;!a.getVideoPlaybackQuality&&"webkitDroppedFrameCount"in a&&(a.getVideoPlaybackQuality=Vf)}});}.call(g,this));
if (typeof(module)!="undefined"&&module.exports)module.exports=g.shaka;
else if (typeof(define)!="undefined" && define.amd)define(function(){return g.shaka});
else this.shaka=g.shaka;
})();


},{}],881:[function(require,module,exports){
/*
Slick Finder
*/"use strict"

// Notable changes from Slick.Finder 1.0.x

// faster bottom -> up expression matching
// prefers mental sanity over *obsessive compulsive* milliseconds savings
// uses prototypes instead of objects
// tries to use matchesSelector smartly, whenever available
// can populate objects as well as arrays
// lots of stuff is broken or not implemented

var parse = require("./parser")

// utilities

var index = 0,
    counter = document.__counter = (parseInt(document.__counter || -1, 36) + 1).toString(36),
    key = "uid:" + counter

var uniqueID = function(n, xml){
    if (n === window) return "window"
    if (n === document) return "document"
    if (n === document.documentElement) return "html"

    if (xml) {
        var uid = n.getAttribute(key)
        if (!uid) {
            uid = (index++).toString(36)
            n.setAttribute(key, uid)
        }
        return uid
    } else {
        return n[key] || (n[key] = (index++).toString(36))
    }
}

var uniqueIDXML = function(n) {
    return uniqueID(n, true)
}

var isArray = Array.isArray || function(object){
    return Object.prototype.toString.call(object) === "[object Array]"
}

// tests

var uniqueIndex = 0;

var HAS = {

    GET_ELEMENT_BY_ID: function(test, id){
        id = "slick_" + (uniqueIndex++);
        // checks if the document has getElementById, and it works
        test.innerHTML = '<a id="' + id + '"></a>'
        return !!this.getElementById(id)
    },

    QUERY_SELECTOR: function(test){
        // this supposedly fixes a webkit bug with matchesSelector / querySelector & nth-child
        test.innerHTML = '_<style>:nth-child(2){}</style>'

        // checks if the document has querySelectorAll, and it works
        test.innerHTML = '<a class="MiX"></a>'

        return test.querySelectorAll('.MiX').length === 1
    },

    EXPANDOS: function(test, id){
        id = "slick_" + (uniqueIndex++);
        // checks if the document has elements that support expandos
        test._custom_property_ = id
        return test._custom_property_ === id
    },

    // TODO: use this ?

    // CHECKED_QUERY_SELECTOR: function(test){
    //
    //     // checks if the document supports the checked query selector
    //     test.innerHTML = '<select><option selected="selected">a</option></select>'
    //     return test.querySelectorAll(':checked').length === 1
    // },

    // TODO: use this ?

    // EMPTY_ATTRIBUTE_QUERY_SELECTOR: function(test){
    //
    //     // checks if the document supports the empty attribute query selector
    //     test.innerHTML = '<a class=""></a>'
    //     return test.querySelectorAll('[class*=""]').length === 1
    // },

    MATCHES_SELECTOR: function(test){

        test.className = "MiX"

        // checks if the document has matchesSelector, and we can use it.

        var matches = test.matchesSelector || test.mozMatchesSelector || test.webkitMatchesSelector

        // if matchesSelector trows errors on incorrect syntax we can use it
        if (matches) try {
            matches.call(test, ':slick')
        } catch(e){
            // just as a safety precaution, also test if it works on mixedcase (like querySelectorAll)
            return matches.call(test, ".MiX") ? matches : false
        }

        return false
    },

    GET_ELEMENTS_BY_CLASS_NAME: function(test){
        test.innerHTML = '<a class="f"></a><a class="b"></a>'
        if (test.getElementsByClassName('b').length !== 1) return false

        test.firstChild.className = 'b'
        if (test.getElementsByClassName('b').length !== 2) return false

        // Opera 9.6 getElementsByClassName doesnt detects the class if its not the first one
        test.innerHTML = '<a class="a"></a><a class="f b a"></a>'
        if (test.getElementsByClassName('a').length !== 2) return false

        // tests passed
        return true
    },

    // no need to know

    // GET_ELEMENT_BY_ID_NOT_NAME: function(test, id){
    //     test.innerHTML = '<a name="'+ id +'"></a><b id="'+ id +'"></b>'
    //     return this.getElementById(id) !== test.firstChild
    // },

    // this is always checked for and fixed

    // STAR_GET_ELEMENTS_BY_TAG_NAME: function(test){
    //
    //     // IE returns comment nodes for getElementsByTagName('*') for some documents
    //     test.appendChild(this.createComment(''))
    //     if (test.getElementsByTagName('*').length > 0) return false
    //
    //     // IE returns closed nodes (EG:"</foo>") for getElementsByTagName('*') for some documents
    //     test.innerHTML = 'foo</foo>'
    //     if (test.getElementsByTagName('*').length) return false
    //
    //     // tests passed
    //     return true
    // },

    // this is always checked for and fixed

    // STAR_QUERY_SELECTOR: function(test){
    //
    //     // returns closed nodes (EG:"</foo>") for querySelector('*') for some documents
    //     test.innerHTML = 'foo</foo>'
    //     return !!(test.querySelectorAll('*').length)
    // },

    GET_ATTRIBUTE: function(test){
        // tests for working getAttribute implementation
        var shout = "fus ro dah"
        test.innerHTML = '<a class="' + shout + '"></a>'
        return test.firstChild.getAttribute('class') === shout
    }

}

// Finder

var Finder = function Finder(document){

    this.document        = document
    var root = this.root = document.documentElement
    this.tested          = {}

    // uniqueID

    this.uniqueID = this.has("EXPANDOS") ? uniqueID : uniqueIDXML

    // getAttribute

    this.getAttribute = (this.has("GET_ATTRIBUTE")) ? function(node, name){

        return node.getAttribute(name)

    } : function(node, name){

        node = node.getAttributeNode(name)
        return (node && node.specified) ? node.value : null

    }

    // hasAttribute

    this.hasAttribute = (root.hasAttribute) ? function(node, attribute){

        return node.hasAttribute(attribute)

    } : function(node, attribute) {

        node = node.getAttributeNode(attribute)
        return !!(node && node.specified)

    }

    // contains

    this.contains = (document.contains && root.contains) ? function(context, node){

        return context.contains(node)

    } : (root.compareDocumentPosition) ? function(context, node){

        return context === node || !!(context.compareDocumentPosition(node) & 16)

    } : function(context, node){

        do {
            if (node === context) return true
        } while ((node = node.parentNode))

        return false
    }

    // sort
    // credits to Sizzle (http://sizzlejs.com/)

    this.sorter = (root.compareDocumentPosition) ? function(a, b){

        if (!a.compareDocumentPosition || !b.compareDocumentPosition) return 0
        return a.compareDocumentPosition(b) & 4 ? -1 : a === b ? 0 : 1

    } : ('sourceIndex' in root) ? function(a, b){

        if (!a.sourceIndex || !b.sourceIndex) return 0
        return a.sourceIndex - b.sourceIndex

    } : (document.createRange) ? function(a, b){

        if (!a.ownerDocument || !b.ownerDocument) return 0
        var aRange = a.ownerDocument.createRange(),
            bRange = b.ownerDocument.createRange()

        aRange.setStart(a, 0)
        aRange.setEnd(a, 0)
        bRange.setStart(b, 0)
        bRange.setEnd(b, 0)
        return aRange.compareBoundaryPoints(Range.START_TO_END, bRange)

    } : null

    this.failed = {}

    var nativeMatches = this.has("MATCHES_SELECTOR")

    if (nativeMatches) this.matchesSelector = function(node, expression){

        if (this.failed[expression]) return null

        try {
            return nativeMatches.call(node, expression)
        } catch(e){
            if (slick.debug) console.warn("matchesSelector failed on " + expression)
            this.failed[expression] = true
            return null
        }

    }

    if (this.has("QUERY_SELECTOR")){

        this.querySelectorAll = function(node, expression){

            if (this.failed[expression]) return true

            var result, _id, _expression, _combinator, _node


            // non-document rooted QSA
            // credits to Andrew Dupont

            if (node !== this.document){

                _combinator = expression[0].combinator

                _id         = node.getAttribute("id")
                _expression = expression

                if (!_id){
                    _node = node
                    _id = "__slick__"
                    _node.setAttribute("id", _id)
                }

                expression = "#" + _id + " " + _expression


                // these combinators need a parentNode due to how querySelectorAll works, which is:
                // finding all the elements that match the given selector
                // then filtering by the ones that have the specified element as an ancestor
                if (_combinator.indexOf("~") > -1 || _combinator.indexOf("+") > -1){

                    node = node.parentNode
                    if (!node) result = true
                    // if node has no parentNode, we return "true" as if it failed, without polluting the failed cache

                }

            }

            if (!result) try {
                result = node.querySelectorAll(expression.toString())
            } catch(e){
                if (slick.debug) console.warn("querySelectorAll failed on " + (_expression || expression))
                result = this.failed[_expression || expression] = true
            }

            if (_node) _node.removeAttribute("id")

            return result

        }

    }

}

Finder.prototype.has = function(FEATURE){

    var tested        = this.tested,
        testedFEATURE = tested[FEATURE]

    if (testedFEATURE != null) return testedFEATURE

    var root     = this.root,
        document = this.document,
        testNode = document.createElement("div")

    testNode.setAttribute("style", "display: none;")

    root.appendChild(testNode)

    var TEST = HAS[FEATURE], result = false

    if (TEST) try {
        result = TEST.call(document, testNode)
    } catch(e){}

    if (slick.debug && !result) console.warn("document has no " + FEATURE)

    root.removeChild(testNode)

    return tested[FEATURE] = result

}

var combinators = {

    " ": function(node, part, push){

        var item, items

        var noId = !part.id, noTag = !part.tag, noClass = !part.classes

        if (part.id && node.getElementById && this.has("GET_ELEMENT_BY_ID")){
            item = node.getElementById(part.id)

            // return only if id is found, else keep checking
            // might be a tad slower on non-existing ids, but less insane

            if (item && item.getAttribute('id') === part.id){
                items = [item]
                noId = true
                // if tag is star, no need to check it in match()
                if (part.tag === "*") noTag = true
            }
        }

        if (!items){

            if (part.classes && node.getElementsByClassName && this.has("GET_ELEMENTS_BY_CLASS_NAME")){
                items = node.getElementsByClassName(part.classList)
                noClass = true
                // if tag is star, no need to check it in match()
                if (part.tag === "*") noTag = true
            } else {
                items = node.getElementsByTagName(part.tag)
                // if tag is star, need to check it in match because it could select junk, boho
                if (part.tag !== "*") noTag = true
            }

            if (!items || !items.length) return false

        }

        for (var i = 0; item = items[i++];)
            if ((noTag && noId && noClass && !part.attributes && !part.pseudos) || this.match(item, part, noTag, noId, noClass))
                push(item)

        return true

    },

    ">": function(node, part, push){ // direct children
        if ((node = node.firstChild)) do {
            if (node.nodeType == 1 && this.match(node, part)) push(node)
        } while ((node = node.nextSibling))
    },

    "+": function(node, part, push){ // next sibling
        while ((node = node.nextSibling)) if (node.nodeType == 1){
            if (this.match(node, part)) push(node)
            break
        }
    },

    "^": function(node, part, push){ // first child
        node = node.firstChild
        if (node){
            if (node.nodeType === 1){
                if (this.match(node, part)) push(node)
            } else {
                combinators['+'].call(this, node, part, push)
            }
        }
    },

    "~": function(node, part, push){ // next siblings
        while ((node = node.nextSibling)){
            if (node.nodeType === 1 && this.match(node, part)) push(node)
        }
    },

    "++": function(node, part, push){ // next sibling and previous sibling
        combinators['+'].call(this, node, part, push)
        combinators['!+'].call(this, node, part, push)
    },

    "~~": function(node, part, push){ // next siblings and previous siblings
        combinators['~'].call(this, node, part, push)
        combinators['!~'].call(this, node, part, push)
    },

    "!": function(node, part, push){ // all parent nodes up to document
        while ((node = node.parentNode)) if (node !== this.document && this.match(node, part)) push(node)
    },

    "!>": function(node, part, push){ // direct parent (one level)
        node = node.parentNode
        if (node !== this.document && this.match(node, part)) push(node)
    },

    "!+": function(node, part, push){ // previous sibling
        while ((node = node.previousSibling)) if (node.nodeType == 1){
            if (this.match(node, part)) push(node)
            break
        }
    },

    "!^": function(node, part, push){ // last child
        node = node.lastChild
        if (node){
            if (node.nodeType == 1){
                if (this.match(node, part)) push(node)
            } else {
                combinators['!+'].call(this, node, part, push)
            }
        }
    },

    "!~": function(node, part, push){ // previous siblings
        while ((node = node.previousSibling)){
            if (node.nodeType === 1 && this.match(node, part)) push(node)
        }
    }

}

Finder.prototype.search = function(context, expression, found){

    if (!context) context = this.document
    else if (!context.nodeType && context.document) context = context.document

    var expressions = parse(expression)

    // no expressions were parsed. todo: is this really necessary?
    if (!expressions || !expressions.length) throw new Error("invalid expression")

    if (!found) found = []

    var uniques, push = isArray(found) ? function(node){
        found[found.length] = node
    } : function(node){
        found[found.length++] = node
    }

    // if there is more than one expression we need to check for duplicates when we push to found
    // this simply saves the old push and wraps it around an uid dupe check.
    if (expressions.length > 1){
        uniques = {}
        var plush = push
        push = function(node){
            var uid = uniqueID(node)
            if (!uniques[uid]){
                uniques[uid] = true
                plush(node)
            }
        }
    }

    // walker

    var node, nodes, part

    main: for (var i = 0; expression = expressions[i++];){

        // querySelector

        // TODO: more functional tests

        // if there is querySelectorAll (and the expression does not fail) use it.
        if (!slick.noQSA && this.querySelectorAll){

            nodes = this.querySelectorAll(context, expression)
            if (nodes !== true){
                if (nodes && nodes.length) for (var j = 0; node = nodes[j++];) if (node.nodeName > '@'){
                    push(node)
                }
                continue main
            }
        }

        // if there is only one part in the expression we don't need to check each part for duplicates.
        // todo: this might be too naive. while solid, there can be expression sequences that do not
        // produce duplicates. "body div" for instance, can never give you each div more than once.
        // "body div a" on the other hand might.
        if (expression.length === 1){

            part = expression[0]
            combinators[part.combinator].call(this, context, part, push)

        } else {

            var cs = [context], c, f, u, p = function(node){
                var uid = uniqueID(node)
                if (!u[uid]){
                    u[uid] = true
                    f[f.length] = node
                }
            }

            // loop the expression parts
            for (var j = 0; part = expression[j++];){
                f = []; u = {}
                // loop the contexts
                for (var k = 0; c = cs[k++];) combinators[part.combinator].call(this, c, part, p)
                // nothing was found, the expression failed, continue to the next expression.
                if (!f.length) continue main
                cs = f // set the contexts for future parts (if any)
            }

            if (i === 0) found = f // first expression. directly set found.
            else for (var l = 0; l < f.length; l++) push(f[l]) // any other expression needs to push to found.
        }

    }

    if (uniques && found && found.length > 1) this.sort(found)

    return found

}

Finder.prototype.sort = function(nodes){
    return this.sorter ? Array.prototype.sort.call(nodes, this.sorter) : nodes
}

// TODO: most of these pseudo selectors include <html> and qsa doesnt. fixme.

var pseudos = {


    // TODO: returns different results than qsa empty.

    'empty': function(){
        return !(this && this.nodeType === 1) && !(this.innerText || this.textContent || '').length
    },

    'not': function(expression){
        return !slick.matches(this, expression)
    },

    'contains': function(text){
        return (this.innerText || this.textContent || '').indexOf(text) > -1
    },

    'first-child': function(){
        var node = this
        while ((node = node.previousSibling)) if (node.nodeType == 1) return false
        return true
    },

    'last-child': function(){
        var node = this
        while ((node = node.nextSibling)) if (node.nodeType == 1) return false
        return true
    },

    'only-child': function(){
        var prev = this
        while ((prev = prev.previousSibling)) if (prev.nodeType == 1) return false

        var next = this
        while ((next = next.nextSibling)) if (next.nodeType == 1) return false

        return true
    },

    'first-of-type': function(){
        var node = this, nodeName = node.nodeName
        while ((node = node.previousSibling)) if (node.nodeName == nodeName) return false
        return true
    },

    'last-of-type': function(){
        var node = this, nodeName = node.nodeName
        while ((node = node.nextSibling)) if (node.nodeName == nodeName) return false
        return true
    },

    'only-of-type': function(){
        var prev = this, nodeName = this.nodeName
        while ((prev = prev.previousSibling)) if (prev.nodeName == nodeName) return false
        var next = this
        while ((next = next.nextSibling)) if (next.nodeName == nodeName) return false
        return true
    },

    'enabled': function(){
        return !this.disabled
    },

    'disabled': function(){
        return this.disabled
    },

    'checked': function(){
        return this.checked || this.selected
    },

    'selected': function(){
        return this.selected
    },

    'focus': function(){
        var doc = this.ownerDocument
        return doc.activeElement === this && (this.href || this.type || slick.hasAttribute(this, 'tabindex'))
    },

    'root': function(){
        return (this === this.ownerDocument.documentElement)
    }

}

Finder.prototype.match = function(node, bit, noTag, noId, noClass){

    // TODO: more functional tests ?

    if (!slick.noQSA && this.matchesSelector){
        var matches = this.matchesSelector(node, bit)
        if (matches !== null) return matches
    }

    // normal matching

    if (!noTag && bit.tag){

        var nodeName = node.nodeName.toLowerCase()
        if (bit.tag === "*"){
            if (nodeName < "@") return false
        } else if (nodeName != bit.tag){
            return false
        }

    }

    if (!noId && bit.id && node.getAttribute('id') !== bit.id) return false

    var i, part

    if (!noClass && bit.classes){

        var className = this.getAttribute(node, "class")
        if (!className) return false

        for (part in bit.classes) if (!RegExp('(^|\\s)' + bit.classes[part] + '(\\s|$)').test(className)) return false
    }

    var name, value

    if (bit.attributes) for (i = 0; part = bit.attributes[i++];){

        var operator  = part.operator,
            escaped   = part.escapedValue

        name  = part.name
        value = part.value

        if (!operator){

            if (!this.hasAttribute(node, name)) return false

        } else {

            var actual = this.getAttribute(node, name)
            if (actual == null) return false

            switch (operator){
                case '^=' : if (!RegExp(      '^' + escaped            ).test(actual)) return false; break
                case '$=' : if (!RegExp(            escaped + '$'      ).test(actual)) return false; break
                case '~=' : if (!RegExp('(^|\\s)' + escaped + '(\\s|$)').test(actual)) return false; break
                case '|=' : if (!RegExp(      '^' + escaped + '(-|$)'  ).test(actual)) return false; break

                case '='  : if (actual !== value) return false; break
                case '*=' : if (actual.indexOf(value) === -1) return false; break
                default   : return false
            }

        }
    }

    if (bit.pseudos) for (i = 0; part = bit.pseudos[i++];){

        name  = part.name
        value = part.value

        if (pseudos[name]) return pseudos[name].call(node, value)

        if (value != null){
            if (this.getAttribute(node, name) !== value) return false
        } else {
            if (!this.hasAttribute(node, name)) return false
        }

    }

    return true

}

Finder.prototype.matches = function(node, expression){

    var expressions = parse(expression)

    if (expressions.length === 1 && expressions[0].length === 1){ // simplest match
        return this.match(node, expressions[0][0])
    }

    // TODO: more functional tests ?

    if (!slick.noQSA && this.matchesSelector){
        var matches = this.matchesSelector(node, expressions)
        if (matches !== null) return matches
    }

    var nodes = this.search(this.document, expression, {length: 0})

    for (var i = 0, res; res = nodes[i++];) if (node === res) return true
    return false

}

var finders = {}

var finder = function(context){
    var doc = context || document
    if (doc.ownerDocument) doc = doc.ownerDocument
    else if (doc.document) doc = doc.document

    if (doc.nodeType !== 9) throw new TypeError("invalid document")

    var uid = uniqueID(doc)
    return finders[uid] || (finders[uid] = new Finder(doc))
}

// ... API ...

var slick = function(expression, context){
    return slick.search(expression, context)
}

slick.search = function(expression, context, found){
    return finder(context).search(context, expression, found)
}

slick.find = function(expression, context){
    return finder(context).search(context, expression)[0] || null
}

slick.getAttribute = function(node, name){
    return finder(node).getAttribute(node, name)
}

slick.hasAttribute = function(node, name){
    return finder(node).hasAttribute(node, name)
}

slick.contains = function(context, node){
    return finder(context).contains(context, node)
}

slick.matches = function(node, expression){
    return finder(node).matches(node, expression)
}

slick.sort = function(nodes){
    if (nodes && nodes.length > 1) finder(nodes[0]).sort(nodes)
    return nodes
}

slick.parse = parse;

// slick.debug = true
// slick.noQSA  = true

module.exports = slick

},{"./parser":883}],882:[function(require,module,exports){
(function (global){
/*
slick
*/"use strict"

module.exports = "document" in global ? require("./finder") : { parse: require("./parser") }

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./finder":881,"./parser":883}],883:[function(require,module,exports){
/*
Slick Parser
 - originally created by the almighty Thomas Aylott <@subtlegradient> (http://subtlegradient.com)
*/"use strict"

// Notable changes from Slick.Parser 1.0.x

// The parser now uses 2 classes: Expressions and Expression
// `new Expressions` produces an array-like object containing a list of Expression objects
// - Expressions::toString() produces a cleaned up expressions string
// `new Expression` produces an array-like object
// - Expression::toString() produces a cleaned up expression string
// The only exposed method is parse, which produces a (cached) `new Expressions` instance
// parsed.raw is no longer present, use .toString()
// parsed.expression is now useless, just use the indices
// parsed.reverse() has been removed for now, due to its apparent uselessness
// Other changes in the Expressions object:
// - classNames are now unique, and save both escaped and unescaped values
// - attributes now save both escaped and unescaped values
// - pseudos now save both escaped and unescaped values

var escapeRe   = /([-.*+?^${}()|[\]\/\\])/g,
    unescapeRe = /\\/g

var escape = function(string){
    // XRegExp v2.0.0-beta-3
    // « https://github.com/slevithan/XRegExp/blob/master/src/xregexp.js
    return (string + "").replace(escapeRe, '\\$1')
}

var unescape = function(string){
    return (string + "").replace(unescapeRe, '')
}

var slickRe = RegExp(
/*
#!/usr/bin/env ruby
puts "\t\t" + DATA.read.gsub(/\(\?x\)|\s+#.*$|\s+|\\$|\\n/,'')
__END__
    "(?x)^(?:\
      \\s* ( , ) \\s*               # Separator          \n\
    | \\s* ( <combinator>+ ) \\s*   # Combinator         \n\
    |      ( \\s+ )                 # CombinatorChildren \n\
    |      ( <unicode>+ | \\* )     # Tag                \n\
    | \\#  ( <unicode>+       )     # ID                 \n\
    | \\.  ( <unicode>+       )     # ClassName          \n\
    |                               # Attribute          \n\
    \\[  \
        \\s* (<unicode1>+)  (?:  \
            \\s* ([*^$!~|]?=)  (?:  \
                \\s* (?:\
                    ([\"']?)(.*?)\\9 \
                )\
            )  \
        )?  \\s*  \
    \\](?!\\]) \n\
    |   :+ ( <unicode>+ )(?:\
    \\( (?:\
        (?:([\"'])([^\\12]*)\\12)|((?:\\([^)]+\\)|[^()]*)+)\
    ) \\)\
    )?\
    )"
*/
"^(?:\\s*(,)\\s*|\\s*(<combinator>+)\\s*|(\\s+)|(<unicode>+|\\*)|\\#(<unicode>+)|\\.(<unicode>+)|\\[\\s*(<unicode1>+)(?:\\s*([*^$!~|]?=)(?:\\s*(?:([\"']?)(.*?)\\9)))?\\s*\\](?!\\])|(:+)(<unicode>+)(?:\\((?:(?:([\"'])([^\\13]*)\\13)|((?:\\([^)]+\\)|[^()]*)+))\\))?)"
    .replace(/<combinator>/, '[' + escape(">+~`!@$%^&={}\\;</") + ']')
    .replace(/<unicode>/g, '(?:[\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
    .replace(/<unicode1>/g, '(?:[:\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
)

// Part

var Part = function Part(combinator){
    this.combinator = combinator || " "
    this.tag = "*"
}

Part.prototype.toString = function(){

    if (!this.raw){

        var xpr = "", k, part

        xpr += this.tag || "*"
        if (this.id) xpr += "#" + this.id
        if (this.classes) xpr += "." + this.classList.join(".")
        if (this.attributes) for (k = 0; part = this.attributes[k++];){
            xpr += "[" + part.name + (part.operator ? part.operator + '"' + part.value + '"' : '') + "]"
        }
        if (this.pseudos) for (k = 0; part = this.pseudos[k++];){
            xpr += ":" + part.name
            if (part.value) xpr += "(" + part.value + ")"
        }

        this.raw = xpr

    }

    return this.raw
}

// Expression

var Expression = function Expression(){
    this.length = 0
}

Expression.prototype.toString = function(){

    if (!this.raw){

        var xpr = ""

        for (var j = 0, bit; bit = this[j++];){
            if (j !== 1) xpr += " "
            if (bit.combinator !== " ") xpr += bit.combinator + " "
            xpr += bit
        }

        this.raw = xpr

    }

    return this.raw
}

var replacer = function(
    rawMatch,

    separator,
    combinator,
    combinatorChildren,

    tagName,
    id,
    className,

    attributeKey,
    attributeOperator,
    attributeQuote,
    attributeValue,

    pseudoMarker,
    pseudoClass,
    pseudoQuote,
    pseudoClassQuotedValue,
    pseudoClassValue
){

    var expression, current

    if (separator || !this.length){
        expression = this[this.length++] = new Expression
        if (separator) return ''
    }

    if (!expression) expression = this[this.length - 1]

    if (combinator || combinatorChildren || !expression.length){
        current = expression[expression.length++] = new Part(combinator)
    }

    if (!current) current = expression[expression.length - 1]

    if (tagName){

        current.tag = unescape(tagName)

    } else if (id){

        current.id = unescape(id)

    } else if (className){

        var unescaped = unescape(className)

        var classes = current.classes || (current.classes = {})
        if (!classes[unescaped]){
            classes[unescaped] = escape(className)
            var classList = current.classList || (current.classList = [])
            classList.push(unescaped)
            classList.sort()
        }

    } else if (pseudoClass){

        pseudoClassValue = pseudoClassValue || pseudoClassQuotedValue

        ;(current.pseudos || (current.pseudos = [])).push({
            type         : pseudoMarker.length == 1 ? 'class' : 'element',
            name         : unescape(pseudoClass),
            escapedName  : escape(pseudoClass),
            value        : pseudoClassValue ? unescape(pseudoClassValue) : null,
            escapedValue : pseudoClassValue ? escape(pseudoClassValue) : null
        })

    } else if (attributeKey){

        attributeValue = attributeValue ? escape(attributeValue) : null

        ;(current.attributes || (current.attributes = [])).push({
            operator     : attributeOperator,
            name         : unescape(attributeKey),
            escapedName  : escape(attributeKey),
            value        : attributeValue ? unescape(attributeValue) : null,
            escapedValue : attributeValue ? escape(attributeValue) : null
        })

    }

    return ''

}

// Expressions

var Expressions = function Expressions(expression){
    this.length = 0

    var self = this

    var original = expression, replaced

    while (expression){
        replaced = expression.replace(slickRe, function(){
            return replacer.apply(self, arguments)
        })
        if (replaced === expression) throw new Error(original + ' is an invalid expression')
        expression = replaced
    }
}

Expressions.prototype.toString = function(){
    if (!this.raw){
        var expressions = []
        for (var i = 0, expression; expression = this[i++];) expressions.push(expression)
        this.raw = expressions.join(", ")
    }

    return this.raw
}

var cache = {}

var parse = function(expression){
    if (expression == null) return null
    expression = ('' + expression).replace(/^\s+|\s+$/g, '')
    return cache[expression] || (cache[expression] = new Expressions(expression))
}

module.exports = parse

},{}],884:[function(require,module,exports){

/**
 * `Batch' constructor
 *
 * @api public
 * @param {Number} max - optional (Default: Infinity)
 */

module.exports = Batch;
function Batch (max) {
  if (!(this instanceof Batch)) {
    return new Batch(max);
  }

  var self = this;

  this.m = 0; // max
  this.c = 0; // concurrency
  this.jobs = [];

  this.concurrency(Infinity);
  this.max(max);

  Object.defineProperty(this, 'length', {
    get: function () {
      return self.jobs.length;
    }
  });
}

/**
 * Set batch concurrency
 *
 * @api public
 * @param {Number} n
 */

Batch.prototype.concurrency = function (n) {
  if (n > 0) {
    this.c = n;
  }
  return this;
};

/**
 * Set max job limit
 *
 * @api publc
 * @param {Number} n
 */

Batch.prototype.max = function (n) {
  this.m = 'number' == typeof n && n > 0 ? n : Infinity;
  return this;
};

/**
 * Push job onto queue
 *
 * @api publc
 * @param {Function} fn
 */

Batch.prototype.push = function (fn) {
  if ('function' != typeof fn) {
    throw new TypeError("expecting a function");
  } else if (this.length < this.m) {
    this.jobs.push(fn);
  }
  return this;
};

/**
 * Shift job off of queue
 *
 * @api public
 */

Batch.prototype.shift = function () {
  return this.jobs.shift();
};

/**
 * Dequeues all queued jobs
 *
 * @api public
 * @param {Function} done - optional
 */

Batch.prototype.run = function (done) {
  done = 'function' == typeof done ? done : Function();
  var self = this;
  var c = this.c;
  var i = 0;

  // empty queue
  if (0 == this.length) {
    return done(null);
  }

  function dequeue  () {
    var job = null;
    if (0 == self.length) {
      return false;
    }

    job = self.shift();

    if ('function' != typeof job) {
      return;
    }

    try { job(next); }
    catch (err) {
      done(err)
      return false;
    }

    function next (err) {
      if (err) {
        done(err);
      } else if (self.length) {
        dequeue();
      } else {
        done();
      }
    }
  }

  while (i++ < c) {
    if (false === dequeue()) {
      break;
    }
  }

  return this;
};

},{}],885:[function(require,module,exports){
/*jslint node: true */

'use strict';

var ClientRequest = require('./request').ClientRequest;

/**
 * An autoincremented id that is used to distinguish Resolver instances.
 *
 * @type {number}
 * @private
 */
var resolverUID = 0;

/**
 * A resolver takes a request for a resources and sends it through the
 * transport.
 *
 * @constructs Resolver
 */
function Resolver() {
  if (!(this instanceof Resolver))
    return new Resolver();

  /**
   * The resolver's id.
   *
   * @type {number}
   * @protected
   */
  this._id = resolverUID++;

  /**
   * An incrementing ID used for tracking requests.
   *
   * @type {number}
   * @protected
   */
  this._requestID = 0;

  /**
   * Storage for the sent request handlers waiting for a response.
   *
   * @type {Object.<string, function>}
   * @protected
   */
  this._handlers = {};
}
exports.Resolver = Resolver;

/**
 * Adds a handler to the internal storage.
 *
 * @param {number} requestID The identifier for the request.
 * @param {ClientRequest} handler The handler for the request.
 * @protected
 */
Resolver.prototype._addHandler = function(requestID, handler) {
  this._handlers[requestID] = handler;
  return this;
};

/**
 * Removes a handler from the internal storage.
 *
 * @param {number} requestID The identifier for the request.
 * @protected
 */
Resolver.prototype._removeHandler = function(requestID) {
  this._handlers[requestID] = null;
  return this;
};

/**
 * Sends a request through the transport.
 *
 * Subclasses of this class need to implement this method.
 *
 * @param {number} requestID The id of the request.
 * @param {Object} data The payload data for the request.
 * @protected
 */
Resolver.prototype._sendRequest = function(requestID, data) {
  throw new Error('Resolver _sendRequest not implemented.');
};

/**
 * Handles a response from the transport.
 *
 * @param {Object} response The response from the transport.
 * @protected
 */
Resolver.prototype._handleResponse = function(response) {
  throw new Error('Resolver _handleResponse not implemented.');
};

/**
 * Dispatches a request handler with some data.
 *
 * @param {number} requestID The request handler to dispatch.
 * @param {Object} data The response data to send back.
 * @protected
 */
Resolver.prototype._dispatchResponse = function(requestID, requestType, data) {
  var handler = this._handlers[requestID];
  if (!handler) return;
  handler._handleResponse(requestType, data);
};

/**
 * Resolves a request (represented by the data) through the transport.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
Resolver.prototype._resolve = function(data, onsuccess, onerror) {
  if (!data || !onsuccess || !onerror ||
      typeof onsuccess != 'function' || typeof onerror != 'function')
    throw new TypeError('Invalid argument length for `resolve`.');

  var requestID = ++this._requestID;
  var request = new ClientRequest(this, requestID, data, onsuccess, onerror);

  this._addHandler(requestID, request);

  request.onClose = this._removeHandler.bind(this);
  request.open();

  return request;
};

/**
 * Resolves a single request (represented by the data) through the transport.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
Resolver.prototype.resolve = function(data, onsuccess, onerror) {
  throw new Error('Resolver resolve not implemented.');
};

/**
 * Resolves a subscription request (represented by the data) through the transport.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
Resolver.prototype.subscribe = function(data, onsuccess, onerror) {
  throw new Error('Resolver subscribe not implemented.');
};

},{"./request":889}],886:[function(require,module,exports){
(function (global){
/*jslint node: true */

'use strict';

var defer = require('spotify-deferred');
var Resolver = require('./bootstrap').Resolver;

/**
 * A mock resolver for a nodejs environment.
 *
 * This resolver uses regular callbacks as a transport.
 *
 * @constructs Cosmos.MockResolver
 * @extends Cosmos.Resolver
 */
function MockResolver() {
  if (!(this instanceof MockResolver))
    return new MockResolver();
  Resolver.call(this);

  // rebind the _handleResponse method so that we can reuse it for both
  // addEventListener and removeEventListener
  this._handleResponse = this._handleResponse.bind(this);

  /**
   * The identifier for request messages.
   *
   * @type {string}
   * @protected
   */
  this._requestMessageType = 'cosmos-request';

  /**
   * The identifier for response messages.
   *
   * @type {string}
   * @protected
   */
  this._responseMessageType = 'cosmos-response';

  /**
   * Prefix for the requests ids to prevent clashes
   * with bridge requests in webplayer
   *
   * @type {string}
   * @private
   */
  this._requestIdPrefix = 'cosmos_';

  this._handlersMap = {};

  // attach the handler
  this.attach();
}
MockResolver.prototype = new Resolver();
MockResolver.prototype.constructor = MockResolver;
exports.MockResolver = MockResolver;

/**
 * @inheritDoc
 */
MockResolver.prototype._sendRequest = function(requestName, requestID, data) {
  var self = this;

  var message = {
    type: this._requestMessageType,
    resolver: this._id,
    id: this._requestIdPrefix + requestID,
    name: requestName,
    payload: data.serialize ? data.serialize() : data
  };

  if (!this._handlersMap[data._action]) {
    return;
  }

  if (!this._handlersMap[data._action][data._uri]) {
    return;
  }

  this._handlersMap[data._action][data._uri](data, function (status, resp) {
    message.payload = {
      body: typeof resp !== 'undefined' ? resp : status,
      uri: data._uri,
      status: typeof resp !== 'undefined' ? status : 200
    };
    message.type = self._responseMessageType;

    var response = {
      data: message
    };
    self._handleResponse(response);
  });
};

/**
 * @inheritDoc
 */
MockResolver.prototype._handleResponse = function(response) {
  var data = response.data;
  if (typeof data == 'string') {
    try {
      data = JSON.parse(response.data);
    } catch (e) {
      return;
    }
  }
  if (data.type != this._responseMessageType ||
      data.resolver != this._id ||
      !data.payload) return;
  var id = data.id || '';
  var requestID = parseInt(id.replace(this._requestIdPrefix, ''), 10);
  var requestName = data.name || '';
  if (!requestID || !requestName) return;
  this._dispatchResponse(requestID, requestName, data.payload);
};

/**
 * Attaches the resolver so that it could process calls from the window object.
 */
MockResolver.prototype.attach = function() {
  var win = global.window;
  if (win) {
    win._cosmosRequest = this.resolve.bind(this);
  }
};

/**
 * Detaches the resolver so that it doesn't process calls from the window object.
 */
MockResolver.prototype.detach = function() {
  var win = global.window;
  if (win) {
    delete win._cosmosRequest;
  }
};

/**
 * Specific method for the mock resolver to add request handlers
 *
 * @param {string}   method       Type of method (GET, POST, PUT, SUB)
 * @param {string}   uri          Request to handle
 * @param {Function} fn           Function that handles the request
 */
MockResolver.prototype.addHandler = function(method, uri, fn) {
  if (!this._handlersMap[method]) {
    this._handlersMap[method] = {};
  }

  this._handlersMap[method][uri] = fn;
};

/**
 * Specific method for the mock resolver to remove a specific request handler
 *
 * @param {string}   method       Type of method (GET, POST, PUT, SUB)
 * @param {string}   uri          Request to handle
 */
MockResolver.prototype.removeHandler = function(method, uri) {
  if (!this._handlersMap[method]) {
    return;
  }

  if (this._handlersMap[method][uri]) {
    delete this._handlersMap[method][uri];
  }
};

/**
 * Specific method for the mock resolver to remove all handlers
 */
MockResolver.prototype.clearHandlers = function() {
  this._handlersMap = {};
};

/**
 * Resolves a single request (represented by the data) through the transport.
 * Single requests need to be closed immediately after the response is
 * received.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
MockResolver.prototype.resolve = function(data, onsuccess, onerror) {
  function onResult(callback, response) {
    defer(callback.bind(this, response));
    request.close();
  }

  var request = this._resolve(data, onResult.bind(this, onsuccess), onResult.bind(this, onerror));
  return request;
};

/**
 * Resolves a  subscription request (represented by the data) through the transport.
 * Subscriptions stay open until they're explicitly closed.
 * Every time the request returns some data pull for next
 * batch is sent.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
MockResolver.prototype.subscribe = function(data, onsuccess, onerror) {
  return this._resolve(data, onsuccess, onerror);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./bootstrap":885,"spotify-deferred":891}],887:[function(require,module,exports){
/*jslint node: true */

'use strict';

var Resolver = require('./bootstrap').Resolver;
var defer = require('spotify-deferred');

/**
 * A resolver for a native environment.
 *
 * This resolver uses the Stitch bridge as a transport
 *
 * @constructs Cosmos.NativeResolver
 * @extends Cosmos.Resolver
 * @param {Object} spBridge Spotify CPP/JS bridge
 */
function NativeResolver(spBridge) {
  if (!(this instanceof NativeResolver))
    return new NativeResolver();
  if (!spBridge) {
    throw new TypeError('Missing `spBridge` parameter');
  }
  Resolver.call(this);

  this._bridge = spBridge;

  this._deferredFlush = false;
}
NativeResolver.prototype = new Resolver();
NativeResolver.prototype.constructor = NativeResolver;
exports.NativeResolver = NativeResolver;

/**
 * Prepare bridge flush.
 * TODO: Move to the separate module
 */
NativeResolver.prototype._prepareCoreFlush = function() {
  if (!this._deferredFlush) {
    this._deferredFlush = true;
    this._defer(this, this._flushRequests);
  }
};

/**
 * Flush bridge requests.
 * TODO: Move to the separate module
 */
NativeResolver.prototype._flushRequests = function() {
  this._deferredFlush = false;
  var flushMsg = JSON.stringify({ name: 'core_flush', args: []});
  this._sendBridgeRequest(flushMsg, {
    onSuccess: function() {},
    onFailure: function() {}
  });
};

/**
 * Defer the function call.
 * TODO: Move to the separate module
 */
NativeResolver.prototype._defer = function(context, callback) {
  defer(callback.bind(context));
};

/**
 * Construct and send Cosmos message.
 */
NativeResolver.prototype._sendRequest = function(requestName, requestId, data) {
  var self = this;
  data = (data.serialize ? data.serialize() : data);

  var args = [requestId, data];
  var caller = { self: this, id: requestId, type: requestName };

  this._sendCosmosRequest(requestName, args, caller, this._handleResponse, this._handleError);
};


/**
 * Talk to bridge directly from Cosmos
 * TODO: Move to the separate module
 */
NativeResolver.prototype._sendCosmosRequest = function(requestName, args, caller, onSuccess, onError) {
  var message = JSON.stringify({
    name: requestName,
    args: args
  });

  this._sendBridgeRequest(message, {
    onSuccess: function(data) {
      onSuccess.call(caller, JSON.parse(data));
    },
    onFailure: function(data) {
      data = JSON.parse(data);
      onError.call(caller, data);
    }
  });

  this._prepareCoreFlush();
};

/**
 * Send message to the bridge
 * @param {string} message The message to send to the bridge.
 * @param {Object.<string, function>} callbackMap The `onSuccess`
 * and `onFailure` functions to be executed after request is completed.
 * TODO: Use proxy that will handle Cosmos/Stitch calls for the resolver.
 */
NativeResolver.prototype._sendBridgeRequest = function(message, callbackMap) {
  this._bridge.executeRequest(message, callbackMap || {});
};

/**
 * Handles successful responses from the bridge
 * @param {Object} data The response data.
 */
NativeResolver.prototype._handleResponse = function(data) {
  this.self._dispatchResponse(this.id, this.type, data.responses && data.responses[0] || data);
};

/**
 * Handles failed responses from the bridge
 * @param {Object} error The error data.
 */
NativeResolver.prototype._handleError = function(error) {
  this.self._dispatchResponse(this.id, this.type, error);
};

/**
 * Resolves a single request (represented by the data) through the transport.
 * Single requests need to be closed immediately after the response is
 * received.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
NativeResolver.prototype.resolve = function(data, onsuccess, onerror) {
  function onResult(callback, response) {
    this._defer(this, callback.bind(this, response));
    request.close();
  }

  var request = this._resolve(data, onResult.bind(this, onsuccess), onResult.bind(this, onerror));
  return request;
};

/**
 * Resolves a  subscription request (represented by the data) through the transport.
 * Subscriptions stay open until they're explicitly closed.
 * Every time the request returns some data pull for next
 * batch is sent.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
NativeResolver.prototype.subscribe = function(data, onsuccess, onerror) {
  function onResult(callback, response) {
    callback.call(this, response);
    request.pull();
  }

  var request = this._resolve(data, onResult.bind(this, onsuccess), onResult.bind(this, onerror));
  return request;
};

},{"./bootstrap":885,"spotify-deferred":891}],888:[function(require,module,exports){
(function (global){
/*jslint node: true */

'use strict';

var defer = require('spotify-deferred');
var Resolver = require('./bootstrap').Resolver;

/**
 * A resolver for a web-based environment.
 *
 * This resolver uses postMessage as a transport.
 *
 * @constructs Cosmos.WebResolver
 * @extends Cosmos.Resolver
 * @type {string=} opt_target The optional target for the postMessage calls.
 */
function WebResolver(opt_target) {
  if (!(this instanceof WebResolver))
    return new WebResolver(opt_target);
  Resolver.call(this);

  /**
   * The target for postMessage calls.
   *
   * @type {string}
   * @protected
   */
  this._target = opt_target || '*';

  // rebind the _handleResponse method so that we can reuse it for both
  // addEventListener and removeEventListener
  this._handleResponse = this._handleResponse.bind(this);

  /**
   * The identifier for request messages.
   *
   * @type {string}
   * @protected
   */
  this._requestMessageType = 'cosmos-request';

  /**
   * The identifier for response messages.
   *
   * @type {string}
   * @protected
   */
  this._responseMessageType = 'cosmos-response';

  /**
   * Prefix for the requests ids to prevent clashes
   * with bridge requests in webplayer
   *
   * @type {string}
   * @private
   */
  this._requestIdPrefix = 'cosmos_';

  // attach the handler
  this.attach();
}
WebResolver.prototype = new Resolver();
WebResolver.prototype.constructor = WebResolver;
exports.WebResolver = WebResolver;

/**
 * @inheritDoc
 */
WebResolver.prototype._sendRequest = function(requestName, requestID, data) {
  var top = global.window.top;

  var message = {
    type: this._requestMessageType,
    resolver: this._id,
    id: this._requestIdPrefix + requestID,
    name: requestName,
    payload: data.serialize ? data.serialize() : data
  };
  top.postMessage(JSON.stringify(message), this._target);
};

/**
 * @inheritDoc
 */
WebResolver.prototype._handleResponse = function(response) {
  var data = response.data;
  if (typeof data == 'string') {
    try {
      data = JSON.parse(response.data);
    } catch (e) {
      return;
    }
  }
  if (data.type != this._responseMessageType ||
      data.resolver != this._id ||
      !data.payload) return;
  var id = data.id || '';
  var requestID = parseInt(id.replace(this._requestIdPrefix, ''), 10);
  var requestName = data.name || '';
  if (!requestID || !requestName) return;
  this._dispatchResponse(requestID, requestName, data.payload);
};

/**
 * Attaches the resolver so that it could process postMessage calls.
 */
WebResolver.prototype.attach = function() {
  var win = global.window;
  if (win.addEvent && !win.addEventListener) {
    win.addEvent('onmessage', this._handleResponse);
  } else {
    win.addEventListener('message', this._handleResponse, false);
  }
};

/**
 * Detaches the resolver so that it doesn't process postMessage calls.
 */
WebResolver.prototype.detach = function() {
  var win = global.window;
  if (win.removeEvent && !win.removeEventListener) {
    win.removeEvent('onmessage', this._handleResponse);
  } else {
    win.removeEventListener('message', this._handleResponse, false);
  }
};

/**
 * Resolves a single request (represented by the data) through the transport.
 * Single requests need to be closed immediately after the response is
 * received.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
WebResolver.prototype.resolve = function(data, onsuccess, onerror) {
  function onResult(callback, response) {
    defer(callback.bind(this, response));
    request.close();
  }

  var request = this._resolve(data, onResult.bind(this, onsuccess), onResult.bind(this, onerror));
  return request;
};

/**
 * Resolves a  subscription request (represented by the data) through the transport.
 * Subscriptions stay open until they're explicitly closed.
 * Every time the request returns some data pull for next
 * batch is sent.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
WebResolver.prototype.subscribe = function(data, onsuccess, onerror) {
  return this._resolve(data, onsuccess, onerror);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./bootstrap":885,"spotify-deferred":891}],889:[function(require,module,exports){
/*jslint node: true */

'use strict';

var defer = require('spotify-deferred');

/**
 * The representation of the connection to the client.
 * With introduction of Cosmos subscription the model of making
 * client requests changed.
 * Each Cosmos requests now needs to be explicitly cancelled to
 * close the connection.
 * Simple requests that only send or retrieve data (e.g POST and GET)
 * need to send 'cosmos_request_cancel' message immediately after the response
 * is received.
 * Subscription requests need to send a 'cosmos_request_pull' message every time
 * they receive data. The consumer of the subscription needs to cancel the subscription
 * when no more data should be sent from the provider.
 */
function ClientRequest(resolver, requestId, data, onsuccess, onerror) {

  /**
   * Request identifier.
   * @type {number}
   */
  this._requestId = requestId;

  /**
   * Either web or native request resolver.
   * @type {Cosmos.Resolver}
   */
  this._resolver = resolver;

  /**
   * Data that should be passed with every request.
   * @type {*}
   */
  this._requestData = data;

  /**
   * Triggered on success
   * @type {function}
   */
  this._successCallback = onsuccess;

  /**
   * Triggered on error
   * @type {function}
   */
  this._errorCallback = onerror;

  /**
   * Current state of the request.
   * @type {ClientRequest.status}
   */
  this._status = ClientRequest.status.INITIALIZED;
}
exports.ClientRequest = ClientRequest;

/**
 * Possible state of the ClientRequest instance.
 */
ClientRequest.status = {
  INITIALIZED: 'INITIALIZED',
  CLOSED: 'CLOSED',
  OPEN: 'OPEN'
};

/**
 * Possible desktop bridge messages.
 */
ClientRequest.messages = {
  OPEN: 'cosmos_request_create',
  PULL: 'cosmos_request_pull',
  CLOSE: 'cosmos_request_cancel'
};

/**
 * Opens the connection with the client.
 */
ClientRequest.prototype.open = function() {
  if (this._status === ClientRequest.status.INITIALIZED) {
    this._status = ClientRequest.status.OPEN;
    this._sendRequest(ClientRequest.messages.OPEN, this._requestData);
  }
};

/**
 * Send pull request for the open connection.
 * For subscriptions pull should resolve to a
 * piece of data.
 */
ClientRequest.prototype.pull = function() {
  if (this._status === ClientRequest.status.OPEN) {
    this._sendRequest(ClientRequest.messages.PULL, this._requestData);
  }
  return this._status;
};

/**
 * Closes the connection with the client.
 */
ClientRequest.prototype.close = function() {
  if (this._status === ClientRequest.status.OPEN) {
    this._status = ClientRequest.status.CLOSE;
    this._sendRequest(ClientRequest.messages.CLOSE);
  }
};

ClientRequest.prototype.onClose = function() {};

/**
 * Sends the request to the platform specific resolver
 * @param {string} requestName The message type. One of the {ClientRequest.messages}.
 * @param {object?} data The data to send with the request.
 */
ClientRequest.prototype._sendRequest = function(requestName, data) {
  this._resolver._sendRequest(requestName, this._requestId, data || {});
};

/**
 * Handles the response for the given request
 * @param {String} requestName The message type. One of the {ClientRequest.messages}.
 * @param {Object} data The response data.
 */
ClientRequest.prototype._handleResponse = function(requestName, data) {
  var self = this;
  var status = data && data.status;
  var callback;

  if (requestName === ClientRequest.messages.CLOSE) {
    this._successCallback = null;
    this._errorCallback = null;
    this._requestData = null;
    this.onClose(this._requestId);
    return;
  }

  callback = this._successCallback;
  callback = typeof callback === 'function' ? callback : function() {};
  defer(callback.bind(this, data));
};

},{"spotify-deferred":891}],890:[function(require,module,exports){
(function (global){
'use strict';

var window = global.window || {};
var process = global.process;

var common = require('cosmos-common-js');
var Resolver = require('./scripts/resolver').Resolver;

var SPResolver = null;
var spResolver = null;

var hasNativeBridge = window._getSpotifyModule &&
    typeof window._getSpotifyModule === 'function' &&
    window._getSpotifyModule('bridge');

var nodeRegex = /(node)|(grunt)|(iojs)(\.exe)*$/;
var isNodeJs = process && process.title && nodeRegex.test(process.argv[0]);

if (!isNodeJs) {
  if (hasNativeBridge) {
    SPResolver = require('./env/bootstrap.native.js').NativeResolver;
    spResolver = new SPResolver(hasNativeBridge);
  } else {
    SPResolver = require('./env/bootstrap.web.js').WebResolver;
    spResolver = new SPResolver();
  }
} else {
  SPResolver = require('./env/bootstrap.mock.js').MockResolver;
  spResolver = new SPResolver();

  exports.mockResolver = {
    addHandler: spResolver.addHandler.bind(spResolver),
    removeHandler: spResolver.removeHandler.bind(spResolver),
    clearHandlers: spResolver.clearHandlers.bind(spResolver)
  };
}

exports.Resolver = Resolver;
exports.Action = common.request.Action;
exports.Request = common.request.Request;
exports.Response = common.response.Response;
exports.resolver = spResolver ? new Resolver(spResolver) : null;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./env/bootstrap.mock.js":886,"./env/bootstrap.native.js":887,"./env/bootstrap.web.js":888,"./scripts/resolver":892,"cosmos-common-js":577}],891:[function(require,module,exports){
/**
 * @file
 * Introduces a function called "defer" that allows functions to be
 * executed in the next available tick.
 *
 * Unlike "setTimeout", "defer" executes the function at the nearest
 * possible time without clamping.
 *
 * @see Spotify.defer
 */
'use strict';

var PostRouter = require('spotify-postrouter');


/**
 * Storage for deferred functions to be executed.
 *
 * @type {Array.<function()>}
 * @private
 */
var deferred = [];


/**
 * A bound version of the postMessage routine used to trigger deferred
 * execution.
 *
 * @type {function()}
 * @private
 */
var send = function () {
  PostRouter.sendLocalMessage('execute_deferreds');
};


/**
 * Executes the deferred functions when the window
 * receives an 'execute_deferreds' message.
 *
 * @private
 */
function executeDeferreds() {
  var fns = deferred.splice(0);
  if (!fns.length) return;
  for (var i = 0, l = fns.length; i < l; i++) {
    try {
      fns[i]();
    } finally {
      // Do nothing.
      null;
    }
  }
}

PostRouter.addMessageHandler('execute_deferreds', executeDeferreds);


/**
 * Executes the function applied at the nearest possible time without
 * clamping.
 *
 * @param {function()} fn The function to execute.
 */
var defer = function(fn) {
  var trigger = !deferred.length;
  deferred.push(fn);
  if (trigger) send();
};


/**
 * Export public interface
 */
module.exports = defer;

},{"spotify-postrouter":904}],892:[function(require,module,exports){
var common = require('cosmos-common-js');

var Request = common.request.Request;
var Action = common.request.Action;
var Response = common.response.Response;

/**
 * Checks whether a status is successful.
 *
 * We define a successful status to be something within the 200 to 299 range.
 *
 * @param {number} status The status to check.
 */
function _isSuccessStatus(status) {
  // This constitutes a successfull status.
  return (status >= 200 && status <= 299);
};


function Resolver(spResolver) {
  if (!spResolver || typeof spResolver.resolve !== 'function') {
    throw TypeError('Incorrect resolver argument');
  }

  this._resolver = spResolver;
}

/**
 * The basic, generic method of sending the requests.
 *
 * For params description:
 * @borrows Resolver#_resolve as Resolver#resolve
 */
Resolver.prototype.resolve = function(request, callback) {
  return this._resolve(request, callback);
};

/**
 * Convenience method for doing GET requests.
 * resolver.get('sp://player') is an equivalent of
 * resolver.resolve(new Request('GET', 'sp://player')).
 *
 * @param {string|Object.<string, object>} options If is a string
 * will be parsed as url. If more data is needed, object notation
 * should be used.
 *  param options.url {string} The url of the request.
 *  param options.body {object=} The request body.
 *  param options.headers {object=} The request headers.
 * @param {function(error=, object?)} callback The function
 * executed after the request has been completed.
 *
 * @return {RequestHandler} The cancellable request handler.
 */
Resolver.prototype.get = function(options, callback) {
  return this._resolveFromParams(Action.GET, options, callback);
};

/**
 * Convenience method for doing POST requests.
 * resolver.post('sp://player') is an equivalent of
 * resolver.resolve(new Request('POST', 'sp://player'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.post = function(options, callback) {
  return this._resolveFromParams(Action.POST, options, callback);
};

/**
 * Convenience method for doing SUB requests.
 * resolver.subscribe('sp://player') is an equivalent of
 * resolver.resolve(new Request('SUB', 'sp://player'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.subscribe = function(options, callback) {
  return this._resolveFromParams(Action.SUB, options, callback);
};

/**
 * Convenience method for doing PUT requests.
 * resolver.put('sp://ads/v1/settings/session') is an equivalent of
 * resolver.resolve(new Request('PUT', 'sp://ads/v1/settings/session'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.put = function(options, callback) {
  return this._resolveFromParams(Action.PUT, options, callback);
};

/**
 * Convenience method for doing PATCH requests.
 * resolver.patch('sp://ads/v1/settings/session') is an equivalent of
 * resolver.resolve(new Request('PATCH', 'sp://ads/v1/settings/session'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.patch = function(options, callback) {
  return this._resolveFromParams(Action.PATCH, options, callback);
};

/**
 * Convenience method for doing DELETE requests.
 * resolver.delete('sp://player') is an equivalent of
 * resolver.resolve(new Request('DELETE', 'sp://player'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.delete = function(options, callback) {
  return this._resolveFromParams(Action.DELETE, options, callback);
};

/**
 * @private
 * Sends the request to the platform specific request resolver.
 * If the request action is 'SUB' it will send subscribe request
 * In any other case it will send simple resolve request.
 *
 * @param {Cosmos.Request} request A request object.
 * @param {function(error=, object?)} callback The function
 * executed after the request has been completed.
 *
 * @return {RequestHandler} The cancellable request handler.
 */
Resolver.prototype._resolve = function(request, callback) {
  if (!callback || typeof callback !== 'function') {
    callback = function() {};
  }

  var requestHandler;

  function onSuccess(serverResponse) {
    if (!requestHandler._request) {
      return;
    }

    var response = Response.fromObject(serverResponse);
    if (!response) {
      var error = new Error(
        'Failed to parse response: ' + JSON.stringify(serverResponse));
      return callback(error);
    }

    if (_isSuccessStatus(response.getStatusCode())) {
      return callback(null, response);
    } else {
      // Extract just the initial part of the request uri. It's good to have something
      // but it is also good to avoid having everything, since that can hurt dashboards
      // that group error messages.
      var requestEndpoint = request.toJSON().uri.match(/[^\:]*(\:\/\/)?[^\/]*/)[0];
      var errorMessage = (
        response.getHeader("error") ||
        "Request to " + requestEndpoint + " failed with status code " + response.getStatusCode());
      var error = new Error(errorMessage);
      error.response = response;
      return callback(error, response);
    }
  }

  function onError(serverResponse) {
    return callback(serverResponse instanceof Error ?
      serverResponse :
      new Error('Request failed: ' + JSON.stringify(serverResponse)));
  }

  var resolveFn = request.getAction() === Action.SUB ?
      this._resolver.subscribe : this._resolver.resolve;

  var clientRequest = resolveFn.call(this._resolver, request, onSuccess, onError);

  requestHandler = new RequestHandler(clientRequest);
  return requestHandler;
};

/**
 * @private
 * Creates Request object from supplied params.
 * @param {string} method Request method. One of the Request.Action.
 * @param {string|Object.<string, object>} options If is a string
 * will be parsed as url. If more data is needed, object notation
 * should be used.
 *  param options.url {string} The url of the request.
 *  param options.body {object=} The request body.
 *  param options.headers {object=} The request headers.
 * @param {function(error=, object?)} callback The function
 * executed after the request has been completed.
 *
 * @return {RequestHandler} The cancellable request handler.
 */
Resolver.prototype._resolveFromParams = function(method, options, callback) {
  options = options || {};

  var url = typeof options === 'string' ? options : options.url;
  var headers = options.headers;
  var body = options.body;

  var request = new Request(method, url, headers, body);

  return this._resolve(request, callback);
};

/**
 * The object that wraps the clientRequest
 * in a very simple interface.
 * Separates the implementation of the ClientRequest
 * from the request handler returned by Cosmos API.
 *
 * @param {Cosmos.ClientRequest} request The object
 * representing the newly opened request to the client.
 * Usually a request will be a subscription that
 * needs a close handler.
 */
function RequestHandler(request) {
  if (!request || typeof request.close !== 'function')
    throw new TypeError('Invalid `request` argument.');

  this._request = request;
}

/**
 * Closes the request and removes the object.
 */
RequestHandler.prototype.cancel = function() {
  if (this._request) {
    this._request.close();
    this._request = null;
  }
};

exports.Resolver = Resolver;

},{"cosmos-common-js":577}],893:[function(require,module,exports){
'use strict';

/**
 * The Base62 Converter
 *
 * @class Base62
 * @constructor
 *
 */

var digits = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
var invHexDigits = {};
var invDigits = {};

// Prepare tables.
(function() {
  var i;
  var l;
  for (i = 0, l = digits.length; i < l; ++i) { invDigits[digits[i]] = i; }
  for (i = 0; i < 16; ++i) { invHexDigits['0123456789abcdef'[i]] = i; }
  for (i = 0; i < 16; ++i) { invHexDigits['0123456789ABCDEF'[i]] = i; }
})();


/**
 * lhs *= rhs
 * @private
 */
function mul(lhs, rhs, base) {
  var rest = 0;
  for (var i = 0; i < lhs.length; ++i) {
    var tmp = lhs[i] * rhs + rest;
    lhs[i] = tmp % base;
    rest = ~~(tmp / base);
  }
  while (rest) {
    lhs.push(rest % base);
    rest = ~~(rest / base);
  }
}

/**
 * acc += lhs * rhs
 * @private
 */
function madd(acc, lhs, rhs, base) {
  var rest = 0;
  var tmp;
  var i;
  for (i = 0; i < lhs.length; ++i) {
    tmp = ~~acc[i] + lhs[i] * rhs + rest;
    acc[i] = tmp % base;
    rest = ~~(tmp / base);
  }
  while (rest) {
    tmp = ~~acc[i] + rest;
    acc[i] = tmp % base;
    rest = ~~(tmp / base);
    ++i;
  }
}

/**
 * Change base
 * @private
 */
function convert(data, fromBase, toBase) {
  var r = [0];
  var b = [1];
  for (var i = 0; i < data.length; ++i) {
    madd(r, b, data[i], toBase);
    mul(b, fromBase, toBase);
  }
  return r;
}

/**
 * Decode to
 * @private
 */
function mapr(data, mapping) {
  var r = [];
  for (var i = 0; i < data.length; ++i) {
    r.push(mapping[data[i]]);
  }
  return r.reverse();
}

/**
 * Pad with 0s
 * @private
 */
function pad(data, length) {
  while (data.length < length) { data.push(0); }
  return data;
}

module.exports = {

  /**
   * Converts from array of bytes to base62 encoded string.
   *
   * @public
   * @name Spotify.Utils.Base62#fromBytes
   * @function
   * @param {Array.<number>} data Array of byte numbers.
   * @param {?number} length Do zeropadding until at least this length.
   * @return {string} Base62 encoded string.
  **/
  fromBytes: function(data, length) {
    var r = convert(data.slice(0).reverse(), 256, 62);
    return mapr(pad(r, length), digits).join('');
  },

  /**
   * Converts from base62 encoded string to array of bytes
   *
   * @public
   * @name Spotify.Utils.Base62#toBytes
   * @function
   * @param {string} str Base62 encoded string.
   * @param {?number} length Do zeropadding until at least this length.
   * @return {Array.<number>} Array of byte numbers.
  **/
  toBytes: function(str, length) {
    var r = convert(mapr(str, invDigits), 62, 256);
    return pad(r, length).reverse();
  },

  /**
   * Converts from base62 encoded string to hex encoded string
   *
   * @public
   * @name Spotify.Utils.Base62#toHex
   * @function
   * @param {string} str Base62 encoded string.
   * @param {?number} length Do zeropadding until at least this length.
   * @return {string} Hex encoded string.
  **/
  toHex: function(str, length) {
    var r = convert(mapr(str, invDigits), 62, 16);
    return mapr(pad(r, length), digits).join('');
  },

  /**
   * Converts from hex encoded strign to base62 encoded string
   *
   * @public
   * @name Spotify.Utils.Base62#fromHex
   * @function
   * @param {string} str Hex encoded string.
   * @param {?number} length Do zeropadding until at least this length.
   * @return {string} Base62 encoded string.
  **/
  fromHex: function(str, length) {
    var r = convert(mapr(str, invHexDigits), 16, 62);
    return mapr(pad(r, length), digits).join('');
  }

};

},{}],894:[function(require,module,exports){
(function() {
  /**
   * @file
   * Introduces a function called "defer" that allows functions to be
   * executed in the next available tick.
   *
   * Unlike "setTimeout", "defer" executes the function at the nearest
   * possible time without clamping.
   *
   * @see Spotify.defer
   */
  'use strict';

  var hasWindow = typeof window != 'undefined';
  var hasDefineProperty = typeof Object.defineProperty == 'function';

  if (hasWindow && window.__modDefFn) {
    // If deferred has been attached to the global scope
    module.exports = window.__modDefFn;
    return;
  }

  /**
   * Storage for deferred functions to be executed.
   *
   * @type {Array.<function()>}
   * @private
   */
  var deferred = [];


  /**
   * A bound version of the postMessage routine used to trigger deferred
   * execution.
   *
   * @type {function()}
   * @private
   */
  var send;
  var origin;

  if (hasWindow && window.postMessage) {
    origin = (window.location.origin ||
          window.location.protocol + '//' + window.location.hostname);
    send = window.postMessage.bind(window, '@execute_deferreds', origin);
    if (!window.__hasDeferredHandler) {
      if (hasDefineProperty) {
        Object.defineProperty(window, '__hasDeferredHandler', {value: 1});
      } else {
        window.__hasDeferredHandler = 1;
      }
      var handler = function(e) {
        if (e.origin != origin && e.data != '@execute_deferreds') {
          return;
        }
        executeDeferreds();
      };
      if (window.addEventListener) {
        window.addEventListener('message', handler);
      } else {
        window.attachEvent('onmessage', handler);
      }
    }
  } else if (typeof setImmediate != 'undefined') {
    send = setImmediate.bind(null, executeDeferreds);
  } else {
    send = setTimeout.bind(null, executeDeferreds, 10);
  }


  /**
   * Executes the deferred functions when the window
   * receives an 'execute_deferreds' message.
   *
   * @private
   */
  function executeDeferreds() {
    var fns = deferred.splice(0);
    if (!fns.length) return;
    for (var i = 0, l = fns.length; i < l; i++) {
      try {
        fns[i]();
      } finally {
        // Do nothing.
        null;
      }
    }
  }


  /**
   * Executes the function applied at the nearest possible time without
   * clamping.
   *
   * @param {function()} fn The function to execute.
   */
  var defer = function(fn) {
    var trigger = !deferred.length;
    deferred.push(fn);
    if (trigger) send();
  };

  if (hasWindow && !window.__modDefFn) {
    if (hasDefineProperty) {
      Object.defineProperty(window, '__modDefFn', {value: defer});
    } else {
      window.__modDefFn = defer;
    }
  }

  /**
   * Export public interface
   */
  module.exports = defer;

})();

},{}],895:[function(require,module,exports){
/**
 * @module spotify-eventemitter
 */
'use strict';

/**
 * @private
 */
var _defer = require('spotify-deferred');

/**
 * The event handlers.
 *
 * @typedef {Array.<function>}
 * @private
 */
var EventHandlers;

/**
 * Represents an Event.
 *
 * **NOTE**: The Event class is an internal class: you cannot instantiate it
 * directly. Instead, you should use the provided
 * {@link module:spotify-eventemitter.createEvent} function.
 *
 * @constructor
 * @param {string} type The type name of the event object.
 * @param {Object} props An object that will be added as properties of the
 *     event object.
 * @see {@link module:spotify-eventemitter.createEvent}
 */
function Event(type, props) {
  /**
   * The type of the event.
   *
   * @type {string}
   */
  this.type = type;

  /**
   * A flag for whether preventDefault was called.
   *
   * @type {boolean}
   * @private
   */
  this._prevented = false;

  /**
   * A flag for whether stopPropagation was called
   *
   * @type {boolean}
   * @private
   */
  this._stopped = false;

  /**
   * A flag for whether stopImmediatePropagation was called.
   *
   * @type {boolean}
   * @private
   */
  this._immediateStopped = false;

  if (props) {
    for (var key in props) {
      if (key == 'type') {
        continue;
      }
      this[key] = props[key];
    }
  }
}

/**
 * Prevents the default operation for the event.
 */
Event.prototype.preventDefault = function() {
  this._prevented = true;
};

/**
 * Returns whether preventDefault was called on the event.
 *
 * @return {boolean} True if preventDefault was called, false otherwise.
 */
Event.prototype.isDefaultPrevented = function() {
  return this._prevented;
};

/**
 * Stops the propagation of the event.
 */
Event.prototype.stopPropagation = function() {
  this._stopped = true;
};

/**
 * Returns whether stopPropagation was called on the event.
 *
 * @return {boolean} True if stopPropagation was called, false otherwise.
 */
Event.prototype.isPropagationStopped = function() {
  return this._stopped;
};

/**
 * Stops the immediate propagation of the event.
 *
 * Handlers added after any event handler calling this method will not receive
 * the event.
 */
Event.prototype.stopImmediatePropagation = function() {
  this._immediateStopped = true;
};

/**
 * Returns whether stopImmediatePropagation was called on the event.
 *
 * @return {boolean} True if stopImmediatePropagation was called, false
 *     otherwise.
 */
Event.prototype.isImmediatePropagationStopped = function() {
  return this._immediateStopped;
};

/**
 * An EventEmitter is an object that can be listened to for events.
 *
 * Instances of this class are not usually used directly; instead, a class that
 * needs EventEmitter functionality would inherit from the EventEmitter class
 * so that it's instances can use events.
 *
 * @constructor
 * @alias module:spotify-eventemitter
 *
 * @example <caption>Direct usage</caption>
 * var EventEmitter = require('spotify-eventemitter');
 * var emitter = new EventEmitter();
 * emitter.addListener('someEvent', function() {
 *     console.log('someEvent fired!');
 * });
 * emitter.emit('someEvent');
 * @example <caption>Inheritance</caption>
 * var EventEmitter = require('spotify-eventemitter');
 * var inherit = require('spotify-inherit/inherit');
 *
 * function MyClass() {
 *   EventEmitter.call(this);
 * }
 * inherit(MyClass, EventEmitter);
 *
 * var instance = new MyClass();
 * instance.addListener('someEvent', function() {
 *     console.log('someEvent fired!');
 * });
 * instance.emit('someEvent');
 */
function EventEmitter() {
  /**
   * A map of event names to event handlers.
   *
   * @type {Object.<string, module:spotify-eventemitter~EventHandlers>}
   * @private
   */
  this._listenerMap = {};
}

/**
 * Creates a new Event object.
 *
 * @param {string} type The type name of the event.
 * @param {Object=} opt_params An object containing properties for the new event
 *     object.
 * @return {module:spotify-eventemitter~Event} The new event object.
 */
EventEmitter.createEvent = function(type, opt_params) {
  return new Event(type, opt_params);
};

/**
 * Adds an event listener to the emitter.
 *
 * This method is idempotent: calling it multiple times using the same type
 * and listener arguments will only set the listener once. This behaviour is
 * done to prevent accidental additions of the same event listener.
 *
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.addListener = function(type, listener) {
  var _listenerMap = this._listenerMap || (this._listenerMap = {});
  var listeners = _listenerMap[type] || (_listenerMap[type] = []);
  if (listeners.indexOf(listener) != -1) {
    // Handler already added, return quickly.
    return this;
  }
  listeners.push(listener);
  return this;
};

/**
 * Adds multiple event listeners to the emitter.
 *
 * @param {Object.<string, function>} eventListeners An object, the keys of
 *     which correspond to the name of events to listen to, and the value of
 *     each of these keys should be a function that would be added as the
 *     listener for that event.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.addListeners = function(eventListeners) {
  for (var type in eventListeners) {
    this.addListener(type, eventListeners[type]);
  }
  return this;
};

/**
 * Adds a "once" event listener to the emitter, which will be removed right
 * after it has been fired.
 *
 * In order to achieve the "once" behaviour, the listener argument passed to
 * this method is wrapped in a function, which is then returned by the method.
 *
 * Because of this wrapping, this method is not idempotent: calling it multiple
 * times with the same type and listener arguments will result to multiple
 * event listeners attached.
 *
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type and then automatically removed.
 * @return {function} The function used to wrap the listener function argument.
 *     This function can be used as an argument to removeEvent.
 */
EventEmitter.prototype.addOnceListener = function(type, listener) {
  var wrapper = function() {
    this.removeListener(type, wrapper);
    return listener.apply(this, arguments);
  };
  this.addListener(type, wrapper);
  return wrapper;
};

/**
 * Removes an event listener from the emitter.
 *
 * @param {string} type The type of event to remove.
 * @param {function} listener The listener function to remove. This must be a
 *     function that was added previously using addEvent.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.removeListener = function(type, listener) {
  var _listenerMap = this._listenerMap;
  var listeners = _listenerMap && _listenerMap[type];
  if (!listeners) {
    return this;
  }
  var index = listeners.indexOf(listener);
  if (index == -1) {
    return this;
  }
  listeners.splice(index, 1);
  if (!listeners.length) {
    _listenerMap[type] = null;
  }
  return this;
};

/**
 * Removes all event listeners from the emitter for a particular type.
 * If no event type is given, all event listeners will be removed.
 * 
 * @param {string=} opt_type The event type to remove.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.removeAllListeners = function(opt_type) {
  var _listenerMap = this._listenerMap;
  if (!_listenerMap) {
    return this;
  }

  if (opt_type === undefined) {
    this._listenerMap = {};
    return this;
  }

  _listenerMap[opt_type] = null;
  return this;
};

/**
 * Removes multiple event listeners from the emitter.
 *
 * @param {Object.<string, function>} eventListeners An object, the keys of
 *     which correspond to the name of events to listen to, and the value of
 *     each of these keys should be a function that would be added as the
 *     listener for that event.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.removeListeners = function(eventListeners) {
  for (var type in eventListeners) {
    this.removeListener(type, eventListeners[type]);
  }
  return this;
};

/**
 * Creates and emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` provided in
 * the order they were added, passing in a new Event object created using the
 * provided `type` and `opt_params` arguments.
 *
 * This method emits events asynchronously: the listeners are not called until
 * the next run loop.
 *
 * @param {string} type The type name of the event to emit.
 * @param {Object=} opt_params An object containing parameters for the Event
 *     object.
 * @return {module:spotify-eventemitter~Event} The Event object that was
 *     created.
 */
EventEmitter.prototype.emit = function(type, opt_params) {
  var event = new Event(type, opt_params);
  _defer(function() {
    this.emitEventSync(event);
  }.bind(this));
  return event;
};

/**
 * Emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` of the 
 * `event` provided in the order they were added, passing in the `event` as an
 * argument.
 *
 * This method emits events asynchronously: the listeners are not called until
 * the next run loop.
 *
 * @param {module:spotify-eventemitter~Event} event The Event object.
 * @return {module:spotify-eventemitter~Event} The Event object that was passed.
 */
EventEmitter.prototype.emitEvent = function(event) {
  _defer(function() {
    this.emitEventSync(event);
  }.bind(this));
  return event;
};

/**
 * Creates and synchronously emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` provided in
 * the order they were added, passing in a new Event object created using the
 * provided `type` and `opt_params` arguments.
 *
 * @param {string} type The type name of event to emit.
 * @param {Object=} opt_params An object containing parameters for the event
 *     object.
 * @return {module:spotify-eventemitter~Event} The Event object that was
 *     created.
 */
EventEmitter.prototype.emitSync = function(type, opt_params) {
  var event = new Event(type, opt_params);
  this.emitEventSync(event);
  return event;
};

/**
 * Synchronously emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` of the
 * `event` provided in the order they were added, passing in the `event` as an
 * argument.
 *
 * @param {module:spotify-eventemitter~Event} event The Event object.
 * @return {module:spotify-eventemitter~Event} The Event object that was passed.
 */
EventEmitter.prototype.emitEventSync = function(event) {
  var type = event.type;
  var _listenerMap = this._listenerMap;
  var listeners = _listenerMap && _listenerMap[type];
  if (!listeners || !listeners.length) {
    return event;
  }
  listeners = listeners.slice(0);
  for (var i = 0, l = listeners.length; i < l; i++) {
    listeners[i].call(this, event);
    if (event.isImmediatePropagationStopped()) {
      break;
    }
  }
  return event;
};

/**
 * Adds an event listener to the emitter.
 *
 * **NOTE**: This method is an alias of
 * {@link module:spotify-eventemitter#addListener}.
 *
 * This method is idempotent: calling it multiple times using the same type
 * and listener arguments will only set the listener once. This behaviour is
 * done to prevent accidental additions of the same event listener.
 *
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#addListener}
 */
EventEmitter.prototype.on = function(type, listener) {
  return this.addListener(type, listener);
};

/**
 * Adds a "once" event listener to the emitter, which will be removed right
 * after it has been fired.
 *
 * **NOTE**: This method is an alias of
 * {@link module:spotify-eventemitter#addOnceListener}.
 *
 * In order to achieve the "once" behaviour, the listener argument passed to
 * this method is wrapped in a function, which is then returned by the method.
 *
 * Because of this wrapping, this method is not idempotent: calling it multiple
 * times with the same type and listener arguments will result to multiple
 * event listeners attached.
 *
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type and then automatically removed.
 * @return {function} The function used to wrap the listener function argument.
 *     This function can be used as an argument to removeEvent.
 * @see {@link module:spotify-eventemitter#addOnceListener}
 */
EventEmitter.prototype.once = function(type, listener) {
  return this.addOnceListener(type, listener);
};

// DEPRECATED METHODS:

/**
 * Adds an event listener to the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#addListener}.
 *
 * This method is idempotent: calling it multiple times using the same type
 * and listener arguments will only set the listener once. This behaviour is
 * done to prevent accidental additions of the same event listener.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#addListener}
 */
EventEmitter.prototype.addEvent = function(type, listener) {
  return this.addListener(type, listener);
};

/**
 * Adds multiple event listeners to the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#addListeners}.
 *
 * @deprecated since v2.0.0.
 * @param {Object.<string, function>} eventListeners An object, the keys of
 *     which correspond to the name of events to listen to, and the value of
 *     each of these keys should be a function that would be added as the
 *     listener for that event.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#addListeners}
 */
EventEmitter.prototype.addEvents = function(eventListeners) {
  return this.addListeners(eventListeners);
};

/**
 * Adds a "once" event listener to the emitter, which will be removed right
 * after it has been fired.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#addOnceListener}.
 *
 * In order to achieve the "once" behaviour, the listener argument passed to
 * this method is wrapped in a function, which is then returned by the method.
 *
 * Because of this wrapping, this method is not idempotent: calling it multiple
 * times with the same type and listener arguments will result to multiple
 * event listeners attached.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type and then automatically removed.
 * @return {function} The function used to wrap the listener function argument.
 *     This function can be used as an argument to removeEvent.
 * @see {@link module:spotify-eventemitter#addOnceListener}
 */
EventEmitter.prototype.addOnceEvent = function(type, listener) {
  return this.addOnceListener(type, listener);
};

/**
 * Removes an event listener from the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#removeListener}.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to remove.
 * @param {function} listener The listener function to remove. This must be a
 *     function that was added previously using addEvent.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#removeListener}
 */
EventEmitter.prototype.removeEvent = function(type, listener) {
  return this.removeListener(type, listener);
};

/**
 * Removes multiple event listeners from the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#removeListeners}.
 *
 * @deprecated since v2.0.0.
 * @param {Object.<string, function>} events An object, the keys of which
 *     correspond to the name of events to remove, and the value of each of
 *     these keys should be a function that would be removed as a listener.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#removeListeners}
 */
EventEmitter.prototype.removeEvents = function(eventListeners) {
  return this.removeListeners(eventListeners);
};

/**
 * Fires an event on the emitter, optionally passing arguments to the listeners.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#emit}.
 *
 * This method fire events asynchronously: the listeners are not called until
 * the next run loop. A third boolean parameter can be passed to change this
 * behaviour.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to fire.
 * @param {Array.<*>=} opt_args A set of objects that would be passed to the
 *     event listeners as arguments.
 * @param {boolean=} opt_priority Passing true will fire the event synchronously.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#emit}
 */
EventEmitter.prototype.fireEvent = function(type, opt_args, opt_priority) {
  if (opt_priority) {
    this.fireEventSync(type, opt_args);
  } else {
    var self = this;
    _defer(function() { self.fireEventSync(type, opt_args); });
  }
  return this;
};

/**
 * Fires an event on the emitter synchronously, optionally passing arguments to
 * the listeners.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#emitSync}.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to fire.
 * @param {Array.<*>=} opt_args A set of objects that would be passed to the
 *     event listeners as arguments.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#emitSync}
 */
EventEmitter.prototype.fireEventSync = function(type, opt_args) {
  var self = this;
  var events = this._listenerMap && this._listenerMap[type];
  if (!events || !events.length) return this;
  events = events.slice(0);
  var i, l;
  if (!opt_args) {
    for (i = 0, l = events.length; i < l; i++) {
      events[i].call(self);
    }
  } else {
    if (!Array.isArray(opt_args)) {
      opt_args = [opt_args];
    }
    for (i = 0, l = events.length; i < l; i++) {
      events[i].apply(self, opt_args);
    }
  }
  return this;
};

/**
 * Removes an event listener or all event listeners from the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#removeListener}.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to remove.
 * @param {function=} opt_listener The listener function to remove. This must be
 *     a function that was added previously using addEvent. If this parameter is
 *     not given, all event listeners of the corresponding `type` argument will
 *     be removed.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#removeListener}
 * @see {@link module:spotify-eventemitter#removeListeners}
 */
EventEmitter.prototype.off = function(type, opt_listener) {
  if (typeof opt_listener === 'function') {
    return this.removeEvent(type, opt_listener);
  }
  // if no listener set, remove all the listeners from the event
  this._listenerMap[type] = null;
  return this;
};

/**
 * Exporting
 */
module.exports = EventEmitter;

},{"spotify-deferred":894}],896:[function(require,module,exports){
'use strict';

/**
 * Function to add properties to an object
 * @param {Object} obj The input object
 * @param {Object} args The objects which are going to be injected
 * @return {Object} The extended object
 */
var extend = function(obj, args) {
  var source;

  for (var i = 1; i < arguments.length; i++) {
    source = arguments[i];
    if (source) {
      for (var prop in source) {
        if (source.hasOwnProperty(prop)) {
          obj[prop] = source[prop];
        }
      }
    }
  }
  return obj;
};


/**
 * Export public interface
 */
module.exports = extend;

},{}],897:[function(require,module,exports){
'use strict';

module.exports = {
  inherit: require('./inherit'),
  extend: require('./extend')
};

},{"./extend":896,"./inherit":898}],898:[function(require,module,exports){
'use strict';

/**
 * Makes a class inherit from a superclass' prototype indirectly.
 *
 * @param {Spotify.ClassLike} Sub The class that will inherit.
 * @param {Spotify.ClassLike} Super The class to inherit from.
 */
var inherit = function(Sub, Super) {
  var superProto = Super.prototype;
  function Superclass() {}
  Superclass.prototype = Sub._super = superProto;
  Superclass.prototype.constructor = Super;
  Sub.prototype = new Superclass();
};


/**
 * Export public interface
 */
module.exports = inherit;

},{}],899:[function(require,module,exports){
'use strict';

/**
 * @private
 */
var Base62 = require('spotify-crypto/base62');

/**
 * The URI prefix for URIs.
 *
 * @const
 * @private
 */
var URI_PREFIX = 'spotify:';

/**
 * The URL prefix for Play.
 *
 * @const
 * @private
 */
var PLAY_HTTP_PREFIX = 'http://play.spotify.com/';

/**
 * The HTTPS URL prefix for Play.
 *
 * @const
 * @private
 */
var PLAY_HTTPS_PREFIX = 'https://play.spotify.com/';

/**
 * The URL prefix for Open.
 *
 * @const
 * @private
 */
var OPEN_HTTP_PREFIX = 'http://open.spotify.com/';

/**
 * The HTTPS URL prefix for Open.
 *
 * @const
 * @private
 */
var OPEN_HTTPS_PREFIX = 'https://open.spotify.com/';

var ERROR_INVALID = new TypeError('Invalid Spotify URI!');
var ERROR_NOT_IMPLEMENTED = new TypeError('Not implemented!');


/**
 * The format for the URI to parse.
 *
 * @enum {number}
 * @private
 */
var Format = {
  URI: 0,
  URL: 1
};

/**
 * Represents the result of a URI splitting operation.
 *
 * @typedef {{
 *    format: Format,
 *    components: Array.<string>
 * }}
 * @see _splitIntoComponents
 * @private
 */
var SplittedURI;

/**
 * Split an string URI or HTTP/HTTPS URL into components, skipping the prefix.
 *
 * @param {string} str A string URI to split.
 * @return {SplittedURI} The parsed URI.
 * @private
 */
var _splitIntoComponents = function(str) {
  var components;
  var format;
  var query;
  var anchor;

  var querySplit = str.split('?');
  if (querySplit.length > 1) {
    str = querySplit.shift();
    query = querySplit.pop();

    var queryHashSplit = query.split('#');
    if (queryHashSplit.length > 1) {
      query = queryHashSplit.shift();
      anchor = queryHashSplit.pop();
    }

    query = decodeQueryString(query);
  }

  var hashSplit = str.split('#');
  if (hashSplit.length > 1) {
    // first token
    str = hashSplit.shift();
    // last token
    anchor = hashSplit.pop();
  }

  if (str.indexOf(URI_PREFIX) === 0) {
    components = str.slice(URI_PREFIX.length).split(':');
    format = Format.URI;
  } else {
    // For HTTP URLs, ignore any query string argument
    str = str.split('?')[0];

    if (str.indexOf(PLAY_HTTP_PREFIX) === 0) {
      components = str.slice(PLAY_HTTP_PREFIX.length).split('/');
    } else if (str.indexOf(PLAY_HTTPS_PREFIX) === 0) {
      components = str.slice(PLAY_HTTPS_PREFIX.length).split('/');
    } else if (str.indexOf(OPEN_HTTP_PREFIX) === 0) {
      components = str.slice(OPEN_HTTP_PREFIX.length).split('/');
    } else if (str.indexOf(OPEN_HTTPS_PREFIX) === 0) {
      components = str.slice(OPEN_HTTPS_PREFIX.length).split('/');
    } else {
      throw ERROR_INVALID;
    }
    format = Format.URL;
  }

  if (anchor) {
    components.push(anchor);
  }

  return {
    format: format,
    components: components,
    query: query
  };
};

/**
 * Encodes a component according to a format.
 *
 * @param {string} component A component string.
 * @param {Format} format A format.
 * @return {string} An encoded component string.
 * @private
 */
var _encodeComponent = function(component, format) {
  component = encodeURIComponent(component);
  if (format === Format.URI) {
    component = component.replace(/%20/g, '+');
  }

  // encode characters that are not encoded by default by encodeURIComponent
  // but that the Spotify URI spec encodes: !'*()
  component = component.replace(/[!'()]/g, escape);
  component = component.replace(/\*/g, '%2A');

  return component;
};

/**
 * Decodes a component according to a format.
 *
 * @param {string} component An encoded component string.
 * @param {Format} format A format.
 * @return {string} An decoded component string.
 * @private
 */
var _decodeComponent = function(component, format) {
  var part = format == Format.URI ? component.replace(/\+/g, '%20') : component;
  return decodeURIComponent(part);
};

/**
 * Returns the components of a URI as an array.
 *
 * @param {URI} uri A uri.
 * @param {Format} format The output format.
 * @return {Array.<string>} An array of uri components.
 * @private
 */
var _getComponents = function(uri, format) {
  var base62;
  if (uri.id) {
    base62 = uri._base62Id;
  }

  var components;
  var i;
  var len;
  switch (uri.type) {
    case URI.Type.ALBUM:
      components = [URI.Type.ALBUM, base62];
      if (uri.disc) {
        components.push(uri.disc);
      }
      return components;
    case URI.Type.AD:
      return [URI.Type.AD, uri._base62Id];
    case URI.Type.ARTIST:
      return [URI.Type.ARTIST, base62];
    case URI.Type.ARTIST_TOPLIST:
      return [URI.Type.ARTIST, base62, URI.Type.TOP, uri.toplist];
    case URI.Type.SEARCH:
      return [URI.Type.SEARCH, _encodeComponent(uri.query, format)];
    case URI.Type.TRACK:
      if (uri.context || uri.play) {
        base62 += encodeQueryString({
          context: uri.context,
          play: uri.play
        });
      }
      if (uri.anchor) {
        base62 += '#' + uri.anchor;
      }
      return [URI.Type.TRACK, base62];
    case URI.Type.TRACKSET:
      var trackIds = [];
      for (i = 0, len = uri.tracks.length; i < len; i++) {
        trackIds.push(uri.tracks[i]._base62Id);
      }
      trackIds = [trackIds.join(',')];
      // Index can be 0 sometimes (required for trackset)
      if (uri.index !== null) {
        trackIds.push('#', uri.index);
      }
      return [URI.Type.TRACKSET, _encodeComponent(uri.name)].concat(trackIds);
    case URI.Type.FACEBOOK:
      return [URI.Type.USER, URI.Type.FACEBOOK, uri.uid];
    case URI.Type.AUDIO_FILE:
      return [URI.Type.AUDIO_FILE, uri.extension, uri._base62Id];
    case URI.Type.FOLDER:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.FOLDER, uri._base62Id];
    case URI.Type.FOLLOWERS:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.FOLLOWERS];
    case URI.Type.FOLLOWING:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.FOLLOWING];
    case URI.Type.PLAYLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.PLAYLIST, base62];
    case URI.Type.STARRED:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.STARRED];
    case URI.Type.TEMP_PLAYLIST:
      return [URI.Type.TEMP_PLAYLIST, uri.origin, uri.data];
    case URI.Type.CONTEXT_GROUP:
      return [URI.Type.CONTEXT_GROUP, uri.origin, uri.name];
    case URI.Type.USER_TOPLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.TOP, uri.toplist];
    // Legacy Toplist
    case URI.Type.USER_TOP_TRACKS:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.TOPLIST];
    case URI.Type.TOPLIST:
      return [URI.Type.TOP, uri.toplist].concat(uri.global ? [URI.Type.GLOBAL] : ['country', uri.country]);
    case URI.Type.INBOX:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.INBOX];
    case URI.Type.ROOTLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.ROOTLIST];
    case URI.Type.PUBLISHED_ROOTLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.PUBLISHED_ROOTLIST];
    case URI.Type.COLLECTION_TRACK_LIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION_TRACK_LIST, base62];
    case URI.Type.PROFILE:
      if (uri.args && uri.args.length > 0)
        return [URI.Type.USER, _encodeComponent(uri.username, format)].concat(uri.args);
      return [URI.Type.USER, _encodeComponent(uri.username, format)];
    case URI.Type.LOCAL_ARTIST:
      return [URI.Type.LOCAL, _encodeComponent(uri.artist, format)];
    case URI.Type.LOCAL_ALBUM:
      return [URI.Type.LOCAL, _encodeComponent(uri.artist, format), _encodeComponent(uri.album, format)];
    case URI.Type.LOCAL:
      return [URI.Type.LOCAL,
        _encodeComponent(uri.artist, format),
        _encodeComponent(uri.album, format),
        _encodeComponent(uri.track, format),
        uri.duration];
    case URI.Type.LIBRARY:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.LIBRARY].concat(uri.category ? [uri.category] : []);
    case URI.Type.IMAGE:
      return [URI.Type.IMAGE, uri._base62Id];
    case URI.Type.MOSAIC:
      components = uri.ids.slice(0);
      components.unshift(URI.Type.MOSAIC);
      return components;
    case URI.Type.RADIO:
      return [URI.Type.RADIO, uri.args];
    case URI.Type.SPECIAL:
      components = [URI.Type.SPECIAL];
      var args = uri.args || [];
      for (i = 0, len = args.length; i < len; ++i)
        components.push(_encodeComponent(args[i], format));
      return components;
    case URI.Type.STATION:
      components = [URI.Type.STATION];
      var args = uri.args || [];
      for (i = 0, len = args.length; i < len; i++) {
        components.push(_encodeComponent(args[i], format));
      }
      return components;
    case URI.Type.APPLICATION:
      components = [URI.Type.APP, uri._base62Id];
      var args = uri.args || [];
      for (i = 0, len = args.length; i < len; ++i)
        components.push(_encodeComponent(args[i], format));
      return components;
    case URI.Type.COLLECTION_ALBUM:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION, URI.Type.ALBUM, base62];
    case URI.Type.COLLECTION_MISSING_ALBUM:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION, URI.Type.ALBUM, base62, 'missing'];
    case URI.Type.COLLECTION_ARTIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION, URI.Type.ARTIST, base62];
    case URI.Type.COLLECTION:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION].concat(uri.category ? [uri.category] : []);
    case URI.Type.EPISODE:
      if (uri.context || uri.play) {
        base62 += encodeQueryString({
          context: uri.context,
          play: uri.play
        });
      }
      return [URI.Type.EPISODE, base62];
    default:
      throw ERROR_INVALID;
  }
};

var encodeQueryString = function(values) {
  var str = '?';
  for (var i in values) {
    if (values.hasOwnProperty(i) && values[i] !== undefined) {
      if (str.length > 1) {
        str += '&';
      }
      str += i + '=' + encodeURIComponent(values[i]);
    }
  }
  return str;
};

var decodeQueryString = function(str) {
  return str.split('&').reduce(function(object, pair) {
    pair = pair.split('=');
    object[pair[0]] = decodeURIComponent(pair[1]);
    return object;
  }, {});
};

/**
 * Parses the components of a URI into a real URI object.
 *
 * @param {Array.<string>} components The components of the URI as a string
 *     array.
 * @param {Format} format The format of the source string.
 * @return {URI} The URI object.
 * @private
 */
var _parseFromComponents = function(components, format, query) {
  var _current = 0;
  query = query || {};

  var _getNextComponent = function() {
    return components[_current++];
  };

  var _getIdComponent = function() {
    var component = _getNextComponent();

    if (component.length > 22) {
      throw new Error('Invalid ID');
    }
    return component;
  };

  var _getRemainingComponents = function() {
    return components.slice(_current);
  };

  var _getRemainingString = function() {
    var separator = (format == Format.URI) ? ':' : '/';
    return components.slice(_current).join(separator);
  };

  var part = _getNextComponent();
  var id;
  var i;
  var len;

  switch (part) {
    case URI.Type.ALBUM:
      return URI.albumURI(_getIdComponent(), parseInt(_getNextComponent(), 10));
    case URI.Type.AD:
      return URI.adURI(_getNextComponent());
    case URI.Type.ARTIST:
      id = _getIdComponent();
      if (_getNextComponent() == URI.Type.TOP) {
        return URI.artistToplistURI(id, _getNextComponent());
      } else {
        return URI.artistURI(id);
      }
    case URI.Type.AUDIO_FILE:
      return URI.audioFileURI(_getNextComponent(), _getNextComponent());
    case URI.Type.TEMP_PLAYLIST:
      return URI.temporaryPlaylistURI(_getNextComponent(), _getRemainingString());
    case URI.Type.SEARCH:
      return URI.searchURI(_decodeComponent(_getRemainingString(), format));
    case URI.Type.TRACK:
      return URI.trackURI(_getIdComponent(), _getNextComponent(), query.context, query.play);
    case URI.Type.TRACKSET:
      var name = _decodeComponent(_getNextComponent());
      var tracksArray = _getNextComponent();
      var hashSign = _getNextComponent();
      var index = parseInt(_getNextComponent(), 10);
      // Sanity check: %23 is URL code for "#"
      if (hashSign !== '%23' || isNaN(index)) {
        index = null;
      }
      var tracksetTracks = [];
      if (tracksArray) {
        tracksArray = _decodeComponent(tracksArray).split(',');
        for (i = 0, len = tracksArray.length; i < len; i++) {
          var trackId = tracksArray[i];
          tracksetTracks.push(URI.trackURI(trackId));
        }
      }
      return URI.tracksetURI(tracksetTracks, name, index);
    case URI.Type.CONTEXT_GROUP:
      return URI.contextGroupURI(_getNextComponent(), _getNextComponent());
    case URI.Type.TOP:
      var type = _getNextComponent();
      if (_getNextComponent() == URI.Type.GLOBAL) {
        return URI.toplistURI(type, null, true);
      } else {
        return URI.toplistURI(type, _getNextComponent(), false);
      }
    case URI.Type.USER:
      var username = _decodeComponent(_getNextComponent(), format);
      var text = _getNextComponent();
      if (username == URI.Type.FACEBOOK && text != null) {
        return URI.facebookURI(parseInt(text, 10));
      } else if (text != null) {
        switch (text) {
          case URI.Type.PLAYLIST:
            return URI.playlistURI(username, _getIdComponent());
          case URI.Type.FOLDER:
            return URI.folderURI(username, _getIdComponent());
          case URI.Type.COLLECTION_TRACK_LIST:
            return URI.collectionTrackList(username, _getIdComponent());
          case URI.Type.COLLECTION:
            var collectionItemType = _getNextComponent();
            switch (collectionItemType) {
              case URI.Type.ALBUM:
                id = _getIdComponent();
                if (_getNextComponent() === 'missing') {
                  return URI.collectionMissingAlbumURI(username, id);
                } else {
                  return URI.collectionAlbumURI(username, id);
                }
              case URI.Type.ARTIST:
                return URI.collectionArtistURI(username, _getIdComponent());
              default:
                return URI.collectionURI(username, collectionItemType);
            }
          case URI.Type.STARRED:
            return URI.starredURI(username);
          case URI.Type.FOLLOWERS:
            return URI.followersURI(username);
          case URI.Type.FOLLOWING:
            return URI.followingURI(username);
          case URI.Type.TOP:
            return URI.userToplistURI(username, _getNextComponent());
          case URI.Type.INBOX:
            return URI.inboxURI(username);
          case URI.Type.ROOTLIST:
            return URI.rootlistURI(username);
          case URI.Type.PUBLISHED_ROOTLIST:
            return URI.publishedRootlistURI(username);
          case URI.Type.TOPLIST:
            // legacy toplist
            return URI.userTopTracksURI(username);
          case URI.Type.LIBRARY:
            return URI.libraryURI(username, _getNextComponent());
        }
      }
      var rem = _getRemainingComponents();
      if (text != null && rem.length > 0) {
        return URI.profileURI(username, [text].concat(rem));
      } else if (text != null) {
        return URI.profileURI(username, [text]);
      } else {
        return URI.profileURI(username);
      }
    case URI.Type.LOCAL:
      var artistNameComponent = _getNextComponent();
      var artistName = artistNameComponent && _decodeComponent(artistNameComponent, format);
      var albumNameComponent = _getNextComponent();
      var albumName = albumNameComponent && _decodeComponent(albumNameComponent, format);
      var trackNameComponent = _getNextComponent();
      var trackName = trackNameComponent && _decodeComponent(trackNameComponent, format);
      var durationComponent = _getNextComponent();
      var duration = parseInt(durationComponent, 10);
      if (trackNameComponent !== undefined) {
        return URI.localURI(artistName, albumName, trackName, duration);
      } else if (albumNameComponent !== undefined) {
        return URI.localAlbumURI(artistName, albumName);
      } else {
        return URI.localArtistURI(artistName);
      }
    case URI.Type.IMAGE:
      return URI.imageURI(_getIdComponent());
    case URI.Type.MOSAIC:
      return URI.mosaicURI(components.slice(_current));
    case URI.Type.RADIO:
      return URI.radioURI(_getRemainingString());
    case URI.Type.SPECIAL:
      var args = _getRemainingComponents();
      for (i = 0, len = args.length; i < len; ++i)
        args[i] = _decodeComponent(args[i], format);
      return URI.specialURI(args);
    case URI.Type.STATION:
      return URI.stationURI(_getRemainingComponents());
    case URI.Type.EPISODE:
      return URI.episodeURI(_getIdComponent(), query.context, query.play);
    case '':
      break;
    default:
      if (part === URI.Type.APP) {
        id = _getNextComponent();
      } else {
        id = part;
      }
      var decodedId = _decodeComponent(id, format);
      if (_encodeComponent(decodedId, format) !== id) {
        break;
      }
      var args = _getRemainingComponents();
      for (i = 0, len = args.length; i < len; ++i)
        args[i] = _decodeComponent(args[i], format);
      return URI.applicationURI(decodedId, args);
  }

  throw ERROR_INVALID;
};

/**
 * A class holding information about a uri.
 *
 * @constructor
 * @param {URI.Type} type
 * @param {Object} props
 */
function URI(type, props) {
  this.type = type;

  // Merge properties into URI object.
  for (var prop in props) {
    if (typeof props[prop] == 'function') {
      continue;
    }
    this[prop] = props[prop];
  }
}

// Lazy convert the id to hexadecimal only when requested
Object.defineProperty(URI.prototype, 'id', {
  get: function() {
    if (!this._hexId) {
      this._hexId = this._base62Id ? URI.idToHex(this._base62Id) : undefined;
    }
    return this._hexId;
  },
  set: function(id) {
    this._base62Id = id ? URI.hexToId(id) : undefined;
    this._hexId = undefined;
  },
  enumerable: true,
  configurable: true
});

/**
 * Creates an application URI object from the current URI object.
 *
 * If the current URI object is already an application type, a copy is made.
 *
 * @return {URI} The current URI as an application URI.
 */
URI.prototype.toAppType = function() {
  if (this.type == URI.Type.APPLICATION) {
    return URI.applicationURI(this.id, this.args);
  } else {
    var components = _getComponents(this, Format.URL);
    var id = components.shift();
    var len = components.length;
    if (len) {
      while (len--) {
        components[len] = _decodeComponent(components[len], Format.URL);
      }
    }
    if (this.type == URI.Type.RADIO) {
      components = components.shift().split(':');
    }
    var result = URI.applicationURI(id, components);
    return result;
  }
};

/**
 * Creates a URI object from an application URI object.
 *
 * If the current URI object is not an application type, a copy is made.
 *
 * @return {URI} The current URI as a real typed URI.
 */
URI.prototype.toRealType = function() {
  if (this.type == URI.Type.APPLICATION) {
    return _parseFromComponents([this.id].concat(this.args), Format.URI);
  } else {
    return new URI(null, this);
  }
};

/**
 * Returns the URI representation of this URI.
 *
 * @return {String} The URI representation of this uri.
 */
URI.prototype.toURI = function() {
  return URI_PREFIX + _getComponents(this, Format.URI).join(':');
};

/**
 * Returns the String representation of this URI.
 *
 * @return {String} The URI representation of this uri.
 * @see {URI#toURI}
 */
URI.prototype.toString = function() {
  return this.toURI();
};

/**
 * Get the URL path of this uri.
 *
 * @param {boolean} opt_leadingSlash True if a leading slash should be prepended.
 * @return {String} The path of this uri.
 */
URI.prototype.toURLPath = function(opt_leadingSlash) {
  var components = _getComponents(this, Format.URL);
  if (components[0] === URI.Type.APP) {
    components.shift();
  }

  // Some URIs are allowed to have empty components. It should be investigated
  // whether we need to strip empty components at all from any URIs. For now,
  // we check specifically for tracksets and local tracks and strip empty
  // components for all other URIs.
  //
  // For tracksets, it's permissible to have a path that looks like
  // 'trackset//trackURI' because the identifier parameter for a trackset can
  // be blank. For local tracks, some metadata can be missing, like missing
  // album name would be 'spotify:local:artist::track:duration'.
  var isTrackset = components[0] === URI.Type.TRACKSET;
  var isLocalTrack = components[0] === URI.Type.LOCAL;
  var shouldStripEmptyComponents = !isTrackset && !isLocalTrack;

  if (shouldStripEmptyComponents) {
    var _temp = [];
    for (var i = 0, l = components.length; i < l; i++) {
      var component = components[i];
      if (!!component) {
        _temp.push(component);
      }
    }
    components = _temp;
  }
  var path = components.join('/');
  return opt_leadingSlash ? '/' + path : path;
};

/**
 * Returns the Play URL string for the uri.
 *
 * @return {string} The Play URL string for the uri.
 */
URI.prototype.toPlayURL = function() {
    return PLAY_HTTPS_PREFIX + this.toURLPath();
};

/**
 * Returns the URL string for the uri.
 *
 * @return {string} The URL string for the uri.
 * @see {URL#toPlayURL}
 */
URI.prototype.toURL = function() {
  return this.toPlayURL();
};

/**
 * Returns the Open URL string for the uri.
 *
 * @return {string} The Open URL string for the uri.
 */
URI.prototype.toOpenURL = function() {
  return OPEN_HTTPS_PREFIX + this.toURLPath();
};

/**
 * Returns the Play HTTPS URL string for the uri.
 *
 * @return {string} The Play HTTPS URL string for the uri.
 */
URI.prototype.toSecurePlayURL = function() {
    return this.toPlayURL();
};

/**
 * Returns the HTTPS URL string for the uri.
 *
 * @return {string} The HTTPS URL string for the uri.
 * @see {URL#toSecurePlayURL}
 */
URI.prototype.toSecureURL = function() {
  return this.toPlayURL();
};

/**
 * Returns the Open HTTPS URL string for the uri.
 *
 * @return {string} The Open HTTPS URL string for the uri.
 */
URI.prototype.toSecureOpenURL = function() {
  return this.toOpenURL();
};

/**
 * Returns the id of the uri as a bytestring.
 *
 * @return {Array} The id of the uri as a bytestring.
 */
URI.prototype.idToByteString = function() {
  var data = Base62.toBytes(this._base62Id);
  data = data.map(function(i) {
    return String.fromCharCode(i);
  }).join('');
  while (data.length < 16) {
    data = String.fromCharCode(0) + data;
  }
  return data;
};

URI.prototype.getPath = function() {
  var uri = this.toString().replace(/[#?].*/, '');
  return uri;
}

URI.prototype.getBase62Id = function() {
  return this._base62Id;
}

/**
 * The various URI Types.
 *
 * Note that some of the types in this enum are not real URI types, but are
 * actually URI particles. They are marked so.
 *
 * @enum {string}
 */
URI.Type = {
  EMPTY: 'empty',
  ALBUM: 'album',
  AD: 'ad',
  /** URI particle; not an actual URI. */
  APP: 'app',
  APPLICATION: 'application',
  ARTIST: 'artist',
  ARTIST_TOPLIST: 'artist-toplist',
  AUDIO_FILE: 'audiofile',
  COLLECTION: 'collection',
  COLLECTION_ALBUM: 'collection-album',
  COLLECTION_MISSING_ALBUM: 'collection-missing-album',
  COLLECTION_ARTIST: 'collection-artist',
  CONTEXT_GROUP: 'context-group',
  EPISODE: 'episode',
  /** URI particle; not an actual URI. */
  FACEBOOK: 'facebook',
  FOLDER: 'folder',
  FOLLOWERS: 'followers',
  FOLLOWING: 'following',
  /** URI particle; not an actual URI. */
  GLOBAL: 'global',
  IMAGE: 'image',
  INBOX: 'inbox',
  LOCAL_ARTIST: 'local-artist',
  LOCAL_ALBUM: 'local-album',
  LOCAL: 'local',
  LIBRARY: 'library',
  MOSAIC: 'mosaic',
  PLAYLIST: 'playlist',
  PROFILE: 'profile',
  PUBLISHED_ROOTLIST: 'published-rootlist',
  RADIO: 'radio',
  ROOTLIST: 'rootlist',
  COLLECTION_TRACK_LIST: 'collectiontracklist',
  SEARCH: 'search',
  SPECIAL: 'special',
  STARRED: 'starred',
  STATION: 'station',
  TEMP_PLAYLIST: 'temp-playlist',
  /** URI particle; not an actual URI. */
  TOP: 'top',
  TOPLIST: 'toplist',
  TRACK: 'track',
  TRACKSET: 'trackset',
  /** URI particle; not an actual URI. */
  USER: 'user',
  USER_TOPLIST: 'user-toplist',
  USER_TOP_TRACKS: 'user-top-tracks',
  /** Deprecated contant. Please use USER_TOP_TRACKS. */
  USET_TOP_TRACKS: 'user-top-tracks'
};

/**
 * Creates a new URI object from a parsed string argument.
 *
 * @param {string} str The string that will be parsed into a URI object.
 * @throws TypeError If the string argument is not a valid URI, a TypeError will
 *     be thrown.
 * @return {URI} The parsed URI object.
 */
URI.fromString = function(str) {
  var splitted = _splitIntoComponents(str);
  return _parseFromComponents(splitted.components, splitted.format, splitted.query);
};

/**
 * Parses a given object into a URI instance.
 *
 * Unlike URI.fromString, this function could receive any kind of value. If
 * the value is already a URI instance, it is simply returned.
 * Otherwise the value will be stringified before parsing.
 *
 * This function also does not throw an error like URI.fromString, but
 * instead simply returns null if it can't parse the value.
 *
 * @param {*} value The value to parse.
 * @return {URI?} The corresponding URI instance, or null if the
 *     passed value is not a valid value.
 */
URI.from = function(value) {
  try {
    if (value instanceof URI) {
      return value;
    }
    if (typeof value == 'object' && value.type) {
      return new URI(null, value);
    }
    return URI.fromString(value.toString());
  } catch(e) {
    return null;
  }
};

/**
 * Creates a new URI from a bytestring.
 *
 * @param {URI.Type} type The type of the URI.
 * @param {ByteString} idByteString The ID of the URI as a bytestring.
 * @param {Object} opt_args Optional arguments to the URI constructor.
 * @return {URI} The URI object created.
 */
URI.fromByteString = function(type, idByteString, opt_args) {
  var bytes = [];
  for (var i = 0; i < idByteString.length; i++) {
    bytes.push(idByteString.charCodeAt(i));
  }
  var id = Base62.fromBytes(bytes, 22);
  var args = opt_args || {};
  args.id = id;
  return new URI(type, args);
};

/**
 * Clones a given SpotifyURI instance.
 *
 * @param {URI} uri The uri to clone.
 * @return {URI?} An instance of URI.
 */
URI.clone = function(uri) {
  if (!(uri instanceof URI)) {
    return null;
  }
  return new URI(null, uri);
};

/**
 * @deprecated
 */
URI.getCanonical = function(username) {
  return this.getCanonical(username);
};

/**
 * Returns the canonical representation of a username.
 *
 * @param {string} username The username to encode.
 * @return {string} The encoded canonical representation of the username.
 */
URI.getCanonicalUsername = function(username) {
  return _encodeComponent(username, Format.URI);
};

/**
 * Returns the non-canonical representation of a username.
 *
 * @param {string} username The username to encode.
 * @return {string} The unencoded canonical representation of the username.
 */
URI.getDisplayUsername = function(username) {
  return _decodeComponent(username, Format.URI);
};

/**
 * Returns the hex representation of a Base62 encoded id.
 *
 * @param {string} id The base62 encoded id.
 * @return {string} The hex representation of the base62 id.
 */
URI.idToHex = function(id) {
  if (id.length == 22) {
    return Base62.toHex(id, 32);
  }
  return id;
};

/**
 * Returns the base62 representation of a hex encoded id.
 *
 * @param {string} hex The hex encoded id.
 * @return {string} The base62 representation of the id.
 */
URI.hexToId = function(hex) {
  if (hex.length == 32) {
    return Base62.fromHex(hex, 22);
  }
  return hex;
};

/**
 * Creates a new empty URI.
 *
 * @return {URI} The empty URI.
 */
URI.emptyURI = function() {
  return new URI(URI.Type.EMPTY, {});
};

/**
 * Creates a new 'album' type URI.
 *
 * @param {string} id The id of the album.
 * @param {number} disc The disc number of the album.
 * @return {URI} The album URI.
 */
URI.albumURI = function(id, disc) {
  return new URI(URI.Type.ALBUM, {id: id, disc: disc});
};

/**
 * Creates a new 'ad' type URI.
 *
 * @param {string} id The id of the ad.
 * @return {URI} The ad URI.
 */
URI.adURI = function(id) {
  return new URI(URI.Type.AD, {id: id});
};

/**
 * Creates a new 'audiofile' type URI.
 *
 * @param {string} extension The extension of the audiofile.
 * @param {string} id The id of the extension.
 * @return {URI} The audiofile URI.
 */
URI.audioFileURI = function(extension, id) {
  return new URI(URI.Type.AUDIO_FILE, {id: id, extension: extension});
};

/**
 * Creates a new 'artist' type URI.
 *
 * @param {string} id The id of the artist.
 * @return {URI} The artist URI.
 */
URI.artistURI = function(id) {
  return new URI(URI.Type.ARTIST, {id: id});
};

/**
 * Creates a new 'artist-toplist' type URI.
 *
 * @param {string} id The id of the artist.
 * @param {string} toplist The toplist type.
 * @return {URI} The artist-toplist URI.
 */
URI.artistToplistURI = function(id, toplist) {
  return new URI(URI.Type.ARTIST_TOPLIST, {id: id, toplist: toplist});
};

/**
 * Creates a new 'search' type URI.
 *
 * @param {string} query The unencoded search query.
 * @return {URI} The search URI
 */
URI.searchURI = function(query) {
  return new URI(URI.Type.SEARCH, {query: query});
};

/**
 * Creates a new 'track' type URI.
 *
 * @param {string} id The id of the track.
 * @param {string} anchor The point in the track formatted as mm:ss
 * @return {URI} The track URI.
 */
URI.trackURI = function(id, anchor, context, play) {
  return new URI(URI.Type.TRACK, {
    id: id,
    anchor: anchor,
    context: context ? URI.fromString(context) : context,
    play: play
  });
};

/**
 * Creates a new 'trackset' type URI.
 *
 * @param {Array.<URI>} tracks An array of 'track' type URIs.
 * @param {string} name The name of the trackset.
 * @param {number} index The index in the trackset.
 * @return {URI} The trackset URI.
 */
URI.tracksetURI = function(tracks, name, index) {
  return new URI(URI.Type.TRACKSET, {
    tracks: tracks,
    name: name || '',
    index: isNaN(index) ? null : index
  });
};

/**
 * Creates a new 'facebook' type URI.
 *
 * @param {string} uid The user id.
 * @return {URI} The facebook URI.
 */
URI.facebookURI = function(uid) {
  return new URI(URI.Type.FACEBOOK, {uid: uid});
};

/**
 * Creates a new 'followers' type URI.
 *
 * @param {string} username The non-canonical username.
 * @return {URI} The followers URI.
 */
URI.followersURI = function(username) {
  return new URI(URI.Type.FOLLOWERS, {username: username});
};

/**
 * Creates a new 'following' type URI.
 *
 * @param {string} username The non-canonical username.
 * @return {URI} The following URI.
 */
URI.followingURI = function(username) {
  return new URI(URI.Type.FOLLOWING, {username: username});
};

/**
 * Creates a new 'playlist' type URI.
 *
 * @param {string} username The non-canonical username of the playlist owner.
 * @param {string} id The id of the playlist.
 * @return {URI} The playlist URI.
 */
URI.playlistURI = function(username, id) {
  return new URI(URI.Type.PLAYLIST, {username: username, id: id});
};

/**
 * Creates a new 'folder' type URI.
 *
 * @param {string} username The non-canonical username of the folder owner.
 * @param {string} id The id of the folder.
 * @return {URI} The folder URI.
 */
URI.folderURI = function(username, id) {
  return new URI(URI.Type.FOLDER, {username: username, id: id});
};

/**
 * Creates a new 'collectiontracklist' type URI.
 *
 * @param {string} username The non-canonical username of the collection owner.
 * @param {string} id The id of the tracklist.
 * @return {URI} The collectiontracklist URI.
 */
URI.collectionTrackList = function(username, id) {
  return new URI(URI.Type.COLLECTION_TRACK_LIST, {username: username, id: id});
};

/**
 * Creates a new 'starred' type URI.
 *
 * @param {string} username The non-canonical username of the starred list owner.
 * @return {URI} The starred URI.
 */
URI.starredURI = function(username) {
  return new URI(URI.Type.STARRED, {username: username});
};

/**
 * Creates a new 'user-toplist' type URI.
 *
 * @param {string} username The non-canonical username of the toplist owner.
 * @param {string} toplist The toplist type.
 * @return {URI} The user-toplist URI.
 */
URI.userToplistURI = function(username, toplist) {
  return new URI(URI.Type.USER_TOPLIST, {username: username, toplist: toplist});
};

/**
 * Creates a new 'user-top-tracks' type URI.
 *
 * @deprecated
 * @param {string} username The non-canonical username of the toplist owner.
 * @return {URI} The user-top-tracks URI.
 */
URI.userTopTracksURI = function(username) {
  return new URI(URI.Type.USER_TOP_TRACKS, {username: username});
};

/**
 * Creates a new 'toplist' type URI.
 *
 * @param {string} toplist The toplist type.
 * @param {string} country The country code for the toplist.
 * @param {boolean} global True if this is a global rather than a country list.
 * @return {URI} The toplist URI.
 */
URI.toplistURI = function(toplist, country, global) {
  return new URI(URI.Type.TOPLIST, {toplist: toplist, country: country, global: !!global});
};

/**
 * Creates a new 'inbox' type URI.
 *
 * @param {string} username The non-canonical username of the inbox owner.
 * @return {URI} The inbox URI.
 */
URI.inboxURI = function(username) {
  return new URI(URI.Type.INBOX, {username: username});
};

/**
 * Creates a new 'rootlist' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @return {URI} The rootlist URI.
 */
URI.rootlistURI = function(username) {
  return new URI(URI.Type.ROOTLIST, {username: username});
};

/**
 * Creates a new 'published-rootlist' type URI.
 *
 * @param {string} username The non-canonical username of the published-rootlist owner.
 * @return {URI} The published-rootlist URI.
 */
URI.publishedRootlistURI = function(username) {
  return new URI(URI.Type.PUBLISHED_ROOTLIST, {username: username});
};

/**
 * Creates a new 'local-artist' type URI.
 *
 * @param {string} artist The artist name.
 * @return {URI} The local-artist URI.
 */
URI.localArtistURI = function(artist) {
  return new URI(URI.Type.LOCAL_ARTIST, {artist: artist});
};

/**
 * Creates a new 'local-album' type URI.
 *
 * @param {string} artist The artist name.
 * @param {string} album The album name.
 * @return {URI} The local-album URI.
 */
URI.localAlbumURI = function(artist, album) {
  return new URI(URI.Type.LOCAL_ALBUM, {artist: artist, album: album});
};

/**
 * Creates a new 'local' type URI.
 *
 * @param {string} artist The artist name.
 * @param {string} album The album name.
 * @param {string} track The track name.
 * @param {number} duration The track duration in ms.
 * @return {URI} The local URI.
 */
URI.localURI = function(artist, album, track, duration) {
  return new URI(URI.Type.LOCAL, {
    artist: artist,
    album: album,
    track: track,
    duration: duration
  });
};

/**
 * Creates a new 'library' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} category The category of the library.
 * @return {URI} The library URI.
 */
URI.libraryURI = function(username, category) {
  return new URI(URI.Type.LIBRARY, {username: username, category: category});
};

/**
 * Creates a new 'collection' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} category The category of the collection.
 * @return {URI} The collection URI.
 */
URI.collectionURI = function(username, category) {
  return new URI(URI.Type.COLLECTION, {username: username, category: category});
};

/**
 * Creates a new 'temp-playlist' type URI.
 *
 * @param {string} origin The origin of the temporary playlist.
 * @param {string} data Additional data for the playlist.
 * @return {URI} The temp-playlist URI.
 */
URI.temporaryPlaylistURI = function(origin, data) {
  return new URI(URI.Type.TEMP_PLAYLIST, {origin: origin, data: data});
};

/**
 * Creates a new 'context-group' type URI.
 *
 * @deprecated
 * @param {string} origin The origin of the temporary playlist.
 * @param {string} name The name of the context group.
 * @return {URI} The context-group URI.
 */
URI.contextGroupURI = function(origin, name) {
  return new URI(URI.Type.CONTEXT_GROUP, {origin: origin, name: name});
};

/**
 * Creates a new 'profile' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {Array.<string>} args A list of arguments.
 * @return {URI} The profile URI.
 */
URI.profileURI = function(username, args) {
  return new URI(URI.Type.PROFILE, {username: username, args: args});
};

/**
 * Creates a new 'image' type URI.
 *
 * @param {string} id The id of the image.
 * @return {URI} The image URI.
 */
URI.imageURI = function(id) {
  return new URI(URI.Type.IMAGE, {id: id});
};

/**
 * Creates a new 'mosaic' type URI.
 *
 * @param {Array.<string>} ids The ids of the mosaic immages.
 * @return {URI} The mosaic URI.
 */
URI.mosaicURI = function(ids) {
  return new URI(URI.Type.MOSAIC, {ids: ids});
};

/**
 * Creates a new 'radio' type URI.
 *
 * @param {string} args The radio seed arguments.
 * @return {URI} The radio URI.
 */
URI.radioURI = function(args) {
  args = typeof args === 'undefined' ? '' : args;
  return new URI(URI.Type.RADIO, {args: args});
};

/**
 * Creates a new 'special' type URI.
 *
 * @param {Array.<string>} args An array containing the other arguments.
 * @return {URI} The special URI.
 */
URI.specialURI = function(args) {
  args = typeof args === 'undefined' ? [] : args;
  return new URI(URI.Type.SPECIAL, {args: args});
};

/**
 * Creates a new 'station' type URI.
 *
 * @param {Array.<string>} args An array of arguments for the station.
 * @return {URI} The station URI.
 */
URI.stationURI = function(args) {
  args = typeof args === 'undefined' ? [] : args;
  return new URI(URI.Type.STATION, {args: args});
};

/**
 * Creates a new 'application' type URI.
 *
 * @param {string} id The id of the application.
 * @param {Array.<string>} args An array containing the arguments to the app.
 * @return {URI} The application URI.
 */
URI.applicationURI = function(id, args) {
  args = typeof args === 'undefined' ? [] : args;
  return new URI(URI.Type.APPLICATION, {id: id, args: args});
};

/**
 * Creates a new 'collection-album' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} id The id of the album.
 * @return {URI} The collection-album URI.
 */
URI.collectionAlbumURI = function(username, id) {
  return new URI(URI.Type.COLLECTION_ALBUM, {username: username, id: id});
};

/**
 * Creates a new 'collection-album-missing' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} id The id of the album.
 * @return {URI} The collection-album-missing URI.
 */
URI.collectionMissingAlbumURI = function(username, id) {
  return new URI(URI.Type.COLLECTION_MISSING_ALBUM, {username: username, id: id});
};

/**
 * Creates a new 'collection-artist' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} id The id of the artist.
 * @return {URI} The collection-artist URI.
 */
URI.collectionArtistURI = function(username, id) {
  return new URI(URI.Type.COLLECTION_ARTIST, {username: username, id: id});
};

/**
 * Creates a new 'episode' type URI.
 *
 * @param {string} id The id of the episode.
 * @param {string} context An optional context URI
 * @param {boolean} play Toggles autoplay in the episode URI
 * @return {URI} The episode URI.
 */
URI.episodeURI = function(id, context, play) {
  return new URI(URI.Type.EPISODE, {
    id: id,
    context: context ? URI.fromString(context) : context,
    play: play
  });
};

/**
 * Export public interface
 */
module.exports = URI;

},{"spotify-crypto/base62":893}],900:[function(require,module,exports){
var player = require("./player");
var types = require("./types");
var play = require("./play");

exports.Play = play.Play;
exports.Player = player.Player;
exports.PlayerContext = types.Context;
exports.PlayOptions = types.PlayOptions;
exports.PlayerRestrictions = types.Restrictions;
exports.PlayerSuppressions = types.Suppressions;
exports.PlayerTrack = types.Track;
exports.PlayerContextPage = types.ContextPage;
exports.IndexPath = types.IndexPath;

},{"./play":901,"./player":902,"./types":903}],901:[function(require,module,exports){
var cosmos = require('spotify-cosmos-api');
var nodefn = require('when/node');

/**
 * Play is exposed as Player.Play. It represents a prepared playback action.
 * Play objects are obtained from the preparePlay method on the Player; the
 * constructor is not a public API.
 *
 * Instantiating a Play object does not make a Cosmos request, the caller is
 * expected to make that call and pass in a promise of the result in the
 * createSessionPromise parameter.
 *
 * @param {Cosmos.resolver} resolver The resolver to send requests to.
 * @param {Promise} createSessionPromise A promise of a Cosmos.Response for
 *     the call to sp://player/v2/xyz/session.
 * @param {Player} player The player that initiated the call.
 * @param {function()=Number} getTime Clock. Should usually return
 *     new Date().getTime()
 * @param {module:spotify-player/types.Context} The context that was passed
 *     to the preparePlay call.
 * @param {Cosmos.PlayOptions=} opt_options The options that were passed to
 *     the preparePlay call.
 */
function Play(resolver, createSessionPromise, player, getTime, context, opt_options) {
  if (!(this instanceof Play)) {
    return new Play(resolver, createSessionPromise, player, getTime, context, opt_options);
  }

  if (!resolver || !createSessionPromise || !player || !getTime || !context) {
    throw new TypeError('Missing parameters for Play');
  }

  /**
   * @type {Cosmos.resolver}
   */
  this._resolver = resolver;

  /**
   * @type {Promise}
   */
  this._createSessionPromise = createSessionPromise;

  /**
   * @type {Player}
   */
  this._player = player;

  /**
   * @type {function()=Number}
   */
  this._getTime = getTime;

  /**
   * @type {module:spotify-player/types.Context}
   */
  this._context = context;

  /**
   * @type {Cosmos.PlayOptions=}
   */
  this._opt_options = opt_options;
}

/**
 * @return Promise of the session URL
 */
Play.prototype._sessionUrl = function() {
  return this._createSessionPromise.then(function(response) {
    return response.getJSONBody().session;
  });
};

Play.prototype._createPlayRequest = function(sessionUrl) {
  var body = {
    logging_params: {
      command_initiated_time: this._getTime()
    }
  };
  return new cosmos.Request(cosmos.Action.POST, sessionUrl + '/play', null, body);
};

Play.prototype._createUpdateRequest = function(sessionUrl, body) {
  body.logging_params = {
    command_initiated_time: this._getTime()
  };
  return new cosmos.Request(cosmos.Action.POST, sessionUrl + '/update', null, body);
};

/**
 * Perform the playback action that this handle represents.
 *
 * It is legal to call play more than once, but the playback action is only
 * prefetched the first time. If subsequent preparation is required, a new
 * Play object should be obtained.
 */
Play.prototype.play = function(opt_callback) {
  opt_callback = opt_callback || function() {};

  var self = this;
  if (this._createSessionPromise) {
    this._sessionUrl()
      .then(function(sessionUrl) {
        return nodefn.call(
          self._resolver.resolve.bind(self._resolver), self._createPlayRequest(sessionUrl));
      })
      .done(function() {
          opt_callback(null);
        }, function(error) {
          if (error.response && error.response.getStatusCode() === 404) {
            // The session has been invalidated. Try again without prefetching.
            self._createSessionPromise = null;
            self.play(opt_callback);
          } else {
            var wrappedError = new Error('Failed to prepare playback session: ' + error.message);
            wrappedError.cause = function() { return error; };
            opt_callback(wrappedError);
          }
        });
  } else {
    this._player.play(this._context, this._opt_options, opt_callback);
  }
};

Play.prototype._update = function(body, opt_callback) {
  opt_callback = opt_callback || function() {};

  var self = this;
  if (!this._createSessionPromise) {
    return opt_callback(new Error('Cannot update invalidated Play'));
  }

  this._sessionUrl()
    .then(function(sessionUrl) {
      return nodefn.call(
        self._resolver.resolve.bind(self._resolver), self._createUpdateRequest(sessionUrl, body));
    })
    .done(function() {
        opt_callback(null);
      }, function(error) {
        var wrappedError = new Error('Failed to update playback session: ' + error.message);
        wrappedError.cause = function() { return error; };
        opt_callback(wrappedError);
      });
};

Play.prototype.updateContext = function(context, opt_callback) {
  this._update({ context: context }, opt_callback);
};

Play.prototype.updatePage = function(page, opt_callback) {
  this._update({ page: page }, opt_callback);
};

Play.prototype.updateTrack = function(track, opt_callback) {
  this._update({ track: track }, opt_callback);
};

Play.prototype.updateViewUri = function(view_uri, opt_callback) {
  this._update({ view_uri: view_uri }, opt_callback);
};

/**
 * Invalidate the handle. This will cause any ongoing prefetching work to be
 * cancelled. It is good if any holder of a handle calls this method as soon
 * as it knows that it is not interested in its play action anymore.
 *
 * It is illegal to call play after this has been called. Invalidating an
 * invalidated Play is a no-op.
 */
Play.prototype.invalidate = function(opt_callback) {
  if (!this._createSessionPromise) {
    // Already invalidated
    return;
  }

  opt_callback = opt_callback || function() {};

  var self = this;
  this._sessionUrl().done(function(sessionUrl) {
    var request = new cosmos.Request(
      cosmos.Action.DELETE, sessionUrl, null, null);
    self._resolver.resolve(request, function() {
      opt_callback(null);
    });
  }, function() {
    // Ignore errors
    opt_callback(null);
  });

  this._createSessionPromise = null;
};

exports.Play = Play;

},{"spotify-cosmos-api":890,"when/node":927}],902:[function(require,module,exports){
var cosmos = require('spotify-cosmos-api');
var nodefn = require('when/node');
var play = require('./play');

var PLAYER_URI = 'sp://player/v2/';
var DEFAULT_PLAYER_ID = 'main';

/**
 * The object decribing the context for the playback
 * Can be used to pass viewUri or externalReferrer specific
 * for the play action.
 *
 * @typedef {Object} ContextConfig
 * @property {Cosmos.PlayerContext} context The context to play
 * @property {string=} opt_viewId Optional. Set to override the default viewUri
 * @property {string=} opt_externalReferrer Optional. Set to indicate that
 *      the playback is owne by external website/app.
 */

/**
 * Player is the main entry point to control music playback with cosmos.
 *
 * Player in itself isn't what deals with playback; it is merely an object
 * that controls playback and provides ability to observe the player state.
 * There can be more than one Player object at the same time, and they
 * will sync up as one would expect.
 *
 * In practice there will be at least one Player object per feature that
 * wants to control playback. The feature can choose to create one per view
 * or have only one object, it doesn't really matter.
 *
 * @param {Cosmos.resolver} resolver The resolver to send requests to.
 * @param {String} viewUri The uri of the view that owns the playback.
 * @param {String} featureIdentifier The identifier of the feature that started
 *     playback. This is arguably the most important field of this class. It is
 *     used for logging messages, in particular EndSong and EndVideo. (In EndSong,
 *     it ends up in source_start / source_end.) It should be a short human
 *     readable name of the feature, for example "radio", "album", "playlist".
 *     Ideally, it should be the same for a given feature across platforms.
 *
 *     Each feature should have only one string constant that it passes in here.
 *     You must not pass lots of distinct values here; for instance do not send
 *     something that contains the username or artist identifier.
 * @param {String} featureVersion The version of the feature. It often makes sense to set
 *     this value to the version of the spm package, for instance "0.7.5".
 * @param {{playerId: string}} opt_options The additional parameters for the player.
 *  param {string} options.playerId Can be used to override the id of the player
 *      which will result in a different endpoint for the player requests.
 */
function Player(resolver, viewUri, featureIdentifier, featureVersion, opt_options) {
  if (!(this instanceof Player)) {
    return new Player(resolver, viewUri, featureIdentifier, featureVersion);
  }

  if (!resolver || !viewUri || !featureIdentifier || !featureVersion) {
    throw new TypeError('Missing parameters for Player');
  }

  this._getTime = opt_options && opt_options.getTime || function() {
    return new Date().getTime();
  };

  /**
   * @type {string}
   */
  this._id = opt_options && opt_options.playerId || DEFAULT_PLAYER_ID;

  /**
   * @type {string}
   */
  this._referrerIdentifier = opt_options && opt_options.referrerIdentifier;

  /**
   * @type {Cosmos.resolver}
   */
  this._resolver = resolver;

  /**
   * @type {string}
   */
  this._viewUri = viewUri;

  /**
   * @type {string}
   */
  this._featureId = featureIdentifier;

  /**
   * @type {string}
   */
  this._featureVersion = featureVersion;
}

/**
 * The actions that can be understood by the PlayerResolver
 * in Cosmos Router.
 */
Player.Actions = {
  PLAY: 'play',
  SESSION: 'session',
  STOP: 'stop',
  UPDATE: 'update',
  PAUSE: 'pause',
  RESUME: 'resume',
  SKIP_NEXT: 'skip_next',
  SKIP_PREV: 'skip_prev',
  SHUFFLE: 'set_shuffling_context',
  REPEAT_CONTEXT: 'set_repeating_context',
  REPEAT_TRACK: 'set_repeating_track',
  SEEK_TO: 'seek_to'
};

/**
 * Private helper method for play and preparePlay
 */
Player.prototype._playOrPrepare = function(action, context, opt_options, opt_callback) {
  if (!context)
    throw new TypeError('Invalid `context` object');

  // Allow to not send the opt_options
  if (opt_options instanceof Function && !opt_callback) {
    opt_callback = opt_options;
    opt_options = null;
  }

  var params = {};
  params.context = context;
  params.play_origin = this._makePlayOrigin();
  params.options = opt_options;

  return this._sendRequestWithParams(action, params, opt_callback);
};

/**
 * Plays the given context.
 * Since both options and callback are optional this method can
 * take from 1 to 3 arguments. if callback is specified, it has to be
 * the last argument:
 *
 *    player.play(myContext);
 *    player.play(myContext, myPlayOptions);
 *    player.play(myContext, function myCallback() {});
 *    player.play(myContext, myPlayOptions, function myCallback() {});
 *
 * @param {module:spotify-player/types.Context} context The context to play.
 * @param {Cosmos.PlayOptions=} opt_options Optional play options.
 * @param {function(Error, Cosmos.Response?)=} opt_callback Optional
 *    callback that will be executed after player request is resolved.
 *
 *    NOTE: The reponse in the callback only has information about the
 *    request itself (i.e. if it was resolved correctly). If you want to have
 *    information about currently playing context you should subscribe to
 *    player events or fetch the current state using. getContext.
 *
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.play = function(context, opt_options, opt_callback) {
  return this._playOrPrepare(Player.Actions.PLAY, context, opt_options, opt_callback);
};

/**
 * This method is like play, but it doesn't actually initiate playback, it
 * merely expresses intent that the user is rather likely going to do a play
 * action like this soon.
 *
 * @return {Player.Play} A handle that is used for actually performing the
 *     playback action. When the object will no longer be used, the user is
 *     responsible for calling invalidate on it, otherwise it will keep
 *     holding resources. As long as this object is not invalidated, the
 *     playback system will take that as a hint that it should try to prepare
 *     playback like this.
 */
Player.prototype.preparePlay = function(context, opt_options) {
  var sessionPromise = nodefn.call(
    this._playOrPrepare.bind(this), Player.Actions.SESSION, context, opt_options);

  return new play.Play(this._resolver, sessionPromise, this, this._getTime, context, opt_options);
};

/**
 * Stop the playback and clear the context.
 *
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.stop = function(opt_callback) {
  return this._sendRequestWithAction(Player.Actions.STOP, opt_callback);
};

/**
 * Update the current context.
 *
 * @see https://short.spotify.net/0I for more detailed information on the
 *    implementation.
 *
 * @param {module:spotify-player/types.Context} context The context to update to.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.update = function(context, opt_callback) {
  if (!context)
    throw new TypeError('Invalid `context` object');

  var params = { context: context };
  return this._sendRequestWithParams(Player.Actions.UPDATE, params, opt_callback);
};

/**
 * Resume the playback.
 *
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.resume = function(opt_callback) {
  return this._sendRequestWithAction(Player.Actions.RESUME, opt_callback);
};

/**
 * Pause the playback.
 *
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.pause = function(opt_callback) {
  return this._sendRequestWithAction(Player.Actions.PAUSE, opt_callback);
};

/**
 * Skip to the previous song.
 *
 * @param {Object=} opt_skip_options The object with the skip options
 *    like allow_seeking
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.skipToPrevTrack = function(opt_skip_options, opt_callback) {
  if (arguments.length === 1) {
    // In order to keep backwards compatibility we still need to support
    // passing just the callback as the first parameter
    if (typeof opt_skip_options === 'function') {
      opt_callback = opt_skip_options;
      opt_skip_options = null;
    }
  }
  var params = {};
  if (opt_skip_options) {
    params.options = opt_skip_options;
  }
  return this._sendRequestWithParams(Player.Actions.SKIP_PREV, params, opt_callback);
};

/**
 * Skip to the next song.
 *
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.skipToNextTrack = function(opt_callback) {
  return this._sendRequestWithAction(Player.Actions.SKIP_NEXT, opt_callback);
};

/**
 * Skip backwards until it gets to the specified track. This method never skips
 * to the beginning of the current track. For that, use seekTo.
 *
 * @discussion If the reverse runs out of tracks or skipping becomes disallowed
 *    for some other reason, this method will give up when it can no longer
 *    continue. This means that calling this for MFT users will almost
 *    certainly be a bad idea.
 *
 *    The intended purpose of this method is to make it possible to implement
 *    a view of the current future/reverse and allow the user to skip in it.
 *
 *    This method will look at the track URI and the track's UID (if present)
 *    to determine when it has reached its goal.
 *
 * @param {Object} track The track object, as it was provided from the
 *    player state reverse.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.skipToSpecificPrevTrack = function(track, opt_callback) {
  return this._sendRequestWithParams(Player.Actions.SKIP_PREV, { track: track }, opt_callback);
};

/**
 * Skip forwards until it gets to the specified track.
 *
 * @discussion See discussion for -skipToPreviousTrack:
 *
 * @param {Object} track The track object, as it was provided from the
 *    player state reverse.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.skipToSpecificNextTrack = function(track, opt_callback) {
  return this._sendRequestWithParams(Player.Actions.SKIP_NEXT, { track: track }, opt_callback);
};

/**
 * Deprecated alias for skipToPrevTrack
 */
Player.prototype.skipToPrev = Player.prototype.skipToPrevTrack;

/**
 * Deprecated alias for skipToNextTrack
 */
Player.prototype.skipToNext = Player.prototype.skipToNextTrack;

/**
 * Set the shuffle flag
 *
 * @param {boolean} isShuffling The value of the flag to set.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.setShufflingContext = function(isShuffling, opt_callback) {
  return this._sendRequestWithParam(Player.Actions.SHUFFLE, isShuffling, opt_callback);
};

/**
 * Repeat the whole context
 *
 * @param {boolean} isRepeating The value of the flag to set.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.setRepeatingContext = function(isRepeating, opt_callback) {
  return this._sendRequestWithParam(Player.Actions.REPEAT_CONTEXT, isRepeating, opt_callback);
};

/**
 * Repeat the single track
 *
 * @param {boolean} isRepeating The value of the flag to set.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.setRepeatingTrack = function(isRepeating, opt_callback) {
  return this._sendRequestWithParam(Player.Actions.REPEAT_TRACK, isRepeating, opt_callback);
};

/**
 * Set the seek position. It should be set in seconds.
 *
 * @param {boolean} positionInMs Position to seek to in miliseconds.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.seekTo = function(positionInMs, opt_callback) {
  return this._sendRequestWithParam(Player.Actions.SEEK_TO, positionInMs, opt_callback);
};

/**
 * Gets the current player state as an opaque string that can later be used to restore the
 * current state.
 *
 * @param {function(Error, Cosmos.Response=)} callback The function
 *    that will be called when the snapshot is available.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.save = function(callback) {
  var requestUri = this.getPlayerEndpointUri() + '/snapshot';
  var request = new cosmos.Request(cosmos.Action.GET, requestUri);
  return this._resolver.resolve(request, callback);
};

/**
 * Restores a state string that was previously saved by save().
 *
 * @param {string} state The state to restore.
 * @param {function(Error, Cosmos.Response=)} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.restore = function(state, opt_callback) {
  var requestUri = this.getPlayerEndpointUri() + '/snapshot';
  var request = new cosmos.Request(cosmos.Action.PUT, requestUri, null, state);
  return this._resolver.resolve(request, opt_callback);
};

/**
 * Gets the current player queue as an string that can later be modified to replace
 * the current queue.
 *
 * @param {function(Error, Cosmos.Response=)} callback The function
 *    that will be called when the queue is available.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */

Player.prototype.getQueue = function(callback) {
  var requestUri = this.getPlayerEndpointUri() + '/queue';
  var request = new cosmos.Request(cosmos.Action.GET, requestUri);
  return this._resolver.resolve(request, callback);
};

/**
 * Replace the player queue. The state will not replace the current one of the player if
 * the revision does not match the current revision of the player. This happens when
 * the player queue was changed elsewhere by the time it was received until it was set.
 * A response-status of 409 will inform about this situation.
 *
 * @param {string} state The queue-state to replace with.
 * @param {function(Error, Cosmos.Response=)} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.setQueue = function(state, opt_callback) {
  var requestUri = this.getPlayerEndpointUri() + '/queue';
  var request = new cosmos.Request(cosmos.Action.PUT, requestUri, null, state);
  return this._resolver.resolve(request, opt_callback);
};

/**
 * Subscribe to queue changes. There will be an initial callback when subscribing.
 */
Player.prototype.subscribeToQueue = function(callback) {
  var request = new cosmos.Request(cosmos.Action.SUB, this.getPlayerEndpointUri() + '/queue');
  return this._resolver.resolve(request, callback);
};

/**
 * Get the current player state.
 *
 * @param {function(Error, Cosmos.Response=)} callback The function
 *    that will be called when the state is available.
 * @param {Object=} opt_params The additional parameters for the request.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.getState = function(callback, opt_params) {
  var request = new cosmos.Request(
    cosmos.Action.GET, this.getPlayerEndpointUriWithParams(opt_params));
  return this._resolver.resolve(request, callback);
};

/**
 * Subscribe to the player events
 *
 * @param {function(Error, Cosmos.Response=)} callback The function
 *    that will be called every time the event occurs.
 * @param {Object=} opt_params The additional parameters for the request.
 * @return {RequestHandle} The subscription handle.
 *
 *    This object can be used to cancel the subscription
 *    by calling 'cancel()' on it:
 *
 *    var sub = player.subscribe(function(err, response) { });
 *    sub.cancel();
 */
Player.prototype.subscribe = function(callback, opt_params) {
  var request = new cosmos.Request(
    cosmos.Action.SUB, this.getPlayerEndpointUriWithParams(opt_params));
  return this._resolver.resolve(request, callback);
};

/**
 * Subscribe to player error events
 */
Player.prototype.onError = function(callback) {
  var request = new cosmos.Request(cosmos.Action.SUB, this.getPlayerEndpointUri() + '/error');
  return this._resolver.resolve(request, callback);
};

Player.prototype._makePlayOrigin = function() {
  return {
    view_uri: this._viewUri,
    feature_identifier: this._featureId,
    feature_version: this._featureVersion,
    referrer_identifier: this._referrerIdentifier
  };
};

Player.prototype.getPlayerEndpointUri = function() {
  return PLAYER_URI + this._id;
};

Player.prototype.getPlayerEndpointUriWithParams = function(params) {
  params = params || {};

  var paramsArray = Object.keys(params).reduce(function(arr, key) {
    arr.push(key + '=' + encodeURIComponent(params[key]));
    return arr;
  }, []);

  if (paramsArray.length > 0) {
    return this.getPlayerEndpointUri() + '?' + paramsArray.join('&');
  } else {
    return this.getPlayerEndpointUri();
  }
};

/**
 * @private
 * Sends context-less request.
 *
 * @param {string} action The action to perform on the player.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype._sendRequestWithAction = function(action, opt_callback) {
  return this._sendRequestWithParams(action, null, opt_callback);
};

/**
 * @private
 * Sends the request that only expects the single value in the body.
 *
 * @param {string} action The action to perform on the player.
 * @param {*} paramValue The value to send to the player.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype._sendRequestWithParam = function(action, paramValue, opt_callback) {
  var params = {
    value: paramValue
  };
  return this._sendRequestWithParams(action, params, opt_callback);
};

/**
 * @private
 * Sends request with context and optional options.
 *
 * @param {string} action The action to perform on the player.
 * @param {Object?} params The context to play.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype._sendRequestWithParams = function(action, params, opt_callback) {
  var requestUri = this.getPlayerEndpointUri() + '/' + action;
  var body = params || {};
  body.logging_params = {
    command_initiated_time: this._getTime()
  };
  var request = new cosmos.Request(
    cosmos.Action.POST, requestUri, null, body);
  return this._resolver.resolve(request, opt_callback);
};

exports.Player = Player;

},{"./play":901,"spotify-cosmos-api":890,"when/node":927}],903:[function(require,module,exports){
/**
 * A PlayerTrack represents a single track in a context.
 *
 * @typedef {Object}
 * @property {String} uri
 *    The URI of the track. This will be one of the Spotify URIs, such as
 *    spotify:track:GID or spotify:local:DATA.
 * @property {String} album_uri
 *    The URI of the album that the track appears on. This property must always
 *    be set if the track URI is set. This is a requirement so that functions
 *    like MFT rules and biased shuffle can operate without having to fetch
 *    additional metadata for each track.
 * @property {String} artist_uri
 *    The URI of the main artist of the track. This property must always be set
 *    if the track URI is set. This is a requirement so that functions like MFT
 *    rules and biased shuffle can operate without having to fetch additional
 *    metadata for each track.
 * @property {Object} metadata
 *    A map with custom metadata for the track. This map can hold anything that
 *    the feature decides to put in it. Features should be prepared that the
 *    metadata can disappear and be able to work around that situation.
 *    The metadata is passed around and persisted, so it will usually stick
 *    around, but there are certain situations where the data is lost because of
 *    transferring the track over legacy protocols, to Connect enabled speakers
 *    and back.
 */
exports.Track;

/**
 * PlayerRestrictions is used to encapsulate limitations of a player or a
 * context. The caller can specify that restrictions should apply when playing a
 * given context (see PlayerContext.restrictions), and a player can notify that
 * restrictions (see PlayState.restrictions).
 *
 * @typedef {Object}
 * @property {Array.<String>} disallow_skipping_prev_reasons
 *    The reasons why skipping to the previous track should be / is disallowed.
 * @property {Array.<String>} disallow_skipping_next_reasons
 *    The reasons why skipping to the next track should be / is disallowed.
 * @property {Array.<String>} disallow_peeking_prev_reasons
 *    The reasons why peeking at the previous track should be / is disallowed.
 * @property {Array.<String>} disallow_peeking_next_reasons
 *    The reasons why peeking at the next track should be / is disallowed.
 * @property {Array.<String>} disallow_skipping_to_reasons
 *    The reasons why skipping to a specific track should be / is disallowed.
 * @property {Array.<String>} disallow_pausing_reasons
 *    The reasons why pausing playback should be / is disallowed.
 * @property {Array.<String>} disallow_resuming_reasons
 *    The reasons why resuming playback should be / is disallowed.
 * @property {Array.<String>} disallow_toggling_repeat_context_reasons
 *    The reasons why toggling repeat context should be / is disallowed.
 * @property {Array.<String>} disallow_toggling_repeat_track_reasons
 *    The reasons why toggling repeat track should be / is disallowed.
 * @property {Array.<String>} disallow_toggling_shuffle_reasons
 *    The reasons why toggling shuffle should be / is disallowed.
 * @property {Array.<String>} disallow_seeking_reasons
 *    The reasons why seeking within a track should be / is disallowed.
 * @property {Array.<String>} disallow_muting_reasons
 *    The reasons why muting audio should be / is disallowed.
 */
exports.Restrictions;

/**
 * PlayerSuppressions are used to disable certain player rules while playing a
 * context. The caller can specify that suppressions should apply when playing a
 * context (see PlayerOptions.suppressions), and a player can notify those
 * suppressions (see PlayState.suppressions).
 *
 * @typedef {Object}
 * @property {Array.<String>} providers
 *    The provider identifiers of the rules that should be disabled.
 */
exports.Suppressions;

/**
 * An object representing the index of the track to play within a context.
 * In the simplest case there is only one page thus its index should be 0.
 *
 * @typedef {Object}
 * @property {Number} page The index of the page to find the track in.
 * @property {Number} track The index of the track in the page.
 */
exports.IndexPath;

/**
 * This structure holds options that should be applied to the player: they are
 * either specified at a global or per-context level. When they are specified
 * globally, finishing the current context or starting to play a new context
 * does not change the player options: specifying them at a context-level means
 * that the previous global setting will be restored when the player is asked to
 * play another context.
 *
 * @typedef {Object}
 * @property {Boolean} shuffling_context
 *    Specifies if the player should shuffle the context or not.
 * @property {Boolean} repeating_context
 *    Specifies if the player should repeat the context or not.
 * @property {Boolean} repeating_track
 *    Specifies if the player should repeat the current track or not.
 */
exports.PlayerOptions;

/**
 * Options for a specific playback request. This object can specify for instance
 * which track to play within the given context, where to seek within the track
 * etc.
 *
 * @typedef {Object}
 * @property {module:spotify-player/types.IndexPath} skip_to_index
 *    The index in the context to start playing from. It is possible to specify
 *    a page that is not yet loaded, in which case the page will be downloaded
 *    before playback starts. The context player state will indicate that the
 *    playback is delayed because of loading the page.
 * @property {Number} seek_to
 *    The number of milliseconds to seek into the track when starting to
 *    play it.
 * @property {Boolean} initially_paused
 *    When this property is set, the context player will load the context but
 *    will not start playing audio for the first track. The is_paused property
 *    is set in the context player state to indicate that playback is paused. To
 *    start playing the track, call the `resume` method on the context player.
 * @property {module:spotify-player/types.PlayerOptions} player_options_override
 *    Use this to temporarily override the player options for this play request
 *    only. This can for instance be used to implement shuffle play buttons that
 *    enable shuffling but only for this particular context.
 */
exports.PlayOptions;

/**
 * Allows the list of tracks that will be played to be split up into chunks.
 * Pages may loaded or unloaded: an unloaded page will be loaded by the player
 * when it needs more tracks to play.
 *
 * @typedef {Object}
 * @property {String} page_url
 *     The URL of this page. If this property is set to a valid URL, it will be
 *     used to fetch the tracks of the page. The URL must be something that is
 *     supported by the context page loader in use, e.g., Hermes endpoints or
 *     Spotify playlist URIs. In the latter case, the context page loader will
 *     trigger the loaded signal each time the underlying playlist changes. If
 *     the tracks for the (static) context page are already provided in the
 *     tracks property, the page is considered loaded and the URL can be left
 *     empty.
 * @property {String} next_page_url
 *     The URL of the next context page. When the context page is stored in a
 *     context, the next page URL will be used to automatically append new pages
 *     at the end of the pages (or the fallback page) array. The new page
 *     will have its page URL set according to the next page URL of the last
 *     page in the context. The context page loaded will be used at some point
 *     to fetch the tracks for the new page. When the new page is fetched from
 *     the backend, it can also have the next page URL set, and yet another page
 *     is added to the context.
 * @property {Array<module:spotify-player/types.Track>} tracks
 *     An optional array with the tracks of this context page. When the context
 *     page is not loaded, the property is not initialized, and a context page
 *     loader will be used to fetch a loaded version of the page. In a loaded
 *     page this property will be set to an array of tracks. Note that the array
 *     can be empty, which means that the page does not have any tracks. This is
 *     not the same as a page that is not loaded, which may or may not have
 *     tracks.
 */
exports.ContextPage;

/**
 * Describes a set of tracks to be played.
 *
 * @typedef {Object}
 * @property {String} entity_uri
 *    An optional Spotify URI that represents what this entire context contains.
 *    For established entities like playlist, album, artist, this should be their
 *    respective URIs. This can be used for inter-feature playback status
 *    indication.
 *
 *    For instance, when the search page starts to play an artist, it should
 *    provide the artist URI in this field. The playback status indication for
 *    that artist in the search result list should be set if the current context
 *    entity URI matches the artist URI. On the artist page, the artist play
 *    button should also look at the entity URI for playback indication.
 * @property {Object} metadata
 *    A map with custom metadata for the track. This map can hold anything that
 *    the feature decides to put in it. Features should be prepared that the
 *    metadata can disappear and be able to work around that situation.
 *    The metadata is passed around and persisted, so it will usually stick
 *    around, but there are certain situations where the data is lost because of
 *    transferring the track over legacy protocols, to Connect enabled speakers
 *    and back.
 * @property {Array<module:spotify-player/types.ContextPage>} pages
 *    An array of context pages that contain the tracks that should be played
 *    for this context. The context pages may or may not be loaded when passing
 *    the context to the player for playback. Note that if the last context page
 *    has a next page URL, at some point a new context page will be added to the
 *    end of the array, for that page URL. This will happen when playback is
 *    nearing the end of the available context pages.
 * @property {Array<module:spotify-player/types.ContextPage>} fallback_pages
 *    A vector of context pages that contain the tracks that should be used as a
 *    fallback if some rule does not allow the tracks in the future to be
 *    played.  An example of this is the MFT rules, which has a number of
 *    restrictions of how many times a track and album can be played during a
 *    given time period.  Another example is the DMCA rules that is used for the
 *    radio feature. When a fallback track is picked from the fallback pages, it
 *    must be removed from the page, so that it is not used again later. The
 *    fallback track can be provided by the feature that starts playback or
 *    they will be populated by the player if they are needed and none are
 *    provided.
 * @property {module:spotify-player/types.Restricitions} restrictions
 *    The restrictons that should be applied to the player when playing tracks
 *    from the context, e.g., whether the user is allowed to skip backward and
 *    forward in the context or enable shuffling and repeating. Note that the
 *    actual restrictions of the player at any given moment is decided not only
 *    by the context restrictions but also by the rules that are applied, e.g.,
 *    the MFT rules will always disable skipping backward, and will disable
 *    skipping forward as well when the user has reached the maximum number of
 *    skips allowed per time period.
 */
exports.Context;

},{}],904:[function(require,module,exports){
/**
 * @file
 * Unified window messaging facility.
 *
 * This module exports two functions to the Spotify
 * namespace which allows other subsystems to handle
 * particular types of messages sent through the native
 * window.postMessage method.
 *
 * @see Spotify.addMessageHandler
 * @see Spotify.removeMessageHandler
 */
'use strict';

var POST_ROUTER_ID = 'post-router-msg-' + new Date().getTime();

var hasStructuredClone = false;

var setImmediate = setImmediate ? setImmediate : setTimeout;

var CURRENT_WINDOW_ORIGIN = undefined;

if (typeof window !== 'undefined') {
  CURRENT_WINDOW_ORIGIN = (window.location.origin ||
      window.location.protocol + '//' + window.location.hostname);

  // Hacky solution to make it work for the webplayer.
  if (!window.__forceNoStructuredClone) {
    // Check if the platform has support for structured cloning.
    //
    // In platforms where this is supported, sending a postMessage with an
    // object that contains a function will throw an error, as it is not
    // cloneable.
    try {
      window.postMessage({
        toString: function() {
          return "clone-test";
        }
      }, CURRENT_WINDOW_ORIGIN);
      hasStructuredClone = false;
    } catch(e) {
      hasStructuredClone = true;
    }
  }
}

/**
 * Storage for message handlers.
 *
 * @type {Object.<string, Spotify.Shell.MessageHandler>}
 * @private
 */
var handlers = {};


/**
 * Variable to check if the window is already listening to postMessage events
 *
 * @type {bool}
 * @private
 */
var isListening = false;


function handleImmediateMessage(data) {
  var handler = handlers[data.type];
  if (!handler) return;
  handler.fn.call(this, data);
}


/**
 * Main event handler for the window message event.
 *
 * @param {Event} event The message event object.
 * @private
 */
function handlePostMessage(event) {
  var data = event.data;
  if (!hasStructuredClone) {
    if (typeof data == 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) {
        return;
      }
    } else {
      // We only expect strings.
      return;
    }
  }
  if (event.origin == CURRENT_WINDOW_ORIGIN) {
    data = data[POST_ROUTER_ID];
    if (!data) {
      // Not our data, return immediately.
      return;
    }
  }
  var handler = handlers[data.type];
  if (!handler || handler.origin != '*' && event.origin !== handler.origin) {
    return;
  }
  handler.fn.call(this, data, event);
}

/**
 * Attaches the handlePostMessage function to PostMessage events
 *
 * @private
 */
var startListening = function() {
  if (window.attachEvent && !window.addEventListener) {
    // IE8 and Below
    window.attachEvent('onmessage', handlePostMessage);
  } else if (window.attachEvent && window.addEventListener) {
    // IE9
    window.addEventListener('message', handlePostMessage, false);
  } else if (window.addEventListener) {
    // Everyone else
    window.addEventListener('message', handlePostMessage, false);
  }
};


/**
 * Adds a message handler for a particular message type.
 *
 * The message handler function will be invoked when the window receives
 * a message marked as a particular type, receiving an argument. The
 * argument will be the data payload of the event decoded from JSON.
 *
 * @param {string} type The type of the message to handle.
 * @param {function} fn The handler function.
 * @param {string} origin needed
 * @throws {Error} Thrown if the message type being handled already has
 *     a handler function.
 */
var addMessageHandler = function(type, fn, origin) {
  if (typeof window !== 'undefined' && !isListening) {
    startListening();
    isListening = true;
  }

  if (!origin) {
    origin = CURRENT_WINDOW_ORIGIN;
  }

  if (handlers[type]) {
    throw new Error('Rehandling of message "' + type + '" not allowed.');
  }
  handlers[type] = {
    fn: fn,
    origin: origin
  };
  return;
};


/**
 * Removes a message handler for a particular message type.
 *
 * @param {string} type The type of the message to remove.
 * @param {Spotify.Shell.MessageHandler} fn The handler function.
 * @return {boolean} True if the handler function was succesfully removed.
 */
var removeMessageHandler = function(type, fn) {
  if (handlers[type] && (!fn || handlers[type].fn === fn)) {
    handlers[type] = null;
    return true;
  }
  return false;
};


/**
 * Sends a message to the event handler
 *
 * @param {string} type The type of the message to remove.
 * @param {Object} data JSON object to pass to the handler
 */
var sendMessage = function(type, data, destWindow, origin) {
  data = data || {};
  data.type = type;

  if (typeof window === 'undefined') {
    return setImmediate(handleImmediateMessage.bind(null, data));
  }

  destWindow = destWindow || window;

  if (!origin) {
    origin = CURRENT_WINDOW_ORIGIN;
  }

  destWindow.postMessage(JSON.stringify(data), origin);
};

var sendLocalMessage = function(type, data) {
  data = data || {};
  data.type = type;

  if (typeof window === 'undefined') {
    return setImmediate(handleImmediateMessage.bind(null, data));
  }

  // Wrap the data in a custom object to quickly identify the message.
  var wrapper = {};
  wrapper[POST_ROUTER_ID] = data;

  window.postMessage(hasStructuredClone ?
                     wrapper :
                     JSON.stringify(wrapper), CURRENT_WINDOW_ORIGIN);
};


/**
 * Export public interface
 */
module.exports = {
  addMessageHandler: addMessageHandler,
  removeMessageHandler: removeMessageHandler,
  sendMessage: sendMessage,
  sendLocalMessage: sendLocalMessage,
  WINDOW_ORIGIN: CURRENT_WINDOW_ORIGIN
};

},{}],905:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],906:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],907:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":906,"_process":702,"inherits":905}],908:[function(require,module,exports){
/*
 * UUID-js: A js library to generate and parse UUIDs, TimeUUIDs and generate
 * TimeUUID based on dates for range selections.
 * @see http://www.ietf.org/rfc/rfc4122.txt
 **/

function UUIDjs() {
};

UUIDjs.maxFromBits = function(bits) {
  return Math.pow(2, bits);
};

UUIDjs.limitUI04 = UUIDjs.maxFromBits(4);
UUIDjs.limitUI06 = UUIDjs.maxFromBits(6);
UUIDjs.limitUI08 = UUIDjs.maxFromBits(8);
UUIDjs.limitUI12 = UUIDjs.maxFromBits(12);
UUIDjs.limitUI14 = UUIDjs.maxFromBits(14);
UUIDjs.limitUI16 = UUIDjs.maxFromBits(16);
UUIDjs.limitUI32 = UUIDjs.maxFromBits(32);
UUIDjs.limitUI40 = UUIDjs.maxFromBits(40);
UUIDjs.limitUI48 = UUIDjs.maxFromBits(48);

// Returns a random integer between min and max
// Using Math.round() will give you a non-uniform distribution!
// @see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/random
function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

UUIDjs.randomUI04 = function() {
  return getRandomInt(0, UUIDjs.limitUI04-1);
};
UUIDjs.randomUI06 = function() {
  return getRandomInt(0, UUIDjs.limitUI06-1);
};
UUIDjs.randomUI08 = function() {
  return getRandomInt(0, UUIDjs.limitUI08-1);
};
UUIDjs.randomUI12 = function() {
  return getRandomInt(0, UUIDjs.limitUI12-1);
};
UUIDjs.randomUI14 = function() {
  return getRandomInt(0, UUIDjs.limitUI14-1);
};
UUIDjs.randomUI16 = function() {
  return getRandomInt(0, UUIDjs.limitUI16-1);
};
UUIDjs.randomUI32 = function() {
  return getRandomInt(0, UUIDjs.limitUI32-1);
};
UUIDjs.randomUI40 = function() {
  return (0 | Math.random() * (1 << 30)) + (0 | Math.random() * (1 << 40 - 30)) * (1 << 30);
};
UUIDjs.randomUI48 = function() {
  return (0 | Math.random() * (1 << 30)) + (0 | Math.random() * (1 << 48 - 30)) * (1 << 30);
};

UUIDjs.paddedString = function(string, length, z) {
  string = String(string);
  z = (!z) ? '0' : z;
  var i = length - string.length;
  for (; i > 0; i >>>= 1, z += z) {
    if (i & 1) {
      string = z + string;
    }
  }
  return string;
};

UUIDjs.prototype.fromParts = function(timeLow, timeMid, timeHiAndVersion, clockSeqHiAndReserved, clockSeqLow, node) {
  this.version = (timeHiAndVersion >> 12) & 0xF;
  this.hex = UUIDjs.paddedString(timeLow.toString(16), 8)
             + '-'
             + UUIDjs.paddedString(timeMid.toString(16), 4)
             + '-'
             + UUIDjs.paddedString(timeHiAndVersion.toString(16), 4)
             + '-'
             + UUIDjs.paddedString(clockSeqHiAndReserved.toString(16), 2)
             + UUIDjs.paddedString(clockSeqLow.toString(16), 2)
             + '-'
             + UUIDjs.paddedString(node.toString(16), 12);
  return this;
};

UUIDjs.prototype.toString = function() {
  return this.hex;
};
UUIDjs.prototype.toURN = function() {
  return 'urn:uuid:' + this.hex;
};

UUIDjs.prototype.toBytes = function() {
  var parts = this.hex.split('-');
  var ints = [];
  var intPos = 0;
  for (var i = 0; i < parts.length; i++) {
    for (var j = 0; j < parts[i].length; j+=2) {
      ints[intPos++] = parseInt(parts[i].substr(j, 2), 16);
    }
  }
  return ints;
};

UUIDjs.prototype.equals = function(uuid) {
  if (!(uuid instanceof UUID)) {
    return false;
  }
  if (this.hex !== uuid.hex) {
    return false;
  }
  return true;
};

UUIDjs.getTimeFieldValues = function(time) {
  var ts = time - Date.UTC(1582, 9, 15);
  var hm = ((ts / 0x100000000) * 10000) & 0xFFFFFFF;
  return { low: ((ts & 0xFFFFFFF) * 10000) % 0x100000000,
            mid: hm & 0xFFFF, hi: hm >>> 16, timestamp: ts };
};

UUIDjs._create4 = function() {
  return new UUIDjs().fromParts(
    UUIDjs.randomUI32(),
    UUIDjs.randomUI16(),
    0x4000 | UUIDjs.randomUI12(),
    0x80   | UUIDjs.randomUI06(),
    UUIDjs.randomUI08(),
    UUIDjs.randomUI48()
  );
};

UUIDjs._create1 = function() {
  var now = new Date().getTime();
  var sequence = UUIDjs.randomUI14();
  var node = (UUIDjs.randomUI08() | 1) * 0x10000000000 + UUIDjs.randomUI40();
  var tick = UUIDjs.randomUI04();
  var timestamp = 0;
  var timestampRatio = 1/4;

  if (now != timestamp) {
    if (now < timestamp) {
      sequence++;
    }
    timestamp = now;
    tick = UUIDjs.randomUI04();
  } else if (Math.random() < timestampRatio && tick < 9984) {
    tick += 1 + UUIDjs.randomUI04();
  } else {
    sequence++;
  }

  var tf = UUIDjs.getTimeFieldValues(timestamp);
  var tl = tf.low + tick;
  var thav = (tf.hi & 0xFFF) | 0x1000;

  sequence &= 0x3FFF;
  var cshar = (sequence >>> 8) | 0x80;
  var csl = sequence & 0xFF;

  return new UUIDjs().fromParts(tl, tf.mid, thav, cshar, csl, node);
};

UUIDjs.create = function(version) {
  version = version || 4;
  return this['_create' + version]();
};

UUIDjs.fromTime = function(time, last) {
  last = (!last) ? false : last;
  var tf = UUIDjs.getTimeFieldValues(time);
  var tl = tf.low;
  var thav = (tf.hi & 0xFFF) | 0x1000;  // set version '0001'
  if (last === false) {
    return new UUIDjs().fromParts(tl, tf.mid, thav, 0, 0, 0);
  } else {
    return new UUIDjs().fromParts(tl, tf.mid, thav, 0x80 | UUIDjs.limitUI06, UUIDjs.limitUI08 - 1, UUIDjs.limitUI48 - 1);
  }
};

UUIDjs.firstFromTime = function(time) {
  return UUIDjs.fromTime(time, false);
};
UUIDjs.lastFromTime = function(time) {
  return UUIDjs.fromTime(time, true);
};

UUIDjs.fromURN = function(strId) {
  var r, p = /^(?:urn:uuid:|\{)?([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{2})([0-9a-f]{2})-([0-9a-f]{12})(?:\})?$/i;
  if ((r = p.exec(strId))) {
    return new UUIDjs().fromParts(parseInt(r[1], 16), parseInt(r[2], 16),
                            parseInt(r[3], 16), parseInt(r[4], 16),
                            parseInt(r[5], 16), parseInt(r[6], 16));
  }
  return null;
};

UUIDjs.fromBytes = function(ints) {
  if (ints.length < 5) {
    return null;
  }
  var str = '';
  var pos = 0;
  var parts = [4, 2, 2, 2, 6];
  for (var i = 0; i < parts.length; i++) {
    for (var j = 0; j < parts[i]; j++) {
      var octet = ints[pos++].toString(16);
      if (octet.length == 1) {
        octet = '0' + octet;
      }
      str += octet;
    }
    if (parts[i] !== 6) {
      str += '-';
    }
  }
  return UUIDjs.fromURN(str);
};

UUIDjs.fromBinary = function(binary) {
  var ints = [];
  for (var i = 0; i < binary.length; i++) {
    ints[i] = binary.charCodeAt(i);
    if (ints[i] > 255 || ints[i] < 0) {
      throw new Error('Unexpected byte in binary data.');
    }
  }
  return UUIDjs.fromBytes(ints);
};

// Aliases to support legacy code. Do not use these when writing new code as
// they may be removed in future versions!
UUIDjs.new = function() {
  return this.create(4);
};
UUIDjs.newTS = function() {
  return this.create(1);
};

module.exports = UUIDjs;

},{}],909:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function (require) {

	var makePromise = require('./makePromise');
	var Scheduler = require('./Scheduler');
	var async = require('./env').asap;

	return makePromise({
		scheduler: new Scheduler(async)
	});

});
})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });

},{"./Scheduler":910,"./env":922,"./makePromise":925}],910:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	// Credit to Twisol (https://github.com/Twisol) for suggesting
	// this type of extensible queue + trampoline approach for next-tick conflation.

	/**
	 * Async task scheduler
	 * @param {function} async function to schedule a single async function
	 * @constructor
	 */
	function Scheduler(async) {
		this._async = async;
		this._running = false;

		this._queue = this;
		this._queueLen = 0;
		this._afterQueue = {};
		this._afterQueueLen = 0;

		var self = this;
		this.drain = function() {
			self._drain();
		};
	}

	/**
	 * Enqueue a task
	 * @param {{ run:function }} task
	 */
	Scheduler.prototype.enqueue = function(task) {
		this._queue[this._queueLen++] = task;
		this.run();
	};

	/**
	 * Enqueue a task to run after the main task queue
	 * @param {{ run:function }} task
	 */
	Scheduler.prototype.afterQueue = function(task) {
		this._afterQueue[this._afterQueueLen++] = task;
		this.run();
	};

	Scheduler.prototype.run = function() {
		if (!this._running) {
			this._running = true;
			this._async(this.drain);
		}
	};

	/**
	 * Drain the handler queue entirely, and then the after queue
	 */
	Scheduler.prototype._drain = function() {
		var i = 0;
		for (; i < this._queueLen; ++i) {
			this._queue[i].run();
			this._queue[i] = void 0;
		}

		this._queueLen = 0;
		this._running = false;

		for (i = 0; i < this._afterQueueLen; ++i) {
			this._afterQueue[i].run();
			this._afterQueue[i] = void 0;
		}

		this._afterQueueLen = 0;
	};

	return Scheduler;

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],911:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	/**
	 * Custom error type for promises rejected by promise.timeout
	 * @param {string} message
	 * @constructor
	 */
	function TimeoutError (message) {
		Error.call(this);
		this.message = message;
		this.name = TimeoutError.name;
		if (typeof Error.captureStackTrace === 'function') {
			Error.captureStackTrace(this, TimeoutError);
		}
	}

	TimeoutError.prototype = Object.create(Error.prototype);
	TimeoutError.prototype.constructor = TimeoutError;

	return TimeoutError;
});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));
},{}],912:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	makeApply.tryCatchResolve = tryCatchResolve;

	return makeApply;

	function makeApply(Promise, call) {
		if(arguments.length < 2) {
			call = tryCatchResolve;
		}

		return apply;

		function apply(f, thisArg, args) {
			var p = Promise._defer();
			var l = args.length;
			var params = new Array(l);
			callAndResolve({ f:f, thisArg:thisArg, args:args, params:params, i:l-1, call:call }, p._handler);

			return p;
		}

		function callAndResolve(c, h) {
			if(c.i < 0) {
				return call(c.f, c.thisArg, c.params, h);
			}

			var handler = Promise._handler(c.args[c.i]);
			handler.fold(callAndResolveNext, c, void 0, h);
		}

		function callAndResolveNext(c, x, h) {
			c.params[c.i] = x;
			c.i -= 1;
			callAndResolve(c, h);
		}
	}

	function tryCatchResolve(f, thisArg, args, resolver) {
		try {
			resolver.resolve(f.apply(thisArg, args));
		} catch(e) {
			resolver.reject(e);
		}
	}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));



},{}],913:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function(require) {

	var state = require('../state');
	var applier = require('../apply');

	return function array(Promise) {

		var applyFold = applier(Promise);
		var toPromise = Promise.resolve;
		var all = Promise.all;

		var ar = Array.prototype.reduce;
		var arr = Array.prototype.reduceRight;
		var slice = Array.prototype.slice;

		// Additional array combinators

		Promise.any = any;
		Promise.some = some;
		Promise.settle = settle;

		Promise.map = map;
		Promise.filter = filter;
		Promise.reduce = reduce;
		Promise.reduceRight = reduceRight;

		/**
		 * When this promise fulfills with an array, do
		 * onFulfilled.apply(void 0, array)
		 * @param {function} onFulfilled function to apply
		 * @returns {Promise} promise for the result of applying onFulfilled
		 */
		Promise.prototype.spread = function(onFulfilled) {
			return this.then(all).then(function(array) {
				return onFulfilled.apply(this, array);
			});
		};

		return Promise;

		/**
		 * One-winner competitive race.
		 * Return a promise that will fulfill when one of the promises
		 * in the input array fulfills, or will reject when all promises
		 * have rejected.
		 * @param {array} promises
		 * @returns {Promise} promise for the first fulfilled value
		 */
		function any(promises) {
			var p = Promise._defer();
			var resolver = p._handler;
			var l = promises.length>>>0;

			var pending = l;
			var errors = [];

			for (var h, x, i = 0; i < l; ++i) {
				x = promises[i];
				if(x === void 0 && !(i in promises)) {
					--pending;
					continue;
				}

				h = Promise._handler(x);
				if(h.state() > 0) {
					resolver.become(h);
					Promise._visitRemaining(promises, i, h);
					break;
				} else {
					h.visit(resolver, handleFulfill, handleReject);
				}
			}

			if(pending === 0) {
				resolver.reject(new RangeError('any(): array must not be empty'));
			}

			return p;

			function handleFulfill(x) {
				/*jshint validthis:true*/
				errors = null;
				this.resolve(x); // this === resolver
			}

			function handleReject(e) {
				/*jshint validthis:true*/
				if(this.resolved) { // this === resolver
					return;
				}

				errors.push(e);
				if(--pending === 0) {
					this.reject(errors);
				}
			}
		}

		/**
		 * N-winner competitive race
		 * Return a promise that will fulfill when n input promises have
		 * fulfilled, or will reject when it becomes impossible for n
		 * input promises to fulfill (ie when promises.length - n + 1
		 * have rejected)
		 * @param {array} promises
		 * @param {number} n
		 * @returns {Promise} promise for the earliest n fulfillment values
		 *
		 * @deprecated
		 */
		function some(promises, n) {
			/*jshint maxcomplexity:7*/
			var p = Promise._defer();
			var resolver = p._handler;

			var results = [];
			var errors = [];

			var l = promises.length>>>0;
			var nFulfill = 0;
			var nReject;
			var x, i; // reused in both for() loops

			// First pass: count actual array items
			for(i=0; i<l; ++i) {
				x = promises[i];
				if(x === void 0 && !(i in promises)) {
					continue;
				}
				++nFulfill;
			}

			// Compute actual goals
			n = Math.max(n, 0);
			nReject = (nFulfill - n + 1);
			nFulfill = Math.min(n, nFulfill);

			if(n > nFulfill) {
				resolver.reject(new RangeError('some(): array must contain at least '
				+ n + ' item(s), but had ' + nFulfill));
			} else if(nFulfill === 0) {
				resolver.resolve(results);
			}

			// Second pass: observe each array item, make progress toward goals
			for(i=0; i<l; ++i) {
				x = promises[i];
				if(x === void 0 && !(i in promises)) {
					continue;
				}

				Promise._handler(x).visit(resolver, fulfill, reject, resolver.notify);
			}

			return p;

			function fulfill(x) {
				/*jshint validthis:true*/
				if(this.resolved) { // this === resolver
					return;
				}

				results.push(x);
				if(--nFulfill === 0) {
					errors = null;
					this.resolve(results);
				}
			}

			function reject(e) {
				/*jshint validthis:true*/
				if(this.resolved) { // this === resolver
					return;
				}

				errors.push(e);
				if(--nReject === 0) {
					results = null;
					this.reject(errors);
				}
			}
		}

		/**
		 * Apply f to the value of each promise in a list of promises
		 * and return a new list containing the results.
		 * @param {array} promises
		 * @param {function(x:*, index:Number):*} f mapping function
		 * @returns {Promise}
		 */
		function map(promises, f) {
			return Promise._traverse(f, promises);
		}

		/**
		 * Filter the provided array of promises using the provided predicate.  Input may
		 * contain promises and values
		 * @param {Array} promises array of promises and values
		 * @param {function(x:*, index:Number):boolean} predicate filtering predicate.
		 *  Must return truthy (or promise for truthy) for items to retain.
		 * @returns {Promise} promise that will fulfill with an array containing all items
		 *  for which predicate returned truthy.
		 */
		function filter(promises, predicate) {
			var a = slice.call(promises);
			return Promise._traverse(predicate, a).then(function(keep) {
				return filterSync(a, keep);
			});
		}

		function filterSync(promises, keep) {
			// Safe because we know all promises have fulfilled if we've made it this far
			var l = keep.length;
			var filtered = new Array(l);
			for(var i=0, j=0; i<l; ++i) {
				if(keep[i]) {
					filtered[j++] = Promise._handler(promises[i]).value;
				}
			}
			filtered.length = j;
			return filtered;

		}

		/**
		 * Return a promise that will always fulfill with an array containing
		 * the outcome states of all input promises.  The returned promise
		 * will never reject.
		 * @param {Array} promises
		 * @returns {Promise} promise for array of settled state descriptors
		 */
		function settle(promises) {
			return all(promises.map(settleOne));
		}

		function settleOne(p) {
			var h = Promise._handler(p);
			if(h.state() === 0) {
				return toPromise(p).then(state.fulfilled, state.rejected);
			}

			h._unreport();
			return state.inspect(h);
		}

		/**
		 * Traditional reduce function, similar to `Array.prototype.reduce()`, but
		 * input may contain promises and/or values, and reduceFunc
		 * may return either a value or a promise, *and* initialValue may
		 * be a promise for the starting value.
		 * @param {Array|Promise} promises array or promise for an array of anything,
		 *      may contain a mix of promises and values.
		 * @param {function(accumulated:*, x:*, index:Number):*} f reduce function
		 * @returns {Promise} that will resolve to the final reduced value
		 */
		function reduce(promises, f /*, initialValue */) {
			return arguments.length > 2 ? ar.call(promises, liftCombine(f), arguments[2])
					: ar.call(promises, liftCombine(f));
		}

		/**
		 * Traditional reduce function, similar to `Array.prototype.reduceRight()`, but
		 * input may contain promises and/or values, and reduceFunc
		 * may return either a value or a promise, *and* initialValue may
		 * be a promise for the starting value.
		 * @param {Array|Promise} promises array or promise for an array of anything,
		 *      may contain a mix of promises and values.
		 * @param {function(accumulated:*, x:*, index:Number):*} f reduce function
		 * @returns {Promise} that will resolve to the final reduced value
		 */
		function reduceRight(promises, f /*, initialValue */) {
			return arguments.length > 2 ? arr.call(promises, liftCombine(f), arguments[2])
					: arr.call(promises, liftCombine(f));
		}

		function liftCombine(f) {
			return function(z, x, i) {
				return applyFold(f, void 0, [z,x,i]);
			};
		}
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

},{"../apply":912,"../state":926}],914:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function flow(Promise) {

		var resolve = Promise.resolve;
		var reject = Promise.reject;
		var origCatch = Promise.prototype['catch'];

		/**
		 * Handle the ultimate fulfillment value or rejection reason, and assume
		 * responsibility for all errors.  If an error propagates out of result
		 * or handleFatalError, it will be rethrown to the host, resulting in a
		 * loud stack track on most platforms and a crash on some.
		 * @param {function?} onResult
		 * @param {function?} onError
		 * @returns {undefined}
		 */
		Promise.prototype.done = function(onResult, onError) {
			this._handler.visit(this._handler.receiver, onResult, onError);
		};

		/**
		 * Add Error-type and predicate matching to catch.  Examples:
		 * promise.catch(TypeError, handleTypeError)
		 *   .catch(predicate, handleMatchedErrors)
		 *   .catch(handleRemainingErrors)
		 * @param onRejected
		 * @returns {*}
		 */
		Promise.prototype['catch'] = Promise.prototype.otherwise = function(onRejected) {
			if (arguments.length < 2) {
				return origCatch.call(this, onRejected);
			}

			if(typeof onRejected !== 'function') {
				return this.ensure(rejectInvalidPredicate);
			}

			return origCatch.call(this, createCatchFilter(arguments[1], onRejected));
		};

		/**
		 * Wraps the provided catch handler, so that it will only be called
		 * if the predicate evaluates truthy
		 * @param {?function} handler
		 * @param {function} predicate
		 * @returns {function} conditional catch handler
		 */
		function createCatchFilter(handler, predicate) {
			return function(e) {
				return evaluatePredicate(e, predicate)
					? handler.call(this, e)
					: reject(e);
			};
		}

		/**
		 * Ensures that onFulfilledOrRejected will be called regardless of whether
		 * this promise is fulfilled or rejected.  onFulfilledOrRejected WILL NOT
		 * receive the promises' value or reason.  Any returned value will be disregarded.
		 * onFulfilledOrRejected may throw or return a rejected promise to signal
		 * an additional error.
		 * @param {function} handler handler to be called regardless of
		 *  fulfillment or rejection
		 * @returns {Promise}
		 */
		Promise.prototype['finally'] = Promise.prototype.ensure = function(handler) {
			if(typeof handler !== 'function') {
				return this;
			}

			return this.then(function(x) {
				return runSideEffect(handler, this, identity, x);
			}, function(e) {
				return runSideEffect(handler, this, reject, e);
			});
		};

		function runSideEffect (handler, thisArg, propagate, value) {
			var result = handler.call(thisArg);
			return maybeThenable(result)
				? propagateValue(result, propagate, value)
				: propagate(value);
		}

		function propagateValue (result, propagate, x) {
			return resolve(result).then(function () {
				return propagate(x);
			});
		}

		/**
		 * Recover from a failure by returning a defaultValue.  If defaultValue
		 * is a promise, it's fulfillment value will be used.  If defaultValue is
		 * a promise that rejects, the returned promise will reject with the
		 * same reason.
		 * @param {*} defaultValue
		 * @returns {Promise} new promise
		 */
		Promise.prototype['else'] = Promise.prototype.orElse = function(defaultValue) {
			return this.then(void 0, function() {
				return defaultValue;
			});
		};

		/**
		 * Shortcut for .then(function() { return value; })
		 * @param  {*} value
		 * @return {Promise} a promise that:
		 *  - is fulfilled if value is not a promise, or
		 *  - if value is a promise, will fulfill with its value, or reject
		 *    with its reason.
		 */
		Promise.prototype['yield'] = function(value) {
			return this.then(function() {
				return value;
			});
		};

		/**
		 * Runs a side effect when this promise fulfills, without changing the
		 * fulfillment value.
		 * @param {function} onFulfilledSideEffect
		 * @returns {Promise}
		 */
		Promise.prototype.tap = function(onFulfilledSideEffect) {
			return this.then(onFulfilledSideEffect)['yield'](this);
		};

		return Promise;
	};

	function rejectInvalidPredicate() {
		throw new TypeError('catch predicate must be a function');
	}

	function evaluatePredicate(e, predicate) {
		return isError(predicate) ? e instanceof predicate : predicate(e);
	}

	function isError(predicate) {
		return predicate === Error
			|| (predicate != null && predicate.prototype instanceof Error);
	}

	function maybeThenable(x) {
		return (typeof x === 'object' || typeof x === 'function') && x !== null;
	}

	function identity(x) {
		return x;
	}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],915:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */
/** @author Jeff Escalante */

(function(define) { 'use strict';
define(function() {

	return function fold(Promise) {

		Promise.prototype.fold = function(f, z) {
			var promise = this._beget();

			this._handler.fold(function(z, x, to) {
				Promise._handler(z).fold(function(x, z, to) {
					to.resolve(f.call(this, z, x));
				}, x, this, to);
			}, z, promise._handler.receiver, promise._handler);

			return promise;
		};

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],916:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function(require) {

	var inspect = require('../state').inspect;

	return function inspection(Promise) {

		Promise.prototype.inspect = function() {
			return inspect(Promise._handler(this));
		};

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

},{"../state":926}],917:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function generate(Promise) {

		var resolve = Promise.resolve;

		Promise.iterate = iterate;
		Promise.unfold = unfold;

		return Promise;

		/**
		 * @deprecated Use github.com/cujojs/most streams and most.iterate
		 * Generate a (potentially infinite) stream of promised values:
		 * x, f(x), f(f(x)), etc. until condition(x) returns true
		 * @param {function} f function to generate a new x from the previous x
		 * @param {function} condition function that, given the current x, returns
		 *  truthy when the iterate should stop
		 * @param {function} handler function to handle the value produced by f
		 * @param {*|Promise} x starting value, may be a promise
		 * @return {Promise} the result of the last call to f before
		 *  condition returns true
		 */
		function iterate(f, condition, handler, x) {
			return unfold(function(x) {
				return [x, f(x)];
			}, condition, handler, x);
		}

		/**
		 * @deprecated Use github.com/cujojs/most streams and most.unfold
		 * Generate a (potentially infinite) stream of promised values
		 * by applying handler(generator(seed)) iteratively until
		 * condition(seed) returns true.
		 * @param {function} unspool function that generates a [value, newSeed]
		 *  given a seed.
		 * @param {function} condition function that, given the current seed, returns
		 *  truthy when the unfold should stop
		 * @param {function} handler function to handle the value produced by unspool
		 * @param x {*|Promise} starting value, may be a promise
		 * @return {Promise} the result of the last value produced by unspool before
		 *  condition returns true
		 */
		function unfold(unspool, condition, handler, x) {
			return resolve(x).then(function(seed) {
				return resolve(condition(seed)).then(function(done) {
					return done ? seed : resolve(unspool(seed)).spread(next);
				});
			});

			function next(item, newSeed) {
				return resolve(handler(item)).then(function() {
					return unfold(unspool, condition, handler, newSeed);
				});
			}
		}
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],918:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function progress(Promise) {

		/**
		 * @deprecated
		 * Register a progress handler for this promise
		 * @param {function} onProgress
		 * @returns {Promise}
		 */
		Promise.prototype.progress = function(onProgress) {
			return this.then(void 0, void 0, onProgress);
		};

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],919:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function(require) {

	var env = require('../env');
	var TimeoutError = require('../TimeoutError');

	function setTimeout(f, ms, x, y) {
		return env.setTimer(function() {
			f(x, y, ms);
		}, ms);
	}

	return function timed(Promise) {
		/**
		 * Return a new promise whose fulfillment value is revealed only
		 * after ms milliseconds
		 * @param {number} ms milliseconds
		 * @returns {Promise}
		 */
		Promise.prototype.delay = function(ms) {
			var p = this._beget();
			this._handler.fold(handleDelay, ms, void 0, p._handler);
			return p;
		};

		function handleDelay(ms, x, h) {
			setTimeout(resolveDelay, ms, x, h);
		}

		function resolveDelay(x, h) {
			h.resolve(x);
		}

		/**
		 * Return a new promise that rejects after ms milliseconds unless
		 * this promise fulfills earlier, in which case the returned promise
		 * fulfills with the same value.
		 * @param {number} ms milliseconds
		 * @param {Error|*=} reason optional rejection reason to use, defaults
		 *   to a TimeoutError if not provided
		 * @returns {Promise}
		 */
		Promise.prototype.timeout = function(ms, reason) {
			var p = this._beget();
			var h = p._handler;

			var t = setTimeout(onTimeout, ms, reason, p._handler);

			this._handler.visit(h,
				function onFulfill(x) {
					env.clearTimer(t);
					this.resolve(x); // this = h
				},
				function onReject(x) {
					env.clearTimer(t);
					this.reject(x); // this = h
				},
				h.notify);

			return p;
		};

		function onTimeout(reason, h, ms) {
			var e = typeof reason === 'undefined'
				? new TimeoutError('timed out after ' + ms + 'ms')
				: reason;
			h.reject(e);
		}

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

},{"../TimeoutError":911,"../env":922}],920:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function(require) {

	var setTimer = require('../env').setTimer;
	var format = require('../format');

	return function unhandledRejection(Promise) {

		var logError = noop;
		var logInfo = noop;
		var localConsole;

		if(typeof console !== 'undefined') {
			// Alias console to prevent things like uglify's drop_console option from
			// removing console.log/error. Unhandled rejections fall into the same
			// category as uncaught exceptions, and build tools shouldn't silence them.
			localConsole = console;
			logError = typeof localConsole.error !== 'undefined'
				? function (e) { localConsole.error(e); }
				: function (e) { localConsole.log(e); };

			logInfo = typeof localConsole.info !== 'undefined'
				? function (e) { localConsole.info(e); }
				: function (e) { localConsole.log(e); };
		}

		Promise.onPotentiallyUnhandledRejection = function(rejection) {
			enqueue(report, rejection);
		};

		Promise.onPotentiallyUnhandledRejectionHandled = function(rejection) {
			enqueue(unreport, rejection);
		};

		Promise.onFatalRejection = function(rejection) {
			enqueue(throwit, rejection.value);
		};

		var tasks = [];
		var reported = [];
		var running = null;

		function report(r) {
			if(!r.handled) {
				reported.push(r);
				logError('Potentially unhandled rejection [' + r.id + '] ' + format.formatError(r.value));
			}
		}

		function unreport(r) {
			var i = reported.indexOf(r);
			if(i >= 0) {
				reported.splice(i, 1);
				logInfo('Handled previous rejection [' + r.id + '] ' + format.formatObject(r.value));
			}
		}

		function enqueue(f, x) {
			tasks.push(f, x);
			if(running === null) {
				running = setTimer(flush, 0);
			}
		}

		function flush() {
			running = null;
			while(tasks.length > 0) {
				tasks.shift()(tasks.shift());
			}
		}

		return Promise;
	};

	function throwit(e) {
		throw e;
	}

	function noop() {}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

},{"../env":922,"../format":923}],921:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function addWith(Promise) {
		/**
		 * Returns a promise whose handlers will be called with `this` set to
		 * the supplied receiver.  Subsequent promises derived from the
		 * returned promise will also have their handlers called with receiver
		 * as `this`. Calling `with` with undefined or no arguments will return
		 * a promise whose handlers will again be called in the usual Promises/A+
		 * way (no `this`) thus safely undoing any previous `with` in the
		 * promise chain.
		 *
		 * WARNING: Promises returned from `with`/`withThis` are NOT Promises/A+
		 * compliant, specifically violating 2.2.5 (http://promisesaplus.com/#point-41)
		 *
		 * @param {object} receiver `this` value for all handlers attached to
		 *  the returned promise.
		 * @returns {Promise}
		 */
		Promise.prototype['with'] = Promise.prototype.withThis = function(receiver) {
			var p = this._beget();
			var child = p._handler;
			child.receiver = receiver;
			this._handler.chain(child, receiver);
			return p;
		};

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));


},{}],922:[function(require,module,exports){
(function (process){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

/*global process,document,setTimeout,clearTimeout,MutationObserver,WebKitMutationObserver*/
(function(define) { 'use strict';
define(function(require) {
	/*jshint maxcomplexity:6*/

	// Sniff "best" async scheduling option
	// Prefer process.nextTick or MutationObserver, then check for
	// setTimeout, and finally vertx, since its the only env that doesn't
	// have setTimeout

	var MutationObs;
	var capturedSetTimeout = typeof setTimeout !== 'undefined' && setTimeout;

	// Default env
	var setTimer = function(f, ms) { return setTimeout(f, ms); };
	var clearTimer = function(t) { return clearTimeout(t); };
	var asap = function (f) { return capturedSetTimeout(f, 0); };

	// Detect specific env
	if (isNode()) { // Node
		asap = function (f) { return process.nextTick(f); };

	} else if (MutationObs = hasMutationObserver()) { // Modern browser
		asap = initMutationObserver(MutationObs);

	} else if (!capturedSetTimeout) { // vert.x
		var vertxRequire = require;
		var vertx = vertxRequire('vertx');
		setTimer = function (f, ms) { return vertx.setTimer(ms, f); };
		clearTimer = vertx.cancelTimer;
		asap = vertx.runOnLoop || vertx.runOnContext;
	}

	return {
		setTimer: setTimer,
		clearTimer: clearTimer,
		asap: asap
	};

	function isNode () {
		return typeof process !== 'undefined' &&
			Object.prototype.toString.call(process) === '[object process]';
	}

	function hasMutationObserver () {
		return (typeof MutationObserver === 'function' && MutationObserver) ||
			(typeof WebKitMutationObserver === 'function' && WebKitMutationObserver);
	}

	function initMutationObserver(MutationObserver) {
		var scheduled;
		var node = document.createTextNode('');
		var o = new MutationObserver(run);
		o.observe(node, { characterData: true });

		function run() {
			var f = scheduled;
			scheduled = void 0;
			f();
		}

		var i = 0;
		return function (f) {
			scheduled = f;
			node.data = (i ^= 1);
		};
	}
});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

}).call(this,require('_process'))
},{"_process":702}],923:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return {
		formatError: formatError,
		formatObject: formatObject,
		tryStringify: tryStringify
	};

	/**
	 * Format an error into a string.  If e is an Error and has a stack property,
	 * it's returned.  Otherwise, e is formatted using formatObject, with a
	 * warning added about e not being a proper Error.
	 * @param {*} e
	 * @returns {String} formatted string, suitable for output to developers
	 */
	function formatError(e) {
		var s = typeof e === 'object' && e !== null && (e.stack || e.message) ? e.stack || e.message : formatObject(e);
		return e instanceof Error ? s : s + ' (WARNING: non-Error used)';
	}

	/**
	 * Format an object, detecting "plain" objects and running them through
	 * JSON.stringify if possible.
	 * @param {Object} o
	 * @returns {string}
	 */
	function formatObject(o) {
		var s = String(o);
		if(s === '[object Object]' && typeof JSON !== 'undefined') {
			s = tryStringify(o, s);
		}
		return s;
	}

	/**
	 * Try to return the result of JSON.stringify(x).  If that fails, return
	 * defaultValue
	 * @param {*} x
	 * @param {*} defaultValue
	 * @returns {String|*} JSON.stringify(x) or defaultValue
	 */
	function tryStringify(x, defaultValue) {
		try {
			return JSON.stringify(x);
		} catch(e) {
			return defaultValue;
		}
	}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],924:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function liftAll(liftOne, combine, dst, src) {
		if(typeof combine === 'undefined') {
			combine = defaultCombine;
		}

		return Object.keys(src).reduce(function(dst, key) {
			var f = src[key];
			return typeof f === 'function' ? combine(dst, liftOne(f), key) : dst;
		}, typeof dst === 'undefined' ? defaultDst(src) : dst);
	};

	function defaultCombine(o, f, k) {
		o[k] = f;
		return o;
	}

	function defaultDst(src) {
		return typeof src === 'function' ? src.bind() : Object.create(src);
	}
});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],925:[function(require,module,exports){
(function (process){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function makePromise(environment) {

		var tasks = environment.scheduler;
		var emitRejection = initEmitRejection();

		var objectCreate = Object.create ||
			function(proto) {
				function Child() {}
				Child.prototype = proto;
				return new Child();
			};

		/**
		 * Create a promise whose fate is determined by resolver
		 * @constructor
		 * @returns {Promise} promise
		 * @name Promise
		 */
		function Promise(resolver, handler) {
			this._handler = resolver === Handler ? handler : init(resolver);
		}

		/**
		 * Run the supplied resolver
		 * @param resolver
		 * @returns {Pending}
		 */
		function init(resolver) {
			var handler = new Pending();

			try {
				resolver(promiseResolve, promiseReject, promiseNotify);
			} catch (e) {
				promiseReject(e);
			}

			return handler;

			/**
			 * Transition from pre-resolution state to post-resolution state, notifying
			 * all listeners of the ultimate fulfillment or rejection
			 * @param {*} x resolution value
			 */
			function promiseResolve (x) {
				handler.resolve(x);
			}
			/**
			 * Reject this promise with reason, which will be used verbatim
			 * @param {Error|*} reason rejection reason, strongly suggested
			 *   to be an Error type
			 */
			function promiseReject (reason) {
				handler.reject(reason);
			}

			/**
			 * @deprecated
			 * Issue a progress event, notifying all progress listeners
			 * @param {*} x progress event payload to pass to all listeners
			 */
			function promiseNotify (x) {
				handler.notify(x);
			}
		}

		// Creation

		Promise.resolve = resolve;
		Promise.reject = reject;
		Promise.never = never;

		Promise._defer = defer;
		Promise._handler = getHandler;

		/**
		 * Returns a trusted promise. If x is already a trusted promise, it is
		 * returned, otherwise returns a new trusted Promise which follows x.
		 * @param  {*} x
		 * @return {Promise} promise
		 */
		function resolve(x) {
			return isPromise(x) ? x
				: new Promise(Handler, new Async(getHandler(x)));
		}

		/**
		 * Return a reject promise with x as its reason (x is used verbatim)
		 * @param {*} x
		 * @returns {Promise} rejected promise
		 */
		function reject(x) {
			return new Promise(Handler, new Async(new Rejected(x)));
		}

		/**
		 * Return a promise that remains pending forever
		 * @returns {Promise} forever-pending promise.
		 */
		function never() {
			return foreverPendingPromise; // Should be frozen
		}

		/**
		 * Creates an internal {promise, resolver} pair
		 * @private
		 * @returns {Promise}
		 */
		function defer() {
			return new Promise(Handler, new Pending());
		}

		// Transformation and flow control

		/**
		 * Transform this promise's fulfillment value, returning a new Promise
		 * for the transformed result.  If the promise cannot be fulfilled, onRejected
		 * is called with the reason.  onProgress *may* be called with updates toward
		 * this promise's fulfillment.
		 * @param {function=} onFulfilled fulfillment handler
		 * @param {function=} onRejected rejection handler
		 * @param {function=} onProgress @deprecated progress handler
		 * @return {Promise} new promise
		 */
		Promise.prototype.then = function(onFulfilled, onRejected, onProgress) {
			var parent = this._handler;
			var state = parent.join().state();

			if ((typeof onFulfilled !== 'function' && state > 0) ||
				(typeof onRejected !== 'function' && state < 0)) {
				// Short circuit: value will not change, simply share handler
				return new this.constructor(Handler, parent);
			}

			var p = this._beget();
			var child = p._handler;

			parent.chain(child, parent.receiver, onFulfilled, onRejected, onProgress);

			return p;
		};

		/**
		 * If this promise cannot be fulfilled due to an error, call onRejected to
		 * handle the error. Shortcut for .then(undefined, onRejected)
		 * @param {function?} onRejected
		 * @return {Promise}
		 */
		Promise.prototype['catch'] = function(onRejected) {
			return this.then(void 0, onRejected);
		};

		/**
		 * Creates a new, pending promise of the same type as this promise
		 * @private
		 * @returns {Promise}
		 */
		Promise.prototype._beget = function() {
			return begetFrom(this._handler, this.constructor);
		};

		function begetFrom(parent, Promise) {
			var child = new Pending(parent.receiver, parent.join().context);
			return new Promise(Handler, child);
		}

		// Array combinators

		Promise.all = all;
		Promise.race = race;
		Promise._traverse = traverse;

		/**
		 * Return a promise that will fulfill when all promises in the
		 * input array have fulfilled, or will reject when one of the
		 * promises rejects.
		 * @param {array} promises array of promises
		 * @returns {Promise} promise for array of fulfillment values
		 */
		function all(promises) {
			return traverseWith(snd, null, promises);
		}

		/**
		 * Array<Promise<X>> -> Promise<Array<f(X)>>
		 * @private
		 * @param {function} f function to apply to each promise's value
		 * @param {Array} promises array of promises
		 * @returns {Promise} promise for transformed values
		 */
		function traverse(f, promises) {
			return traverseWith(tryCatch2, f, promises);
		}

		function traverseWith(tryMap, f, promises) {
			var handler = typeof f === 'function' ? mapAt : settleAt;

			var resolver = new Pending();
			var pending = promises.length >>> 0;
			var results = new Array(pending);

			for (var i = 0, x; i < promises.length && !resolver.resolved; ++i) {
				x = promises[i];

				if (x === void 0 && !(i in promises)) {
					--pending;
					continue;
				}

				traverseAt(promises, handler, i, x, resolver);
			}

			if(pending === 0) {
				resolver.become(new Fulfilled(results));
			}

			return new Promise(Handler, resolver);

			function mapAt(i, x, resolver) {
				if(!resolver.resolved) {
					traverseAt(promises, settleAt, i, tryMap(f, x, i), resolver);
				}
			}

			function settleAt(i, x, resolver) {
				results[i] = x;
				if(--pending === 0) {
					resolver.become(new Fulfilled(results));
				}
			}
		}

		function traverseAt(promises, handler, i, x, resolver) {
			if (maybeThenable(x)) {
				var h = getHandlerMaybeThenable(x);
				var s = h.state();

				if (s === 0) {
					h.fold(handler, i, void 0, resolver);
				} else if (s > 0) {
					handler(i, h.value, resolver);
				} else {
					resolver.become(h);
					visitRemaining(promises, i+1, h);
				}
			} else {
				handler(i, x, resolver);
			}
		}

		Promise._visitRemaining = visitRemaining;
		function visitRemaining(promises, start, handler) {
			for(var i=start; i<promises.length; ++i) {
				markAsHandled(getHandler(promises[i]), handler);
			}
		}

		function markAsHandled(h, handler) {
			if(h === handler) {
				return;
			}

			var s = h.state();
			if(s === 0) {
				h.visit(h, void 0, h._unreport);
			} else if(s < 0) {
				h._unreport();
			}
		}

		/**
		 * Fulfill-reject competitive race. Return a promise that will settle
		 * to the same state as the earliest input promise to settle.
		 *
		 * WARNING: The ES6 Promise spec requires that race()ing an empty array
		 * must return a promise that is pending forever.  This implementation
		 * returns a singleton forever-pending promise, the same singleton that is
		 * returned by Promise.never(), thus can be checked with ===
		 *
		 * @param {array} promises array of promises to race
		 * @returns {Promise} if input is non-empty, a promise that will settle
		 * to the same outcome as the earliest input promise to settle. if empty
		 * is empty, returns a promise that will never settle.
		 */
		function race(promises) {
			if(typeof promises !== 'object' || promises === null) {
				return reject(new TypeError('non-iterable passed to race()'));
			}

			// Sigh, race([]) is untestable unless we return *something*
			// that is recognizable without calling .then() on it.
			return promises.length === 0 ? never()
				 : promises.length === 1 ? resolve(promises[0])
				 : runRace(promises);
		}

		function runRace(promises) {
			var resolver = new Pending();
			var i, x, h;
			for(i=0; i<promises.length; ++i) {
				x = promises[i];
				if (x === void 0 && !(i in promises)) {
					continue;
				}

				h = getHandler(x);
				if(h.state() !== 0) {
					resolver.become(h);
					visitRemaining(promises, i+1, h);
					break;
				} else {
					h.visit(resolver, resolver.resolve, resolver.reject);
				}
			}
			return new Promise(Handler, resolver);
		}

		// Promise internals
		// Below this, everything is @private

		/**
		 * Get an appropriate handler for x, without checking for cycles
		 * @param {*} x
		 * @returns {object} handler
		 */
		function getHandler(x) {
			if(isPromise(x)) {
				return x._handler.join();
			}
			return maybeThenable(x) ? getHandlerUntrusted(x) : new Fulfilled(x);
		}

		/**
		 * Get a handler for thenable x.
		 * NOTE: You must only call this if maybeThenable(x) == true
		 * @param {object|function|Promise} x
		 * @returns {object} handler
		 */
		function getHandlerMaybeThenable(x) {
			return isPromise(x) ? x._handler.join() : getHandlerUntrusted(x);
		}

		/**
		 * Get a handler for potentially untrusted thenable x
		 * @param {*} x
		 * @returns {object} handler
		 */
		function getHandlerUntrusted(x) {
			try {
				var untrustedThen = x.then;
				return typeof untrustedThen === 'function'
					? new Thenable(untrustedThen, x)
					: new Fulfilled(x);
			} catch(e) {
				return new Rejected(e);
			}
		}

		/**
		 * Handler for a promise that is pending forever
		 * @constructor
		 */
		function Handler() {}

		Handler.prototype.when
			= Handler.prototype.become
			= Handler.prototype.notify // deprecated
			= Handler.prototype.fail
			= Handler.prototype._unreport
			= Handler.prototype._report
			= noop;

		Handler.prototype._state = 0;

		Handler.prototype.state = function() {
			return this._state;
		};

		/**
		 * Recursively collapse handler chain to find the handler
		 * nearest to the fully resolved value.
		 * @returns {object} handler nearest the fully resolved value
		 */
		Handler.prototype.join = function() {
			var h = this;
			while(h.handler !== void 0) {
				h = h.handler;
			}
			return h;
		};

		Handler.prototype.chain = function(to, receiver, fulfilled, rejected, progress) {
			this.when({
				resolver: to,
				receiver: receiver,
				fulfilled: fulfilled,
				rejected: rejected,
				progress: progress
			});
		};

		Handler.prototype.visit = function(receiver, fulfilled, rejected, progress) {
			this.chain(failIfRejected, receiver, fulfilled, rejected, progress);
		};

		Handler.prototype.fold = function(f, z, c, to) {
			this.when(new Fold(f, z, c, to));
		};

		/**
		 * Handler that invokes fail() on any handler it becomes
		 * @constructor
		 */
		function FailIfRejected() {}

		inherit(Handler, FailIfRejected);

		FailIfRejected.prototype.become = function(h) {
			h.fail();
		};

		var failIfRejected = new FailIfRejected();

		/**
		 * Handler that manages a queue of consumers waiting on a pending promise
		 * @constructor
		 */
		function Pending(receiver, inheritedContext) {
			Promise.createContext(this, inheritedContext);

			this.consumers = void 0;
			this.receiver = receiver;
			this.handler = void 0;
			this.resolved = false;
		}

		inherit(Handler, Pending);

		Pending.prototype._state = 0;

		Pending.prototype.resolve = function(x) {
			this.become(getHandler(x));
		};

		Pending.prototype.reject = function(x) {
			if(this.resolved) {
				return;
			}

			this.become(new Rejected(x));
		};

		Pending.prototype.join = function() {
			if (!this.resolved) {
				return this;
			}

			var h = this;

			while (h.handler !== void 0) {
				h = h.handler;
				if (h === this) {
					return this.handler = cycle();
				}
			}

			return h;
		};

		Pending.prototype.run = function() {
			var q = this.consumers;
			var handler = this.handler;
			this.handler = this.handler.join();
			this.consumers = void 0;

			for (var i = 0; i < q.length; ++i) {
				handler.when(q[i]);
			}
		};

		Pending.prototype.become = function(handler) {
			if(this.resolved) {
				return;
			}

			this.resolved = true;
			this.handler = handler;
			if(this.consumers !== void 0) {
				tasks.enqueue(this);
			}

			if(this.context !== void 0) {
				handler._report(this.context);
			}
		};

		Pending.prototype.when = function(continuation) {
			if(this.resolved) {
				tasks.enqueue(new ContinuationTask(continuation, this.handler));
			} else {
				if(this.consumers === void 0) {
					this.consumers = [continuation];
				} else {
					this.consumers.push(continuation);
				}
			}
		};

		/**
		 * @deprecated
		 */
		Pending.prototype.notify = function(x) {
			if(!this.resolved) {
				tasks.enqueue(new ProgressTask(x, this));
			}
		};

		Pending.prototype.fail = function(context) {
			var c = typeof context === 'undefined' ? this.context : context;
			this.resolved && this.handler.join().fail(c);
		};

		Pending.prototype._report = function(context) {
			this.resolved && this.handler.join()._report(context);
		};

		Pending.prototype._unreport = function() {
			this.resolved && this.handler.join()._unreport();
		};

		/**
		 * Wrap another handler and force it into a future stack
		 * @param {object} handler
		 * @constructor
		 */
		function Async(handler) {
			this.handler = handler;
		}

		inherit(Handler, Async);

		Async.prototype.when = function(continuation) {
			tasks.enqueue(new ContinuationTask(continuation, this));
		};

		Async.prototype._report = function(context) {
			this.join()._report(context);
		};

		Async.prototype._unreport = function() {
			this.join()._unreport();
		};

		/**
		 * Handler that wraps an untrusted thenable and assimilates it in a future stack
		 * @param {function} then
		 * @param {{then: function}} thenable
		 * @constructor
		 */
		function Thenable(then, thenable) {
			Pending.call(this);
			tasks.enqueue(new AssimilateTask(then, thenable, this));
		}

		inherit(Pending, Thenable);

		/**
		 * Handler for a fulfilled promise
		 * @param {*} x fulfillment value
		 * @constructor
		 */
		function Fulfilled(x) {
			Promise.createContext(this);
			this.value = x;
		}

		inherit(Handler, Fulfilled);

		Fulfilled.prototype._state = 1;

		Fulfilled.prototype.fold = function(f, z, c, to) {
			runContinuation3(f, z, this, c, to);
		};

		Fulfilled.prototype.when = function(cont) {
			runContinuation1(cont.fulfilled, this, cont.receiver, cont.resolver);
		};

		var errorId = 0;

		/**
		 * Handler for a rejected promise
		 * @param {*} x rejection reason
		 * @constructor
		 */
		function Rejected(x) {
			Promise.createContext(this);

			this.id = ++errorId;
			this.value = x;
			this.handled = false;
			this.reported = false;

			this._report();
		}

		inherit(Handler, Rejected);

		Rejected.prototype._state = -1;

		Rejected.prototype.fold = function(f, z, c, to) {
			to.become(this);
		};

		Rejected.prototype.when = function(cont) {
			if(typeof cont.rejected === 'function') {
				this._unreport();
			}
			runContinuation1(cont.rejected, this, cont.receiver, cont.resolver);
		};

		Rejected.prototype._report = function(context) {
			tasks.afterQueue(new ReportTask(this, context));
		};

		Rejected.prototype._unreport = function() {
			if(this.handled) {
				return;
			}
			this.handled = true;
			tasks.afterQueue(new UnreportTask(this));
		};

		Rejected.prototype.fail = function(context) {
			this.reported = true;
			emitRejection('unhandledRejection', this);
			Promise.onFatalRejection(this, context === void 0 ? this.context : context);
		};

		function ReportTask(rejection, context) {
			this.rejection = rejection;
			this.context = context;
		}

		ReportTask.prototype.run = function() {
			if(!this.rejection.handled && !this.rejection.reported) {
				this.rejection.reported = true;
				emitRejection('unhandledRejection', this.rejection) ||
					Promise.onPotentiallyUnhandledRejection(this.rejection, this.context);
			}
		};

		function UnreportTask(rejection) {
			this.rejection = rejection;
		}

		UnreportTask.prototype.run = function() {
			if(this.rejection.reported) {
				emitRejection('rejectionHandled', this.rejection) ||
					Promise.onPotentiallyUnhandledRejectionHandled(this.rejection);
			}
		};

		// Unhandled rejection hooks
		// By default, everything is a noop

		Promise.createContext
			= Promise.enterContext
			= Promise.exitContext
			= Promise.onPotentiallyUnhandledRejection
			= Promise.onPotentiallyUnhandledRejectionHandled
			= Promise.onFatalRejection
			= noop;

		// Errors and singletons

		var foreverPendingHandler = new Handler();
		var foreverPendingPromise = new Promise(Handler, foreverPendingHandler);

		function cycle() {
			return new Rejected(new TypeError('Promise cycle'));
		}

		// Task runners

		/**
		 * Run a single consumer
		 * @constructor
		 */
		function ContinuationTask(continuation, handler) {
			this.continuation = continuation;
			this.handler = handler;
		}

		ContinuationTask.prototype.run = function() {
			this.handler.join().when(this.continuation);
		};

		/**
		 * Run a queue of progress handlers
		 * @constructor
		 */
		function ProgressTask(value, handler) {
			this.handler = handler;
			this.value = value;
		}

		ProgressTask.prototype.run = function() {
			var q = this.handler.consumers;
			if(q === void 0) {
				return;
			}

			for (var c, i = 0; i < q.length; ++i) {
				c = q[i];
				runNotify(c.progress, this.value, this.handler, c.receiver, c.resolver);
			}
		};

		/**
		 * Assimilate a thenable, sending it's value to resolver
		 * @param {function} then
		 * @param {object|function} thenable
		 * @param {object} resolver
		 * @constructor
		 */
		function AssimilateTask(then, thenable, resolver) {
			this._then = then;
			this.thenable = thenable;
			this.resolver = resolver;
		}

		AssimilateTask.prototype.run = function() {
			var h = this.resolver;
			tryAssimilate(this._then, this.thenable, _resolve, _reject, _notify);

			function _resolve(x) { h.resolve(x); }
			function _reject(x)  { h.reject(x); }
			function _notify(x)  { h.notify(x); }
		};

		function tryAssimilate(then, thenable, resolve, reject, notify) {
			try {
				then.call(thenable, resolve, reject, notify);
			} catch (e) {
				reject(e);
			}
		}

		/**
		 * Fold a handler value with z
		 * @constructor
		 */
		function Fold(f, z, c, to) {
			this.f = f; this.z = z; this.c = c; this.to = to;
			this.resolver = failIfRejected;
			this.receiver = this;
		}

		Fold.prototype.fulfilled = function(x) {
			this.f.call(this.c, this.z, x, this.to);
		};

		Fold.prototype.rejected = function(x) {
			this.to.reject(x);
		};

		Fold.prototype.progress = function(x) {
			this.to.notify(x);
		};

		// Other helpers

		/**
		 * @param {*} x
		 * @returns {boolean} true iff x is a trusted Promise
		 */
		function isPromise(x) {
			return x instanceof Promise;
		}

		/**
		 * Test just enough to rule out primitives, in order to take faster
		 * paths in some code
		 * @param {*} x
		 * @returns {boolean} false iff x is guaranteed *not* to be a thenable
		 */
		function maybeThenable(x) {
			return (typeof x === 'object' || typeof x === 'function') && x !== null;
		}

		function runContinuation1(f, h, receiver, next) {
			if(typeof f !== 'function') {
				return next.become(h);
			}

			Promise.enterContext(h);
			tryCatchReject(f, h.value, receiver, next);
			Promise.exitContext();
		}

		function runContinuation3(f, x, h, receiver, next) {
			if(typeof f !== 'function') {
				return next.become(h);
			}

			Promise.enterContext(h);
			tryCatchReject3(f, x, h.value, receiver, next);
			Promise.exitContext();
		}

		/**
		 * @deprecated
		 */
		function runNotify(f, x, h, receiver, next) {
			if(typeof f !== 'function') {
				return next.notify(x);
			}

			Promise.enterContext(h);
			tryCatchReturn(f, x, receiver, next);
			Promise.exitContext();
		}

		function tryCatch2(f, a, b) {
			try {
				return f(a, b);
			} catch(e) {
				return reject(e);
			}
		}

		/**
		 * Return f.call(thisArg, x), or if it throws return a rejected promise for
		 * the thrown exception
		 */
		function tryCatchReject(f, x, thisArg, next) {
			try {
				next.become(getHandler(f.call(thisArg, x)));
			} catch(e) {
				next.become(new Rejected(e));
			}
		}

		/**
		 * Same as above, but includes the extra argument parameter.
		 */
		function tryCatchReject3(f, x, y, thisArg, next) {
			try {
				f.call(thisArg, x, y, next);
			} catch(e) {
				next.become(new Rejected(e));
			}
		}

		/**
		 * @deprecated
		 * Return f.call(thisArg, x), or if it throws, *return* the exception
		 */
		function tryCatchReturn(f, x, thisArg, next) {
			try {
				next.notify(f.call(thisArg, x));
			} catch(e) {
				next.notify(e);
			}
		}

		function inherit(Parent, Child) {
			Child.prototype = objectCreate(Parent.prototype);
			Child.prototype.constructor = Child;
		}

		function snd(x, y) {
			return y;
		}

		function noop() {}

		function initEmitRejection() {
			/*global process, self, CustomEvent*/
			if(typeof process !== 'undefined' && process !== null
				&& typeof process.emit === 'function') {
				// Returning falsy here means to call the default
				// onPotentiallyUnhandledRejection API.  This is safe even in
				// browserify since process.emit always returns falsy in browserify:
				// https://github.com/defunctzombie/node-process/blob/master/browser.js#L40-L46
				return function(type, rejection) {
					return type === 'unhandledRejection'
						? process.emit(type, rejection.value, rejection)
						: process.emit(type, rejection);
				};
			} else if(typeof self !== 'undefined' && typeof CustomEvent === 'function') {
				return (function(noop, self, CustomEvent) {
					var hasCustomEvent = false;
					try {
						var ev = new CustomEvent('unhandledRejection');
						hasCustomEvent = ev instanceof CustomEvent;
					} catch (e) {}

					return !hasCustomEvent ? noop : function(type, rejection) {
						var ev = new CustomEvent(type, {
							detail: {
								reason: rejection.value,
								key: rejection
							},
							bubbles: false,
							cancelable: true
						});

						return !self.dispatchEvent(ev);
					};
				}(noop, self, CustomEvent));
			}

			return noop;
		}

		return Promise;
	};
});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

}).call(this,require('_process'))
},{"_process":702}],926:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return {
		pending: toPendingState,
		fulfilled: toFulfilledState,
		rejected: toRejectedState,
		inspect: inspect
	};

	function toPendingState() {
		return { state: 'pending' };
	}

	function toRejectedState(e) {
		return { state: 'rejected', reason: e };
	}

	function toFulfilledState(x) {
		return { state: 'fulfilled', value: x };
	}

	function inspect(handler) {
		var state = handler.state();
		return state === 0 ? toPendingState()
			 : state > 0   ? toFulfilledState(handler.value)
			               : toRejectedState(handler.value);
	}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],927:[function(require,module,exports){
/** @license MIT License (c) copyright 2013 original author or authors */

/**
 * Collection of helpers for interfacing with node-style asynchronous functions
 * using promises.
 *
 * @author Brian Cavalier
 * @contributor Renato Zannon
 */

(function(define) {
define(function(require) {

	var when = require('./when');
	var _liftAll = require('./lib/liftAll');
	var setTimer = require('./lib/env').setTimer;
	var slice = Array.prototype.slice;

	var _apply = require('./lib/apply')(when.Promise, dispatch);

	return {
		lift: lift,
		liftAll: liftAll,
		apply: apply,
		call: call,
		createCallback: createCallback,
		bindCallback: bindCallback,
		liftCallback: liftCallback
	};

	/**
	 * Takes a node-style async function and calls it immediately (with an optional
	 * array of arguments or promises for arguments). It returns a promise whose
	 * resolution depends on whether the async functions calls its callback with the
	 * conventional error argument or not.
	 *
	 * With this it becomes possible to leverage existing APIs while still reaping
	 * the benefits of promises.
	 *
	 * @example
	 *    function onlySmallNumbers(n, callback) {
	 *		if(n < 10) {
	 *			callback(null, n + 10);
	 *		} else {
	 *			callback(new Error("Calculation failed"));
	 *		}
	 *	}
	 *
	 *    var nodefn = require("when/node/function");
	 *
	 *    // Logs '15'
	 *    nodefn.apply(onlySmallNumbers, [5]).then(console.log, console.error);
	 *
	 *    // Logs 'Calculation failed'
	 *    nodefn.apply(onlySmallNumbers, [15]).then(console.log, console.error);
	 *
	 * @param {function} f node-style function that will be called
	 * @param {Array} [args] array of arguments to func
	 * @returns {Promise} promise for the value func passes to its callback
	 */
	function apply(f, args) {
		return _apply(f, this, args || []);
	}

	function dispatch(f, thisArg, args, h) {
		var cb = createCallback(h);
		try {
			switch(args.length) {
				case 2: f.call(thisArg, args[0], args[1], cb); break;
				case 1: f.call(thisArg, args[0], cb); break;
				case 0: f.call(thisArg, cb); break;
				default:
					args.push(cb);
					f.apply(thisArg, args);
			}
		} catch(e) {
			h.reject(e);
		}
	}

	/**
	 * Has the same behavior that {@link apply} has, with the difference that the
	 * arguments to the function are provided individually, while {@link apply} accepts
	 * a single array.
	 *
	 * @example
	 *    function sumSmallNumbers(x, y, callback) {
	 *		var result = x + y;
	 *		if(result < 10) {
	 *			callback(null, result);
	 *		} else {
	 *			callback(new Error("Calculation failed"));
	 *		}
	 *	}
	 *
	 *    // Logs '5'
	 *    nodefn.call(sumSmallNumbers, 2, 3).then(console.log, console.error);
	 *
	 *    // Logs 'Calculation failed'
	 *    nodefn.call(sumSmallNumbers, 5, 10).then(console.log, console.error);
	 *
	 * @param {function} f node-style function that will be called
	 * @param {...*} [args] arguments that will be forwarded to the function
	 * @returns {Promise} promise for the value func passes to its callback
	 */
	function call(f /*, args... */) {
		return _apply(f, this, slice.call(arguments, 1));
	}

	/**
	 * Takes a node-style function and returns new function that wraps the
	 * original and, instead of taking a callback, returns a promise. Also, it
	 * knows how to handle promises given as arguments, waiting for their
	 * resolution before executing.
	 *
	 * Upon execution, the orginal function is executed as well. If it passes
	 * a truthy value as the first argument to the callback, it will be
	 * interpreted as an error condition, and the promise will be rejected
	 * with it. Otherwise, the call is considered a resolution, and the promise
	 * is resolved with the callback's second argument.
	 *
	 * @example
	 *    var fs = require("fs"), nodefn = require("when/node/function");
	 *
	 *    var promiseRead = nodefn.lift(fs.readFile);
	 *
	 *    // The promise is resolved with the contents of the file if everything
	 *    // goes ok
	 *    promiseRead('exists.txt').then(console.log, console.error);
	 *
	 *    // And will be rejected if something doesn't work out
	 *    // (e.g. the files does not exist)
	 *    promiseRead('doesnt_exist.txt').then(console.log, console.error);
	 *
	 *
	 * @param {Function} f node-style function to be lifted
	 * @param {...*} [args] arguments to be prepended for the new function @deprecated
	 * @returns {Function} a promise-returning function
	 */
	function lift(f /*, args... */) {
		var args1 = arguments.length > 1 ? slice.call(arguments, 1) : [];
		return function() {
			// TODO: Simplify once partialing has been removed
			var l = args1.length;
			var al = arguments.length;
			var args = new Array(al + l);
			var i;
			for(i=0; i<l; ++i) {
				args[i] = args1[i];
			}
			for(i=0; i<al; ++i) {
				args[i+l] = arguments[i];
			}
			return _apply(f, this, args);
		};
	}

	/**
	 * Lift all the functions/methods on src
	 * @param {object|function} src source whose functions will be lifted
	 * @param {function?} combine optional function for customizing the lifting
	 *  process. It is passed dst, the lifted function, and the property name of
	 *  the original function on src.
	 * @param {(object|function)?} dst option destination host onto which to place lifted
	 *  functions. If not provided, liftAll returns a new object.
	 * @returns {*} If dst is provided, returns dst with lifted functions as
	 *  properties.  If dst not provided, returns a new object with lifted functions.
	 */
	function liftAll(src, combine, dst) {
		return _liftAll(lift, combine, dst, src);
	}

	/**
	 * Takes an object that responds to the resolver interface, and returns
	 * a function that will resolve or reject it depending on how it is called.
	 *
	 * @example
	 *	function callbackTakingFunction(callback) {
	 *		if(somethingWrongHappened) {
	 *			callback(error);
	 *		} else {
	 *			callback(null, interestingValue);
	 *		}
	 *	}
	 *
	 *	var when = require('when'), nodefn = require('when/node/function');
	 *
	 *	var deferred = when.defer();
	 *	callbackTakingFunction(nodefn.createCallback(deferred.resolver));
	 *
	 *	deferred.promise.then(function(interestingValue) {
	 *		// Use interestingValue
	 *	});
	 *
	 * @param {Resolver} resolver that will be 'attached' to the callback
	 * @returns {Function} a node-style callback function
	 */
	function createCallback(resolver) {
		return function(err, value) {
			if(err) {
				resolver.reject(err);
			} else if(arguments.length > 2) {
				resolver.resolve(slice.call(arguments, 1));
			} else {
				resolver.resolve(value);
			}
		};
	}

	/**
	 * Attaches a node-style callback to a promise, ensuring the callback is
	 * called for either fulfillment or rejection. Returns a promise with the same
	 * state as the passed-in promise.
	 *
	 * @example
	 *	var deferred = when.defer();
	 *
	 *	function callback(err, value) {
	 *		// Handle err or use value
	 *	}
	 *
	 *	bindCallback(deferred.promise, callback);
	 *
	 *	deferred.resolve('interesting value');
	 *
	 * @param {Promise} promise The promise to be attached to.
	 * @param {Function} callback The node-style callback to attach.
	 * @returns {Promise} A promise with the same state as the passed-in promise.
	 */
	function bindCallback(promise, callback) {
		promise = when(promise);

		if (callback) {
			promise.then(success, wrapped);
		}

		return promise;

		function success(value) {
			wrapped(null, value);
		}

		function wrapped(err, value) {
			setTimer(function () {
				callback(err, value);
			}, 0);
		}
	}

	/**
	 * Takes a node-style callback and returns new function that accepts a
	 * promise, calling the original callback when the promise is either
	 * fulfilled or rejected with the appropriate arguments.
	 *
	 * @example
	 *	var deferred = when.defer();
	 *
	 *	function callback(err, value) {
	 *		// Handle err or use value
	 *	}
	 *
	 *	var wrapped = liftCallback(callback);
	 *
	 *	// `wrapped` can now be passed around at will
	 *	wrapped(deferred.promise);
	 *
	 *	deferred.resolve('interesting value');
	 *
	 * @param {Function} callback The node-style callback to wrap.
	 * @returns {Function} The lifted, promise-accepting function.
	 */
	function liftCallback(callback) {
		return function(promise) {
			return bindCallback(promise, callback);
		};
	}
});

})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });




},{"./lib/apply":912,"./lib/env":922,"./lib/liftAll":924,"./when":928}],928:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */

/**
 * Promises/A+ and when() implementation
 * when is part of the cujoJS family of libraries (http://cujojs.com/)
 * @author Brian Cavalier
 * @author John Hann
 */
(function(define) { 'use strict';
define(function (require) {

	var timed = require('./lib/decorators/timed');
	var array = require('./lib/decorators/array');
	var flow = require('./lib/decorators/flow');
	var fold = require('./lib/decorators/fold');
	var inspect = require('./lib/decorators/inspect');
	var generate = require('./lib/decorators/iterate');
	var progress = require('./lib/decorators/progress');
	var withThis = require('./lib/decorators/with');
	var unhandledRejection = require('./lib/decorators/unhandledRejection');
	var TimeoutError = require('./lib/TimeoutError');

	var Promise = [array, flow, fold, generate, progress,
		inspect, withThis, timed, unhandledRejection]
		.reduce(function(Promise, feature) {
			return feature(Promise);
		}, require('./lib/Promise'));

	var apply = require('./lib/apply')(Promise);

	// Public API

	when.promise     = promise;              // Create a pending promise
	when.resolve     = Promise.resolve;      // Create a resolved promise
	when.reject      = Promise.reject;       // Create a rejected promise

	when.lift        = lift;                 // lift a function to return promises
	when['try']      = attempt;              // call a function and return a promise
	when.attempt     = attempt;              // alias for when.try

	when.iterate     = Promise.iterate;      // DEPRECATED (use cujojs/most streams) Generate a stream of promises
	when.unfold      = Promise.unfold;       // DEPRECATED (use cujojs/most streams) Generate a stream of promises

	when.join        = join;                 // Join 2 or more promises

	when.all         = all;                  // Resolve a list of promises
	when.settle      = settle;               // Settle a list of promises

	when.any         = lift(Promise.any);    // One-winner race
	when.some        = lift(Promise.some);   // Multi-winner race
	when.race        = lift(Promise.race);   // First-to-settle race

	when.map         = map;                  // Array.map() for promises
	when.filter      = filter;               // Array.filter() for promises
	when.reduce      = lift(Promise.reduce);       // Array.reduce() for promises
	when.reduceRight = lift(Promise.reduceRight);  // Array.reduceRight() for promises

	when.isPromiseLike = isPromiseLike;      // Is something promise-like, aka thenable

	when.Promise     = Promise;              // Promise constructor
	when.defer       = defer;                // Create a {promise, resolve, reject} tuple

	// Error types

	when.TimeoutError = TimeoutError;

	/**
	 * Get a trusted promise for x, or by transforming x with onFulfilled
	 *
	 * @param {*} x
	 * @param {function?} onFulfilled callback to be called when x is
	 *   successfully fulfilled.  If promiseOrValue is an immediate value, callback
	 *   will be invoked immediately.
	 * @param {function?} onRejected callback to be called when x is
	 *   rejected.
	 * @param {function?} onProgress callback to be called when progress updates
	 *   are issued for x. @deprecated
	 * @returns {Promise} a new promise that will fulfill with the return
	 *   value of callback or errback or the completion value of promiseOrValue if
	 *   callback and/or errback is not supplied.
	 */
	function when(x, onFulfilled, onRejected, onProgress) {
		var p = Promise.resolve(x);
		if (arguments.length < 2) {
			return p;
		}

		return p.then(onFulfilled, onRejected, onProgress);
	}

	/**
	 * Creates a new promise whose fate is determined by resolver.
	 * @param {function} resolver function(resolve, reject, notify)
	 * @returns {Promise} promise whose fate is determine by resolver
	 */
	function promise(resolver) {
		return new Promise(resolver);
	}

	/**
	 * Lift the supplied function, creating a version of f that returns
	 * promises, and accepts promises as arguments.
	 * @param {function} f
	 * @returns {Function} version of f that returns promises
	 */
	function lift(f) {
		return function() {
			for(var i=0, l=arguments.length, a=new Array(l); i<l; ++i) {
				a[i] = arguments[i];
			}
			return apply(f, this, a);
		};
	}

	/**
	 * Call f in a future turn, with the supplied args, and return a promise
	 * for the result.
	 * @param {function} f
	 * @returns {Promise}
	 */
	function attempt(f /*, args... */) {
		/*jshint validthis:true */
		for(var i=0, l=arguments.length-1, a=new Array(l); i<l; ++i) {
			a[i] = arguments[i+1];
		}
		return apply(f, this, a);
	}

	/**
	 * Creates a {promise, resolver} pair, either or both of which
	 * may be given out safely to consumers.
	 * @return {{promise: Promise, resolve: function, reject: function, notify: function}}
	 */
	function defer() {
		return new Deferred();
	}

	function Deferred() {
		var p = Promise._defer();

		function resolve(x) { p._handler.resolve(x); }
		function reject(x) { p._handler.reject(x); }
		function notify(x) { p._handler.notify(x); }

		this.promise = p;
		this.resolve = resolve;
		this.reject = reject;
		this.notify = notify;
		this.resolver = { resolve: resolve, reject: reject, notify: notify };
	}

	/**
	 * Determines if x is promise-like, i.e. a thenable object
	 * NOTE: Will return true for *any thenable object*, and isn't truly
	 * safe, since it may attempt to access the `then` property of x (i.e.
	 *  clever/malicious getters may do weird things)
	 * @param {*} x anything
	 * @returns {boolean} true if x is promise-like
	 */
	function isPromiseLike(x) {
		return x && typeof x.then === 'function';
	}

	/**
	 * Return a promise that will resolve only once all the supplied arguments
	 * have resolved. The resolution value of the returned promise will be an array
	 * containing the resolution values of each of the arguments.
	 * @param {...*} arguments may be a mix of promises and values
	 * @returns {Promise}
	 */
	function join(/* ...promises */) {
		return Promise.all(arguments);
	}

	/**
	 * Return a promise that will fulfill once all input promises have
	 * fulfilled, or reject when any one input promise rejects.
	 * @param {array|Promise} promises array (or promise for an array) of promises
	 * @returns {Promise}
	 */
	function all(promises) {
		return when(promises, Promise.all);
	}

	/**
	 * Return a promise that will always fulfill with an array containing
	 * the outcome states of all input promises.  The returned promise
	 * will only reject if `promises` itself is a rejected promise.
	 * @param {array|Promise} promises array (or promise for an array) of promises
	 * @returns {Promise} promise for array of settled state descriptors
	 */
	function settle(promises) {
		return when(promises, Promise.settle);
	}

	/**
	 * Promise-aware array map function, similar to `Array.prototype.map()`,
	 * but input array may contain promises or values.
	 * @param {Array|Promise} promises array of anything, may contain promises and values
	 * @param {function(x:*, index:Number):*} mapFunc map function which may
	 *  return a promise or value
	 * @returns {Promise} promise that will fulfill with an array of mapped values
	 *  or reject if any input promise rejects.
	 */
	function map(promises, mapFunc) {
		return when(promises, function(promises) {
			return Promise.map(promises, mapFunc);
		});
	}

	/**
	 * Filter the provided array of promises using the provided predicate.  Input may
	 * contain promises and values
	 * @param {Array|Promise} promises array of promises and values
	 * @param {function(x:*, index:Number):boolean} predicate filtering predicate.
	 *  Must return truthy (or promise for truthy) for items to retain.
	 * @returns {Promise} promise that will fulfill with an array containing all items
	 *  for which predicate returned truthy.
	 */
	function filter(promises, predicate) {
		return when(promises, function(promises) {
			return Promise.filter(promises, predicate);
		});
	}

	return when;
});
})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });

},{"./lib/Promise":909,"./lib/TimeoutError":911,"./lib/apply":912,"./lib/decorators/array":913,"./lib/decorators/flow":914,"./lib/decorators/fold":915,"./lib/decorators/inspect":916,"./lib/decorators/iterate":917,"./lib/decorators/progress":918,"./lib/decorators/timed":919,"./lib/decorators/unhandledRejection":920,"./lib/decorators/with":921}]},{},[33]);
